diff -Nur libstb-hal-ddt.git.orig/acinclude.m4 libstb-hal-ddt.git/acinclude.m4
--- libstb-hal-ddt.git.orig/acinclude.m4	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/acinclude.m4	2022-07-23 18:18:31.491773270 +0200
@@ -129,14 +129,11 @@
 TUXBOX_APPS_DIRECTORY_ONE(fontdir, FONTDIR, datadir, /share, /fonts,
 	[--with-fontdir=PATH], [where to find fonts])
 
-TUXBOX_APPS_DIRECTORY_ONE(gamesdir, GAMESDIR, localstatedir, /var, /tuxbox/games,
-	[--with-gamesdir=PATH], [where to find games])
-
 TUXBOX_APPS_DIRECTORY_ONE(libdir, LIBDIR, libdir, /lib, /tuxbox,
 	[--with-libdir=PATH], [where to find internal libs])
 
-TUXBOX_APPS_DIRECTORY_ONE(plugindir, PLUGINDIR, libdir, /lib, /tuxbox/plugins,
-	[--with-plugindir=PATH], [where to find plugins])
+TUXBOX_APPS_DIRECTORY_ONE(plugindir, PLUGINDIR, localstatedir, /var, /tuxbox/plugins,
+	[--with-plugindir=PATH], [where to find plugins in /var])
 
 TUXBOX_APPS_DIRECTORY_ONE(themesdir, THEMESDIR, datadir, /share, /tuxbox/neutrino/themes,
 	[--with-themesdir=PATH], [where to find themes])
@@ -146,7 +143,6 @@
 AC_SUBST(CONFIGDIR)
 AC_SUBST(DATADIR)
 AC_SUBST(FONTDIR)
-AC_SUBST(GAMESDIR)
 AC_SUBST(LIBDIR)
 AC_SUBST(PLUGINDIR)
 AC_SUBST(THEMESDIR)
@@ -154,9 +150,9 @@
 
 AC_DEFUN([TUXBOX_BOXTYPE], [
 AC_ARG_WITH(boxtype,
-	AS_HELP_STRING([--with-boxtype], [valid values: tripledragon, spark, azbox, generic, armbox, duckbox, spark7162, mipsbox]),
+	AS_HELP_STRING([--with-boxtype], [valid values: spark, generic, armbox, duckbox, spark7162, mipsbox]),
 	[case "${withval}" in
-		tripledragon|azbox|generic|armbox)
+		generic|armbox)
 			BOXTYPE="$withval"
 		;;
 		spark|spark7162)
@@ -195,11 +191,11 @@
 			BOXTYPE="duckbox"
 			BOXMODEL="$withval"
 		;;
-		hd51|hd60|hd61|bre2ze4k|vusolo4k|vuduo4k|vuultimo4k|vuzero4k|vuuno4kse|vuuno4k|h7|osmio4k|osmio4kplus)
+		hd51|hd60|hd61|bre2ze4k|vusolo4k|vuduo4k|vuduo4kse|vuultimo4k|vuzero4k|vuuno4kse|vuuno4k|h7|osmio4k|osmio4kplus)
 			BOXTYPE="armbox"
 			BOXMODEL="$withval"
 		;;
-		vuduo)
+		vuduo|dm8000)
 			BOXTYPE="mipsbox"
 			BOXMODEL="$withval"
 		;;
@@ -213,8 +209,8 @@
 	AS_HELP_STRING([--with-boxmodel], [valid for generic: raspi])
 AS_HELP_STRING([], [valid for duckbox: ufs910, ufs912, ufs913, ufs922, atevio7500, fortis_hdbox, octagon1008, cuberevo, cuberevo_mini, cuberevo_mini2, cuberevo_250hd, cuberevo_2000hd, cuberevo_3000hd, ipbox9900, ipbox99, ipbox55, tf7700])
 AS_HELP_STRING([], [valid for spark: spark, spark7162])
-AS_HELP_STRING([], [valid for armbox: bre2ze4k, hd51, hd60, hd61, vusolo4k, vuduo4k, vuultimo4k, vuzero4k, vuuno4kse, vuuno4k, h7, osmio4k, osmio4kplus])
-AS_HELP_STRING([], [valid for mipsbox: vuduo]),
+AS_HELP_STRING([], [valid for armbox: bre2ze4k, hd51, hd60, hd61, vusolo4k, vuduo4k, vuduo4kse, vuultimo4k, vuzero4k, vuuno4kse, vuuno4k, h7, osmio4k, osmio4kplus])
+AS_HELP_STRING([], [valid for mipsbox: vuduo, dm8000]),
 	[case "${withval}" in
 		ufs910|ufs912|ufs913|ufs922|atevio7500|fortis_hdbox|octagon1008|cuberevo|cuberevo_mini|cuberevo_mini2|cuberevo_250hd|cuberevo_2000hd|cuberevo_3000hd|ipbox9900|ipbox99|ipbox55|tf7700)
 			if test "$BOXTYPE" = "duckbox"; then
@@ -230,14 +226,14 @@
 				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
 			fi
 		;;
-		hd51|hd60|hd61|bre2ze4k|vusolo4k|vuduo4k|vuultimo4k|vuzero4k|vuuno4kse|vuuno4k|h7|osmio4k|osmio4kplus)
+		hd51|hd60|hd61|bre2ze4k|vusolo4k|vuduo4k|vuduo4kse|vuultimo4k|vuzero4k|vuuno4kse|vuuno4k|h7|osmio4k|osmio4kplus)
 			if test "$BOXTYPE" = "armbox"; then
 				BOXMODEL="$withval"
 			else
 				AC_MSG_ERROR([unknown model $withval for boxtype $BOXTYPE])
 			fi
 		;;
-		vuduo)
+		vuduo|dm8000)
 			if test "$BOXTYPE" = "mipsbox"; then
 				BOXMODEL="$withval"
 			else
@@ -259,8 +255,6 @@
 AC_SUBST(BOXTYPE)
 AC_SUBST(BOXMODEL)
 
-AM_CONDITIONAL(BOXTYPE_AZBOX, test "$BOXTYPE" = "azbox")
-AM_CONDITIONAL(BOXTYPE_TRIPLE, test "$BOXTYPE" = "tripledragon")
 AM_CONDITIONAL(BOXTYPE_SPARK, test "$BOXTYPE" = "spark")
 AM_CONDITIONAL(BOXTYPE_GENERIC, test "$BOXTYPE" = "generic")
 AM_CONDITIONAL(BOXTYPE_DUCKBOX, test "$BOXTYPE" = "duckbox")
@@ -294,26 +288,24 @@
 AM_CONDITIONAL(BOXMODEL_BRE2ZE4K, test "$BOXMODEL" = "bre2ze4k")
 AM_CONDITIONAL(BOXMODEL_VUSOLO4K, test "$BOXMODEL" = "vusolo4k")
 AM_CONDITIONAL(BOXMODEL_VUDUO4K, test "$BOXMODEL" = "vuduo4k")
+AM_CONDITIONAL(BOXMODEL_VUDUO4KSE, test "$BOXMODEL" = "vuduo4kse")
 AM_CONDITIONAL(BOXMODEL_VUULTIMO4K, test "$BOXMODEL" = "vuultimo4k")
 AM_CONDITIONAL(BOXMODEL_VUZERO4K, test "$BOXMODEL" = "vuzero4k")
 AM_CONDITIONAL(BOXMODEL_VUUNO4KSE, test "$BOXMODEL" = "vuuno4kse")
 AM_CONDITIONAL(BOXMODEL_VUUNO4K, test "$BOXMODEL" = "vuuno4k")
 AM_CONDITIONAL(BOXMODEL_VUDUO, test "$BOXMODEL" = "vuduo")
+AM_CONDITIONAL(BOXMODEL_DM8000, test "$BOXMODEL" = "dm8000")
 AM_CONDITIONAL(BOXMODEL_H7, test "$BOXMODEL" = "h7")
 AM_CONDITIONAL(BOXMODEL_OSMIO4K, test "$BOXMODEL" = "osmio4k")
 AM_CONDITIONAL(BOXMODEL_OSMIO4KPLUS, test "$BOXMODEL" = "osmio4kplus")
 
 AM_CONDITIONAL(BOXMODEL_RASPI, test "$BOXMODEL" = "raspi")
 
-AM_CONDITIONAL(BOXMODEL_VUPLUS_ALL, test "$BOXMODEL" = "vusolo4k" -o "$BOXMODEL" = "vuduo4k"  -o "$BOXMODEL" = "vuultimo4k" -o "$BOXMODEL" = "vuzero4k" -o "$BOXMODEL" = "vuuno4kse" -o "$BOXMODEL" = "vuuno4k" -o "$BOXMODEL" = "vuduo")
-AM_CONDITIONAL(BOXMODEL_VUPLUS_ARM, test "$BOXMODEL" = "vusolo4k" -o "$BOXMODEL" = "vuduo4k"  -o "$BOXMODEL" = "vuultimo4k" -o "$BOXMODEL" = "vuzero4k" -o "$BOXMODEL" = "vuuno4kse" -o "$BOXMODEL" = "vuuno4k")
+AM_CONDITIONAL(BOXMODEL_VUPLUS_ALL, test "$BOXMODEL" = "vusolo4k" -o "$BOXMODEL" = "vuduo4k" -o "$BOXMODEL" = "vuduo4kse" -o "$BOXMODEL" = "vuultimo4k" -o "$BOXMODEL" = "vuzero4k" -o "$BOXMODEL" = "vuuno4kse" -o "$BOXMODEL" = "vuuno4k" -o "$BOXMODEL" = "vuduo")
+AM_CONDITIONAL(BOXMODEL_VUPLUS_ARM, test "$BOXMODEL" = "vusolo4k" -o "$BOXMODEL" = "vuduo4k" -o "$BOXMODEL" = "vuduo4kse" -o "$BOXMODEL" = "vuultimo4k" -o "$BOXMODEL" = "vuzero4k" -o "$BOXMODEL" = "vuuno4kse" -o "$BOXMODEL" = "vuuno4k")
 AM_CONDITIONAL(BOXMODEL_VUPLUS_MIPS, test "$BOXMODEL" = "vuduo")
 
-if test "$BOXTYPE" = "azbox"; then
-	AC_DEFINE(HAVE_AZBOX_HARDWARE, 1, [building for an azbox])
-elif test "$BOXTYPE" = "tripledragon"; then
-	AC_DEFINE(HAVE_TRIPLEDRAGON, 1, [building for a tripledragon])
-elif test "$BOXTYPE" = "spark"; then
+if test "$BOXTYPE" = "spark"; then
 	AC_DEFINE(HAVE_SPARK_HARDWARE, 1, [building for a goldenmedia 990 or edision pingulux])
 	AC_DEFINE(HAVE_SH4_HARDWARE, 1, [building for a sh4 box])
 elif test "$BOXTYPE" = "duckbox"; then
@@ -378,6 +370,8 @@
 	AC_DEFINE(BOXMODEL_VUSOLO4K, 1, [vusolo4k])
 elif test "$BOXMODEL" = "vuduo4k"; then
 	AC_DEFINE(BOXMODEL_VUDUO4K, 1, [vuduo4k])
+elif test "$BOXMODEL" = "vuduo4kse"; then
+	AC_DEFINE(BOXMODEL_VUDUO4KSE, 1, [vuduo4kse])
 elif test "$BOXMODEL" = "vuultimo4k"; then
 	AC_DEFINE(BOXMODEL_VUULTIMO4K, 1, [vuultimo4k])
 elif test "$BOXMODEL" = "vuzero4k"; then
@@ -388,6 +382,8 @@
 	AC_DEFINE(BOXMODEL_VUUNO4K, 1, [vuuno4k])
 elif test "$BOXMODEL" = "vuduo"; then
 	AC_DEFINE(BOXMODEL_VUDUO, 1, [vuduo])
+elif test "$BOXMODEL" = "dm8000"; then
+	AC_DEFINE(BOXMODEL_DM8000, 1, [dm8000])
 elif test "$BOXMODEL" = "h7"; then
 	AC_DEFINE(BOXMODEL_H7, 1, [h7])
 elif test "$BOXMODEL" = "osmio4k"; then
@@ -400,14 +396,14 @@
 
 # all vuplus BOXMODELs
 case "$BOXMODEL" in
-	vusolo4k|vuduo4k|vuultimo4k|vuuno4k|vuuno4kse|vuzero4k|vuduo)
+	vusolo4k|vuduo4k|vuduo4kse|vuultimo4k|vuuno4k|vuuno4kse|vuzero4k|vuduo)
 		AC_DEFINE(BOXMODEL_VUPLUS_ALL, 1, [vuplus_all])
 	;;
 esac
 
 # all vuplus arm BOXMODELs
 case "$BOXMODEL" in
-	vusolo4k|vuduo4k|vuultimo4k|vuuno4k|vuuno4kse|vuzero4k)
+	vusolo4k|vuduo4k|vuduo4kse|vuultimo4k|vuuno4k|vuuno4kse|vuzero4k)
 		AC_DEFINE(BOXMODEL_VUPLUS_ARM, 1, [vuplus_arm])
 	;;
 esac
diff -Nur libstb-hal-ddt.git.orig/common/ca_ci.cpp libstb-hal-ddt.git/common/ca_ci.cpp
--- libstb-hal-ddt.git.orig/common/ca_ci.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/common/ca_ci.cpp	2022-07-23 18:18:31.495773190 +0200
@@ -18,7 +18,6 @@
 
 #include "ca_ci.h"
 #include "hal_debug.h"
-#include <cs_api.h>
 #include <hardware_caps.h>
 
 #include <dvbci_session.h>
@@ -36,7 +35,7 @@
 
 #define hal_debug(args...) _hal_debug(HAL_DEBUG_CA, this, args)
 
-static const char * FILENAME = "[ca_ci]";
+static const char *FILENAME = "[ca_ci]";
 #if HAVE_DUCKBOX_HARDWARE
 const char ci_path[] = "/dev/dvb/adapter0/ci%d";
 ca_slot_info_t info;
@@ -48,9 +47,10 @@
 static bool checkLiveSlot = false;
 static bool CertChecked = false;
 static bool Cert_OK = false;
-static uint8_t NullPMT[50]={0x9F,0x80,0x32,0x2E,0x03,0x6E,0xA7,0x37,0x00,0x00,0x1B,0x15,0x7D,0x00,0x00,0x03,0x15,0x7E,0x00,0x00,0x03,0x15,0x7F,0x00,
-0x00,0x06,0x15,0x80,0x00,0x00,0x06,0x15,0x82,0x00,0x00,0x0B,0x08,0x7B,0x00,0x00,0x05,0x09,0x42,0x00,0x00,0x06,0x15,0x81,0x00,0x00};
-static cCA* pcCAInstance = NULL;
+static uint8_t NullPMT[50] = {0x9F, 0x80, 0x32, 0x2E, 0x03, 0x6E, 0xA7, 0x37, 0x00, 0x00, 0x1B, 0x15, 0x7D, 0x00, 0x00, 0x03, 0x15, 0x7E, 0x00, 0x00, 0x03, 0x15, 0x7F, 0x00,
+        0x00, 0x06, 0x15, 0x80, 0x00, 0x00, 0x06, 0x15, 0x82, 0x00, 0x00, 0x0B, 0x08, 0x7B, 0x00, 0x00, 0x05, 0x09, 0x42, 0x00, 0x00, 0x06, 0x15, 0x81, 0x00, 0x00
+    };
+static cCA *pcCAInstance = NULL;
 
 /* fÃ¼r callback */
 /* nur diese Message wird vom CI aus neutrinoMessages.h benutzt */
@@ -62,9 +62,9 @@
 uint32_t EVT_CA_MESSAGE = 0x80000000 + 60;
 #endif
 
-static cs_messenger cam_messenger = NULL;
+static hal_messenger cam_messenger = NULL;
 
-void cs_register_messenger(cs_messenger messenger)
+void hal_register_messenger(hal_messenger messenger)
 {
 	cam_messenger = messenger;
 	return;
@@ -82,7 +82,7 @@
 	printf("%s -> %s\n", FILENAME, __func__);
 }
 
-cCA * cCA::GetInstance()
+cCA *cCA::GetInstance()
 {
 	if (pcCAInstance == NULL)
 	{
@@ -94,7 +94,7 @@
 	return pcCAInstance;
 }
 
-bool cCA::checkQueueSize(eDVBCISlot* slot)
+bool cCA::checkQueueSize(eDVBCISlot *slot)
 {
 	return (slot->sendqueue.size() > 0);
 }
@@ -106,11 +106,11 @@
 	char mname[200];
 	char fname[20];
 	int count, cx, cy, i;
-	snprintf(fname, sizeof(fname), "/tmp/ci-slot%d" , slot);
+	snprintf(fname, sizeof(fname), "/tmp/ci-slot%d", slot);
 	ModuleName(CA_SLOT_TYPE_CI, slot, mname);
-	FILE* fd = fopen(fname, "w");
+	FILE *fd = fopen(fname, "w");
 	if (fd == NULL) return;
-	snprintf(buf, sizeof(buf), "%s\n" , mname);
+	snprintf(buf, sizeof(buf), "%s\n", mname);
 	fputs(buf, fd);
 	if (caids.size() > 40)
 		count = 40;
@@ -130,22 +130,22 @@
 void cCA::del_ci_info(int slot)
 {
 	char fname[20];
-	snprintf(fname, sizeof(fname), "/tmp/ci-slot%d" , slot);
+	snprintf(fname, sizeof(fname), "/tmp/ci-slot%d", slot);
 	if (access(fname, F_OK) == 0) remove(fname);
 }
 
 /* helper function to call the cpp thread loop */
-void* execute_thread(void *c)
+void *execute_thread(void *c)
 {
-	eDVBCISlot* slot = (eDVBCISlot*) c;
-	cCA *obj = (cCA*)slot->pClass;
+	eDVBCISlot *slot = (eDVBCISlot *) c;
+	cCA *obj = (cCA *)slot->pClass;
 	obj->slot_pollthread(c);
 	return NULL;
 }
 
 /* from dvb-apps */
-int asn_1_decode(uint16_t * length, unsigned char * asn_1_array,
-		 uint32_t asn_1_array_len)
+int asn_1_decode(uint16_t *length, unsigned char *asn_1_array,
+    uint32_t asn_1_array_len)
 {
 	uint8_t length_field;
 
@@ -180,7 +180,7 @@
 }
 
 //wait for a while for some data und read it if some
-eData waitData(int fd, unsigned char* buffer, int* len)
+eData waitData(int fd, unsigned char *buffer, int *len)
 {
 	int retval;
 	struct pollfd fds;
@@ -203,7 +203,7 @@
 	{
 		if (fds.revents & POLLIN)
 		{
-			int n = read (fd, buffer, *len);
+			int n = read(fd, buffer, *len);
 			if (n > 0)
 			{
 				*len = n;
@@ -234,11 +234,11 @@
 	return eDataError;
 }
 
-static bool transmitData(eDVBCISlot* slot, unsigned char* d, int len)
+static bool transmitData(eDVBCISlot *slot, unsigned char *d, int len)
 {
 	printf("%s -> %s len(%d)\n", FILENAME, __func__, len);
 
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUULTIMO4K || BOXMODEL_VUZERO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUULTIMO4K || BOXMODEL_VUZERO4K
 #if y_debug
 	for (int i = 0; i < len; i++)
 		printf("%02x ", d[i]);
@@ -265,19 +265,20 @@
 }
 
 //send some data on an fd, for a special slot and connection_id
-eData sendData(eDVBCISlot* slot, unsigned char* data, int len)
+eData sendData(eDVBCISlot *slot, unsigned char *data, int len)
 {
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
-		unsigned char *d = (unsigned char*) malloc(len);
-		memcpy(d, data, len);
-		transmitData(slot, d, len);
+	unsigned char *d = (unsigned char *) malloc(len);
+	memcpy(d, data, len);
+	transmitData(slot, d, len);
 #else
 	// only poll connection if we are not awaiting an answer
 	slot->pollConnection = false;
 
 	//send data_last and data
-	if (len < 127) {
-		unsigned char *d = (unsigned char*) malloc(len + 5);
+	if (len < 127)
+	{
+		unsigned char *d = (unsigned char *) malloc(len + 5);
 		memcpy(d + 5, data, len);
 		d[0] = slot->slot;
 		d[1] = slot->connection_id;
@@ -287,8 +288,9 @@
 		len += 5;
 		transmitData(slot, d, len);
 	}
-	else if (len > 126 && len < 255) {
-		unsigned char *d = (unsigned char*) malloc(len + 6);
+	else if (len > 126 && len < 255)
+	{
+		unsigned char *d = (unsigned char *) malloc(len + 6);
 		memcpy(d + 6, data, len);
 		d[0] = slot->slot;
 		d[1] = slot->connection_id;
@@ -299,8 +301,9 @@
 		len += 6;
 		transmitData(slot, d, len);
 	}
-	else if (len > 254) {
-		unsigned char *d = (unsigned char*) malloc(len + 7);
+	else if (len > 254)
+	{
+		unsigned char *d = (unsigned char *) malloc(len + 7);
 		memcpy(d + 7, data, len);
 		d[0] = slot->slot;
 		d[1] = slot->connection_id;
@@ -320,14 +323,14 @@
 #if HAVE_DUCKBOX_HARDWARE
 
 //send a transport connection create request
-bool sendCreateTC(eDVBCISlot* slot)
+bool sendCreateTC(eDVBCISlot *slot)
 {
 	unsigned char data[5];
 	data[0] = slot->slot;
-	data[1] = slot->slot + 1; 	/* conid */
+	data[1] = slot->slot + 1;   /* conid */
 	data[2] = T_CREATE_T_C;
 	data[3] = 1;
-	data[4] = slot->slot + 1 	/* conid */;
+	data[4] = slot->slot + 1    /* conid */;
 	printf("Create TC: ");
 	for (int i = 0; i < 5; i++)
 		printf("%02x ", data[i]);
@@ -336,7 +339,7 @@
 	return true;
 }
 
-static bool sendDataLast(eDVBCISlot* slot)
+static bool sendDataLast(eDVBCISlot *slot)
 {
 	unsigned char data[5];
 	slot->pollConnection = false;
@@ -356,7 +359,7 @@
 	return true;
 }
 
-static bool sendRCV(eDVBCISlot* slot)
+static bool sendRCV(eDVBCISlot *slot)
 {
 	unsigned char send_data[5];
 	slot->pollConnection = false;
@@ -376,7 +379,7 @@
 	return true;
 }
 
-void cCA::process_tpdu(eDVBCISlot* slot, unsigned char tpdu_tag, __u8* data, int asn_data_length, int /*con_id*/)
+void cCA::process_tpdu(eDVBCISlot *slot, unsigned char tpdu_tag, __u8 *data, int asn_data_length, int /*con_id*/)
 {
 	switch (tpdu_tag)
 	{
@@ -402,7 +405,7 @@
 		{
 			int new_data_length = slot->receivedLen + asn_data_length;
 			printf("%s %s Got \"Data More\" from Module\n", FILENAME, __FUNCTION__);
-			__u8 *new_data_buffer = (__u8*) realloc(slot->receivedData, new_data_length);
+			__u8 *new_data_buffer = (__u8 *) realloc(slot->receivedData, new_data_length);
 			slot->receivedData = new_data_buffer;
 			memcpy(slot->receivedData + slot->receivedLen, data, asn_data_length);
 			slot->receivedLen = new_data_length;
@@ -428,11 +431,11 @@
 			}
 			else
 			{
-				/* chained package 
+				/* chained package
 				?? DBO: I never have seen one */
 				int new_data_length = slot->receivedLen + asn_data_length;
 				printf("%s -> chained data\n", FILENAME);
-				__u8 *new_data_buffer = (__u8*) realloc(slot->receivedData, new_data_length);
+				__u8 *new_data_buffer = (__u8 *) realloc(slot->receivedData, new_data_length);
 				slot->receivedData = new_data_buffer;
 				memcpy(slot->receivedData + slot->receivedLen, data, asn_data_length);
 				slot->receivedLen = new_data_length;
@@ -482,7 +485,7 @@
 bool cCA::SendMessage(const CA_MESSAGE *msg)
 {
 	hal_debug("%s\n", __func__);
-	if(cam_messenger)
+	if (cam_messenger)
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
 		cam_messenger(EVT_CA_MESSAGE, (uintptr_t) msg);
 #else
@@ -503,7 +506,7 @@
 {
 	printf("%s -> %s Slot(%d)\n", FILENAME, __func__, bSlotIndex);
 
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 	{
@@ -531,7 +534,7 @@
 {
 	printf("%s -> %s Slot(%d) choice(%d)\n", FILENAME, __func__, bSlotIndex, choice);
 
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 	{
@@ -543,18 +546,18 @@
 	}
 }
 
-void cCA::InputAnswer(enum CA_SLOT_TYPE, uint32_t bSlotIndex, uint8_t * pBuffer, int nLength)
+void cCA::InputAnswer(enum CA_SLOT_TYPE, uint32_t bSlotIndex, uint8_t *pBuffer, int nLength)
 {
 	printf("%s -> %s Slot(%d)\n", FILENAME, __func__, bSlotIndex);
 
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 	{
 		if ((*it)->slot == bSlotIndex)
 		{
 			if ((*it)->hasMMIManager)
-				(*it)->mmiSession->answerEnq((char*) pBuffer, nLength);
+				(*it)->mmiSession->answerEnq((char *) pBuffer, nLength);
 			break;
 		}
 	}
@@ -564,7 +567,7 @@
 {
 	printf("%s -> %s Slot(%d)\n", FILENAME, __func__, bSlotIndex);
 
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 	{
@@ -589,9 +592,9 @@
 	return 0;
 }
 
-void cCA::ModuleName(enum CA_SLOT_TYPE, uint32_t slot, char * Name)
+void cCA::ModuleName(enum CA_SLOT_TYPE, uint32_t slot, char *Name)
 {
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 	{
 		if ((*it)->slot == slot)
@@ -604,7 +607,7 @@
 
 bool cCA::ModulePresent(enum CA_SLOT_TYPE, uint32_t slot)
 {
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 	{
@@ -619,7 +622,7 @@
 
 int cCA::GetCAIDS(CaIdVector &Caids)
 {
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 	{
 		if ((*it)->camIsReady)
@@ -631,10 +634,10 @@
 	return 0;
 }
 
-bool cCA::StopLiveCI( u64 TP, u16 SID, u8 source, u32 calen)
+bool cCA::StopLiveCI(u64 TP, u16 SID, u8 source, u32 calen)
 {
 	printf("%s -> %s\n", FILENAME, __func__);
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 	{
 		for (int j = 0; j < CI_MAX_MULTI; j++)
@@ -650,10 +653,10 @@
 	return false;
 }
 
-bool cCA::StopRecordCI( u64 TP, u16 SID, u8 source, u32 calen)
+bool cCA::StopRecordCI(u64 TP, u16 SID, u8 source, u32 calen)
 {
 	printf("%s -> %s\n", FILENAME, __func__);
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 	{
 		for (int j = 0; j < CI_MAX_MULTI; j++)
@@ -672,7 +675,7 @@
 SlotIt cCA::FindFreeSlot(u64 TP, u8 source, u16 SID, ca_map_t camap, u8 scrambled)
 {
 	printf("%s -> %s\n", FILENAME, __func__);
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 	ca_map_iterator_t caIt;
 	unsigned int i;
 	int count = 0;
@@ -680,7 +683,10 @@
 
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 	{
-		if (!scrambled) { continue; }
+		if (!scrambled)
+		{
+			continue;
+		}
 
 		if ((*it)->init)
 			count++;
@@ -721,8 +727,17 @@
 		if ((*it)->bsids.size())
 		{
 			for (i = 0; i < (*it)->bsids.size(); i++)
-				if ((*it)->bsids[i] == SID) {tmpSidBlackListed = true; break;}
-			if (i == (*it)->bsids.size()) {(*it)->SidBlackListed = false;}
+			{
+				if ((*it)->bsids[i] == SID)
+				{
+					tmpSidBlackListed = true;
+					break;
+				}
+			}
+			if (i == (*it)->bsids.size())
+			{
+				(*it)->SidBlackListed = false;
+			}
 		}
 
 		for (int j = 0; j < CI_MAX_MULTI; j++)
@@ -743,7 +758,7 @@
 			{
 				if ((*it)->source == source && (!checkLiveSlot || !liveUse_found))
 				{
-					SendNullPMT((eDVBCISlot*)(*it));
+					SendNullPMT((eDVBCISlot *)(*it));
 					(*it)->SidBlackListed = true;
 					for (int j = 0; j < CI_MAX_MULTI; j++)
 						(*it)->SID[j] = 0;
@@ -786,7 +801,7 @@
 }
 
 /* erstmal den capmt wie er von Neutrino kommt in den Slot puffern */
-bool cCA::SendCAPMT(u64 tpid, u8 source, u8 camask, const unsigned char * cabuf, u32 calen, const unsigned char * /*rawpmt*/, u32 /*rawlen*/, enum CA_SLOT_TYPE /*SlotType*/, unsigned char scrambled, ca_map_t cm, int mode, bool enabled)
+bool cCA::SendCAPMT(u64 tpid, u8 source, u8 camask, const unsigned char *cabuf, u32 calen, const unsigned char * /*rawpmt*/, u32 /*rawlen*/, enum CA_SLOT_TYPE /*SlotType*/, unsigned char scrambled, ca_map_t cm, int mode, bool enabled)
 {
 	u16 SID = (u16)(tpid & 0xFFFF);
 	u64 TP = tpid >> 16;
@@ -794,7 +809,7 @@
 	bool sid_found = false;
 	bool recordUse_found = false;
 	printf("%s -> %s\n", FILENAME, __func__);
-	if (!num_slots) return true;	/* stb's without ci-slots */
+	if (!num_slots) return true;    /* stb's without ci-slots */
 #if x_debug
 	printf("TP: %llX\n", TP);
 	printf("SID: %04X\n", SID);
@@ -846,7 +861,7 @@
 				}
 				else
 				{
-					SendNullPMT((eDVBCISlot*)(*It2));
+					SendNullPMT((eDVBCISlot *)(*It2));
 					(*It2)->scrambled = 0;
 					(*It2)->TP = 0;
 					for (int j = 0; j < CI_MAX_MULTI; j++)
@@ -869,14 +884,14 @@
 			(*It)->ci_use_count++;
 
 			if (!(cabuf[pos] & 0x80))
-				pos +=1;
+				pos += 1;
 			else
 				pos += ((cabuf[pos] & 0x7F) + 1);
 
 			(*It)->pmtlen = calen;
 			for (i = 0; i < calen; i++)
 				(*It)->pmtdata[i] = cabuf[i];
-			(*It)->pmtdata[pos] = 0x04;		// CAPMT_ADD
+			(*It)->pmtdata[pos] = 0x04;     // CAPMT_ADD
 			(*It)->newCapmt = true;
 		}
 
@@ -888,8 +903,8 @@
 			(*It)->ci_use_count = 1;
 			(*It)->TP = TP;
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
-			if(!checkLiveSlot && mode && (*It)->source != source)
-				setInputSource((eDVBCISlot*)(*It), false);
+			if (!checkLiveSlot && mode && (*It)->source != source)
+				setInputSource((eDVBCISlot *)(*It), false);
 #endif
 			(*It)->source = source;
 			(*It)->pmtlen = calen;
@@ -900,7 +915,7 @@
 
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
 		if ((*It)->newCapmt)
-			extractPids((eDVBCISlot*)(*It));
+			extractPids((eDVBCISlot *)(*It));
 #endif
 		if ((*It)->scrambled && !(*It)->SidBlackListed)
 		{
@@ -910,7 +925,7 @@
 				{
 					if (mode)
 					{
-						if(!checkLiveSlot)
+						if (!checkLiveSlot)
 							(*It)->liveUse[j] = false;
 						(*It)->recordUse[j] = true;
 					}
@@ -921,13 +936,13 @@
 		}
 
 		if (!(*It)->newCapmt && (*It)->ccmgr_ready && (*It)->hasCCManager && (*It)->scrambled && !(*It)->SidBlackListed)
-			(*It)->ccmgrSession->resendKey((eDVBCISlot*)(*It));
+			(*It)->ccmgrSession->resendKey((eDVBCISlot *)(*It));
 
 	}
 	else
 	{
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
-		std::list<eDVBCISlot*>::iterator it;
+		std::list<eDVBCISlot *>::iterator it;
 		recordUse_found = false;
 		for (it = slot_data.begin(); it != slot_data.end(); ++it)
 		{
@@ -940,7 +955,7 @@
 				}
 				if (!recordUse_found && (*it)->init)
 				{
-					setInputSource((eDVBCISlot*)(*it), false);
+					setInputSource((eDVBCISlot *)(*it), false);
 				}
 			}
 			if (!(*it)->init)
@@ -968,17 +983,17 @@
 }
 
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
-void cCA::extractPids(eDVBCISlot* slot)
+void cCA::extractPids(eDVBCISlot *slot)
 {
 	u32 prg_info_len;
 	u32 es_info_len = 0;
 	u16 pid;
-	u8 * data = slot->pmtdata;
+	u8 *data = slot->pmtdata;
 	u32 len = slot->pmtlen;
 	int pos = 3;
 
 	slot->pids.clear();
-	
+
 	if (!(data[pos] & 0x80))
 		pos += 5;
 	else
@@ -987,8 +1002,9 @@
 	prg_info_len = ((data[pos] << 8) | data[pos + 1]) & 0xFFF;
 	pos += prg_info_len + 2;
 
-	for (u32 i = pos; i < len; i += es_info_len + 5) {
-		pid = (data[i+1] << 8 | data[i+2]) & 0x1FFF;
+	for (u32 i = pos; i < len; i += es_info_len + 5)
+	{
+		pid = (data[i + 1] << 8 | data[i + 2]) & 0x1FFF;
 		es_info_len = ((data[i + 3] << 8) | data[i + 4]) & 0xfff;
 		slot->pids.push_back(pid);
 	}
@@ -1004,13 +1020,13 @@
 }
 #endif
 
-void cCA::setSource(eDVBCISlot* slot)
+void cCA::setSource(eDVBCISlot *slot)
 {
 	char buf[64];
 	snprintf(buf, 64, "/proc/stb/tsmux/ci%d_input", slot->slot);
 	FILE *ci = fopen(buf, "wb");
 
-	if (ci > (void*)0)
+	if (ci > (void *)0)
 	{
 		switch (slot->source)
 		{
@@ -1026,7 +1042,7 @@
 			case TUNER_D:
 				fprintf(ci, "D");
 				break;
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUULTIMO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUULTIMO4K
 			case TUNER_E:
 				fprintf(ci, "E");
 				break;
@@ -1096,18 +1112,21 @@
 }
 
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
-static std::string getTunerLetter(int number) { return std::string(1, char(65 + number)); }
+static std::string getTunerLetter(int number)
+{
+	return std::string(1, char(65 + number));
+}
 
 void cCA::setInputs()
 {
 	char input[64];
 	char choices[64];
-	FILE * fd = 0;
+	FILE *fd = 0;
 
 #if BOXMODEL_VUULTIMO4K
 	for (int number = 0; number < 24; number++) // tuner A to X, input 0 to 23
 #else
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 	for (int number = 0; number < 16; number++) // tuner A to P, input 0 to 15
 #else
 	for (int number = 0; number < 4; number++) // tuner A to D, input 0 to 3
@@ -1115,7 +1134,7 @@
 #endif
 	{
 		snprintf(choices, 64, "/proc/stb/tsmux/input%d_choices", number);
-		if(access(choices, R_OK) < 0)
+		if (access(choices, R_OK) < 0)
 		{
 			printf("no choices for input%d\n", number);
 			continue;
@@ -1126,7 +1145,7 @@
 		if (fd)
 		{
 			printf("set input%d to tuner %s\n", number, getTunerLetter(number).c_str());
-			fprintf(fd,"%s", getTunerLetter(number).c_str());
+			fprintf(fd, "%s", getTunerLetter(number).c_str());
 			fclose(fd);
 		}
 		else
@@ -1136,14 +1155,14 @@
 	}
 }
 
-void cCA::setInputSource(eDVBCISlot* slot, bool ci)
+void cCA::setInputSource(eDVBCISlot *slot, bool ci)
 {
 	char buf[64];
 	printf("%s set input%d to %s%d\n", FILENAME, slot->source, ci ? "ci" : "tuner", ci ? slot->slot : slot->source);
 	snprintf(buf, 64, "/proc/stb/tsmux/input%d", slot->source);
 	FILE *input = fopen(buf, "wb");
 
-	if (input > (void*)0)
+	if (input > (void *)0)
 	{
 		if (ci)
 		{
@@ -1173,7 +1192,7 @@
 				case TUNER_D:
 					fprintf(input, "D");
 					break;
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 				case TUNER_E:
 					fprintf(input, "E");
 					break;
@@ -1255,7 +1274,7 @@
 
 	for (int i = 0; i < Slots; i++)
 	{
-		eDVBCISlot* slot = (eDVBCISlot*) malloc(sizeof(eDVBCISlot));
+		eDVBCISlot *slot = (eDVBCISlot *) malloc(sizeof(eDVBCISlot));
 		slot->slot = i;
 		slot->fd = -1;
 		slot->connection_id = 0;
@@ -1318,7 +1337,7 @@
 		/* create a thread for each slot */
 		if (slot->fd > 0)
 		{
-			if (pthread_create(&slot->slot_thread, 0, execute_thread, (void*)slot))
+			if (pthread_create(&slot->slot_thread, 0, execute_thread, (void *)slot))
 			{
 				printf("pthread_create");
 			}
@@ -1330,7 +1349,7 @@
 {
 	printf("%s -> %s\n", FILENAME, __func__);
 
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 	bool haveFound = false;
 
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
@@ -1347,11 +1366,11 @@
 		usleep(200000);
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
 		last_source = (int)(*it)->source;
-		setInputSource((eDVBCISlot*)(*it), false);
+		setInputSource((eDVBCISlot *)(*it), false);
 #endif
 		if ((*it)->hasCCManager)
-			(*it)->ccmgrSession->ci_ccmgr_doClose((eDVBCISlot*)(*it));
-		eDVBCISession::deleteSessions((eDVBCISlot*)(*it));
+			(*it)->ccmgrSession->ci_ccmgr_doClose((eDVBCISlot *)(*it));
+		eDVBCISession::deleteSessions((eDVBCISlot *)(*it));
 		(*it)->mmiSession = NULL;
 		(*it)->hasMMIManager = false;
 		(*it)->hasCAManager = false;
@@ -1389,9 +1408,9 @@
 		(*it)->camask = 0;
 		memset((*it)->pmtdata, 0, sizeof((*it)->pmtdata));
 
-		while((*it)->sendqueue.size())
+		while ((*it)->sendqueue.size())
 		{
-			delete [] (*it)->sendqueue.top().data;
+			delete [](*it)->sendqueue.top().data;
 			(*it)->sendqueue.pop();
 		}
 
@@ -1406,7 +1425,7 @@
 	}
 }
 
-void cCA::ci_inserted(eDVBCISlot* slot)
+void cCA::ci_inserted(eDVBCISlot *slot)
 {
 	printf("1. cam (%d) status changed ->cam now present\n", slot->slot);
 
@@ -1425,7 +1444,7 @@
 	slot->connection_id = slot->slot + 1;
 #endif
 	/* Send a message to Neutrino cam_menu handler */
-	CA_MESSAGE* pMsg = (CA_MESSAGE*) malloc(sizeof(CA_MESSAGE));
+	CA_MESSAGE *pMsg = (CA_MESSAGE *) malloc(sizeof(CA_MESSAGE));
 	memset(pMsg, 0, sizeof(CA_MESSAGE));
 	pMsg->MsgId = CA_MESSAGE_MSG_INSERTED;
 	pMsg->SlotType = CA_SLOT_TYPE_CI;
@@ -1435,12 +1454,12 @@
 	slot->camIsReady = true;
 }
 
-void cCA::ci_removed(eDVBCISlot* slot)
+void cCA::ci_removed(eDVBCISlot *slot)
 {
 	printf("cam (%d) status changed ->cam now _not_ present\n", slot->slot);
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
-		last_source = (int)slot->source;
-		setInputSource(slot, false);
+	last_source = (int)slot->source;
+	setInputSource(slot, false);
 #endif
 	if (slot->hasCCManager)
 		slot->ccmgrSession->ci_ccmgr_doClose(slot);
@@ -1485,14 +1504,14 @@
 	/* delete ci info file */
 	del_ci_info(slot->slot);
 	/* Send a message to Neutrino cam_menu handler */
-	CA_MESSAGE* pMsg = (CA_MESSAGE*) malloc(sizeof(CA_MESSAGE));
+	CA_MESSAGE *pMsg = (CA_MESSAGE *) malloc(sizeof(CA_MESSAGE));
 	memset(pMsg, 0, sizeof(CA_MESSAGE));
 	pMsg->MsgId = CA_MESSAGE_MSG_REMOVED;
 	pMsg->SlotType = CA_SLOT_TYPE_CI;
 	pMsg->Slot = slot->slot;
 	SendMessage(pMsg);
 
-	while(slot->sendqueue.size())
+	while (slot->sendqueue.size())
 	{
 		delete [] slot->sendqueue.top().data;
 		slot->sendqueue.pop();
@@ -1504,14 +1523,14 @@
 void cCA::slot_pollthread(void *c)
 {
 	unsigned char data[1024 * 4];
-	eDVBCISlot* slot = (eDVBCISlot*) c;
+	eDVBCISlot *slot = (eDVBCISlot *) c;
 	bool wait = false;
 
 	while (1)
 	{
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE /* Armbox/Mipsbox */
 
-		int len = 1024 *4;
+		int len = 1024 * 4;
 		eData status;
 
 		switch (slot->status)
@@ -1531,7 +1550,8 @@
 					{
 #if y_debug
 // test was kommt
-						if (len) {
+						if (len)
+						{
 							printf("1. received : > ");
 							for (int i = 0; i < len; i++)
 								printf("%02x ", data[i]);
@@ -1546,7 +1566,7 @@
 				/* slow down the loop, if no CI cam present */
 //				printf("***sleep\n");
 				sleep(1);
-			} /* case statusnone */
+				} /* case statusnone */
 			break;
 			case eStatusWait:
 			{
@@ -1594,9 +1614,9 @@
 				printf("unknown state %d\n", slot->status);
 				break;
 		} /* switch(slot->status) */
-#else		/* Duckbox */
-		int len = 1024 *4;
-		unsigned char* d;
+#else       /* Duckbox */
+		int len = 1024 * 4;
+		unsigned char *d;
 		eData status;
 
 		switch (slot->status)
@@ -1639,7 +1659,7 @@
 						}
 					}
 				}
-			} /* case statusnone */
+				} /* case statusnone */
 			break;
 			case eStatusWait:
 			{
@@ -1649,7 +1669,8 @@
 					slot->pollConnection = false;
 					d = data;
 #if z_debug
-					if ((len == 6 && d[4] == 0x80) || len > 6) { 
+					if ((len == 6 && d[4] == 0x80) || len > 6)
+					{
 						printf("slot: %d con-id: %d tpdu-tag: %02X len: %d\n", d[0], d[1], d[2], len);
 						printf("received data: >");
 						for (int i = 0; i < len; i++)
@@ -1749,7 +1770,7 @@
 				printf("unknown state %d\n", slot->status);
 				break;
 		} /* switch(slot->status) */
-#endif		/* end Duckbox */
+#endif      /* end Duckbox */
 #if HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
 		if (!slot->init && slot->camIsReady && last_source > -1)
 		{
@@ -1776,7 +1797,7 @@
 			write_ci_info(slot->slot, slot->cam_caids);
 
 			/* Send a message to Neutrino cam_menu handler */
-			CA_MESSAGE* pMsg = (CA_MESSAGE*) malloc(sizeof(CA_MESSAGE));
+			CA_MESSAGE *pMsg = (CA_MESSAGE *) malloc(sizeof(CA_MESSAGE));
 			memset(pMsg, 0, sizeof(CA_MESSAGE));
 			pMsg->MsgId = CA_MESSAGE_MSG_INIT_OK;
 			pMsg->SlotType = CA_SLOT_TYPE_CI;
@@ -1784,7 +1805,7 @@
 			SendMessage(pMsg);
 			/* resend a capmt if we have one. this is not very proper but I cant any mechanism in
 			neutrino currently. so if a cam is inserted a pmt is not resend */
-			/* not necessary: the arrived capmt will be automaticly send */ 
+			/* not necessary: the arrived capmt will be automaticly send */
 			//SendCaPMT(slot);
 		}
 		if (slot->hasCAManager && slot->hasAppManager && slot->newCapmt)
@@ -1800,7 +1821,7 @@
 	}
 }
 
-bool cCA::SendCaPMT(eDVBCISlot* slot)
+bool cCA::SendCaPMT(eDVBCISlot *slot)
 {
 	printf("%s -> %s\n", FILENAME, __func__);
 	if (slot->fd > 0)
@@ -1856,21 +1877,16 @@
 	printf("%s -> %s param:%d\n", FILENAME, __func__, (int)p);
 }
 
-void cCA::SetInitMask(enum CA_INIT_MASK p)
-{
-	printf("%s -> %s param:%d\n", FILENAME, __func__, (int)p);
-}
-
 SlotIt cCA::GetSlot(unsigned int slot)
 {
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
 		if ((*it)->slot == slot && (*it)->init)
 			return it;
 	return it;
 }
 
-bool cCA::SendNullPMT(eDVBCISlot* slot)
+bool cCA::SendNullPMT(eDVBCISlot *slot)
 {
 	printf("%s > %s >**\n", FILENAME, __func__);
 	if ((slot->fd > 0) && (slot->camIsReady) && (slot->hasCAManager))
@@ -1882,7 +1898,7 @@
 
 bool cCA::CheckCerts(void)
 {
-	if(!CertChecked)
+	if (!CertChecked)
 	{
 		if (access(ROOT_CERT, F_OK) == 0 && access(ROOT_CERT, F_OK) == 0 && access(ROOT_CERT, F_OK) == 0)
 			Cert_OK = true;
@@ -1893,7 +1909,7 @@
 
 bool cCA::checkChannelID(u64 chanID)
 {
-	std::list<eDVBCISlot*>::iterator it;
+	std::list<eDVBCISlot *>::iterator it;
 	u16 SID = (u16)(chanID & 0xFFFF);
 	u64 TP = chanID >> 16;
 	for (it = slot_data.begin(); it != slot_data.end(); ++it)
@@ -1917,16 +1933,16 @@
 
 void cCA::SetTSClock(u32 Speed, int slot)
 {
-/* TODO:
- * For now using the coolstream values from neutrino cam_menu
- * where 6 ( == 6000000 Hz ) means : 'normal'
- * and other values mean : 'high'
- * also only ci0 will be changed
- * for more than one ci slot code must be changed in neutrino cam_menu
- * and in zapit where ci_clock is set during start.
- * and here too.
- * On the other hand: or ci_clock will be set here for all ci slots ????
- */ 
+	/* TODO:
+	 * For now using the coolstream values from neutrino cam_menu
+	 * where 6 (== 6000000 Hz) means : 'normal'
+	 * and other values mean : 'high'
+	 * also only ci0 will be changed
+	 * for more than one ci slot code must be changed in neutrino cam_menu
+	 * and in zapit where ci_clock is set during start.
+	 * and here too.
+	 * On the other hand: or ci_clock will be set here for all ci slots ????
+	 */
 	char buf[64];
 	snprintf(buf, 64, "/proc/stb/tsmux/ci%d_tsclk", slot);
 	FILE *ci = fopen(buf, "wb");
@@ -1935,8 +1951,7 @@
 	{
 		if (Speed > 9 * 1000000)
 			fprintf(ci, "extra_high");
-		else
-		if (Speed > 6 * 1000000)
+		else if (Speed > 6 * 1000000)
 			fprintf(ci, "high");
 		else
 			fprintf(ci, "normal");
diff -Nur libstb-hal-ddt.git.orig/common/ca.cpp libstb-hal-ddt.git/common/ca.cpp
--- libstb-hal-ddt.git.orig/common/ca.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/common/ca.cpp	2022-07-23 18:18:31.491773270 +0200
@@ -103,8 +103,3 @@
 {
 	hal_debug("%s param:%d\n", __FUNCTION__, (int)p);
 }
-
-void cCA::SetInitMask(enum CA_INIT_MASK p)
-{
-	hal_debug("%s param:%d\n", __FUNCTION__, (int)p);
-}
diff -Nur libstb-hal-ddt.git.orig/common/hal_debug.cpp libstb-hal-ddt.git/common/hal_debug.cpp
--- libstb-hal-ddt.git.orig/common/hal_debug.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/common/hal_debug.cpp	2022-07-23 18:18:31.495773190 +0200
@@ -7,12 +7,10 @@
 #include <sys/prctl.h>
 #include <string.h>
 
-
-int cnxt_debug = 0; /* compat, unused */
-
 int debuglevel = -1;
 
-static const char* hal_facility[] = {
+static const char *hal_facility[] =
+{
 	"audio ",
 	"video ",
 	"demux ",
@@ -40,7 +38,7 @@
 	if (debuglevel < 0)
 		fprintf(stderr, "hal_debug: debuglevel not initialized!\n");
 
-	if (! ((1 << facility) & debuglevel))
+	if (!((1 << facility) & debuglevel))
 		return;
 
 	fprintf(stderr, "[HAL:%08lx:%s] ", (long)func, hal_facility[facility]);
@@ -55,8 +53,6 @@
 	int i = 0;
 	char *tmp = getenv("HAL_DEBUG");
 	if (! tmp)
-		tmp = getenv("TRIPLE_DEBUG"); /* backwards compatibility... */
-	if (! tmp)
 		debuglevel = 0;
 	else
 		debuglevel = (int) strtol(tmp, NULL, 0);
@@ -65,14 +61,18 @@
 	{
 		fprintf(stderr, "libstb-hal debug options can be set by exporting HAL_DEBUG.\n");
 		fprintf(stderr, "The following values (or bitwise OR combinations) are valid:\n");
-		while (hal_facility[i]) {
+		while (hal_facility[i])
+		{
 			fprintf(stderr, "\tcomponent: %s  0x%02x\n", hal_facility[i], 1 << i);
 			i++;
 		}
 		fprintf(stderr, "\tall components:    0x%02x\n", (1 << i) - 1);
-	} else {
+	}
+	else
+	{
 		fprintf(stderr, "libstb-hal debug is active for the following components:\n");
-		while (hal_facility[i]) {
+		while (hal_facility[i])
+		{
 			if (debuglevel & (1 << i))
 				fprintf(stderr, "%s ", hal_facility[i]);
 			i++;
@@ -86,5 +86,5 @@
 	char threadname[17];
 	strncpy(threadname, name, sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 }
diff -Nur libstb-hal-ddt.git.orig/common/hal_debug.h libstb-hal-ddt.git/common/hal_debug.h
--- libstb-hal-ddt.git.orig/common/hal_debug.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/common/hal_debug.h	2022-07-23 18:18:31.495773190 +0200
@@ -1,20 +1,20 @@
 #ifndef __HAL_DEBUG_H__
 #define __HAL_DEBUG_H__
 
-#define HAL_DEBUG_AUDIO		0
-#define HAL_DEBUG_VIDEO		1
-#define HAL_DEBUG_DEMUX		2
-#define HAL_DEBUG_PLAYBACK	3
-#define HAL_DEBUG_PWRMNGR	4
-#define HAL_DEBUG_INIT		5
-#define HAL_DEBUG_CA		6
-#define HAL_DEBUG_RECORD	7
-#define HAL_DEBUG_ALL		((1<<8)-1)
+#define HAL_DEBUG_AUDIO     0
+#define HAL_DEBUG_VIDEO     1
+#define HAL_DEBUG_DEMUX     2
+#define HAL_DEBUG_PLAYBACK  3
+#define HAL_DEBUG_PWRMNGR   4
+#define HAL_DEBUG_INIT      5
+#define HAL_DEBUG_CA        6
+#define HAL_DEBUG_RECORD    7
+#define HAL_DEBUG_ALL       ((1<<8)-1)
 
 extern int debuglevel;
 
-void _hal_debug(int facility, const void *, const char *fmt, ...) __attribute__ ((format (printf, 3, 4)));
-void _hal_info(int facility, const void *, const char *fmt, ...)  __attribute__ ((format (printf, 3, 4)));
+void _hal_debug(int facility, const void *, const char *fmt, ...) __attribute__((format(printf, 3, 4)));
+void _hal_info(int facility, const void *, const char *fmt, ...)  __attribute__((format(printf, 3, 4)));
 
 void hal_debug_init(void);
 void hal_set_threadname(const char *name);
diff -Nur libstb-hal-ddt.git.orig/common/proc_tools.c libstb-hal-ddt.git/common/proc_tools.c
--- libstb-hal-ddt.git.orig/common/proc_tools.c	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/common/proc_tools.c	2022-07-23 18:18:31.495773190 +0200
@@ -10,8 +10,8 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <unistd.h>
-#include <ctype.h>	/* isspace */
-#include <stdio.h>	/* sscanf */
+#include <ctype.h>  /* isspace */
+#include <stdio.h>  /* sscanf */
 
 #include "proc_tools.h"
 
@@ -35,12 +35,12 @@
 	if (pfd < 0)
 		return pfd;
 	ret = read(pfd, value, len);
-	value[len-1] = '\0'; /* make sure string is terminated */
+	value[len - 1] = '\0'; /* make sure string is terminated */
 	if (ret >= 0)
 	{
-		while (ret > 0 && isspace(value[ret-1]))
-			ret--;		/* remove trailing whitespace */
-		value[ret] = '\0';	/* terminate, even if ret = 0 */
+		while (ret > 0 && isspace(value[ret - 1]))
+			ret--;      /* remove trailing whitespace */
+		value[ret] = '\0';  /* terminate, even if ret = 0 */
 	}
 	ret2 = close(pfd);
 	if (ret2 < 0)
diff -Nur libstb-hal-ddt.git.orig/common/pwrmngr.cpp libstb-hal-ddt.git/common/pwrmngr.cpp
--- libstb-hal-ddt.git.orig/common/pwrmngr.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/common/pwrmngr.cpp	2022-07-23 18:18:31.495773190 +0200
@@ -28,128 +28,9 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
-#if HAVE_TRIPLEDRAGON
-#include <avs/avs_inf.h>
-#include <tdpanel/lcdstuff.h>
-#endif
-
 #define hal_debug(args...) _hal_debug(HAL_DEBUG_PWRMNGR, this, args)
 #define hal_info(args...) _hal_info(HAL_DEBUG_PWRMNGR, this, args)
 
-/* cpufreqmanager */
-void cCpuFreqManager::Up(void)
-{
-	hal_debug("%s\n", __func__);
-}
-
-void cCpuFreqManager::Down(void)
-{
-	hal_debug("%s\n", __func__);
-}
-
-void cCpuFreqManager::Reset(void)
-{
-	hal_debug("%s\n", __func__);
-}
-
-/* those function dummies return true or "harmless" values */
-bool cCpuFreqManager::SetDelta(unsigned long)
-{
-	hal_debug("%s\n", __func__);
-	return true;
-}
-
-unsigned long cCpuFreqManager::GetDelta(void)
-{
-	hal_debug("%s\n", __func__);
-	return 0;
-}
-
-#if HAVE_SPARK_HARDWARE || HAVE_DUCKBOX_HARDWARE
-unsigned long cCpuFreqManager::GetCpuFreq(void) {
-	int freq = 0;
-	if (FILE *pll0 = fopen("/proc/cpu_frequ/pll0_ndiv_mdiv", "r")) {
-		char buffer[120];
-		while(fgets(buffer, sizeof(buffer), pll0)) {
-			if (1 == sscanf(buffer, "SH4 = %d MHZ", &freq))
-				break;
-		}
-		fclose(pll0);
-		return 1000 * 1000 * (unsigned long) freq;
-	}
-	return 0;
-}
-#else
-unsigned long cCpuFreqManager::GetCpuFreq(void)
-{
-	hal_debug("%s\n", __func__);
-	return 0;
-}
-#endif
-
-bool cCpuFreqManager::SetCpuFreq(unsigned long f)
-{
-	hal_info("%s(%lu) => set standby = %s\n", __func__, f, f?"true":"false");
-#if HAVE_TRIPLEDRAGON
-	/* actually SetCpuFreq is used to determine if the system is in standby
-	   this is an "elegant" hack, because:
-	   * during a recording, cpu freq is kept "high", even if the box is sent to standby
-	   * the "SetStandby" call is made even if a recording is running
-	   On the TD, setting standby disables the frontend, so we must not do it
-	   if a recording is running.
-	   For now, the values in neutrino are hardcoded:
-	   * f == 0        => max => not standby
-	   * f == 50000000 => min => standby
-	 */
-	int fd = open("/dev/stb/tdsystem", O_RDONLY);
-	if (fd < 0)
-	{
-		perror("open tdsystem");
-		return false;
-	}
-	if (f)
-	{
-		ioctl(fd, IOC_AVS_SET_VOLUME, 31); /* mute AVS to avoid ugly noise */
-		ioctl(fd, IOC_AVS_STANDBY_ENTER);
-		if (getenv("TRIPLE_LCDBACKLIGHT"))
-		{
-			hal_info("%s: TRIPLE_LCDBACKLIGHT is set: keeping LCD backlight on\n", __func__);
-			close(fd);
-			fd = open("/dev/stb/tdlcd", O_RDONLY);
-			if (fd < 0)
-				hal_info("%s: open tdlcd error: %m\n", __func__);
-			else
-				ioctl(fd, IOC_LCD_BACKLIGHT_ON);
-		}
-	}
-	else
-	{
-		ioctl(fd, IOC_AVS_SET_VOLUME, 31); /* mute AVS to avoid ugly noise */
-		ioctl(fd, IOC_AVS_STANDBY_LEAVE);
-		/* unmute will be done by cAudio::do_mute(). Ugly, but prevents pops */
-		// ioctl(fd, IOC_AVS_SET_VOLUME, 0); /* max gain */
-	}
-
-	close(fd);
-#elif HAVE_SPARK_HARDWARE || HAVE_DUCKBOX_HARDWARE
-	if (f) {
-		FILE *pll0 = fopen ("/proc/cpu_frequ/pll0_ndiv_mdiv", "w");
-		if (pll0) {
-			f /= 1000000;
-			fprintf(pll0, "%lu\n", (f/10 << 8) | 3);
-			fclose (pll0);
-			return false;
-		}
-	}
-#endif
-	return true;
-}
-
-cCpuFreqManager::cCpuFreqManager(void)
-{
-	hal_debug("%s\n", __func__);
-}
-
 /* powermanager */
 bool cPowerManager::Open(void)
 {
diff -Nur libstb-hal-ddt.git.orig/common/version_hal.cpp libstb-hal-ddt.git/common/version_hal.cpp
--- libstb-hal-ddt.git.orig/common/version_hal.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/common/version_hal.cpp	2022-07-23 18:18:31.495773190 +0200
@@ -25,7 +25,7 @@
 		return;
 
 	//init struct
-	*ver = {"",0,0,0,"","",""};
+	*ver = {"", 0, 0, 0, "", "", ""};
 
 #ifdef VERSION
 	ver->vVersion = VERSION;
diff -Nur libstb-hal-ddt.git.orig/configure.ac libstb-hal-ddt.git/configure.ac
--- libstb-hal-ddt.git.orig/configure.ac	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/configure.ac	2022-07-23 18:18:31.495773190 +0200
@@ -1,7 +1,7 @@
 # explicit defines for separate revision handling
 define(ver_major, 1)
-define(ver_minor, 1)
-define(ver_micro, 1)
+define(ver_minor, 2)
+define(ver_micro, 0)
 
 # sync with current git
 define(ver_git, m4_esyscmd([
@@ -11,7 +11,7 @@
 ]))
 
 AC_PACKAGE_NAME, PACKAGE_NAME_LIBSTB_HAL
-AC_INIT([Tuxbox-libstb-hal], [ver_major.ver_minor.ver_micro])
+AC_INIT([DDT-libstb-hal], [ver_major.ver_minor.ver_micro])
 AM_INIT_AUTOMAKE
 AC_CONFIG_HEADERS([libstb-hal-config.h:config.h.in])
 m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES])
@@ -51,10 +51,6 @@
 	AC_DEFINE(USE_OPENGL,1,[use opengl instead of clutter])
 fi
 
-if test x"$BOXTYPE" = x"tripledragon"; then
-	PKG_CHECK_MODULES([DIRECTFB], [directfb])
-fi
-
 AC_ARG_ENABLE(gstreamer_01,
 	AS_HELP_STRING(--enable-gstreamer_01, use gstreamer 0.10 playback),
 	,[enable_gstreamer_01=no])
@@ -110,7 +106,6 @@
 common/Makefile
 libmipsbox/Makefile
 libarmbox/Makefile
-libazbox/Makefile
 libduckbox/Makefile
 libdvbci/Makefile
 libeplayer3/Makefile
@@ -118,6 +113,5 @@
 libgeneric-pc/Makefile
 libraspi/Makefile
 libspark/Makefile
-libtriple/Makefile
 tools/Makefile
 ])
diff -Nur libstb-hal-ddt.git.orig/.git/config libstb-hal-ddt.git/.git/config
--- libstb-hal-ddt.git.orig/.git/config	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/.git/config	2022-07-23 18:18:31.491773270 +0200
@@ -4,8 +4,8 @@
 	bare = false
 	logallrefupdates = true
 [remote "origin"]
-	fetch = +refs/heads/*:refs/remotes/origin/*
 	url = https://github.com/Duckbox-Developers/libstb-hal-ddt.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
 [branch "master"]
 	remote = origin
 	merge = refs/heads/master
diff -Nur libstb-hal-ddt.git.orig/.git/FETCH_HEAD libstb-hal-ddt.git/.git/FETCH_HEAD
--- libstb-hal-ddt.git.orig/.git/FETCH_HEAD	2022-07-23 18:13:58.781208282 +0200
+++ libstb-hal-ddt.git/.git/FETCH_HEAD	2022-07-23 18:19:01.479170392 +0200
@@ -0,0 +1,2 @@
+007b718d55b4ffc14d5499941e10e5956c4a76a7		branch 'master' of https://github.com/Duckbox-Developers/libstb-hal-ddt
+0c36695415d1d7a4a7ef1533180aad4056d51b47	not-for-merge	branch 'hal-ddt' of https://github.com/Duckbox-Developers/libstb-hal-ddt
diff -Nur libstb-hal-ddt.git.orig/.git/hooks/applypatch-msg.sample libstb-hal-ddt.git/.git/hooks/applypatch-msg.sample
--- libstb-hal-ddt.git.orig/.git/hooks/applypatch-msg.sample	2019-01-03 17:40:38.000000000 +0100
+++ libstb-hal-ddt.git/.git/hooks/applypatch-msg.sample	2022-07-23 18:18:28.599831365 +0200
@@ -10,6 +10,6 @@
 # To enable this hook, rename this file to "applypatch-msg".
 
 . git-sh-setup
-test -x "$GIT_DIR/hooks/commit-msg" &&
-	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
 :
diff -Nur libstb-hal-ddt.git.orig/.git/hooks/fsmonitor-watchman.sample libstb-hal-ddt.git/.git/hooks/fsmonitor-watchman.sample
--- libstb-hal-ddt.git.orig/.git/hooks/fsmonitor-watchman.sample	2022-06-25 09:42:58.600516000 +0200
+++ libstb-hal-ddt.git/.git/hooks/fsmonitor-watchman.sample	2022-07-23 18:18:28.599831365 +0200
@@ -8,102 +8,166 @@
 # (https://facebook.github.io/watchman/) with git to speed up detecting
 # new and modified files.
 #
-# The hook is passed a version (currently 1) and a time in nanoseconds
-# formatted as a string and outputs to stdout all files that have been
-# modified since the given time. Paths must be relative to the root of
-# the working tree and separated by a single NUL.
+# The hook is passed a version (currently 2) and last update token
+# formatted as a string and outputs to stdout a new update token and
+# all files that have been modified since the update token. Paths must
+# be relative to the root of the working tree and separated by a single NUL.
 #
 # To enable this hook, rename this file to "query-watchman" and set
 # 'git config core.fsmonitor .git/hooks/query-watchman'
 #
-my ($version, $time) = @ARGV;
+my ($version, $last_update_token) = @ARGV;
 
-# Check the hook interface version
+# Uncomment for debugging
+# print STDERR "$0 $version $last_update_token\n";
 
-if ($version == 1) {
-	# convert nanoseconds to seconds
-	# subtract one second to make sure watchman will return all changes
-	$time = int ($time / 1000000000) - 1;
-} else {
+# Check the hook interface version
+if ($version ne 2) {
 	die "Unsupported query-fsmonitor hook version '$version'.\n" .
 	    "Falling back to scanning...\n";
 }
 
-my $git_work_tree;
-if ($^O =~ 'msys' || $^O =~ 'cygwin') {
-	$git_work_tree = Win32::GetCwd();
-	$git_work_tree =~ tr/\\/\//;
-} else {
-	require Cwd;
-	$git_work_tree = Cwd::cwd();
-}
+my $git_work_tree = get_working_dir();
 
 my $retry = 1;
 
+my $json_pkg;
+eval {
+	require JSON::XS;
+	$json_pkg = "JSON::XS";
+	1;
+} or do {
+	require JSON::PP;
+	$json_pkg = "JSON::PP";
+};
+
 launch_watchman();
 
 sub launch_watchman {
+	my $o = watchman_query();
+	if (is_work_tree_watched($o)) {
+		output_result($o->{clock}, @{$o->{files}});
+	}
+}
+
+sub output_result {
+	my ($clockid, @files) = @_;
+
+	# Uncomment for debugging watchman output
+	# open (my $fh, ">", ".git/watchman-output.out");
+	# binmode $fh, ":utf8";
+	# print $fh "$clockid\n@files\n";
+	# close $fh;
 
+	binmode STDOUT, ":utf8";
+	print $clockid;
+	print "\0";
+	local $, = "\0";
+	print @files;
+}
+
+sub watchman_clock {
+	my $response = qx/watchman clock "$git_work_tree"/;
+	die "Failed to get clock id on '$git_work_tree'.\n" .
+		"Falling back to scanning...\n" if $? != 0;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub watchman_query {
 	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
-	    or die "open2() failed: $!\n" .
-	    "Falling back to scanning...\n";
+	or die "open2() failed: $!\n" .
+	"Falling back to scanning...\n";
 
 	# In the query expression below we're asking for names of files that
-	# changed since $time but were not transient (ie created after
-	# $time but no longer exist).
+	# changed since $last_update_token but not from the .git folder.
 	#
 	# To accomplish this, we're using the "since" generator to use the
 	# recency index to select candidate nodes and "fields" to limit the
-	# output to file names only.
-
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	if (substr($last_update_token, 0, 1) eq "c") {
+		$last_update_token = "\"$last_update_token\"";
+	}
 	my $query = <<"	END";
 		["query", "$git_work_tree", {
-			"since": $time,
-			"fields": ["name"]
+			"since": $last_update_token,
+			"fields": ["name"],
+			"expression": ["not", ["dirname", ".git"]]
 		}]
 	END
 
+	# Uncomment for debugging the watchman query
+	# open (my $fh, ">", ".git/watchman-query.json");
+	# print $fh $query;
+	# close $fh;
+
 	print CHLD_IN $query;
 	close CHLD_IN;
 	my $response = do {local $/; <CHLD_OUT>};
 
+	# Uncomment for debugging the watch response
+	# open ($fh, ">", ".git/watchman-response.json");
+	# print $fh $response;
+	# close $fh;
+
 	die "Watchman: command returned no output.\n" .
-	    "Falling back to scanning...\n" if $response eq "";
+	"Falling back to scanning...\n" if $response eq "";
 	die "Watchman: command returned invalid output: $response\n" .
-	    "Falling back to scanning...\n" unless $response =~ /^\{/;
+	"Falling back to scanning...\n" unless $response =~ /^\{/;
 
-	my $json_pkg;
-	eval {
-		require JSON::XS;
-		$json_pkg = "JSON::XS";
-		1;
-	} or do {
-		require JSON::PP;
-		$json_pkg = "JSON::PP";
-	};
-
-	my $o = $json_pkg->new->utf8->decode($response);
+	return $json_pkg->new->utf8->decode($response);
+}
 
-	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
-		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
+sub is_work_tree_watched {
+	my ($output) = @_;
+	my $error = $output->{error};
+	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
 		$retry--;
-		qx/watchman watch "$git_work_tree"/;
+		my $response = qx/watchman watch "$git_work_tree"/;
 		die "Failed to make watchman watch '$git_work_tree'.\n" .
 		    "Falling back to scanning...\n" if $? != 0;
+		$output = $json_pkg->new->utf8->decode($response);
+		$error = $output->{error};
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		# Uncomment for debugging watchman output
+		# open (my $fh, ">", ".git/watchman-output.out");
+		# close $fh;
 
 		# Watchman will always return all files on the first query so
 		# return the fast "everything is dirty" flag to git and do the
 		# Watchman query just to get it over with now so we won't pay
 		# the cost in git to look up each individual file.
-		print "/\0";
+		my $o = watchman_clock();
+		$error = $output->{error};
+
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		output_result($o->{clock}, ("/"));
+		$last_update_token = $o->{clock};
+
 		eval { launch_watchman() };
-		exit 0;
+		return 0;
 	}
 
-	die "Watchman: $o->{error}.\n" .
-	    "Falling back to scanning...\n" if $o->{error};
+	die "Watchman: $error.\n" .
+	"Falling back to scanning...\n" if $error;
 
-	binmode STDOUT, ":utf8";
-	local $, = "\0";
-	print @{$o->{files}};
+	return 1;
+}
+
+sub get_working_dir {
+	my $working_dir;
+	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+		$working_dir = Win32::GetCwd();
+		$working_dir =~ tr/\\/\//;
+	} else {
+		require Cwd;
+		$working_dir = Cwd::cwd();
+	}
+
+	return $working_dir;
 }
diff -Nur libstb-hal-ddt.git.orig/.git/hooks/pre-applypatch.sample libstb-hal-ddt.git/.git/hooks/pre-applypatch.sample
--- libstb-hal-ddt.git.orig/.git/hooks/pre-applypatch.sample	2019-01-03 17:40:38.000000000 +0100
+++ libstb-hal-ddt.git/.git/hooks/pre-applypatch.sample	2022-07-23 18:18:28.599831365 +0200
@@ -9,6 +9,6 @@
 # To enable this hook, rename this file to "pre-applypatch".
 
 . git-sh-setup
-test -x "$GIT_DIR/hooks/pre-commit" &&
-	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
 :
diff -Nur libstb-hal-ddt.git.orig/.git/hooks/pre-commit.sample libstb-hal-ddt.git/.git/hooks/pre-commit.sample
--- libstb-hal-ddt.git.orig/.git/hooks/pre-commit.sample	2019-01-03 17:40:38.000000000 +0100
+++ libstb-hal-ddt.git/.git/hooks/pre-commit.sample	2022-07-23 18:18:28.599831365 +0200
@@ -12,16 +12,16 @@
 	against=HEAD
 else
 	# Initial commit: diff against an empty tree object
-	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
+	against=$(git hash-object -t tree /dev/null)
 fi
 
-# If you want to allow non-ascii filenames set this variable to true.
-allownonascii=$(git config hooks.allownonascii)
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --type=bool hooks.allownonascii)
 
 # Redirect output to stderr.
 exec 1>&2
 
-# Cross platform projects tend to avoid non-ascii filenames; prevent
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
 # them from being added to the repository. We exploit the fact that the
 # printable range starts at the space character and ends with tilde.
 if [ "$allownonascii" != "true" ] &&
@@ -31,18 +31,17 @@
 	test $(git diff --cached --name-only --diff-filter=A -z $against |
 	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
 then
-	echo "Error: Attempt to add a non-ascii file name."
-	echo
-	echo "This can cause problems if you want to work"
-	echo "with people on other platforms."
-	echo
-	echo "To be portable it is advisable to rename the file ..."
-	echo
-	echo "If you know what you are doing you can disable this"
-	echo "check using:"
-	echo
-	echo "  git config hooks.allownonascii true"
-	echo
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
 	exit 1
 fi
 
diff -Nur libstb-hal-ddt.git.orig/.git/hooks/prepare-commit-msg.sample libstb-hal-ddt.git/.git/hooks/prepare-commit-msg.sample
--- libstb-hal-ddt.git.orig/.git/hooks/prepare-commit-msg.sample	2019-01-03 17:40:38.000000000 +0100
+++ libstb-hal-ddt.git/.git/hooks/prepare-commit-msg.sample	2022-07-23 18:18:28.599831365 +0200
@@ -9,8 +9,8 @@
 #
 # To enable this hook, rename this file to "prepare-commit-msg".
 
-# This hook includes three examples.  The first comments out the
-# "Conflicts:" part of a merge commit.
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
 #
 # The second includes the output of "git diff --name-status -r"
 # into the message, just before the "git status" output.  It is
@@ -20,17 +20,23 @@
 # The third example adds a Signed-off-by line to the message, that can
 # still be edited.  This is rarely a good idea.
 
-case "$2,$3" in
-  merge,)
-    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
 
-# ,|template,)
-#   /usr/bin/perl -i.bak -pe '
-#      print "\n" . `git diff --cached --name-status -r`
-#	 if /^#/ && $first++ == 0' "$1" ;;
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
 
-  *) ;;
-esac
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
 
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff -Nur libstb-hal-ddt.git.orig/.git/hooks/pre-push.sample libstb-hal-ddt.git/.git/hooks/pre-push.sample
--- libstb-hal-ddt.git.orig/.git/hooks/pre-push.sample	2022-06-25 09:42:58.600516000 +0200
+++ libstb-hal-ddt.git/.git/hooks/pre-push.sample	2022-07-23 18:18:28.599831365 +0200
@@ -14,7 +14,7 @@
 # Information about the commits which are being pushed is supplied as lines to
 # the standard input in the form:
 #
-#   <local ref> <local sha1> <remote ref> <remote sha1>
+#   <local ref> <local oid> <remote ref> <remote oid>
 #
 # This sample shows how to prevent push of commits where the log message starts
 # with "WIP" (work in progress).
@@ -22,27 +22,27 @@
 remote="$1"
 url="$2"
 
-z40=0000000000000000000000000000000000000000
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
 
-while read local_ref local_sha remote_ref remote_sha
+while read local_ref local_oid remote_ref remote_oid
 do
-	if [ "$local_sha" = $z40 ]
+	if test "$local_oid" = "$zero"
 	then
 		# Handle delete
 		:
 	else
-		if [ "$remote_sha" = $z40 ]
+		if test "$remote_oid" = "$zero"
 		then
 			# New branch, examine all commits
-			range="$local_sha"
+			range="$local_oid"
 		else
 			# Update to existing branch, examine new commits
-			range="$remote_sha..$local_sha"
+			range="$remote_oid..$local_oid"
 		fi
 
 		# Check for WIP commit
-		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
-		if [ -n "$commit" ]
+		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
+		if test -n "$commit"
 		then
 			echo >&2 "Found WIP commit in $local_ref, not pushing"
 			exit 1
diff -Nur libstb-hal-ddt.git.orig/.git/hooks/pre-rebase.sample libstb-hal-ddt.git/.git/hooks/pre-rebase.sample
--- libstb-hal-ddt.git.orig/.git/hooks/pre-rebase.sample	2019-01-03 17:40:38.000000000 +0100
+++ libstb-hal-ddt.git/.git/hooks/pre-rebase.sample	2022-07-23 18:18:28.599831365 +0200
@@ -58,7 +58,7 @@
 	not_in_topic=`git rev-list "^$topic" master`
 	if test -z "$not_in_topic"
 	then
-		echo >&2 "$topic is already up-to-date with master"
+		echo >&2 "$topic is already up to date with master"
 		exit 1 ;# we could allow it, but there is no point.
 	else
 		exit 0
diff -Nur libstb-hal-ddt.git.orig/.git/hooks/push-to-checkout.sample libstb-hal-ddt.git/.git/hooks/push-to-checkout.sample
--- libstb-hal-ddt.git.orig/.git/hooks/push-to-checkout.sample	1970-01-01 01:00:00.000000000 +0100
+++ libstb-hal-ddt.git/.git/hooks/push-to-checkout.sample	2022-07-23 18:18:28.599831365 +0200
@@ -0,0 +1,78 @@
+#!/bin/sh
+
+# An example hook script to update a checked-out tree on a git push.
+#
+# This hook is invoked by git-receive-pack(1) when it reacts to git
+# push and updates reference(s) in its repository, and when the push
+# tries to update the branch that is currently checked out and the
+# receive.denyCurrentBranch configuration variable is set to
+# updateInstead.
+#
+# By default, such a push is refused if the working tree and the index
+# of the remote repository has any difference from the currently
+# checked out commit; when both the working tree and the index match
+# the current commit, they are updated to match the newly pushed tip
+# of the branch. This hook is to be used to override the default
+# behaviour; however the code below reimplements the default behaviour
+# as a starting point for convenient modification.
+#
+# The hook receives the commit with which the tip of the current
+# branch is going to be updated:
+commit=$1
+
+# It can exit with a non-zero status to refuse the push (when it does
+# so, it must not modify the index or the working tree).
+die () {
+	echo >&2 "$*"
+	exit 1
+}
+
+# Or it can make any necessary changes to the working tree and to the
+# index to bring them to the desired state when the tip of the current
+# branch is updated to the new commit, and exit with a zero status.
+#
+# For example, the hook can simply run git read-tree -u -m HEAD "$1"
+# in order to emulate git fetch that is run in the reverse direction
+# with git push, as the two-tree form of git read-tree -u -m is
+# essentially the same as git switch or git checkout that switches
+# branches while keeping the local changes in the working tree that do
+# not interfere with the difference between the branches.
+
+# The below is a more-or-less exact translation to shell of the C code
+# for the default behaviour for git's push-to-checkout hook defined in
+# the push_to_deploy() function in builtin/receive-pack.c.
+#
+# Note that the hook will be executed from the repository directory,
+# not from the working tree, so if you want to perform operations on
+# the working tree, you will have to adapt your code accordingly, e.g.
+# by adding "cd .." or using relative paths.
+
+if ! git update-index -q --ignore-submodules --refresh
+then
+	die "Up-to-date check failed"
+fi
+
+if ! git diff-files --quiet --ignore-submodules --
+then
+	die "Working directory has unstaged changes"
+fi
+
+# This is a rough translation of:
+#
+#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
+if git cat-file -e HEAD 2>/dev/null
+then
+	head=HEAD
+else
+	head=$(git hash-object -t tree --stdin </dev/null)
+fi
+
+if ! git diff-index --quiet --cached --ignore-submodules $head --
+then
+	die "Working directory has staged changes"
+fi
+
+if ! git read-tree -u -m "$commit"
+then
+	die "Could not update working tree to new HEAD"
+fi
diff -Nur libstb-hal-ddt.git.orig/.git/hooks/update.sample libstb-hal-ddt.git/.git/hooks/update.sample
--- libstb-hal-ddt.git.orig/.git/hooks/update.sample	2019-01-03 17:40:38.000000000 +0100
+++ libstb-hal-ddt.git/.git/hooks/update.sample	2022-07-23 18:18:28.599831365 +0200
@@ -1,6 +1,6 @@
 #!/bin/sh
 #
-# An example hook script to blocks unannotated tags from entering.
+# An example hook script to block unannotated tags from entering.
 # Called by "git receive-pack" with arguments: refname sha1-old sha1-new
 #
 # To enable this hook, rename this file to "update".
@@ -38,16 +38,16 @@
 fi
 
 if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
-	echo "Usage: $0 <ref> <oldrev> <newrev>" >&2
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
 	exit 1
 fi
 
 # --- Config
-allowunannotated=$(git config --bool hooks.allowunannotated)
-allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --bool hooks.denycreatebranch)
-allowdeletetag=$(git config --bool hooks.allowdeletetag)
-allowmodifytag=$(git config --bool hooks.allowmodifytag)
+allowunannotated=$(git config --type=bool hooks.allowunannotated)
+allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
 
 # check for no description
 projectdesc=$(sed -e '1q' "$GIT_DIR/description")
@@ -60,7 +60,7 @@
 
 # --- Check types
 # if $newrev is 0000...0000, it's a commit to delete a ref.
-zero="0000000000000000000000000000000000000000"
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
 if [ "$newrev" = "$zero" ]; then
 	newrev_type=delete
 else
Binary files libstb-hal-ddt.git.orig/.git/index and libstb-hal-ddt.git/.git/index differ
diff -Nur libstb-hal-ddt.git.orig/.git/logs/HEAD libstb-hal-ddt.git/.git/logs/HEAD
--- libstb-hal-ddt.git.orig/.git/logs/HEAD	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/.git/logs/HEAD	2022-07-23 18:18:31.475773591 +0200
@@ -1,2 +1 @@
-0000000000000000000000000000000000000000 9017322e21fecf5b90ff8163af47fef206228644 mohousch <mohousch@gmail.com> 1546533642 +0100	clone: from https://github.com/Duckbox-Developers/libstb-hal-ddt.git
-9017322e21fecf5b90ff8163af47fef206228644 62359461930a5c29a3d95a9ed794c7a5f0dfde4f mohousch <mohousch@gmail.com> 1587393162 +0200	pull: Fast-forward
+0000000000000000000000000000000000000000 007b718d55b4ffc14d5499941e10e5956c4a76a7 mohousch <mohousch@gmail.com> 1658593111 +0200	clone: from https://github.com/Duckbox-Developers/libstb-hal-ddt.git
diff -Nur libstb-hal-ddt.git.orig/.git/logs/refs/heads/master libstb-hal-ddt.git/.git/logs/refs/heads/master
--- libstb-hal-ddt.git.orig/.git/logs/refs/heads/master	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/.git/logs/refs/heads/master	2022-07-23 18:18:31.475773591 +0200
@@ -1,2 +1 @@
-0000000000000000000000000000000000000000 9017322e21fecf5b90ff8163af47fef206228644 mohousch <mohousch@gmail.com> 1546533642 +0100	clone: from https://github.com/Duckbox-Developers/libstb-hal-ddt.git
-9017322e21fecf5b90ff8163af47fef206228644 62359461930a5c29a3d95a9ed794c7a5f0dfde4f mohousch <mohousch@gmail.com> 1587393162 +0200	pull: Fast-forward
+0000000000000000000000000000000000000000 007b718d55b4ffc14d5499941e10e5956c4a76a7 mohousch <mohousch@gmail.com> 1658593111 +0200	clone: from https://github.com/Duckbox-Developers/libstb-hal-ddt.git
diff -Nur libstb-hal-ddt.git.orig/.git/logs/refs/remotes/origin/hal-ddt libstb-hal-ddt.git/.git/logs/refs/remotes/origin/hal-ddt
--- libstb-hal-ddt.git.orig/.git/logs/refs/remotes/origin/hal-ddt	2022-04-16 14:08:12.770347000 +0200
+++ libstb-hal-ddt.git/.git/logs/refs/remotes/origin/hal-ddt	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 0c36695415d1d7a4a7ef1533180aad4056d51b47 mohousch <mohousch@gmail.com> 1650110892 +0200	pull: storing head
diff -Nur libstb-hal-ddt.git.orig/.git/logs/refs/remotes/origin/HEAD libstb-hal-ddt.git/.git/logs/refs/remotes/origin/HEAD
--- libstb-hal-ddt.git.orig/.git/logs/refs/remotes/origin/HEAD	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/.git/logs/refs/remotes/origin/HEAD	2022-07-23 18:18:31.475773591 +0200
@@ -1 +1 @@
-0000000000000000000000000000000000000000 9017322e21fecf5b90ff8163af47fef206228644 mohousch <mohousch@gmail.com> 1546533642 +0100	clone: from https://github.com/Duckbox-Developers/libstb-hal-ddt.git
+0000000000000000000000000000000000000000 007b718d55b4ffc14d5499941e10e5956c4a76a7 mohousch <mohousch@gmail.com> 1658593111 +0200	clone: from https://github.com/Duckbox-Developers/libstb-hal-ddt.git
diff -Nur libstb-hal-ddt.git.orig/.git/logs/refs/remotes/origin/master libstb-hal-ddt.git/.git/logs/refs/remotes/origin/master
--- libstb-hal-ddt.git.orig/.git/logs/refs/remotes/origin/master	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/.git/logs/refs/remotes/origin/master	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-9017322e21fecf5b90ff8163af47fef206228644 62359461930a5c29a3d95a9ed794c7a5f0dfde4f mohousch <mohousch@debian> 1587393161 +0200	pull: fast-forward
diff -Nur libstb-hal-ddt.git.orig/.git/logs/refs/remotes/origin/test libstb-hal-ddt.git/.git/logs/refs/remotes/origin/test
--- libstb-hal-ddt.git.orig/.git/logs/refs/remotes/origin/test	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/.git/logs/refs/remotes/origin/test	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 416c5158c311ef14bd80d525fe9f8838b7e99241 mohousch <mohousch@debian> 1587393161 +0200	pull: storing head
diff -Nur libstb-hal-ddt.git.orig/.git/objects/00/7b718d55b4ffc14d5499941e10e5956c4a76a7 libstb-hal-ddt.git/.git/objects/00/7b718d55b4ffc14d5499941e10e5956c4a76a7
--- libstb-hal-ddt.git.orig/.git/objects/00/7b718d55b4ffc14d5499941e10e5956c4a76a7	2022-07-09 15:25:18.384822000 +0200
+++ libstb-hal-ddt.git/.git/objects/00/7b718d55b4ffc14d5499941e10e5956c4a76a7	1970-01-01 01:00:00.000000000 +0100
@@ -1,7 +0,0 @@
-xÉÎ£FF³æ)j3)¥ÌdÀàÉy2M~ú8ÝÊ®W}WWGú¤OW:7û¾ÁeYù7ü(
-À³[As±Ì·#"RR!f2Ç)ÃI.s9GMÉ£0,ÏÉre)d ´,,Q.³¦äÓ4òDHKJ¸`ç$®ø3~lÿàùïzÄ}ÒÜþÈÆþ/ÀPÜÊ¼Èf8¡>ôSB¿®¦jn*ðû³ÓóÃÓ8¡/ßÓ¾s
-P qÍ÷¡R¡\o4m=}O»Iàµa-]Aè0Ww:êè^H©:÷N® Ô_N:ÂLiÐNíì½gÑäÉU£Õûá¸I*Y×eq+
-hos¨L?Ôx0¶ér§{ÃÎGGs7îÈe­ÝéØHJ¦8J[Ã¡ÀFË8.gîi«fij?ô÷î°Óí§.âRöJ½3!¼ECZÏ@M¬¢Ï)°-00µ¼Yì/x¢H³c²öö5X09Û¥n}Q§®ÉÐ;¾Ã9ïO£i±ë]So¼z3ºcCÜ=¿¸ÍÚÆÖ³«ËíÂòûe¬(Ðàåz©rn¾³â=KÉÀÏJ<Kô4½;B&æêÑ,ý:¦ízºÐx=ÞÂWVÙRàmJ¶ö¥µhm)yÁÊéùÍ½T^·¼ÛîÉuö¶ÏG|p{÷è¬oZÈ4C	ÄÉV5P@¡-kÿö£ÞFÆá 
-uKwéQ"oãµs`Ånul§vÔ¢½xwþõÊ';FÞØcOÈrhL¥ÚSÇ_Vå¿Ø}8Ç¾VôÚ¤Y1ÄãL¢êÑDøj$5ìçÊ
-Ãcd­³=_ï]eìP{wÞ3Ç[=
-¯ >Ä³G0ÏÞ#£Z£%tQà6¶"ºÖUQ,oðÁs¸'d¾`uþÕyø²Ãé¦½^9ûFoäÔg´ú3c¨¾çf¨@_Ìs1T;Ëßóç/t[Vä@2ä`ü®zÙ"§þ=²gÚ
\ No newline at end of file
Binary files libstb-hal-ddt.git.orig/.git/objects/1e/34b9d62744a07bc85625ddf9bbf34b6a321b9e and libstb-hal-ddt.git/.git/objects/1e/34b9d62744a07bc85625ddf9bbf34b6a321b9e differ
Binary files libstb-hal-ddt.git.orig/.git/objects/28/6bcc88423f138ea5d43a4994ae604aff1a04d1 and libstb-hal-ddt.git/.git/objects/28/6bcc88423f138ea5d43a4994ae604aff1a04d1 differ
diff -Nur libstb-hal-ddt.git.orig/.git/objects/2f/d882bcd158064ede2b01618da587754d305d1c libstb-hal-ddt.git/.git/objects/2f/d882bcd158064ede2b01618da587754d305d1c
--- libstb-hal-ddt.git.orig/.git/objects/2f/d882bcd158064ede2b01618da587754d305d1c	2022-07-09 15:25:18.384822000 +0200
+++ libstb-hal-ddt.git/.git/objects/2f/d882bcd158064ede2b01618da587754d305d1c	1970-01-01 01:00:00.000000000 +0100
@@ -1,3 +0,0 @@
-xSË®£VÌ¯8{+áyJ(`À×`0ïw3âæq0oøú8ÍnVéUwªU­V%¨m«	g,TÆD9I2Qä¢øáb6yÏ$Éñç(Jù R2ÁúhÈº	ðtqGP4ýæ	&â!qÇ	)£`Â#
-òX4O%hFÝTfø3îtß§ñïMmT5$¨ýÍ°$	N{£oÓ[ôÔE_U~ÿ·Dùz3y5s»ëÙò80PY·CñR©RÉòÚÊÇÉ|KÛD³tT=e­­û%\ÚúcàÍØ·R
-õúI(Ê·y1&ãIïxNF¤Û»5Ûl ÀàÒ=;ÜÑW¸µ®S«IÕ Ù õ«ù;Ö$Õ&çµÚ#£K3ú¸äÍÓh-Èuü2ü>à¯q,´EÆ\qE(CµÇbÝ(±úÚõ:e2Ûë¥°<ÉÈ@A+ÎSüì«+jZn8èÕ+]áðü³ë	;j5ðü;uzªî¦ÜYçsôDú¹À=ÀÀ§EÆttÔ«YÊæSz(åð÷¬süt8=ú"$Ì¾­1lëª"ýVèò:ëÓ}Ì^|§m6<Õb+ãiö¬ØdË\9Ø³ÜhöÙç±¿}Ã@¥Æcí7µòs<TÝÔX"¸2]Ãu°þ°ëe.MF­$s	$§Ùñ±p>¥«ØËò4ìðPÐÃj»k¾i°%´V}V%4áýãä7Tb5;h-j,`¹èøÞ´ç_¯=êNZoíô#Æd_8B×eÑðxó.Ò¤©dFõGæù}ià<æ,Íä?P{Éy#ÉmåÓaãîwéØdF(CW«pñM54ýuÞ÷½Á?òuÑ½5ù-BlÔ¨EóâÎg»ÿô¯ÜØ­R-õÍB}ÃÀ·=Iö#3²!ý*1ØÜÍc¤Û¦ïiÏ²-YýQï^£
\ No newline at end of file
Binary files libstb-hal-ddt.git.orig/.git/objects/31/7449d6fd7e06e6558eaf8e6c922fb03fad92d2 and libstb-hal-ddt.git/.git/objects/31/7449d6fd7e06e6558eaf8e6c922fb03fad92d2 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/35/00eb8c8d5367b90897aca1051fee465bdd5916 and libstb-hal-ddt.git/.git/objects/35/00eb8c8d5367b90897aca1051fee465bdd5916 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/3a/a2e35337692255e9c1fe847df3bfd77610cc14 and libstb-hal-ddt.git/.git/objects/3a/a2e35337692255e9c1fe847df3bfd77610cc14 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/4d/0da1393317283fa1929ab6b2c92936b025281c and libstb-hal-ddt.git/.git/objects/4d/0da1393317283fa1929ab6b2c92936b025281c differ
Binary files libstb-hal-ddt.git.orig/.git/objects/4e/6af226accf0449c68b7c26a22893aad9f14d2c and libstb-hal-ddt.git/.git/objects/4e/6af226accf0449c68b7c26a22893aad9f14d2c differ
Binary files libstb-hal-ddt.git.orig/.git/objects/51/3299eccb50587515fa69fce5b253bbd4da4bf8 and libstb-hal-ddt.git/.git/objects/51/3299eccb50587515fa69fce5b253bbd4da4bf8 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/5d/a8446c0c3d05cf5b1a7f7f69fd2414f9572bad and libstb-hal-ddt.git/.git/objects/5d/a8446c0c3d05cf5b1a7f7f69fd2414f9572bad differ
diff -Nur libstb-hal-ddt.git.orig/.git/objects/62/529e5a54813accbab081ad725dc3590655462f libstb-hal-ddt.git/.git/objects/62/529e5a54813accbab081ad725dc3590655462f
--- libstb-hal-ddt.git.orig/.git/objects/62/529e5a54813accbab081ad725dc3590655462f	2022-07-09 15:25:18.392822000 +0200
+++ libstb-hal-ddt.git/.git/objects/62/529e5a54813accbab081ad725dc3590655462f	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-x+)JMU053`040031QH,MÉÌÏHÌÑË`;*ØoÅ÷Û©òZPõÅh~'ÖØPeÉ@ù3_oÙ°Á/DÙâìgFÅ¾ÍàòñÉ@%ïwZYÖ¬òívVÉ~éÅOåW"@¬)+^yK[®Biñ"}OF£·`jãK*R&Å|ÕÊÜ¼íúDÏ~kFÇãÇu7'ÌªJÉ­ºÏ'ñnÉýZå»ªù«ôöì*JÏIK#«¹VW%cáÙü5×³¬Õ¹á¾ó.TEFbQJybQj|rbÈÆ<un_Çd×i¼w¹Ò¶l¨ÒÌ¼Ì 
-ÇË!«:lÔxt6è
-:*Ù.Ø
-UòþO¿3öÚyßÒû¾òÿÛ­K.Bä$V&%&gC]n·"íüÝ=mý¼§*Ún?SY^^4®äx¼Õ£¤GÍûãx§ºL\´ª¨(59¿(jØDFÕÌÉ*ÓêOÙòáq°Öïp¨º²Ô¢âÌü<¨Â^<­ac1ZrçÇM~³C¿EÂf¦¤ÂÂåÀus/½k[î´îsÉ¬HiSÔÈ+Ü.
\ No newline at end of file
Binary files libstb-hal-ddt.git.orig/.git/objects/64/f005c7dbc3c1a0cac222f2c58a8699b603d677 and libstb-hal-ddt.git/.git/objects/64/f005c7dbc3c1a0cac222f2c58a8699b603d677 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/65/2c093c2fdd99b7f26c575d601d7bd6486e757b and libstb-hal-ddt.git/.git/objects/65/2c093c2fdd99b7f26c575d601d7bd6486e757b differ
Binary files libstb-hal-ddt.git.orig/.git/objects/71/7d6aa5bba71fcaa87e2e99f2006ad3263a9a12 and libstb-hal-ddt.git/.git/objects/71/7d6aa5bba71fcaa87e2e99f2006ad3263a9a12 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/84/c20a8a3a6f95b0b8f57cde9c92037994e6efaf and libstb-hal-ddt.git/.git/objects/84/c20a8a3a6f95b0b8f57cde9c92037994e6efaf differ
Binary files libstb-hal-ddt.git.orig/.git/objects/95/ce848145589316a9000bebb62047840c73a409 and libstb-hal-ddt.git/.git/objects/95/ce848145589316a9000bebb62047840c73a409 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/b2/0be704e953047325bfa5e1c9f61ef6514f6cbc and libstb-hal-ddt.git/.git/objects/b2/0be704e953047325bfa5e1c9f61ef6514f6cbc differ
Binary files libstb-hal-ddt.git.orig/.git/objects/e6/3557dda37b24c6df50daa3769ed5aab7986083 and libstb-hal-ddt.git/.git/objects/e6/3557dda37b24c6df50daa3769ed5aab7986083 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/eb/fe89c0e1afb29f2821eb9ae81f0d40d25b9f65 and libstb-hal-ddt.git/.git/objects/eb/fe89c0e1afb29f2821eb9ae81f0d40d25b9f65 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/ef/b93a397cad94f6db6a74b08f1bfe73e51e53a9 and libstb-hal-ddt.git/.git/objects/ef/b93a397cad94f6db6a74b08f1bfe73e51e53a9 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/f0/5ed55b9737371c141addea9c7becd2a16beef6 and libstb-hal-ddt.git/.git/objects/f0/5ed55b9737371c141addea9c7becd2a16beef6 differ
Binary files libstb-hal-ddt.git.orig/.git/objects/pack/pack-518715c73782c2b8bf2e787a65c79ddaef85645f.idx and libstb-hal-ddt.git/.git/objects/pack/pack-518715c73782c2b8bf2e787a65c79ddaef85645f.idx differ
Binary files libstb-hal-ddt.git.orig/.git/objects/pack/pack-518715c73782c2b8bf2e787a65c79ddaef85645f.pack and libstb-hal-ddt.git/.git/objects/pack/pack-518715c73782c2b8bf2e787a65c79ddaef85645f.pack differ
Binary files libstb-hal-ddt.git.orig/.git/objects/pack/pack-5f82366bffb34a5553b47d43975372899b206216.idx and libstb-hal-ddt.git/.git/objects/pack/pack-5f82366bffb34a5553b47d43975372899b206216.idx differ
Binary files libstb-hal-ddt.git.orig/.git/objects/pack/pack-5f82366bffb34a5553b47d43975372899b206216.pack and libstb-hal-ddt.git/.git/objects/pack/pack-5f82366bffb34a5553b47d43975372899b206216.pack differ
Binary files libstb-hal-ddt.git.orig/.git/objects/pack/pack-60d716d6f39cfb8044e872ed4698ed9208bf7224.idx and libstb-hal-ddt.git/.git/objects/pack/pack-60d716d6f39cfb8044e872ed4698ed9208bf7224.idx differ
Binary files libstb-hal-ddt.git.orig/.git/objects/pack/pack-60d716d6f39cfb8044e872ed4698ed9208bf7224.pack and libstb-hal-ddt.git/.git/objects/pack/pack-60d716d6f39cfb8044e872ed4698ed9208bf7224.pack differ
Binary files libstb-hal-ddt.git.orig/.git/objects/pack/pack-bf984a444b0e629fc1606a6ff6c3a94cd1d8fa19.idx and libstb-hal-ddt.git/.git/objects/pack/pack-bf984a444b0e629fc1606a6ff6c3a94cd1d8fa19.idx differ
Binary files libstb-hal-ddt.git.orig/.git/objects/pack/pack-bf984a444b0e629fc1606a6ff6c3a94cd1d8fa19.pack and libstb-hal-ddt.git/.git/objects/pack/pack-bf984a444b0e629fc1606a6ff6c3a94cd1d8fa19.pack differ
Binary files libstb-hal-ddt.git.orig/.git/objects/pack/pack-ca847f3c7fed09706bca3dab888ad2688518e9c2.idx and libstb-hal-ddt.git/.git/objects/pack/pack-ca847f3c7fed09706bca3dab888ad2688518e9c2.idx differ
Binary files libstb-hal-ddt.git.orig/.git/objects/pack/pack-ca847f3c7fed09706bca3dab888ad2688518e9c2.pack and libstb-hal-ddt.git/.git/objects/pack/pack-ca847f3c7fed09706bca3dab888ad2688518e9c2.pack differ
diff -Nur libstb-hal-ddt.git.orig/.git/ORIG_HEAD libstb-hal-ddt.git/.git/ORIG_HEAD
--- libstb-hal-ddt.git.orig/.git/ORIG_HEAD	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/.git/ORIG_HEAD	2022-07-23 18:19:01.495170070 +0200
@@ -1 +1 @@
-9017322e21fecf5b90ff8163af47fef206228644
+007b718d55b4ffc14d5499941e10e5956c4a76a7
diff -Nur libstb-hal-ddt.git.orig/.git/packed-refs libstb-hal-ddt.git/.git/packed-refs
--- libstb-hal-ddt.git.orig/.git/packed-refs	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/.git/packed-refs	2022-07-23 18:18:31.475773591 +0200
@@ -1,2 +1,3 @@
-# pack-refs with: peeled 
-9017322e21fecf5b90ff8163af47fef206228644 refs/remotes/origin/master
+# pack-refs with: peeled fully-peeled sorted 
+0c36695415d1d7a4a7ef1533180aad4056d51b47 refs/remotes/origin/hal-ddt
+007b718d55b4ffc14d5499941e10e5956c4a76a7 refs/remotes/origin/master
diff -Nur libstb-hal-ddt.git.orig/.git/refs/heads/master libstb-hal-ddt.git/.git/refs/heads/master
--- libstb-hal-ddt.git.orig/.git/refs/heads/master	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/.git/refs/heads/master	2022-07-23 18:18:31.475773591 +0200
@@ -1 +1 @@
-62359461930a5c29a3d95a9ed794c7a5f0dfde4f
+007b718d55b4ffc14d5499941e10e5956c4a76a7
diff -Nur libstb-hal-ddt.git.orig/.git/refs/remotes/origin/hal-ddt libstb-hal-ddt.git/.git/refs/remotes/origin/hal-ddt
--- libstb-hal-ddt.git.orig/.git/refs/remotes/origin/hal-ddt	2022-04-16 14:08:12.770347000 +0200
+++ libstb-hal-ddt.git/.git/refs/remotes/origin/hal-ddt	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-0c36695415d1d7a4a7ef1533180aad4056d51b47
diff -Nur libstb-hal-ddt.git.orig/.git/refs/remotes/origin/master libstb-hal-ddt.git/.git/refs/remotes/origin/master
--- libstb-hal-ddt.git.orig/.git/refs/remotes/origin/master	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/.git/refs/remotes/origin/master	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-62359461930a5c29a3d95a9ed794c7a5f0dfde4f
diff -Nur libstb-hal-ddt.git.orig/.git/refs/remotes/origin/test libstb-hal-ddt.git/.git/refs/remotes/origin/test
--- libstb-hal-ddt.git.orig/.git/refs/remotes/origin/test	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/.git/refs/remotes/origin/test	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-416c5158c311ef14bd80d525fe9f8838b7e99241
diff -Nur libstb-hal-ddt.git.orig/include/audio_hal.h libstb-hal-ddt.git/include/audio_hal.h
--- libstb-hal-ddt.git.orig/include/audio_hal.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/audio_hal.h	2022-07-23 18:18:31.495773190 +0200
@@ -1,7 +1,5 @@
 #include <config.h>
-#if HAVE_TRIPLEDRAGON
-#include "../libtriple/audio_td.h"
-#elif HAVE_DUCKBOX_HARDWARE
+#if HAVE_DUCKBOX_HARDWARE
 #include "../libduckbox/audio_lib.h"
 #include "../libduckbox/audio_mixer.h"
 #elif HAVE_SPARK_HARDWARE
@@ -11,8 +9,6 @@
 #include "../libarmbox/audio_lib.h"
 #elif HAVE_MIPS_HARDWARE
 #include "../libmipsbox/audio_lib.h"
-#elif HAVE_AZBOX_HARDWARE
-#include "../libazbox/audio_lib.h"
 #elif HAVE_GENERIC_HARDWARE
 #if BOXMODEL_RASPI
 #include "../libraspi/audio_lib.h"
diff -Nur libstb-hal-ddt.git.orig/include/ca_ci.h libstb-hal-ddt.git/include/ca_ci.h
--- libstb-hal-ddt.git.orig/include/ca_ci.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/ca_ci.h	2022-07-23 18:18:31.495773190 +0200
@@ -12,63 +12,59 @@
 
 #include "mmi.h"
 #include "cs_types.h"
-#include "cs_api.h"
 
 /* constants taken from dvb-apps */
-#define T_SB                0x80	// sb                           primitive   h<--m
-#define T_RCV               0x81	// receive                      primitive   h-->m
-#define T_CREATE_T_C        0x82	// create transport connection  primitive   h-->m
-#define T_C_T_C_REPLY       0x83	// ctc reply                    primitive   h<--m
-#define T_DELETE_T_C        0x84	// delete tc                    primitive   h<->m
-#define T_D_T_C_REPLY       0x85	// dtc reply                    primitive   h<->m
-#define T_REQUEST_T_C       0x86	// request transport connection primitive   h<--m
-#define T_NEW_T_C           0x87	// new tc / reply to t_request  primitive   h-->m
-#define T_T_C_ERROR         0x77	// error creating tc            primitive   h-->m
-#define T_DATA_LAST         0xA0	// convey data from higher      constructed h<->m
-#define T_DATA_MORE         0xA1	// convey data from higher      constructed h<->m
+#define T_SB                0x80    // sb                           primitive   h<--m
+#define T_RCV               0x81    // receive                      primitive   h-->m
+#define T_CREATE_T_C        0x82    // create transport connection  primitive   h-->m
+#define T_C_T_C_REPLY       0x83    // ctc reply                    primitive   h<--m
+#define T_DELETE_T_C        0x84    // delete tc                    primitive   h<->m
+#define T_D_T_C_REPLY       0x85    // dtc reply                    primitive   h<->m
+#define T_REQUEST_T_C       0x86    // request transport connection primitive   h<--m
+#define T_NEW_T_C           0x87    // new tc / reply to t_request  primitive   h-->m
+#define T_T_C_ERROR         0x77    // error creating tc            primitive   h-->m
+#define T_DATA_LAST         0xA0    // convey data from higher      constructed h<->m
+#define T_DATA_MORE         0xA1    // convey data from higher      constructed h<->m
 
 /* max multi decrypt per ci-cam */
-#define CI_MAX_MULTI			5
+#define CI_MAX_MULTI            5
 
-enum CA_INIT_MASK {
-	CA_INIT_SC = 1,
-	CA_INIT_CI,
-	CA_INIT_BOTH
-};
-
-enum CA_SLOT_TYPE {
+enum CA_SLOT_TYPE
+{
 	CA_SLOT_TYPE_SMARTCARD,
 	CA_SLOT_TYPE_CI,
 	CA_SLOT_TYPE_ALL
 };
 
-enum CA_MESSAGE_FLAGS {
-	CA_MESSAGE_EMPTY		= (1 << 0),
-	CA_MESSAGE_HAS_PARAM1_DATA	= (1 << 1), /// Free after use!
-	CA_MESSAGE_HAS_PARAM1_INT	= (1 << 2),
-	CA_MESSAGE_HAS_PARAM1_PTR	= (1 << 3),
-	CA_MESSAGE_HAS_PARAM2_INT	= (1 << 4),
-	CA_MESSAGE_HAS_PARAM2_PTR	= (1 << 5),
-	CA_MESSAGE_HAS_PARAM2_DATA	= (1 << 6),
-	CA_MESSAGE_HAS_PARAM3_DATA	= (1 << 7), /// Free after use!
-	CA_MESSAGE_HAS_PARAM3_INT	= (1 << 8),
-	CA_MESSAGE_HAS_PARAM3_PTR	= (1 << 9),
-	CA_MESSAGE_HAS_PARAM4_INT	= (1 << 10),
-	CA_MESSAGE_HAS_PARAM4_PTR	= (1 << 11),
-	CA_MESSAGE_HAS_PARAM4_DATA	= (1 << 12),
-	CA_MESSAGE_HAS_PARAM5_INT	= (1 << 13),
-	CA_MESSAGE_HAS_PARAM5_PTR	= (1 << 14),
-	CA_MESSAGE_HAS_PARAM5_DATA	= (1 << 15),
-	CA_MESSAGE_HAS_PARAM6_INT	= (1 << 16),
-	CA_MESSAGE_HAS_PARAM6_PTR	= (1 << 17),
-	CA_MESSAGE_HAS_PARAM6_DATA	= (1 << 18),
-	CA_MESSAGE_HAS_PARAM1_LONG	= (1 << 19),
-	CA_MESSAGE_HAS_PARAM2_LONG	= (1 << 20),
-	CA_MESSAGE_HAS_PARAM3_LONG	= (1 << 21),
-	CA_MESSAGE_HAS_PARAM4_LONG	= (1 << 22)
+enum CA_MESSAGE_FLAGS
+{
+	CA_MESSAGE_EMPTY        = (1 << 0),
+	CA_MESSAGE_HAS_PARAM1_DATA  = (1 << 1), /// Free after use!
+	CA_MESSAGE_HAS_PARAM1_INT   = (1 << 2),
+	CA_MESSAGE_HAS_PARAM1_PTR   = (1 << 3),
+	CA_MESSAGE_HAS_PARAM2_INT   = (1 << 4),
+	CA_MESSAGE_HAS_PARAM2_PTR   = (1 << 5),
+	CA_MESSAGE_HAS_PARAM2_DATA  = (1 << 6),
+	CA_MESSAGE_HAS_PARAM3_DATA  = (1 << 7), /// Free after use!
+	CA_MESSAGE_HAS_PARAM3_INT   = (1 << 8),
+	CA_MESSAGE_HAS_PARAM3_PTR   = (1 << 9),
+	CA_MESSAGE_HAS_PARAM4_INT   = (1 << 10),
+	CA_MESSAGE_HAS_PARAM4_PTR   = (1 << 11),
+	CA_MESSAGE_HAS_PARAM4_DATA  = (1 << 12),
+	CA_MESSAGE_HAS_PARAM5_INT   = (1 << 13),
+	CA_MESSAGE_HAS_PARAM5_PTR   = (1 << 14),
+	CA_MESSAGE_HAS_PARAM5_DATA  = (1 << 15),
+	CA_MESSAGE_HAS_PARAM6_INT   = (1 << 16),
+	CA_MESSAGE_HAS_PARAM6_PTR   = (1 << 17),
+	CA_MESSAGE_HAS_PARAM6_DATA  = (1 << 18),
+	CA_MESSAGE_HAS_PARAM1_LONG  = (1 << 19),
+	CA_MESSAGE_HAS_PARAM2_LONG  = (1 << 20),
+	CA_MESSAGE_HAS_PARAM3_LONG  = (1 << 21),
+	CA_MESSAGE_HAS_PARAM4_LONG  = (1 << 22)
 };
 
-enum CA_MESSAGE_MSGID {
+enum CA_MESSAGE_MSGID
+{
 	CA_MESSAGE_MSG_INSERTED,
 	CA_MESSAGE_MSG_REMOVED,
 	CA_MESSAGE_MSG_INIT_OK,
@@ -91,12 +87,14 @@
 	CA_MESSAGE_MSG_EXIT
 };
 
-typedef struct CA_MESSAGE {
+typedef struct CA_MESSAGE
+{
 	uint32_t MsgId;
 	enum CA_SLOT_TYPE SlotType;
 	int Slot;
 	uint32_t Flags;
-	union {
+	union
+	{
 		uint8_t *Data[4];
 		uint32_t Param[4];
 		void *Ptr[4];
@@ -104,30 +102,46 @@
 	} Msg;
 } CA_MESSAGE;
 
+typedef void (*hal_messenger)(unsigned int msg, unsigned int data);
+
+#if HAVE_DUCKBOX_HARDWARE || HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
+void hal_register_messenger(hal_messenger messenger);
+#else
+static inline void hal_register_messenger(hal_messenger)
+{
+	return;
+};
+#endif
+static inline void hal_deregister_messenger(void)
+{
+	return;
+};
+
 typedef std::set<int> ca_map_t;
 typedef ca_map_t::iterator ca_map_iterator_t;
 
-typedef std::vector<u16>			bSIDVector;
+typedef std::vector<u16>            bSIDVector;
 
-typedef std::vector<u16>			CaIdVector;
-typedef std::vector<u16>::iterator		CaIdVectorIterator;
-typedef std::vector<u16>::const_iterator	CaIdVectorConstIterator;
-
-#define CA_MESSAGE_SIZE		sizeof(CA_MESSAGE)
-#define CA_MESSAGE_ENTRIES	256
-#define CA_MESSAGE_ENTRIES_CI	128
-#define CA_MESSAGE_ENTRIES_SC	64
+typedef std::vector<u16>            CaIdVector;
+typedef std::vector<u16>::iterator      CaIdVectorIterator;
+typedef std::vector<u16>::const_iterator    CaIdVectorConstIterator;
+
+#define CA_MESSAGE_SIZE     sizeof(CA_MESSAGE)
+#define CA_MESSAGE_ENTRIES  256
+#define CA_MESSAGE_ENTRIES_CI   128
+#define CA_MESSAGE_ENTRIES_SC   64
 
 #ifndef CS_CA_PDATA
-#define CS_CA_PDATA		void
+#define CS_CA_PDATA     void
 #endif
 
-typedef enum {
+typedef enum
+{
 	TUNER_A,
 	TUNER_B,
 	TUNER_C,
 	TUNER_D
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 	, TUNER_E
 	, TUNER_F
 	, TUNER_G
@@ -153,7 +167,8 @@
 #endif
 } source_t;
 
-typedef enum {
+typedef enum
+{
 	eDataTimeout,
 	eDataError,
 	eDataReady,
@@ -161,7 +176,8 @@
 	eDataStatusChanged
 } eData;
 
-typedef enum {
+typedef enum
+{
 	eStatusNone,
 	eStatusWait,
 	eStatusReset
@@ -173,11 +189,11 @@
 	unsigned char *data;
 	unsigned int len;
 	queueData(unsigned char *_data, unsigned int _len, __u8 _prio = 0)
-		:prio(_prio), data(_data), len(_len)
+		: prio(_prio), data(_data), len(_len)
 	{
 
 	}
-	bool operator < ( const struct queueData &a ) const
+	bool operator < (const struct queueData &a) const
 	{
 		return prio < a.prio;
 	}
@@ -197,17 +213,17 @@
 	eStatus status;
 
 	int receivedLen;
-	unsigned char* receivedData;
+	unsigned char *receivedData;
 
-	void* pClass;
+	void *pClass;
 
 	bool pollConnection;
 	bool camIsReady;
 
-	eDVBCIMMISession* mmiSession;
-	eDVBCIApplicationManagerSession* appSession;
-	eDVBCICAManagerSession* camgrSession;
-	eDVBCIContentControlManagerSession* ccmgrSession;
+	eDVBCIMMISession *mmiSession;
+	eDVBCIApplicationManagerSession *appSession;
+	eDVBCICAManagerSession *camgrSession;
+	eDVBCIContentControlManagerSession *ccmgrSession;
 
 	bool hasAppManager;
 	bool hasMMIManager;
@@ -253,131 +269,127 @@
 
 } eDVBCISlot;
 
-eData sendData(eDVBCISlot *slot, unsigned char* data, int len);
+eData sendData(eDVBCISlot *slot, unsigned char *data, int len);
 
-typedef std::list<eDVBCISlot*>::iterator SlotIt;
+typedef std::list<eDVBCISlot *>::iterator SlotIt;
 
 /// CA module class
-class cCA {
-private:
-	/// Static instance of the CA module
+class cCA
+{
+	private:
+		/// Static instance of the CA module
 //	static cCA *inst;
-	/// Private constructor (singleton method)
-	cCA(void);
-	/// Private data for the CA module
-	CS_CA_PDATA *privateData;
-	/// set inputs with tuner letter in tsmux
-	void setInputs();
-	/// write ci info file to /tmp
-	void write_ci_info(int slot, CaIdVector caids);
-	/// delete ci info file
-	void del_ci_info(int slot);
-	/// extract audio / video pids from capmt 
-	void extractPids(eDVBCISlot* slot);
-	/// ci module is detected
-	void ci_inserted(eDVBCISlot* slot);
-	/// ci module is removed
-	void ci_removed(eDVBCISlot* slot);
-	/// decode the tpdu tag
-	void process_tpdu(eDVBCISlot* slot, unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id);
-	/// set flag of running ci record to false
-	bool StopRecordCI( u64 TP, u16 SID, u8 source, u32 calen);
-	/// set flag of running ci live-tv to false
-	bool StopLiveCI( u64 TP, u16 SID, u8 source, u32 calen);
-	/// find an unused ci slot for use with service
-	SlotIt FindFreeSlot(u64 tpid, u8 source, u16 sid, ca_map_t camap, u8 scrambled);
-	/// get slot iterator by slot number
-	SlotIt GetSlot(unsigned int slot);
-	/// send buffered capmt to ci modul
-	bool SendCaPMT(eDVBCISlot* slot);
-	/// send a dummy capmt to ci for deactivating
-	bool SendNullPMT(eDVBCISlot* slot);
-	/// set ci source
-	void setSource(eDVBCISlot* slot);
-	/// set demux source
-	void setInputSource(eDVBCISlot* slot, bool ci);
-	/// check if data in queue
-	bool checkQueueSize(eDVBCISlot* slot);
-	enum CA_INIT_MASK initMask;
-	int num_slots;
-	bool init;
-	void SendPMT();
-	pthread_mutex_t ciMutex;
-	std::list<eDVBCISlot*> slot_data;
-	pthread_t slot_thread;
-
-public:
-	/// sh4 unused
-	bool Init(void);
-	/// init ci and start the loop
-	cCA(int Slots);
-	/// Returns the number of CI slots
-	uint32_t GetNumberCISlots(void);
-	/// Returns the number of Smartcard slots
-	uint32_t GetNumberSmartCardSlots(void);
-	/// Singleton
-	static cCA *GetInstance(void);
-	/// Send PMT to a individual or to all available modules (DEPRECATED)
-	bool SendPMT(int Unit, unsigned char *Data, int Len, enum CA_SLOT_TYPE SlotType = CA_SLOT_TYPE_ALL);
-	/// Sends a message to the CA thread
-	bool SendMessage(const CA_MESSAGE *Msg);
-	/// Sets which modules to initialize. It is only
-	/// possible to change this once!
-	/// sh4 unused
-	void SetInitMask(enum CA_INIT_MASK InitMask);
-	/// Sets the frequency (in Hz) of the TS stream input (only valid for CI)
-	/// sh4 unused
-	void SetTSClock(u32 Speed, int slot = 0);
+		/// Private constructor (singleton method)
+		cCA(void);
+		/// Private data for the CA module
+		CS_CA_PDATA *privateData;
+		/// set inputs with tuner letter in tsmux
+		void setInputs();
+		/// write ci info file to /tmp
+		void write_ci_info(int slot, CaIdVector caids);
+		/// delete ci info file
+		void del_ci_info(int slot);
+		/// extract audio / video pids from capmt
+		void extractPids(eDVBCISlot *slot);
+		/// ci module is detected
+		void ci_inserted(eDVBCISlot *slot);
+		/// ci module is removed
+		void ci_removed(eDVBCISlot *slot);
+		/// decode the tpdu tag
+		void process_tpdu(eDVBCISlot *slot, unsigned char tpdu_tag, __u8 *data, int asn_data_length, int con_id);
+		/// set flag of running ci record to false
+		bool StopRecordCI(u64 TP, u16 SID, u8 source, u32 calen);
+		/// set flag of running ci live-tv to false
+		bool StopLiveCI(u64 TP, u16 SID, u8 source, u32 calen);
+		/// find an unused ci slot for use with service
+		SlotIt FindFreeSlot(u64 tpid, u8 source, u16 sid, ca_map_t camap, u8 scrambled);
+		/// get slot iterator by slot number
+		SlotIt GetSlot(unsigned int slot);
+		/// send buffered capmt to ci modul
+		bool SendCaPMT(eDVBCISlot *slot);
+		/// send a dummy capmt to ci for deactivating
+		bool SendNullPMT(eDVBCISlot *slot);
+		/// set ci source
+		void setSource(eDVBCISlot *slot);
+		/// set demux source
+		void setInputSource(eDVBCISlot *slot, bool ci);
+		/// check if data in queue
+		bool checkQueueSize(eDVBCISlot *slot);
+		int num_slots;
+		bool init;
+		void SendPMT();
+		pthread_mutex_t ciMutex;
+		std::list<eDVBCISlot *> slot_data;
+		pthread_t slot_thread;
+
+	public:
+		/// sh4 unused
+		bool Init(void);
+		/// init ci and start the loop
+		cCA(int Slots);
+		/// Returns the number of CI slots
+		uint32_t GetNumberCISlots(void);
+		/// Returns the number of Smartcard slots
+		uint32_t GetNumberSmartCardSlots(void);
+		/// Singleton
+		static cCA *GetInstance(void);
+		/// Send PMT to a individual or to all available modules (DEPRECATED)
+		bool SendPMT(int Unit, unsigned char *Data, int Len, enum CA_SLOT_TYPE SlotType = CA_SLOT_TYPE_ALL);
+		/// Sends a message to the CA thread
+		bool SendMessage(const CA_MESSAGE *Msg);
+		/// Sets the frequency (in Hz) of the TS stream input (only valid for CI)
+		/// sh4 unused
+		void SetTSClock(u32 Speed, int slot = 0);
 
 #if BOXMODEL_VUPLUS_ALL
-	/// dvb wait delay for ci response
-	void SetCIDelay(int Delay);
-	/// relevant pids routing
-	void SetCIRelevantPidsRouting(int RPR, int slot = 0);
+		/// dvb wait delay for ci response
+		void SetCIDelay(int Delay);
+		/// relevant pids routing
+		void SetCIRelevantPidsRouting(int RPR, int slot = 0);
 #endif
 
-	/// Start the CA module
-	/// sh4 unused
-	bool Start(void);
-	/// Stops the CA module
-	/// sh4 unused
-	void Stop(void);
-	/// Notify that the GUI is ready to receive messages
-	/// (CA messages coming from a module)
-	/// sh4 unused
-	void Ready(bool Set);
-	/// Resets a module (if possible)
-	/// sh4 unused
-	void ModuleReset(enum CA_SLOT_TYPE, uint32_t Slot);
-	/// Checks if a module is present
-	bool ModulePresent(enum CA_SLOT_TYPE, uint32_t Slot);
-	/// Returns the module name in array Name
-	void ModuleName(enum CA_SLOT_TYPE, uint32_t Slot, char *Name);
-	/// Notify the module we want to enter menu
-	void MenuEnter(enum CA_SLOT_TYPE, uint32_t Slot);
-	/// Notify the module with our answer (choice nr)
-	void MenuAnswer(enum CA_SLOT_TYPE, uint32_t Slot, uint32_t choice);
-	/// Notify the module with our answer (binary)
-	void InputAnswer(enum CA_SLOT_TYPE, uint32_t Slot, uint8_t * Data, int Len);
-	/// Notify the module we closed the menu
-	void MenuClose(enum CA_SLOT_TYPE, uint32_t Slot);
-	/// Get the supported CAIDs
-	int GetCAIDS(CaIdVector &Caids);
-	/// Send a CA-PMT object and Raw unparsed PMT to the CA layer
-	bool SendCAPMT(u64 /*Source*/, u8 /*DemuxSource*/, u8 /*DemuxMask*/, const unsigned char * /*CAPMT*/, u32 /*CAPMTLen*/, const unsigned char * /*RawPMT*/, u32 /*RawPMTLen*/, enum CA_SLOT_TYPE SlotType = CA_SLOT_TYPE_ALL,
-		unsigned char scrambled = 0, ca_map_t camap = std::set<int>(), int mode = 0, bool enabled = false);
-	/// sh4 unused
-	bool SendDateTime(void);
-	/// the main loop
-	void slot_pollthread(void *c);
-	/// check if current channel uses any ci module
-	bool checkChannelID(u64 chanID);
-	/// set checking for live-tv use ci to true
-	void setCheckLiveSlot(int check);
-	/// as the name says
-	bool CheckCerts(void);
-	/// Virtual destructor
-	virtual ~cCA();
+		/// Start the CA module
+		/// sh4 unused
+		bool Start(void);
+		/// Stops the CA module
+		/// sh4 unused
+		void Stop(void);
+		/// Notify that the GUI is ready to receive messages
+		/// (CA messages coming from a module)
+		/// sh4 unused
+		void Ready(bool Set);
+		/// Resets a module (if possible)
+		/// sh4 unused
+		void ModuleReset(enum CA_SLOT_TYPE, uint32_t Slot);
+		/// Checks if a module is present
+		bool ModulePresent(enum CA_SLOT_TYPE, uint32_t Slot);
+		/// Returns the module name in array Name
+		void ModuleName(enum CA_SLOT_TYPE, uint32_t Slot, char *Name);
+		/// Notify the module we want to enter menu
+		void MenuEnter(enum CA_SLOT_TYPE, uint32_t Slot);
+		/// Notify the module with our answer (choice nr)
+		void MenuAnswer(enum CA_SLOT_TYPE, uint32_t Slot, uint32_t choice);
+		/// Notify the module with our answer (binary)
+		void InputAnswer(enum CA_SLOT_TYPE, uint32_t Slot, uint8_t *Data, int Len);
+		/// Notify the module we closed the menu
+		void MenuClose(enum CA_SLOT_TYPE, uint32_t Slot);
+		/// Get the supported CAIDs
+		int GetCAIDS(CaIdVector &Caids);
+		/// Send a CA-PMT object and Raw unparsed PMT to the CA layer
+		bool SendCAPMT(u64 /*Source*/, u8 /*DemuxSource*/, u8 /*DemuxMask*/, const unsigned char * /*CAPMT*/, u32 /*CAPMTLen*/, const unsigned char * /*RawPMT*/, u32 /*RawPMTLen*/, enum CA_SLOT_TYPE SlotType = CA_SLOT_TYPE_ALL,
+		    unsigned char scrambled = 0, ca_map_t camap = std::set<int>(), int mode = 0, bool enabled = false);
+		/// sh4 unused
+		bool SendDateTime(void);
+		/// the main loop
+		void slot_pollthread(void *c);
+		/// check if current channel uses any ci module
+		bool checkChannelID(u64 chanID);
+		/// set checking for live-tv use ci to true
+		void setCheckLiveSlot(int check);
+		/// as the name says
+		bool CheckCerts(void);
+		/// Virtual destructor
+		virtual ~cCA();
 };
 
 #endif // __CA_CI_H__
diff -Nur libstb-hal-ddt.git.orig/include/ca.h libstb-hal-ddt.git/include/ca.h
--- libstb-hal-ddt.git.orig/include/ca.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/ca.h	2022-07-23 18:18:31.495773190 +0200
@@ -5,49 +5,46 @@
 #include "cs_types.h"
 #include <vector>
 #include <set>
-typedef std::vector<u16>			CaIdVector;
-typedef std::vector<u16>::iterator		CaIdVectorIterator;
-typedef std::vector<u16>::const_iterator	CaIdVectorConstIterator;
+typedef std::vector<u16>            CaIdVector;
+typedef std::vector<u16>::iterator      CaIdVectorIterator;
+typedef std::vector<u16>::const_iterator    CaIdVectorConstIterator;
 
-enum CA_INIT_MASK {
-	CA_INIT_SC = 1,
-	CA_INIT_CI,
-	CA_INIT_BOTH
-};
-
-enum CA_SLOT_TYPE {
+enum CA_SLOT_TYPE
+{
 	CA_SLOT_TYPE_SMARTCARD,
 	CA_SLOT_TYPE_CI,
 	CA_SLOT_TYPE_ALL
 };
 
-enum CA_MESSAGE_FLAGS {
-	CA_MESSAGE_EMPTY		= (1 << 0),
-	CA_MESSAGE_HAS_PARAM1_DATA	= (1 << 1), // Free after use!
-	CA_MESSAGE_HAS_PARAM1_INT	= (1 << 2),
-	CA_MESSAGE_HAS_PARAM1_PTR	= (1 << 3),
-	CA_MESSAGE_HAS_PARAM2_INT	= (1 << 4),
-	CA_MESSAGE_HAS_PARAM2_PTR	= (1 << 5),
-	CA_MESSAGE_HAS_PARAM2_DATA	= (1 << 6),
-	CA_MESSAGE_HAS_PARAM3_DATA	= (1 << 7), // Free after use!
-	CA_MESSAGE_HAS_PARAM3_INT	= (1 << 8),
-	CA_MESSAGE_HAS_PARAM3_PTR	= (1 << 9),
-	CA_MESSAGE_HAS_PARAM4_INT	= (1 << 10),
-	CA_MESSAGE_HAS_PARAM4_PTR	= (1 << 11),
-	CA_MESSAGE_HAS_PARAM4_DATA	= (1 << 12),
-	CA_MESSAGE_HAS_PARAM5_INT	= (1 << 13),
-	CA_MESSAGE_HAS_PARAM5_PTR	= (1 << 14),
-	CA_MESSAGE_HAS_PARAM5_DATA	= (1 << 15),
-	CA_MESSAGE_HAS_PARAM6_INT	= (1 << 16),
-	CA_MESSAGE_HAS_PARAM6_PTR	= (1 << 17),
-	CA_MESSAGE_HAS_PARAM6_DATA	= (1 << 18),
-	CA_MESSAGE_HAS_PARAM1_LONG	= (1 << 19),
-	CA_MESSAGE_HAS_PARAM2_LONG	= (1 << 20),
-	CA_MESSAGE_HAS_PARAM3_LONG	= (1 << 21),
-	CA_MESSAGE_HAS_PARAM4_LONG	= (1 << 22)
+enum CA_MESSAGE_FLAGS
+{
+	CA_MESSAGE_EMPTY        = (1 << 0),
+	CA_MESSAGE_HAS_PARAM1_DATA  = (1 << 1), // Free after use!
+	CA_MESSAGE_HAS_PARAM1_INT   = (1 << 2),
+	CA_MESSAGE_HAS_PARAM1_PTR   = (1 << 3),
+	CA_MESSAGE_HAS_PARAM2_INT   = (1 << 4),
+	CA_MESSAGE_HAS_PARAM2_PTR   = (1 << 5),
+	CA_MESSAGE_HAS_PARAM2_DATA  = (1 << 6),
+	CA_MESSAGE_HAS_PARAM3_DATA  = (1 << 7), // Free after use!
+	CA_MESSAGE_HAS_PARAM3_INT   = (1 << 8),
+	CA_MESSAGE_HAS_PARAM3_PTR   = (1 << 9),
+	CA_MESSAGE_HAS_PARAM4_INT   = (1 << 10),
+	CA_MESSAGE_HAS_PARAM4_PTR   = (1 << 11),
+	CA_MESSAGE_HAS_PARAM4_DATA  = (1 << 12),
+	CA_MESSAGE_HAS_PARAM5_INT   = (1 << 13),
+	CA_MESSAGE_HAS_PARAM5_PTR   = (1 << 14),
+	CA_MESSAGE_HAS_PARAM5_DATA  = (1 << 15),
+	CA_MESSAGE_HAS_PARAM6_INT   = (1 << 16),
+	CA_MESSAGE_HAS_PARAM6_PTR   = (1 << 17),
+	CA_MESSAGE_HAS_PARAM6_DATA  = (1 << 18),
+	CA_MESSAGE_HAS_PARAM1_LONG  = (1 << 19),
+	CA_MESSAGE_HAS_PARAM2_LONG  = (1 << 20),
+	CA_MESSAGE_HAS_PARAM3_LONG  = (1 << 21),
+	CA_MESSAGE_HAS_PARAM4_LONG  = (1 << 22)
 };
 
-enum CA_MESSAGE_MSGID {
+enum CA_MESSAGE_MSGID
+{
 	CA_MESSAGE_MSG_INSERTED,
 	CA_MESSAGE_MSG_REMOVED,
 	CA_MESSAGE_MSG_INIT_OK,
@@ -70,15 +67,32 @@
 	CA_MESSAGE_MSG_EXIT
 };
 
+typedef void (*hal_messenger)(unsigned int msg, unsigned int data);
+
+#if HAVE_DUCKBOX_HARDWARE || HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
+void hal_register_messenger(hal_messenger messenger);
+#else
+static inline void hal_register_messenger(hal_messenger)
+{
+	return;
+};
+#endif
+static inline void hal_deregister_messenger(void)
+{
+	return;
+};
+
 typedef std::set<int> ca_map_t;
 typedef ca_map_t::iterator ca_map_iterator_t;
 
-typedef struct CA_MESSAGE {
+typedef struct CA_MESSAGE
+{
 	uint32_t MsgId;
 	enum CA_SLOT_TYPE SlotType;
 	int Slot;
 	uint32_t Flags;
-	union {
+	union
+	{
 		uint8_t *Data[4];
 		uint32_t Param[4];
 		void *Ptr[4];
@@ -86,34 +100,49 @@
 	} Msg;
 } CA_MESSAGE;
 
-class cCA {
-private:
-	cCA(void);
-public:
-	uint32_t GetNumberCISlots(void);
-	uint32_t GetNumberSmartCardSlots(void);
-	static cCA *GetInstance(void);
-	bool SendPMT(int Unit, unsigned char *Data, int Len, CA_SLOT_TYPE SlotType = CA_SLOT_TYPE_ALL);
+class cCA
+{
+	private:
+		cCA(void);
+	public:
+		uint32_t GetNumberCISlots(void);
+		uint32_t GetNumberSmartCardSlots(void);
+		static cCA *GetInstance(void);
+		bool SendPMT(int Unit, unsigned char *Data, int Len, CA_SLOT_TYPE SlotType = CA_SLOT_TYPE_ALL);
 //	bool SendCAPMT(u64 /*Source*/, u8 /*DemuxSource*/, u8 /*DemuxMask*/, const unsigned char * /*CAPMT*/, u32 /*CAPMTLen*/, const unsigned char * /*RawPMT*/, u32 /*RawPMTLen*/) { return true; };
-	bool SendCAPMT(u64 /*Source*/, u8 /*DemuxSource*/, u8 /*DemuxMask*/, const unsigned char * /*CAPMT*/, u32 /*CAPMTLen*/, const unsigned char * /*RawPMT*/, u32 /*RawPMTLen*/, enum CA_SLOT_TYPE
-	/*SlotType*/, unsigned char /*scrambled = 0*/, ca_map_t /*camap = std::set<int>()*/, int /*mode = 0*/, bool /*enabled = false*/) { return true; };
-	bool SendMessage(const CA_MESSAGE *Msg);
-	void SetInitMask(enum CA_INIT_MASK InitMask);
-	int GetCAIDS(CaIdVector & /*Caids*/) { return 0; };
-	bool Start(void);
-	void Stop(void);
-	void Ready(bool Set);
-	void ModuleReset(enum CA_SLOT_TYPE, uint32_t Slot);
-	bool ModulePresent(enum CA_SLOT_TYPE, uint32_t Slot);
-	void ModuleName(enum CA_SLOT_TYPE, uint32_t Slot, char *Name);
-	void MenuEnter(enum CA_SLOT_TYPE, uint32_t Slot);
-	void MenuAnswer(enum CA_SLOT_TYPE, uint32_t Slot, uint32_t choice);
-	void InputAnswer(enum CA_SLOT_TYPE, uint32_t Slot, uint8_t * Data, int Len);
-	void MenuClose(enum CA_SLOT_TYPE, uint32_t Slot);
-	void SetTSClock(u32 /*Speed*/, int /*slot*/) { return; };
-	bool checkChannelID(u64 /*chanID*/) { return false; };
-	void setCheckLiveSlot(int /*check*/) { return; };
-	virtual ~cCA();
+		bool SendCAPMT(u64 /*Source*/, u8 /*DemuxSource*/, u8 /*DemuxMask*/, const unsigned char * /*CAPMT*/, u32 /*CAPMTLen*/, const unsigned char * /*RawPMT*/, u32 /*RawPMTLen*/, enum CA_SLOT_TYPE
+		    /*SlotType*/, unsigned char /*scrambled = 0*/, ca_map_t /*camap = std::set<int>()*/, int /*mode = 0*/, bool /*enabled = false*/)
+		{
+			return true;
+		};
+		bool SendMessage(const CA_MESSAGE *Msg);
+		int GetCAIDS(CaIdVector & /*Caids*/)
+		{
+			return 0;
+		};
+		bool Start(void);
+		void Stop(void);
+		void Ready(bool Set);
+		void ModuleReset(enum CA_SLOT_TYPE, uint32_t Slot);
+		bool ModulePresent(enum CA_SLOT_TYPE, uint32_t Slot);
+		void ModuleName(enum CA_SLOT_TYPE, uint32_t Slot, char *Name);
+		void MenuEnter(enum CA_SLOT_TYPE, uint32_t Slot);
+		void MenuAnswer(enum CA_SLOT_TYPE, uint32_t Slot, uint32_t choice);
+		void InputAnswer(enum CA_SLOT_TYPE, uint32_t Slot, uint8_t *Data, int Len);
+		void MenuClose(enum CA_SLOT_TYPE, uint32_t Slot);
+		void SetTSClock(u32 /*Speed*/, int /*slot*/)
+		{
+			return;
+		};
+		bool checkChannelID(u64 /*chanID*/)
+		{
+			return false;
+		};
+		void setCheckLiveSlot(int /*check*/)
+		{
+			return;
+		};
+		virtual ~cCA();
 };
 
 #endif // __CA_H__
diff -Nur libstb-hal-ddt.git.orig/include/cs_api.h libstb-hal-ddt.git/include/cs_api.h
--- libstb-hal-ddt.git.orig/include/cs_api.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/cs_api.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-/* compatibility header for tripledragon. I'm lazy, so I just left it
-   as "cs_api.h" so that I don't need too many ifdefs in the code */
-
-#ifndef __CS_API_H__
-#define __CS_API_H__
-
-#include "init.h"
-#include <config.h>
-
-typedef void (*cs_messenger) (unsigned int msg, unsigned int data);
-
-inline void cs_api_init()
-{
-	hal_api_init();
-};
-
-inline void cs_api_exit()
-{
-	hal_api_exit();
-};
-
-#define cs_malloc_uncached	malloc
-#define cs_free_uncached	free
-
-// Callback function helpers
-#if HAVE_DUCKBOX_HARDWARE || HAVE_ARM_HARDWARE || HAVE_MIPS_HARDWARE
-void cs_register_messenger(cs_messenger messenger);
-#else
-static inline void cs_register_messenger(cs_messenger) { return; };
-#endif
-static inline void cs_deregister_messenger(void) { return; };
-
-/* compat... HD1 seems to be version 6. everything newer ist > 6... */
-static inline unsigned int cs_get_revision(void) { return 1; };
-static inline unsigned int cs_get_chip_type(void) { return 0; };
-extern int cnxt_debug;
-
-#endif // __CS_API_H__
diff -Nur libstb-hal-ddt.git.orig/include/cs_frontpanel.h libstb-hal-ddt.git/include/cs_frontpanel.h
--- libstb-hal-ddt.git.orig/include/cs_frontpanel.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/cs_frontpanel.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,320 +0,0 @@
-#ifndef __CS_FRONTPANEL_H__
-#define __CS_FRONTPANEL_H__
-
-#define VFDDISPLAYCHARS      0xc0425a00
-#define VFDWRITECGRAM        0x40425a01
-#define VFDBRIGHTNESS        0xc0425a03
-#define VFDPWRLED            0xc0425a04
-#define VFDDRIVERINIT        0xc0425a08
-#define VFDICONDISPLAYONOFF  0xc0425a0a
-#define VFDDISPLAYWRITEONOFF 0xc0425a05
-
-#define VFDCLEARICONS        0xc0425af6
-#define VFDSETRF             0xc0425af7
-#define VFDSETFAN            0xc0425af8
-#define VFDGETWAKEUPMODE     0xc0425af9
-#define VFDGETTIME           0xc0425afa
-#define VFDSETTIME           0xc0425afb
-#define VFDSTANDBY           0xc0425afc
-#define VFDREBOOT            0xc0425afd
-#define VFDSETLED            0xc0425afe
-#define VFDSETMODE           0xc0425aff
-
-#define VFDGETWAKEUPTIME     0xc0425b00
-#define VFDGETVERSION        0xc0425b01
-#define VFDSETDISPLAYTIME    0xc0425b02
-#define VFDSETTIMEMODE       0xc0425b03
-#define VFDDISPLAYCLR        0xc0425b00
-
-typedef enum {
-#if defined(BOXMODEL_OCTAGON1008)
-	ICON_DOLBY = 0x10,
-	ICON_DTS,
-	ICON_VIDEO,
-	ICON_AUDIO,
-	ICON_LINK,
-	ICON_HDD,
-	ICON_DISC,
-	ICON_DVB,
-	ICON_DVD,
-	ICON_TIME,
-	ICON_TIMER,
-	ICON_CARD,
-	ICON_1,
-	ICON_2,
-	ICON_KEY,
-	ICON_16_9,
-	ICON_USB,
-	ICON_CRYPTED,
-	ICON_PLAY,
-	ICON_REWIND,
-	ICON_PAUSE,
-	ICON_FF,
-	ICON_REC,
-	ICON_ARROW,
-	ICON_COLON1,
-	ICON_COLON2,
-	ICON_COLON3,
-	ICON_MAX,
-	FP_ICON_USB = ICON_USB,
-	FP_ICON_HD = ICON_16_9,
-	FP_ICON_HDD = ICON_HDD,
-	FP_ICON_LOCK = ICON_CRYPTED,
-	FP_ICON_BT,
-	FP_ICON_MP3,
-	FP_ICON_MUSIC,
-	FP_ICON_DD = ICON_DOLBY,
-	FP_ICON_MAIL,
-	FP_ICON_MUTE = ICON_TIME,
-	FP_ICON_PLAY = ICON_PLAY,
-	FP_ICON_PAUSE = ICON_PAUSE,
-	FP_ICON_FF = ICON_FF,
-	FP_ICON_FR = ICON_REWIND,
-	FP_ICON_REC = ICON_REC,
-	FP_ICON_CLOCK = ICON_TIMER,
-	FP_ICON_RADIO = ICON_AUDIO,
-	FP_ICON_TV = ICON_VIDEO,
-	FP_ICON_DOWNLOAD = ICON_LINK,
-	FP_ICON_CAM1 = ICON_REC,
-	FP_ICON_TIMESHIFT = 0,
-#elif defined(BOXMODEL_FORTIS_HDBOX)
-	ICON_USB = 0x10,
-	ICON_STANDBY,
-	ICON_SAT,
-	ICON_REC,
-	ICON_TIMESHIFT,
-	ICON_TIMER,
-	ICON_HD,
-	ICON_SCRAMBLED,
-	ICON_DOLBY,
-	ICON_MUTE,
-	ICON_TUNER1,
-	ICON_TUNER2,
-	ICON_MP3,
-	ICON_REPEAT,
-	ICON_Play,
-	ICON_TER,
-	ICON_FILE,
-	ICON_480i,
-	ICON_480p,
-	ICON_576i,
-	ICON_576p,
-	ICON_720p,
-	ICON_1080i,
-	ICON_1080p,
-	ICON_Circ0,
-	ICON_Circ1,
-	ICON_Circ2,
-	ICON_Circ3,
-	ICON_Circ4,
-	ICON_Circ5,
-	ICON_Circ6,
-	ICON_Circ7,
-	ICON_Circ8,
-	ICON_COLON1,
-	ICON_COLON2,
-	ICON_COLON3,
-	ICON_COLON4,
-	ICON_TV,
-	ICON_RADIO,
-	ICON_MAX,
-	FP_ICON_USB = ICON_USB,
-	FP_ICON_REC = ICON_REC,
-	FP_ICON_CAM1 = ICON_REC,
-	FP_ICON_TIMESHIFT = ICON_TIMESHIFT,
-	FP_ICON_CLOCK = ICON_TIMER,
-	FP_ICON_HD = ICON_HD,
-	FP_ICON_LOCK = ICON_SCRAMBLED,
-	FP_ICON_DD = ICON_DOLBY,
-	FP_ICON_MUTE = ICON_MUTE,
-	FP_ICON_BT = 0,
-	FP_ICON_MP3 = ICON_MP3,
-	FP_ICON_PLAY = ICON_Play,
-	FP_ICON_PAUSE = 0,
-	FP_ICON_HDD = 0,
-	FP_ICON_MAIL = 0,
-	FP_ICON_FF = 0,
-	FP_ICON_FR = 0,
-	FP_ICON_RADIO = ICON_RADIO,
-	FP_ICON_TV = ICON_TV,
-	FP_ICON_MUSIC = ICON_RADIO,
-	FP_ICON_MAX = ICON_MAX
-#elif defined(BOXMODEL_UFS910) || defined(BOXMODEL_UFS922) || defined(BOXMODEL_UFS912) || defined(BOXMODEL_UFS913)
-	FP_ICON_USB = 0x10,
-	FP_ICON_HD,
-	FP_ICON_HDD,
-	FP_ICON_LOCK,
-	FP_ICON_BT,
-	FP_ICON_MP3,
-	FP_ICON_MUSIC,
-	FP_ICON_DD,
-	FP_ICON_MAIL,
-	FP_ICON_MUTE,
-	FP_ICON_PLAY,
-	FP_ICON_PAUSE,
-	FP_ICON_FF,
-	FP_ICON_FR,
-	FP_ICON_REC,
-	FP_ICON_CLOCK,
-	FP_ICON_MAX,
-	FP_ICON_CAM1 = FP_ICON_REC,
-	FP_ICON_TV = 0,
-	FP_ICON_RADIO = FP_ICON_MUSIC,
-	FP_ICON_RECORD = FP_ICON_REC,
-	FP_ICON_DOWNLOAD = 0,
-	FP_ICON_TIMESHIFT = 0
-#elif defined(BOXMODEL_IPBOX9900) || defined(BOXMODEL_IPBOX99)
-	ICON_STANDBY,
-	ICON_SAT,
-	ICON_REC,
-	ICON_TIMESHIFT,
-	ICON_TIMER,
-	ICON_HD,
-	ICON_SCRAMBLED,
-	ICON_MUTE,
-	ICON_TUNER1,
-	ICON_TUNER2,
-	ICON_MP3,
-	ICON_REPEAT,
-	ICON_PLAY,
-	ICON_PAUSE,
-	ICON_TER,
-	ICON_FILE,
-	ICON_480I,
-	ICON_480P,
-	ICON_576I,
-	ICON_576P,
-	ICON_720P,
-	ICON_1080I,
-	ICON_1080P,
-	ICON_TV,
-	ICON_RADIO,
-	ICON_MAX,
-	FP_ICON_480P       = ICON_480P,
-	FP_ICON_480I       = ICON_480I,
-	FP_ICON_576P       = ICON_576P,
-	FP_ICON_576I       = ICON_576I,
-	FP_ICON_PLAY       = ICON_PLAY,
-	FP_ICON_PAUSE      = ICON_PAUSE,
-	FP_ICON_1080P      = 0x0A,
-	FP_ICON_1080I      = 0x09,
-	FP_ICON_720P       = 0x08,
-	FP_ICON_POWER      = 0x00,
-	FP_ICON_HD         = 0x05,
-	FP_ICON_RADIO      = 0x0D,
-	FP_ICON_MP3        = FP_ICON_RADIO,
-	FP_ICON_MUSIC      = FP_ICON_RADIO,
-	FP_ICON_DD         = 0x04,
-	FP_ICON_REC        = 0x03,
-	FP_ICON_FF = 0,
-	FP_ICON_FR = 0,
-	FP_ICON_USB = 0,
-	FP_ICON_HDD = 0,
-	FP_ICON_MUTE = 0,
-	FP_ICON_CLOCK = 0,
-	FP_ICON_CAM1 = 0,
-	FP_ICON_LOCK = 0,
-	FP_ICON_DOWNLOAD = 0,
-	FP_ICON_TIMESHIFT  = FP_ICON_REC,
-	FP_ICON_TV = 0,
-	FP_ICON_MAIL = 0,
-	FP_ICON_BT = 0,
-#else
-	FP_ICON_USB = 0x10,
-	FP_ICON_HD,
-	FP_ICON_HDD,
-	FP_ICON_LOCK,
-	FP_ICON_BT,
-	FP_ICON_MP3,
-	FP_ICON_MUSIC,
-	FP_ICON_DD,
-	FP_ICON_MAIL,
-	FP_ICON_MUTE,
-	FP_ICON_PLAY,
-	FP_ICON_PAUSE,
-	FP_ICON_FF,
-	FP_ICON_FR,
-	FP_ICON_REC,
-	FP_ICON_CLOCK,
-	FP_ICON_CAM1 = FP_ICON_REC,
-	FP_ICON_TV = FP_ICON_MUSIC,
-	FP_ICON_RADIO = FP_ICON_MUSIC,
-	FP_ICON_RECORD = FP_ICON_REC,
-	FP_ICON_DOWNLOAD,
-	FP_ICON_TIMESHIFT,
-#endif
-#if !defined(BOXMODEL_UFS910) && !defined(BOXMODEL_UFS922) && !defined(BOXMODEL_UFS912) && !defined(BOXMODEL_UFS913) && !defined(BOXMODEL_FORTIS_HDBOX)
-	FP_ICON_MAX
-#endif
-} fp_icon;
-
-typedef enum {
-	FP_FLAG_NONE			= 0x00,
-	FP_FLAG_SCROLL_ON		= 0x01,	/* switch scrolling on */
-	FP_FLAG_SCROLL_LTR		= 0x02,	/* scroll from left to rightinstead of default right to left direction (i.e. for arabic text) */
-	FP_FLAG_SCROLL_SIO		= 0x04,	/* start/stop scrolling with empty screen (scroll in/out) */
-	FP_FLAG_SCROLL_DELAY		= 0x08,	/* delayed scroll start */
-	FP_FLAG_ALIGN_LEFT		= 0x10,	/* align the text in display from the left (default) */
-	FP_FLAG_ALIGN_RIGHT		= 0x20,	/* align the text in display from the right (arabic) */
-	FP_FLAG_UPDATE_SCROLL_POS	= 0x40,	/* update the current position for scrolling */
-} fp_flag;
-
-typedef struct {
-	unsigned char		brightness;
-	unsigned char		flags;
-	unsigned char		current_hour;
-	unsigned char		current_minute;
-	unsigned char		timer_minutes_hi;
-	unsigned char		timer_minutes_lo;
-} fp_standby_data_t;
-
-typedef enum {
-	FP_LED_1_ON		= 0x81,
-	FP_LED_2_ON		= 0x82,
-	FP_LED_3_ON		= 0x83,
-	FP_LED_1_OFF		= 0x01,
-	FP_LED_2_OFF		= 0x02,
-	FP_LED_3_OFF		= 0x03,
-} fp_led_ctrl_t;
-
-typedef struct {
-	unsigned char		source;
-	unsigned char		time_minutes_hi;
-	unsigned char		time_minutes_lo;
-} fp_wakeup_data_t;
-
-typedef enum {
-	FP_WAKEUP_SOURCE_TIMER  = 0x01,
-	FP_WAKEUP_SOURCE_BUTTON = 0x02,
-	FP_WAKEUP_SOURCE_REMOTE = 0x04,
-	FP_WAKEUP_SOURCE_PWLOST = 0x7F,
-	FP_WAKEUP_SOURCE_POWER  = 0xFF
-} fp_wakeup_source;
-
-typedef struct {
-	unsigned short		addr;
-	unsigned short		cmd;
-} fp_standby_cmd_data_t;
-
-typedef enum {
-	FP_DISPLAY_TEXT_NONE	= 0,
-	FP_DISPLAY_TEXT_LIMITED,
-	FP_DISPLAY_TEXT_ALL,
-} fp_display_text_type_t;
-
-typedef enum {
-	FP_DISPLAY_TYPE_NONE	= 0,
-	FP_DISPLAY_TYPE_VFD,
-	FP_DISPLAY_TYPE_OLED,
-	FP_DISPLAY_TYPE_LED_SEGMENT
-} fp_display_type_t;
-
-typedef struct {
-	fp_display_type_t	display_type;
-	unsigned short		xres, yres;
-	unsigned int		segment_count;
-	fp_display_text_type_t	text_support;
-	bool			number_support;
-} fp_display_caps_t;
-
-#endif // __CS_FRONTPANEL_H__
diff -Nur libstb-hal-ddt.git.orig/include/cs_types.h libstb-hal-ddt.git/include/cs_types.h
--- libstb-hal-ddt.git.orig/include/cs_types.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/include/cs_types.h	2022-07-23 18:18:31.495773190 +0200
@@ -11,13 +11,13 @@
 	AVSYNC_AUDIO_IS_MASTER
 } AVSYNC_TYPE;
 
-typedef unsigned long long	u64;
-typedef unsigned int		u32;
-typedef unsigned short		u16;
-typedef unsigned char		 u8;
-typedef signed long long	s64;
-typedef signed int		s32;
-typedef signed short		s16;
-typedef signed char		 s8;
+typedef unsigned long long  u64;
+typedef unsigned int        u32;
+typedef unsigned short      u16;
+typedef unsigned char        u8;
+typedef signed long long    s64;
+typedef signed int      s32;
+typedef signed short        s16;
+typedef signed char      s8;
 
 #endif // __CS_TYPES_H__
diff -Nur libstb-hal-ddt.git.orig/include/dmx_hal.h libstb-hal-ddt.git/include/dmx_hal.h
--- libstb-hal-ddt.git.orig/include/dmx_hal.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/dmx_hal.h	2022-07-23 18:18:31.495773190 +0200
@@ -22,24 +22,13 @@
 #include <cstdlib>
 #include <vector>
 #include <inttypes.h>
-/* at least on td, config.h needs to be included before... */
-#ifndef HAVE_TRIPLEDRAGON
 #include <linux/dvb/dmx.h>
-#else /* TRIPLEDRAGON */
-extern "C" {
-#include <hardware/xp/xp_osd_user.h>
-}
-#if defined DMX_FILTER_SIZE
-#undef DMX_FILTER_SIZE
-#endif
-#define DMX_FILTER_SIZE FILTER_LENGTH
-#endif /* TRIPLEDRAGON */
-
 #include <cs_types.h>
+
 #if BOXMODEL_VUULTIMO4K
 #define MAX_DMX_UNITS 24
 #else
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 #define MAX_DMX_UNITS 16
 #else
 #define MAX_DMX_UNITS 4
@@ -76,7 +65,6 @@
 	DMX_AUDIO_CHANNEL,
 	DMX_PES_CHANNEL,
 	DMX_PSI_CHANNEL,
-	DMX_PIP_CHANNEL,
 	DMX_TP_CHANNEL,
 	DMX_PCR_ONLY_CHANNEL
 } DMX_CHANNEL_TYPE;
@@ -91,30 +79,36 @@
 class cPlayback;
 class cDemux
 {
-	friend class cRecord;
-	friend class cPlayback;
+		friend class cRecord;
+		friend class cPlayback;
 	public:
-		bool Open(DMX_CHANNEL_TYPE pes_type, void * x = NULL, int y = 0);
+		bool Open(DMX_CHANNEL_TYPE pes_type, void *x = NULL, int y = 0);
 		void Close(void);
 		bool Start(bool record = false);
 		bool Stop(void);
 		int Read(unsigned char *buff, int len, int Timeout = 0);
-		bool sectionFilter(unsigned short pid, const unsigned char * const filter, const unsigned char * const mask, int len, int Timeout = 0, const unsigned char * const negmask = NULL);
+		bool sectionFilter(unsigned short pid, const unsigned char *const filter, const unsigned char *const mask, int len, int Timeout = 0, const unsigned char *const negmask = NULL);
 		bool pesFilter(const unsigned short pid);
 		void SetSyncMode(AVSYNC_TYPE mode);
-		void * getBuffer();
-		void * getChannel();
-		DMX_CHANNEL_TYPE getChannelType(void) { return dmx_type; };
+		void *getBuffer();
+		void *getChannel();
+		DMX_CHANNEL_TYPE getChannelType(void)
+		{
+			return dmx_type;
+		};
 		bool addPid(unsigned short pid);
-		void getSTC(int64_t * STC);
+		void getSTC(int64_t *STC);
 		int getUnit(void);
 		static bool SetSource(int unit, int source);
 		static int GetSource(int unit);
-		int getFD(void) { return fd; };		/* needed by cPlayback class */
+		int getFD(void)
+		{
+			return fd;
+		};     /* needed by cPlayback class */
 		cDemux(int num = 0);
 		~cDemux();
 	private:
-		void removePid(unsigned short Pid);	/* needed by cRecord class */
+		void removePid(unsigned short Pid); /* needed by cRecord class */
 		int num;
 		int fd;
 		int buffersize;
diff -Nur libstb-hal-ddt.git.orig/include/glfb.h libstb-hal-ddt.git/include/glfb.h
--- libstb-hal-ddt.git.orig/include/glfb.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/include/glfb.h	2022-07-23 18:18:31.495773190 +0200
@@ -1,19 +1,19 @@
 /*
-	Copyright 2010 Carsten Juttner <carjay@gmx.net>
-	Copyright 2012,2013 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
+    Copyright 2010 Carsten Juttner <carjay@gmx.net>
+    Copyright 2012,2013 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
 
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-	GNU General Public License for more details.
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+    GNU General Public License for more details.
 
-	You should have received a copy of the GNU General Public License
-	along with this program. If not, see <http://www.gnu.org/licenses/>.
+    You should have received a copy of the GNU General Public License
+    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
 #ifndef __GLFB_H__
@@ -25,20 +25,26 @@
 
 class GLFramebuffer : public OpenThreads::Thread
 {
-public:
-	GLFramebuffer(int x, int y);
-	~GLFramebuffer();
-	std::vector<unsigned char> *getOSDBuffer() { return &osd_buf; } /* pointer to OSD bounce buffer */
-	void blit();
-	fb_var_screeninfo getScreenInfo() { return si; }
-
-private:
-	fb_var_screeninfo si;
-	std::vector<unsigned char> osd_buf; /* silly bounce buffer */
-	void run();	/* for OpenThreads::Thread */
-	void setup();
-	void blit_osd();
-	void *pdata;	/* not yet used */
+	public:
+		GLFramebuffer(int x, int y);
+		~GLFramebuffer();
+		std::vector<unsigned char> *getOSDBuffer()
+		{
+			return &osd_buf;    /* pointer to OSD bounce buffer */
+		}
+		void blit();
+		fb_var_screeninfo getScreenInfo()
+		{
+			return si;
+		}
+
+	private:
+		fb_var_screeninfo si;
+		std::vector<unsigned char> osd_buf; /* silly bounce buffer */
+		void run(); /* for OpenThreads::Thread */
+		void setup();
+		void blit_osd();
+		void *pdata;    /* not yet used */
 };
 
 #endif // __GLFB_H__
diff -Nur libstb-hal-ddt.git.orig/include/hardware_caps.h libstb-hal-ddt.git/include/hardware_caps.h
--- libstb-hal-ddt.git.orig/include/hardware_caps.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/hardware_caps.h	2022-07-23 18:18:31.495773190 +0200
@@ -16,30 +16,31 @@
 {
 	HW_DISPLAY_NONE,
 	HW_DISPLAY_LED_ONLY,
-	HW_DISPLAY_LED_NUM,	/* simple 7 segment LED display */
-	HW_DISPLAY_LINE_TEXT,	/* 1 line text display */
+	HW_DISPLAY_LED_NUM, /* simple 7 segment LED display */
+	HW_DISPLAY_LINE_TEXT,   /* 1 line text display */
 	HW_DISPLAY_GFX
 } display_type_t;
 
 
 typedef struct hw_caps
 {
-	int has_fan;
 	int has_HDMI;
+	int has_HDMI_input;
 	int has_SCART;
 	int has_SCART_input;
 	int has_YUV_cinch;
+	int can_pip;
+	int pip_devs;
 	int can_shutdown;
 	int can_cec;
-	int can_ar_14_9;	/* video drivers have 14:9 aspect ratio mode */
-	int can_ps_14_9;	/* video drivers have 14:9 panscan mode */
-	int force_tuner_2G;	/* force DVB-S2 even though driver may not advertise it */
+	int force_tuner_2G; /* force DVB-S2 even though driver may not advertise it */
 	display_type_t display_type;
-	int display_xres;	/* x resolution or chars per line */
+	int display_xres;   /* x resolution or chars per line */
 	int display_yres;
 	int display_can_set_brightness;
 	int display_can_deepstandby;
 	int display_has_statusline;
+	int display_has_colon;
 	int has_button_timer;
 	char boxvendor[64];
 	char boxname[64];
diff -Nur libstb-hal-ddt.git.orig/include/mmi.h libstb-hal-ddt.git/include/mmi.h
--- libstb-hal-ddt.git.orig/include/mmi.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/include/mmi.h	2022-07-23 18:18:31.495773190 +0200
@@ -1,11 +1,12 @@
 #ifndef __MMI_H__
 #define __MMI_H__
 
-#define MAX_MMI_ITEMS			40
-#define MAX_MMI_TEXT_LEN		255
-#define MAX_MMI_CHOICE_TEXT_LEN		255
+#define MAX_MMI_ITEMS           40
+#define MAX_MMI_TEXT_LEN        255
+#define MAX_MMI_CHOICE_TEXT_LEN     255
 
-typedef enum {
+typedef enum
+{
 	MMI_TOP_MENU_SUBS = 1,
 	MMI_TOP_MENU_EVENTS,
 	MMI_TOP_MENU_TOKENS,
@@ -14,20 +15,23 @@
 	MMI_TOP_MENU_ABOUT
 } MMI_MENU_CURRENT;
 
-typedef enum {
+typedef enum
+{
 	MMI_MENU_LEVEL_MAIN = 0,
 	MMI_MENU_LEVEL_MATURE,
 	MMI_MENU_LEVEL_ASK_PIN_MATURE
 } MMI_MENU_LEVEL;
 
-typedef enum {
+typedef enum
+{
 	MMI_PIN_LEVEL_ASK_OLD = 0,
 	MMI_PIN_LEVEL_CHECK_CURRENT,
 	MMI_PIN_LEVEL_ASK_REPEAT,
 	MMI_PIN_LEVEL_CHECK_AND_CHANGE
 } MMI_PIN_LEVEL;
 
-typedef struct {
+typedef struct
+{
 	int slot;
 	int choice_nb;
 	char title[MAX_MMI_TEXT_LEN];
@@ -36,7 +40,8 @@
 	char choice_item[MAX_MMI_ITEMS][MAX_MMI_CHOICE_TEXT_LEN];
 } MMI_MENU_LIST_INFO;
 
-typedef struct {
+typedef struct
+{
 	int slot;
 	int blind;
 	int answerlen;
diff -Nur libstb-hal-ddt.git.orig/include/playback_hal.h libstb-hal-ddt.git/include/playback_hal.h
--- libstb-hal-ddt.git.orig/include/playback_hal.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/playback_hal.h	2022-07-23 18:18:31.495773190 +0200
@@ -1,7 +1,5 @@
 #include <config.h>
-#if HAVE_TRIPLEDRAGON
-#include "../libtriple/playback_td.h"
-#elif HAVE_DUCKBOX_HARDWARE
+#if HAVE_DUCKBOX_HARDWARE
 #include "../libduckbox/playback_libeplayer3.h"
 #elif HAVE_SPARK_HARDWARE
 #include "../libspark/playback_libeplayer3.h"
@@ -13,8 +11,6 @@
 #endif
 #elif HAVE_MIPS_HARDWARE
 #include "../libmipsbox/playback_libeplayer3.h"
-#elif HAVE_AZBOX_HARDWARE
-#include "../libazbox/playback_lib.h"
 #elif HAVE_GENERIC_HARDWARE
 #if BOXMODEL_RASPI
 #include "../libraspi/playback_lib.h"
diff -Nur libstb-hal-ddt.git.orig/include/pwrmngr.h libstb-hal-ddt.git/include/pwrmngr.h
--- libstb-hal-ddt.git.orig/include/pwrmngr.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/include/pwrmngr.h	2022-07-23 18:18:31.495773190 +0200
@@ -18,30 +18,17 @@
 #ifndef __PWRMNGR_H__
 #define __PWRMNGR_H__
 
-class cCpuFreqManager
-{
-public:
-	cCpuFreqManager(void);
-	void Up(void);
-	void Down(void);
-	void Reset(void);
-
-	bool SetCpuFreq(unsigned long CpuFreq);
-	bool SetDelta(unsigned long Delta);
-	unsigned long GetCpuFreq(void);
-	unsigned long GetDelta(void);
-};
 
 class cPowerManager
 {
-public:
-	cPowerManager(void);
-	virtual ~cPowerManager();
+	public:
+		cPowerManager(void);
+		virtual ~cPowerManager();
 
-	bool Open(void);
-	void Close(void);
+		bool Open(void);
+		void Close(void);
 
-	bool SetStandby(bool Active, bool Passive);
+		bool SetStandby(bool Active, bool Passive);
 };
 
 #endif // __PWRMNGR_H__
diff -Nur libstb-hal-ddt.git.orig/include/record_hal.h libstb-hal-ddt.git/include/record_hal.h
--- libstb-hal-ddt.git.orig/include/record_hal.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/record_hal.h	2022-07-23 18:18:31.495773190 +0200
@@ -1,7 +1,5 @@
 #include <config.h>
-#if HAVE_TRIPLEDRAGON
-#include "../libtriple/record_td.h"
-#elif HAVE_DUCKBOX_HARDWARE
+#if HAVE_DUCKBOX_HARDWARE
 #include "../libduckbox/record_lib.h"
 #elif HAVE_SPARK_HARDWARE
 #include "../libspark/record_lib.h"
@@ -9,8 +7,6 @@
 #include "../libarmbox/record_lib.h"
 #elif HAVE_MIPS_HARDWARE
 #include "../libmipsbox/record_lib.h"
-#elif HAVE_AZBOX_HARDWARE
-#include "../libazbox/record_lib.h"
 #elif HAVE_GENERIC_HARDWARE
 #if BOXMODEL_RASPI
 #include "../libraspi/record_lib.h"
diff -Nur libstb-hal-ddt.git.orig/include/version_hal.h libstb-hal-ddt.git/include/version_hal.h
--- libstb-hal-ddt.git.orig/include/version_hal.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/version_hal.h	2022-07-23 18:18:31.495773190 +0200
@@ -6,17 +6,15 @@
 // library version functions
 typedef struct hal_libversion_t
 {
-	std::string	vVersion;
-	int			vMajor;
-	int			vMinor;
-	int			vPatch;;
-	std::string	vName;
-	std::string	vStr;
-	std::string	vGitDescribe;
+	std::string vVersion;
+	int         vMajor;
+	int         vMinor;
+	int         vPatch;;
+	std::string vName;
+	std::string vStr;
+	std::string vGitDescribe;
 } hal_libversion_struct_t;
 
 void hal_get_lib_version(hal_libversion_t *ver);
 
-
 #endif //__VERSION_HAL_H__
-
diff -Nur libstb-hal-ddt.git.orig/include/video_hal.h libstb-hal-ddt.git/include/video_hal.h
--- libstb-hal-ddt.git.orig/include/video_hal.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/include/video_hal.h	2022-07-23 18:18:31.495773190 +0200
@@ -1,7 +1,5 @@
 #include <config.h>
-#if HAVE_TRIPLEDRAGON
-#include "../libtriple/video_td.h"
-#elif HAVE_DUCKBOX_HARDWARE
+#if HAVE_DUCKBOX_HARDWARE
 #include "../libduckbox/video_lib.h"
 #elif HAVE_SPARK_HARDWARE
 #include "../libspark/video_lib.h"
@@ -11,8 +9,6 @@
 #elif HAVE_MIPS_HARDWARE
 #include "../libmipsbox/video_lib.h"
 #include "../libmipsbox/hdmi_cec.h"
-#elif HAVE_AZBOX_HARDWARE
-#include "../libazbox/video_lib.h"
 #elif HAVE_GENERIC_HARDWARE
 #if BOXMODEL_RASPI
 #include "../libraspi/video_lib.h"
diff -Nur libstb-hal-ddt.git.orig/libarmbox/audio.cpp libstb-hal-ddt.git/libarmbox/audio.cpp
--- libstb-hal-ddt.git.orig/libarmbox/audio.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libarmbox/audio.cpp	2022-07-23 18:18:31.499773109 +0200
@@ -8,23 +8,58 @@
 
 #include <linux/dvb/audio.h>
 
+#include <hardware_caps.h>
 #include <proc_tools.h>
 
 #include "audio_lib.h"
 #include "hal_debug.h"
-#include <config.h>
 
-#define AUDIO_DEVICE	"/dev/dvb/adapter0/audio0"
 #define hal_debug(args...) _hal_debug(HAL_DEBUG_AUDIO, this, args)
 #define hal_info(args...) _hal_info(HAL_DEBUG_AUDIO, this, args)
 
+#define fop(cmd, args...) ({                \
+    int _r;                     \
+    if (fd >= 0) {                  \
+        if ((_r = ::cmd(fd, args)) < 0)     \
+            hal_info(#cmd"(fd, "#args")\n");\
+        else                    \
+            hal_debug(#cmd"(fd, "#args")\n");\
+    }                       \
+    else { _r = fd; }               \
+    _r;                     \
+})
+
 #include <linux/soundcard.h>
 
-cAudio * audioDecoder = NULL;
+enum
+{
+	ENCODER,
+	AUX
+};
+
+cAudio *audioDecoder = NULL;
+cAudio *pipAudioDecoder[3] = { NULL, NULL, NULL };
 
-cAudio::cAudio(void *, void *, void *)
+static const char *ADEV[] =
 {
+	"/dev/dvb/adapter0/audio0",
+	"/dev/dvb/adapter0/audio1",
+	"/dev/dvb/adapter0/audio2",
+	"/dev/dvb/adapter0/audio3"
+};
+
+cAudio::cAudio(void *, void *, void *, unsigned int unit)
+{
+	hw_caps_t *hwcaps = get_hwcaps();
+	if (unit > (unsigned int) hwcaps->pip_devs)
+	{
+		hal_info("%s: unit %d out of range, setting to 0\n", __func__, unit);
+		devnum = 0;
+	}
+	else
+		devnum = unit;
 	fd = -1;
+	fdd = false;
 	clipfd = -1;
 	mixer_fd = -1;
 	openDevice();
@@ -40,7 +75,7 @@
 {
 	if (fd < 0)
 	{
-		if ((fd = open(AUDIO_DEVICE, O_RDWR)) < 0)
+		if ((fd = open(ADEV[devnum], O_RDWR)) < 0)
 			hal_info("openDevice: open failed (%m)\n");
 		fcntl(fd, F_SETFD, FD_CLOEXEC);
 		//do_mute(true, false);
@@ -51,20 +86,70 @@
 
 void cAudio::closeDevice(void)
 {
-	if (fd > -1) {
+	if (fd > -1)
+	{
 		close(fd);
 		fd = -1;
 	}
-	if (clipfd > -1) {
+	if (clipfd > -1)
+	{
 		close(clipfd);
 		clipfd = -1;
 	}
-	if (mixer_fd > -1) {
+	if (mixer_fd > -1)
+	{
 		close(mixer_fd);
 		mixer_fd = -1;
 	}
 }
 
+#ifndef AUDIO_SOURCE_HDMI
+#define AUDIO_SOURCE_HDMI 2
+#endif
+
+void cAudio::open_AVInput_Device(void)
+{
+	hal_debug("%s\n", __func__);
+
+	if (fdd) /* already open */
+		return;
+
+	fop(ioctl, AUDIO_SELECT_SOURCE, AUDIO_SOURCE_HDMI);
+	fop(ioctl, AUDIO_PLAY);
+	fdd = true;
+}
+
+void cAudio::close_AVInput_Device(void)
+{
+	hal_debug("%s\n", __func__);
+
+	if (fdd)
+	{
+		fop(ioctl, AUDIO_STOP);
+	}
+	fdd = false;
+}
+
+void cAudio::setAVInput(int val)
+{
+	hal_info("%s - switching to: %s\n", __func__, val == AUX ? "AUX" : "ENCODER");
+
+	if (val == AUX)
+	{
+		Stop();
+		open_AVInput_Device();
+	}
+	else
+	{
+		if (fdd)
+		{
+			close_AVInput_Device();
+			fop(ioctl, AUDIO_SELECT_SOURCE, AUDIO_SOURCE_DEMUX);
+			Start();
+		}
+	}
+}
+
 int cAudio::do_mute(bool enable, bool remember)
 {
 	hal_debug("%s(%d, %d)\n", __FUNCTION__, enable, remember);
@@ -157,39 +242,12 @@
 	ioctl(fd, AUDIO_SET_AV_SYNC, Mode);
 }
 
-#define AUDIO_STREAMTYPE_AC3	0
-#define AUDIO_STREAMTYPE_MPEG	1
-#define AUDIO_STREAMTYPE_DTS	2
-#define AUDIO_STREAMTYPE_AAC	8
-#define AUDIO_STREAMTYPE_AACHE	9
-
-void cAudio::SetStreamType(AUDIO_FORMAT type)
-{
-	int bypass = AUDIO_STREAMTYPE_MPEG;
-	hal_debug("%s %d\n", __FUNCTION__, type);
-	StreamType = type;
+void cAudio::SetStreamType(int bypass)
+{
+	StreamType = bypass;
 
-	switch (type)
-	{
-		case AUDIO_FMT_DD_PLUS:
-		case AUDIO_FMT_DOLBY_DIGITAL:
-			bypass = AUDIO_STREAMTYPE_AC3;
-			break;
-		case AUDIO_FMT_AAC:
-			bypass = AUDIO_STREAMTYPE_AAC;
-			break;
-		case AUDIO_FMT_AAC_PLUS:
-			bypass = AUDIO_STREAMTYPE_AACHE;
-			break;
-		case AUDIO_FMT_DTS:
-			bypass = AUDIO_STREAMTYPE_DTS;
-			break;
-		default:
-			break;
-	}
+	hal_info("%s %d (0x%x)\n", __FUNCTION__, bypass, bypass);
 
-	// Normaly the encoding should be set using AUDIO_SET_ENCODING
-	// But as we implemented the behavior to bypass (cause of e2) this is correct here
 	if (ioctl(fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
 		hal_info("%s: AUDIO_SET_BYPASS_MODE failed (%m)\n", __func__);
 }
@@ -207,7 +265,8 @@
 	const char *dsp_dev = getenv("DSP_DEVICE");
 	const char *mix_dev = getenv("MIX_DEVICE");
 	hal_info("cAudio::%s ch %d srate %d bits %d le %d\n", __FUNCTION__, ch, srate, bits, little_endian);
-	if (clipfd > -1) {
+	if (clipfd > -1)
+	{
 		hal_info("%s: clipfd already opened (%d)\n", __func__, clipfd);
 		return -1;
 	}
@@ -221,22 +280,25 @@
 	 *   export MIX_DEVICE=/dev/sound/mixer2
 	 *   neutrino
 	 */
-	if ((!dsp_dev) || (access(dsp_dev, W_OK))) {
+	if ((!dsp_dev) || (access(dsp_dev, W_OK)))
+	{
 		if (dsp_dev)
 			hal_info("%s: DSP_DEVICE is set (%s) but cannot be opened,"
-				" fall back to /dev/dsp\n", __func__, dsp_dev);
+			    " fall back to /dev/dsp\n", __func__, dsp_dev);
 		dsp_dev = "/dev/dsp";
 	}
-	if ((!mix_dev) || (access(mix_dev, W_OK))) {
+	if ((!mix_dev) || (access(mix_dev, W_OK)))
+	{
 		if (mix_dev)
 			hal_info("%s: MIX_DEVICE is set (%s) but cannot be opened,"
-					" fall back to /dev/mixer\n", __func__, dsp_dev);
+			    " fall back to /dev/mixer\n", __func__, dsp_dev);
 		mix_dev = "/dev/mixer";
 	}
 	hal_info("cAudio::%s: dsp_dev %s mix_dev %s\n", __func__, dsp_dev, mix_dev); /* NULL mix_dev is ok */
 	/* the tdoss dsp driver seems to work only on the second open(). really. */
 	clipfd = open(dsp_dev, O_WRONLY);
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s open %s: %m\n", dsp_dev, __FUNCTION__);
 		return -1;
 	}
@@ -261,42 +323,50 @@
 		return 0;
 
 	mixer_fd = open(mix_dev, O_RDWR);
-	if (mixer_fd < 0) {
+	if (mixer_fd < 0)
+	{
 		hal_info("%s: open mixer %s failed (%m)\n", __func__, mix_dev);
 		/* not a real error */
 		return 0;
 	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_DEVMASK, &devmask) == -1) {
+	if (ioctl(mixer_fd, SOUND_MIXER_READ_DEVMASK, &devmask) == -1)
+	{
 		hal_info("%s: SOUND_MIXER_READ_DEVMASK %m\n", __func__);
 		devmask = 0;
 	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_STEREODEVS, &stereo) == -1) {
+	if (ioctl(mixer_fd, SOUND_MIXER_READ_STEREODEVS, &stereo) == -1)
+	{
 		hal_info("%s: SOUND_MIXER_READ_STEREODEVS %m\n", __func__);
 		stereo = 0;
 	}
 	usable = devmask & stereo;
-	if (usable == 0) {
+	if (usable == 0)
+	{
 		hal_info("%s: devmask: %08x stereo: %08x, no usable dev :-(\n",
-			__func__, devmask, stereo);
+		    __func__, devmask, stereo);
 		close(mixer_fd);
 		mixer_fd = -1;
 		return 0; /* TODO: should we treat this as error? */
 	}
 	/* __builtin_popcount needs GCC, it counts the set bits... */
-	if (__builtin_popcount (usable) != 1) {
+	if (__builtin_popcount(usable) != 1)
+	{
 		/* TODO: this code is not yet tested as I have only single-mixer devices... */
 		hal_info("%s: more than one mixer control: devmask %08x stereo %08x\n"
-			"%s: querying MIX_NUMBER environment variable...\n",
-			__func__, devmask, stereo, __func__);
+		    "%s: querying MIX_NUMBER environment variable...\n",
+		    __func__, devmask, stereo, __func__);
 		const char *tmp = getenv("MIX_NUMBER");
 		if (tmp)
 			mixer_num = atoi(tmp);
 		hal_info("%s: mixer_num is %d -> device %08x\n",
-			__func__, mixer_num, (mixer_num >= 0) ? (1 << mixer_num) : 0);
+		    __func__, mixer_num, (mixer_num >= 0) ? (1 << mixer_num) : 0);
 		/* no error checking, you'd better know what you are doing... */
-	} else {
+	}
+	else
+	{
 		mixer_num = 0;
-		while (!(usable & 0x01)) {
+		while (!(usable & 0x01))
+		{
 			mixer_num++;
 			usable >>= 1;
 		}
@@ -308,9 +378,10 @@
 
 int cAudio::WriteClip(unsigned char *buffer, int size)
 {
-	int ret, __attribute__ ((unused)) count = 1;
+	int ret, __attribute__((unused)) count = 1;
 	// hal_debug("cAudio::%s\n", __FUNCTION__);
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
 		return -1;
 	}
@@ -318,12 +389,14 @@
 again:
 #endif
 	ret = write(clipfd, buffer, size);
-	if (ret < 0) {
+	if (ret < 0)
+	{
 		hal_info("%s: write error (%m)\n", __FUNCTION__);
 		return ret;
 	}
 #if BOXMODEL_BRE2ZE4K || BOXMODEL_HD51 || BOXMODEL_H7
-	if (ret != size) {
+	if (ret != size)
+	{
 		hal_info("cAudio::%s: difference > to write (%d) != written (%d) try (%d) > reset dsp and restart write\n", __FUNCTION__, size, ret, count);
 		if (ioctl(clipfd, SNDCTL_DSP_RESET))
 			perror("SNDCTL_DSP_RESET");
@@ -339,7 +412,8 @@
 {
 	hal_info("cAudio::%s\n", __FUNCTION__);
 
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
 		return -1;
 	}
@@ -348,7 +422,8 @@
 #endif
 	close(clipfd);
 	clipfd = -1;
-	if (mixer_fd > -1) {
+	if (mixer_fd > -1)
+	{
 		close(mixer_fd);
 		mixer_fd = -1;
 	}
@@ -376,24 +451,24 @@
 
 	type = atype;
 #if 0
-/* this does not work, some of the values are negative?? */
+	/* this does not work, some of the values are negative?? */
 	AMPEGStatus A;
 	memcpy(&A, &i.word00, sizeof(i.word00));
 	layer   = A.audio_mpeg_layer;
 	mode    = A.audio_mpeg_mode;
 	bitrate = A.audio_mpeg_bitrate;
-	switch(A.audio_mpeg_frequency)
+	switch (A.audio_mpeg_frequency)
 #endif
-	/* layer and bitrate are not used anyway... */
-	layer   = 0; //(i.word00 >> 17) & 3;
+		/* layer and bitrate are not used anyway... */
+		layer   = 0; //(i.word00 >> 17) & 3;
 	bitrate = 0; //(i.word00 >> 12) & 3;
 	switch (type)
 	{
-		case 0:	/* MPEG */
+		case 0: /* MPEG */
 			mode = (i.word00 >> 6) & 3;
 			freq = freq_mpg[(i.word00 >> 10) & 3];
 			break;
-		case 1:	/* AC3 */
+		case 1: /* AC3 */
 			mode = (i.word00 >> 28) & 7;
 			freq = freq_ac3[(i.word00 >> 16) & 3];
 			break;
diff -Nur libstb-hal-ddt.git.orig/libarmbox/audio_lib.h libstb-hal-ddt.git/libarmbox/audio_lib.h
--- libstb-hal-ddt.git.orig/libarmbox/audio_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libarmbox/audio_lib.h	2022-07-23 18:18:31.499773109 +0200
@@ -4,6 +4,7 @@
 #define __AUDIO_LIB_H__
 
 #include "cs_types.h"
+#include <config.h>
 
 typedef enum
 {
@@ -12,44 +13,29 @@
 	AUDIO_SYNC_AUDIO_MASTER
 } AUDIO_SYNC_MODE;
 
-typedef enum {
+typedef enum
+{
 	HDMI_ENCODED_OFF,
 	HDMI_ENCODED_AUTO,
 	HDMI_ENCODED_FORCED
 } HDMI_ENCODED_MODE;
 
-typedef enum
-{
-	AUDIO_FMT_AUTO = 0,
-	AUDIO_FMT_MPEG,
-	AUDIO_FMT_MP3,
-	AUDIO_FMT_DOLBY_DIGITAL,
-	AUDIO_FMT_BASIC = AUDIO_FMT_DOLBY_DIGITAL,
-	AUDIO_FMT_AAC,
-	AUDIO_FMT_AAC_PLUS,
-	AUDIO_FMT_DD_PLUS,
-	AUDIO_FMT_DTS,
-	AUDIO_FMT_AVS,
-	AUDIO_FMT_MLP,
-	AUDIO_FMT_WMA,
-	AUDIO_FMT_MPG1, // TD only. For Movieplayer / cPlayback
-	AUDIO_FMT_ADVANCED = AUDIO_FMT_MLP
-} AUDIO_FORMAT;
-
 class mixerVolume;
 
 class cAudio
 {
-	friend class cPlayback;
+		friend class cPlayback;
 	private:
 		int fd;
+		bool fdd;
+		unsigned int devnum;
 		bool Muted;
 
 		int clipfd; /* for pcm playback */
 		int mixer_fd;  /* if we are using the OSS mixer */
 		int mixer_num; /* oss mixer to use, if any */
 
-		AUDIO_FORMAT	StreamType;
+		int StreamType;
 		AUDIO_SYNC_MODE    SyncMode;
 		bool started;
 
@@ -57,41 +43,67 @@
 
 		int do_mute(bool enable, bool remember);
 		void setBypassMode(bool disable);
-
 	public:
 		/* construct & destruct */
-		cAudio(void *, void *, void *);
+		cAudio(void *, void *, void *, unsigned int unit = 0);
 		~cAudio(void);
 
+		/* used internally by playback */
 		void openDevice(void);
 		void closeDevice(void);
 
-		void *GetHandle() { return NULL; };
+		void open_AVInput_Device(void);
+		void close_AVInput_Device(void);
+
+		void setAVInput(int val);
+
+		void *GetHandle()
+		{
+			return NULL;
+		};
 		/* shut up */
-		int mute(bool remember = true) { return do_mute(true, remember); };
-		int unmute(bool remember = true) { return do_mute(false, remember); };
+		int mute(bool remember = true)
+		{
+			return do_mute(true, remember);
+		};
+		int unmute(bool remember = true)
+		{
+			return do_mute(false, remember);
+		};
 
 		/* volume, min = 0, max = 255 */
 		int setVolume(unsigned int left, unsigned int right);
-		int getVolume(void) { return volume;}
-		bool getMuteStatus(void) { return Muted; };
+		int getVolume(void)
+		{
+			return volume;
+		}
+		bool getMuteStatus(void)
+		{
+			return Muted;
+		};
 
 		/* start and stop audio */
 		int Start(void);
 		int Stop(void);
 		bool Pause(bool Pcm = true);
-		void SetStreamType(AUDIO_FORMAT type);
-		AUDIO_FORMAT GetStreamType(void) { return StreamType; }
+		void SetStreamType(int bypass);
+		int GetStreamType(void)
+		{
+			return StreamType;
+		}
 		void SetSyncMode(AVSYNC_TYPE Mode);
 
 		/* select channels */
 		int setChannel(int channel);
 		int PrepareClipPlay(int uNoOfChannels, int uSampleRate, int uBitsPerSample, int bLittleEndian);
-		int WriteClip(unsigned char * buffer, int size);
+		int WriteClip(unsigned char *buffer, int size);
 		int StopClip();
-		void getAudioInfo(int &type, int &layer, int& freq, int &bitrate, int &mode);
+		void getAudioInfo(int &type, int &layer, int &freq, int &bitrate, int &mode);
 		void SetSRS(int iq_enable, int nmgr_enable, int iq_mode, int iq_level);
-		bool IsHdmiDDSupported() { return true; };
+		bool IsHdmiDDSupported()
+		{
+			return true;
+		};
 		void SetHdmiDD(bool enable);
 		void SetSpdifDD(bool enable);
 		void ScheduleMute(bool On);
diff -Nur libstb-hal-ddt.git.orig/libarmbox/dmx.cpp libstb-hal-ddt.git/libarmbox/dmx.cpp
--- libstb-hal-ddt.git.orig/libarmbox/dmx.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libarmbox/dmx.cpp	2022-07-23 18:18:31.499773109 +0200
@@ -50,15 +50,19 @@
 #define hal_debug_z(args...) _hal_debug(HAL_DEBUG_DEMUX, thiz, args)
 
 #define dmx_err(_errfmt, _errstr, _revents) do { \
-	hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
-		__func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
+    hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
+        __func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
 } while(0);
 
 cDemux *videoDemux = NULL;
 cDemux *audioDemux = NULL;
 //cDemux *pcrDemux = NULL;
 
-static const char *DMX_T[] = {
+cDemux *pipVideoDemux[3] = { NULL, NULL, NULL };
+cDemux *pipAudioDemux[3] = { NULL, NULL, NULL };
+
+static const char *DMX_T[] =
+{
 	"DMX_INVALID",
 	"DMX_VIDEO",
 	"DMX_AUDIO",
@@ -74,7 +78,7 @@
 #if BOXMODEL_VUULTIMO4K
 #define NUM_DEMUX 24
 #else
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 #define NUM_DEMUX 16
 #else
 #define NUM_DEMUX 4
@@ -84,65 +88,44 @@
 #if BOXMODEL_VUULTIMO4K
 static int dmx_source[NUM_DEMUX] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 #else
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 static int dmx_source[NUM_DEMUX] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 #else
 static int dmx_source[NUM_DEMUX] = { 0, 0, 0, 0 };
 #endif
 #endif
 
+char dmxdev[32];
+static char *devname(int adapter, int demux)
+{
+	snprintf(dmxdev, sizeof(dmxdev), "/dev/dvb/adapter%d/demux%d", adapter, demux);
+	return dmxdev;
+}
+
 /* map the device numbers. */
 #if BOXMODEL_VUULTIMO4K
 #define NUM_DEMUXDEV 24
 #else
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 #define NUM_DEMUXDEV 16
 #else
 #define NUM_DEMUXDEV 8
 #endif
 #endif
-static const char *devname[NUM_DEMUXDEV] = {
-	"/dev/dvb/adapter0/demux0",
-	"/dev/dvb/adapter0/demux1",
-	"/dev/dvb/adapter0/demux2",
-	"/dev/dvb/adapter0/demux3",
-	"/dev/dvb/adapter0/demux4",
-	"/dev/dvb/adapter0/demux5",
-	"/dev/dvb/adapter0/demux6",
-	"/dev/dvb/adapter0/demux7"
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
-	, "/dev/dvb/adapter0/demux8"
-	, "/dev/dvb/adapter0/demux9"
-	, "/dev/dvb/adapter0/demux10"
-	, "/dev/dvb/adapter0/demux11"
-	, "/dev/dvb/adapter0/demux12"
-	, "/dev/dvb/adapter0/demux13"
-	, "/dev/dvb/adapter0/demux14"
-	, "/dev/dvb/adapter0/demux15"
-#if BOXMODEL_VUULTIMO4K
-	, "/dev/dvb/adapter0/demux16"
-	, "/dev/dvb/adapter0/demux17"
-	, "/dev/dvb/adapter0/demux18"
-	, "/dev/dvb/adapter0/demux19"
-	, "/dev/dvb/adapter0/demux20"
-	, "/dev/dvb/adapter0/demux21"
-	, "/dev/dvb/adapter0/demux22"
-	, "/dev/dvb/adapter0/demux23"
-#endif
-#endif
-};
+
 /* did we already DMX_SET_SOURCE on that demux device? */
 #if BOXMODEL_VUULTIMO4K
 static bool init[NUM_DEMUXDEV] = { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false };
 #else
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 static bool init[NUM_DEMUXDEV] = { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false };
 #else
 static bool init[NUM_DEMUXDEV] = { false, false, false, false, false, false, false, false };
 #endif
 #endif
 
-typedef struct dmx_pdata {
+typedef struct dmx_pdata
+{
 	int last_source;
 	OpenThreads::Mutex *mutex;
 } dmx_pdata;
@@ -190,31 +173,33 @@
 
 static bool _open(cDemux *thiz, int num, int &fd, int &last_source, DMX_CHANNEL_TYPE dmx_type, int buffersize)
 {
-	int flags = O_RDWR|O_CLOEXEC;
+	int flags = O_RDWR | O_CLOEXEC;
 	int devnum = dmx_source[num];
-	if (last_source == devnum) {
+	if (last_source == devnum)
+	{
 		hal_debug_z("%s #%d: source (%d) did not change\n", __func__, num, last_source);
 		if (fd > -1)
 			return true;
 	}
-	if (fd > -1) {
+	if (fd > -1)
+	{
 		/* we changed source -> close and reopen the fd */
 		hal_debug_z("%s #%d: FD ALREADY OPENED fd = %d lastsource %d devnum %d\n",
-				__func__, num, fd, last_source, devnum);
+		    __func__, num, fd, last_source, devnum);
 		close(fd);
 	}
 
 	if (dmx_type != DMX_PSI_CHANNEL)
 		flags |= O_NONBLOCK;
 
-	fd = open(devname[devnum], flags);
+	fd = open(devname(0, devnum), flags);
 	if (fd < 0)
 	{
-		hal_info_z("%s %s: %m\n", __FUNCTION__, devname[devnum]);
+		hal_info_z("%s %s: %m\n", __FUNCTION__, devname(0, devnum));
 		return false;
 	}
 	hal_debug_z("%s #%d pes_type: %s(%d), uBufferSize: %d fd: %d\n", __func__,
-		 num, DMX_T[dmx_type], dmx_type, buffersize, fd);
+	    num, DMX_T[dmx_type], dmx_type, buffersize, fd);
 
 	/* this would actually need locking, but the worst that weill happen is, that
 	 * we'll DMX_SET_SOURCE twice per device, so don't bother... */
@@ -222,7 +207,7 @@
 	{
 		/* this should not change anything... */
 		int n = DMX_SOURCE_FRONT0 + devnum;
-		hal_info_z("%s: setting %s to source %d\n", __func__, devname[devnum], n);
+		hal_info_z("%s: setting %s to source %d\n", __func__, devname(0, devnum), n);
 		if (ioctl(fd, DMX_SET_SOURCE, &n) < 0)
 			hal_info_z("%s DMX_SET_SOURCE failed!\n", __func__);
 		else
@@ -285,7 +270,7 @@
 #if 0
 	if (len != 4095 && timeout != 10)
 		fprintf(stderr, "cDemux::%s #%d fd: %d type: %s len: %d timeout: %d\n",
-			__FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
+		    __FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
 #endif
 	if (fd < 0)
 	{
@@ -298,7 +283,7 @@
 	int to = timeout;
 	struct pollfd ufds;
 	ufds.fd = fd;
-	ufds.events = POLLIN|POLLPRI|POLLERR;
+	ufds.events = POLLIN | POLLPRI | POLLERR;
 	ufds.revents = 0;
 
 	/* hack: if the frontend loses and regains lock, the demuxer often will not
@@ -309,7 +294,7 @@
 
 	if (to > 0)
 	{
- retry:
+retry:
 		rc = ::poll(&ufds, 1, to);
 		if (ufds.fd != fd)
 		{
@@ -354,8 +339,9 @@
 			return 0;
 		}
 	}
-	if (ufds.fd != fd)	/* does this ever happen? and if, is it harmful? */
-	{			/* read(-1,...) will just return EBADF anyway... */
+	if (ufds.fd != fd)  /* does this ever happen? and if, is it harmful? */
+	{
+		/* read(-1,...) will just return EBADF anyway... */
 		hal_info("%s:2 ========== fd has changed, %d->%d ==========\n", __func__, ufds.fd, fd);
 		return -1;
 	}
@@ -368,9 +354,9 @@
 	return rc;
 }
 
-bool cDemux::sectionFilter(unsigned short _pid, const unsigned char * const filter,
-			   const unsigned char * const mask, int len, int timeout,
-			   const unsigned char * const negmask)
+bool cDemux::sectionFilter(unsigned short _pid, const unsigned char *const filter,
+    const unsigned char *const mask, int len, int timeout,
+    const unsigned char *const negmask)
 {
 	struct dmx_sct_filter_params s_flt;
 	memset(&s_flt, 0, sizeof(s_flt));
@@ -391,7 +377,7 @@
 	if (negmask != NULL)
 		memcpy(s_flt.filter.mode, negmask, len);
 
-	s_flt.flags = DMX_IMMEDIATE_START|DMX_CHECK_CRC;
+	s_flt.flags = DMX_IMMEDIATE_START | DMX_CHECK_CRC;
 
 	int to = 0;
 	switch (filter[0])
@@ -476,13 +462,22 @@
 		s_flt.timeout = to;
 
 	hal_debug("%s #%d pid:0x%04hx fd:%d type:%s len:%d to:%d flags:%x flt[0]:%02x\n", __func__, num,
-		pid, fd, DMX_T[dmx_type], len, s_flt.timeout, s_flt.flags, s_flt.filter.filter[0]);
-#if 0
-	fprintf(stderr,"filt: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.filter[i]); fprintf(stderr, "\n");
-	fprintf(stderr,"mask: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mask  [i]); fprintf(stderr, "\n");
-	fprintf(stderr,"mode: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mode  [i]); fprintf(stderr, "\n");
-#endif
-	ioctl (fd, DMX_STOP);
+	    pid, fd, DMX_T[dmx_type], len, s_flt.timeout, s_flt.flags, s_flt.filter.filter[0]);
+
+	if (debuglevel == 2)
+	{
+		fprintf(stderr, "filt: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.filter[i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mask: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mask  [i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mode: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mode  [i]);
+		fprintf(stderr, "\n");
+	}
+
+	ioctl(fd, DMX_STOP);
 	if (ioctl(fd, DMX_SET_FILTER, &s_flt) < 0)
 		return false;
 
@@ -498,7 +493,7 @@
 	 * this check originally is from tuxbox cvs but I'm not sure
 	 * what it is good for...
 	if (pid <= 0x0001 && dmx_type != DMX_PCR_ONLY_CHANNEL)
-		return false;
+	    return false;
 	 */
 	if ((pid >= 0x0002 && pid <= 0x000f) || pid >= 0x1fff)
 		return false;
@@ -509,31 +504,50 @@
 
 	memset(&p_flt, 0, sizeof(p_flt));
 	p_flt.pid    = pid;
-	p_flt.output = DMX_OUT_DECODER;
 	p_flt.input  = DMX_IN_FRONTEND;
+	p_flt.output = DMX_OUT_DECODER;
 	p_flt.flags  = 0;
 
 	switch (dmx_type)
 	{
-		case DMX_PCR_ONLY_CHANNEL:
-			p_flt.pes_type = DMX_PES_PCR;
-			break;
-		case DMX_AUDIO_CHANNEL:
-			p_flt.pes_type = DMX_PES_AUDIO;
-			break;
 		case DMX_VIDEO_CHANNEL:
-			p_flt.pes_type = DMX_PES_VIDEO;
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_VIDEO0; break;
+				case 1: p_flt.pes_type = DMX_PES_VIDEO1; break;
+				case 2: p_flt.pes_type = DMX_PES_VIDEO2; break;
+				case 3: p_flt.pes_type = DMX_PES_VIDEO3; break;
+			}
 			break;
-		case DMX_PIP_CHANNEL: /* PIP is a special version of DMX_VIDEO_CHANNEL */
-			p_flt.pes_type = DMX_PES_VIDEO1;
+		case DMX_AUDIO_CHANNEL:
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_AUDIO0; break;
+				case 1: p_flt.pes_type = DMX_PES_AUDIO1; break;
+				case 2: p_flt.pes_type = DMX_PES_AUDIO2; break;
+				case 3: p_flt.pes_type = DMX_PES_AUDIO3; break;
+			}
 			break;
 		case DMX_PES_CHANNEL:
 			p_flt.pes_type = DMX_PES_OTHER;
-			p_flt.output  = DMX_OUT_TAP;
+			p_flt.output   = DMX_OUT_TAP;
+			break;
+#if 0
+		case DMX_PSI_CHANNEL:
 			break;
+#endif
 		case DMX_TP_CHANNEL:
 			p_flt.pes_type = DMX_PES_OTHER;
-			p_flt.output  = DMX_OUT_TSDEMUX_TAP;
+			p_flt.output   = DMX_OUT_TSDEMUX_TAP;
+			break;
+		case DMX_PCR_ONLY_CHANNEL:
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_PCR0; break;
+				case 1: p_flt.pes_type = DMX_PES_PCR1; break;
+				case 2: p_flt.pes_type = DMX_PES_PCR2; break;
+				case 3: p_flt.pes_type = DMX_PES_PCR3; break;
+			}
 			break;
 		default:
 			hal_info("%s #%d invalid dmx_type %d!\n", __func__, num, dmx_type);
@@ -590,7 +604,8 @@
 	}
 	for (std::vector<pes_pids>::iterator i = pesfds.begin(); i != pesfds.end(); ++i)
 	{
-		if ((*i).pid == Pid) {
+		if ((*i).pid == Pid)
+		{
 			hal_debug("removePid: removing demux fd %d pid 0x%04x\n", fd, Pid);
 			if (ioctl(fd, DMX_REMOVE_PID, Pid) < 0)
 				hal_info("%s: (DMX_REMOVE_PID, 0x%04hx): %m\n", __func__, Pid);
@@ -601,7 +616,7 @@
 	hal_info("%s pid 0x%04x not found\n", __FUNCTION__, Pid);
 }
 
-void cDemux::getSTC(int64_t * STC)
+void cDemux::getSTC(int64_t *STC)
 {
 	/* apparently I can only get the PTS of the video decoder,
 	 * but that's good enough for dvbsub */
@@ -623,7 +638,8 @@
 
 bool cDemux::SetSource(int unit, int source)
 {
-	if (unit >= NUM_DEMUX || unit < 0) {
+	if (unit >= NUM_DEMUX || unit < 0)
+	{
 		hal_info_c("%s: unit (%d) out of range, NUM_DEMUX %d\n", __func__, unit, NUM_DEMUX);
 		return false;
 	}
@@ -637,7 +653,8 @@
 
 int cDemux::GetSource(int unit)
 {
-	if (unit >= NUM_DEMUX || unit < 0) {
+	if (unit >= NUM_DEMUX || unit < 0)
+	{
 		hal_info_c("%s: unit (%d) out of range, NUM_DEMUX %d\n", __func__, unit, NUM_DEMUX);
 		return -1;
 	}
diff -Nur libstb-hal-ddt.git.orig/libarmbox/hardware_caps.c libstb-hal-ddt.git/libarmbox/hardware_caps.c
--- libstb-hal-ddt.git.orig/libarmbox/hardware_caps.c	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libarmbox/hardware_caps.c	2022-07-23 18:18:31.499773109 +0200
@@ -29,6 +29,12 @@
 
 	memset(&caps, 0, sizeof(hw_caps_t));
 
+	caps.pip_devs = 0;
+	if (access("/dev/dvb/adapter0/video1", F_OK) != -1) caps.pip_devs = 1;
+	if (access("/dev/dvb/adapter0/video2", F_OK) != -1) caps.pip_devs = 2;
+	if (access("/dev/dvb/adapter0/video3", F_OK) != -1) caps.pip_devs = 3;
+	if (caps.pip_devs > 0) caps.can_pip = 1;
+
 #if BOXMODEL_VUSOLO4K
 	initialized = 1;
 	caps.has_CI = 1;
@@ -40,8 +46,10 @@
 	caps.display_can_deepstandby = 0;	// 0 because we use graphlcd/lcd4linux
 	caps.display_can_set_brightness = 0;	// 0 because we use graphlcd/lcd4linux
 	caps.display_has_statusline = 0;	// 0 because we use graphlcd/lcd4linux
+	caps.display_has_colon = 0;
 	caps.has_button_timer = 1;
 	caps.has_HDMI = 1;
+	caps.pip_devs = 2;			// has only 3 real usable video devices
 	strcpy(caps.boxvendor, "VU+");
 	strcpy(caps.boxname, "SOLO4K");
 	strcpy(caps.boxarch, "BCM7376");
@@ -57,12 +65,33 @@
 	caps.display_can_deepstandby = 0;	// 0 because we use graphlcd/lcd4linux
 	caps.display_can_set_brightness = 0;	// 0 because we use graphlcd/lcd4linux
 	caps.display_has_statusline = 0;	// 0 because we use graphlcd/lcd4linux
+	caps.display_has_colon = 0;
 	caps.has_button_timer = 1;
 	caps.has_HDMI = 2;
+	caps.has_HDMI_input = 1;
 	strcpy(caps.boxvendor, "VU+");
 	strcpy(caps.boxname, "DUO4K");
 	strcpy(caps.boxarch, "BCM7278");
 #endif
+#if BOXMODEL_VUDUO4KSE
+	initialized = 1;
+	caps.has_CI = 2;
+	caps.can_cec = 1;
+	caps.can_shutdown = 1;
+	caps.display_xres = 480;
+	caps.display_yres = 320;
+	caps.display_type = HW_DISPLAY_GFX;
+	caps.display_can_deepstandby = 0;	// 0 because we use graphlcd/lcd4linux
+	caps.display_can_set_brightness = 0;	// 0 because we use graphlcd/lcd4linux
+	caps.display_has_statusline = 0;	// 0 because we use graphlcd/lcd4linux
+	caps.display_has_colon = 0;
+	caps.has_button_timer = 1;
+	caps.has_HDMI = 2;
+	caps.has_HDMI_input = 1;
+	strcpy(caps.boxvendor, "VU+");
+	strcpy(caps.boxname, "DUO4KSE");
+	strcpy(caps.boxarch, "BCM7444S");
+#endif
 #if BOXMODEL_VUULTIMO4K
 	initialized = 1;
 	caps.has_CI = 2;
@@ -74,8 +103,10 @@
 	caps.display_can_deepstandby = 0;	// 0 because we use graphlcd/lcd4linux
 	caps.display_can_set_brightness = 0;	// 0 because we use graphlcd/lcd4linux
 	caps.display_has_statusline = 0;	// 0 because we use graphlcd/lcd4linux
+	caps.display_has_colon = 0;
 	caps.has_button_timer = 1;
 	caps.has_HDMI = 2;
+	caps.has_HDMI_input = 1;
 	strcpy(caps.boxvendor, "VU+");
 	strcpy(caps.boxname, "ULTIMO4K");
 	strcpy(caps.boxarch, "BCM7444S");
@@ -89,6 +120,7 @@
 	caps.display_can_deepstandby = 0;
 	caps.display_can_set_brightness = 1;
 	caps.display_has_statusline = 0;
+	caps.display_has_colon = 0;
 	caps.has_button_timer = 1;
 	caps.has_HDMI = 1;
 	strcpy(caps.boxvendor, "VU+");
@@ -106,8 +138,10 @@
 	caps.display_can_deepstandby = 0;	// 0 because we use graphlcd/lcd4linux
 	caps.display_can_set_brightness = 0;	// 0 because we use graphlcd/lcd4linux
 	caps.display_has_statusline = 0;	// 0 because we use graphlcd/lcd4linux
+	caps.display_has_colon = 0;
 	caps.has_button_timer = 1;
 	caps.has_HDMI = 2;
+	caps.has_HDMI_input = 1;
 	strcpy(caps.boxvendor, "VU+");
 	strcpy(caps.boxname, "UNO4KSE");
 	strcpy(caps.boxarch, "BCM7252S");
@@ -121,6 +155,7 @@
 	caps.display_can_deepstandby = 0;
 	caps.display_can_set_brightness = 1;
 	caps.display_has_statusline = 0;
+	caps.display_has_colon = 0;
 	caps.has_button_timer = 1;
 	caps.has_HDMI = 1;
 	strcpy(caps.boxvendor, "VU+");
@@ -132,11 +167,12 @@
 	caps.has_CI = 1;
 	caps.can_cec = 1;
 	caps.can_shutdown = 1;
-	caps.display_xres = 5;
-	caps.display_type = HW_DISPLAY_LINE_TEXT;
+	caps.display_xres = 4;
+	caps.display_type = HW_DISPLAY_LED_NUM;
 	caps.display_can_deepstandby = 0;
 	caps.display_can_set_brightness = 1;
 	caps.display_has_statusline = 0;
+	caps.display_has_colon = 1;
 	caps.has_button_timer = 1;
 	caps.has_HDMI = 1;
 	strcpy(caps.boxvendor, "WWIO");
@@ -153,9 +189,10 @@
 	caps.display_can_deepstandby = 0;
 	caps.display_can_set_brightness = 1;
 	caps.display_has_statusline = 0;
+	caps.display_has_colon = 0;
 	caps.has_button_timer = 1;
 	caps.has_HDMI = 1;
-	strcpy(caps.boxvendor, "AX-Technologies");
+	strcpy(caps.boxvendor, "AX");
 	strcpy(caps.boxname, "HD51");
 	strcpy(caps.boxarch, "BCM7251S");
 #endif
@@ -164,15 +201,16 @@
 	caps.has_CI = 1;
 	caps.can_cec = 1;
 	caps.can_shutdown = 1;
-	caps.display_xres = 5;
-	caps.display_type = HW_DISPLAY_LINE_TEXT;
+	caps.display_xres = 4;
+	caps.display_type = HW_DISPLAY_LED_NUM;
 	caps.display_can_deepstandby = 0;
 	caps.display_can_set_brightness = 1;
 	caps.display_has_statusline = 0;
+	caps.display_has_colon = 1;
 	caps.has_button_timer = 1;
 	caps.has_HDMI = 1;
 	strcpy(caps.boxvendor, "AirDigital");
-	strcpy(caps.boxname, "Zgemma H7C/S");
+	strcpy(caps.boxname, "Zgemma H7");
 	strcpy(caps.boxarch, "BCM7251S");
 #endif
 	return &caps;
diff -Nur libstb-hal-ddt.git.orig/libarmbox/hdmi_cec.cpp libstb-hal-ddt.git/libarmbox/hdmi_cec.cpp
--- libstb-hal-ddt.git.orig/libarmbox/hdmi_cec.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libarmbox/hdmi_cec.cpp	2022-07-23 18:18:31.499773109 +0200
@@ -1,26 +1,26 @@
 /*
-	Copyright (C) 2018 TangoCash
+    Copyright (C) 2018-2021 TangoCash
 
-	License: GPLv2
+    License: GPLv2
 
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation;
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation;
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include <fcntl.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
-#include <sys/poll.h>
+#include <sys/epoll.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -28,6 +28,7 @@
 #include <errno.h>
 #include <ctype.h>
 
+#include <array>
 #include <cstring>
 #include <cstdio>
 #include <cstdlib>
@@ -40,38 +41,51 @@
 #include "hal_debug.h"
 
 #define RED "\x1B[31m"
+#define GREEN "\x1B[32m"
 #define NORMAL "\x1B[0m"
 
+#define EPOLL_WAIT_TIMEOUT (-1)
+#define EPOLL_MAX_EVENTS (1)
+
 #define hal_debug(args...) _hal_debug(HAL_DEBUG_INIT, this, args)
 #define hal_info(args...) _hal_info(HAL_DEBUG_INIT, this, args)
 #define hal_debug_c(args...) _hal_debug(HAL_DEBUG_INIT, NULL, args)
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_INIT, NULL, args)
 
-#define fop(cmd, args...) ({				\
-	int _r;						\
-	if (fd >= 0) { 					\
-		if ((_r = ::cmd(fd, args)) < 0)		\
-			hal_info(#cmd"(fd, "#args")\n");	\
-		else					\
-			hal_debug(#cmd"(fd, "#args")\n");\
-	}						\
-	else { _r = fd; } 				\
-	_r;						\
+#define fop(cmd, args...) ({                \
+    int _r;                     \
+    if (fd >= 0) {                  \
+        if ((_r = ::cmd(fd, args)) < 0)     \
+            hal_info(#cmd"(fd, "#args")\n");    \
+        else                    \
+            hal_debug(#cmd"(fd, "#args")\n");\
+    }                       \
+    else { _r = fd; }               \
+    _r;                     \
 })
 
-#define CEC_DEVICE "/dev/cec0"
+#define CEC_FALLBACK_DEVICE "/dev/cec0"
+#define CEC_HDMIDEV "/dev/hdmi_cec"
+#if BOXMODEL_H7
+#define RC_DEVICE  "/dev/input/event2"
+#else
 #define RC_DEVICE  "/dev/input/event1"
+#endif
 
-hdmi_cec * hdmi_cec::hdmi_cec_instance = NULL;
+hdmi_cec *hdmi_cec::hdmi_cec_instance = NULL;
 
 //hack to get an instance before first call
-hdmi_cec * CEC = hdmi_cec::getInstance();
+hdmi_cec *CEC = hdmi_cec::getInstance();
 
 hdmi_cec::hdmi_cec()
 {
 	standby_cec_activ = autoview_cec_activ = standby = muted = false;
 	hdmiFd = -1;
 	volume = 0;
+	fallback = false;
+	tv_off = true;
+	deviceType = CEC_LOG_ADDR_TYPE_UNREGISTERED;
+	audio_destination = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
 }
 
 hdmi_cec::~hdmi_cec()
@@ -83,12 +97,12 @@
 	}
 }
 
-hdmi_cec* hdmi_cec::getInstance()
+hdmi_cec *hdmi_cec::getInstance()
 {
 	if (hdmi_cec_instance == NULL)
 	{
 		hdmi_cec_instance = new hdmi_cec();
-		hal_debug_c("[CEC] new instance created \n");
+		hal_info_c(GREEN "[CEC] new instance created \n" NORMAL);
 	}
 	return hdmi_cec_instance;
 }
@@ -102,91 +116,111 @@
 	if (_deviceType == VIDEO_HDMI_CEC_MODE_OFF)
 	{
 		Stop();
-		hal_debug("[CEC] switch off %s\n", __func__);
+		hal_info(GREEN "[CEC] switch off %s\n" NORMAL, __func__);
 		return false;
 	}
 	else
 		deviceType = _deviceType;
 
-	hal_debug("[CEC] switch on %s\n", __func__);
+	hal_info(GREEN "[CEC] switch on %s\n" NORMAL, __func__);
 
+#if BOXMODEL_VUPLUS_ALL
 	if (hdmiFd == -1)
 	{
-		hdmiFd = open(CEC_DEVICE, O_RDWR | O_CLOEXEC);
+		hdmiFd = ::open(CEC_HDMIDEV, O_RDWR | O_NONBLOCK | O_CLOEXEC);
+		if (hdmiFd >= 0)
+		{
+			::ioctl(hdmiFd, 0); /* flush old messages */
+		}
 	}
+#endif
 
-	if (hdmiFd >= 0)
+	if (hdmiFd == -1)
 	{
-		__u32 monitor = CEC_MODE_INITIATOR | CEC_MODE_FOLLOWER;
-		struct cec_caps caps = {};
+		hdmiFd = open(CEC_FALLBACK_DEVICE, O_RDWR | O_CLOEXEC);
 
-		if (ioctl(hdmiFd, CEC_ADAP_G_CAPS, &caps) < 0)
-			hal_debug("[CEC] %s: get caps failed (%m)\n", __func__);
-
-		if (caps.capabilities & CEC_CAP_LOG_ADDRS)
+		if (hdmiFd >= 0)
 		{
-			struct cec_log_addrs laddrs = {};
+			fallback = true;
+#if BOXMODEL_VUPLUS_ALL
+			hal_info(RED "[CEC] fallback on %s\n" NORMAL, __func__);
+#endif
 
-			if (ioctl(hdmiFd, CEC_ADAP_S_LOG_ADDRS, &laddrs) < 0)
-				hal_debug("[CEC] %s: reset log addr failed (%m)\n", __func__);
+			__u32 monitor = CEC_MODE_INITIATOR | CEC_MODE_FOLLOWER;
+			struct cec_caps caps = {};
 
-			memset(&laddrs, 0, sizeof(laddrs));
+			if (ioctl(hdmiFd, CEC_ADAP_G_CAPS, &caps) < 0)
+				hal_info(RED "[CEC] %s: get caps failed (%m)\n" NORMAL, __func__);
 
-			/*
-			 * NOTE: cec_version, osd_name and deviceType should be made configurable,
-			 * CEC_ADAP_S_LOG_ADDRS delayed till the desired values are available
-			 * (saves us some startup speed as well, polling for a free logical address
-			 * takes some time)
-			 */
-			laddrs.cec_version = CEC_OP_CEC_VERSION_2_0;
-			strcpy(laddrs.osd_name, "neutrino");
-			laddrs.vendor_id = CEC_VENDOR_ID_NONE;
-
-			switch (deviceType)
+			if (caps.capabilities & CEC_CAP_LOG_ADDRS)
 			{
-			case CEC_LOG_ADDR_TV:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_TV;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_TV;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_TV;
-				break;
-			case CEC_LOG_ADDR_RECORD_1:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_RECORD;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_RECORD;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_RECORD;
-				break;
-			case CEC_LOG_ADDR_TUNER_1:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_TUNER;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_TUNER;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_TUNER;
-				break;
-			case CEC_LOG_ADDR_PLAYBACK_1:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_PLAYBACK;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_PLAYBACK;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_PLAYBACK;
-				break;
-			case CEC_LOG_ADDR_AUDIOSYSTEM:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_AUDIOSYSTEM;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
-				break;
-			default:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_UNREGISTERED;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_SWITCH;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_SWITCH;
-				break;
+				struct cec_log_addrs laddrs = {};
+
+				if (ioctl(hdmiFd, CEC_ADAP_S_LOG_ADDRS, &laddrs) < 0)
+					hal_info(RED "[CEC] %s: reset log addr failed (%m)\n" NORMAL, __func__);
+
+				memset(&laddrs, 0, sizeof(laddrs));
+
+				/*
+				 * NOTE: cec_version, osd_name and deviceType should be made configurable,
+				 * CEC_ADAP_S_LOG_ADDRS delayed till the desired values are available
+				 * (saves us some startup speed as well, polling for a free logical address
+				 * takes some time)
+				 */
+				laddrs.cec_version = CEC_OP_CEC_VERSION_2_0;
+				strcpy(laddrs.osd_name, "neutrino");
+				laddrs.vendor_id = CEC_VENDOR_ID_NONE;
+
+				switch (deviceType)
+				{
+					case CEC_LOG_ADDR_TV:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_TV;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_TV;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_TV;
+						break;
+					case CEC_LOG_ADDR_RECORD_1:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_RECORD;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_RECORD;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_RECORD;
+						break;
+					case CEC_LOG_ADDR_TUNER_1:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_TUNER;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_TUNER;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_TUNER;
+						break;
+					case CEC_LOG_ADDR_PLAYBACK_1:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_PLAYBACK;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_PLAYBACK;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_PLAYBACK;
+						break;
+					case CEC_LOG_ADDR_AUDIOSYSTEM:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_AUDIOSYSTEM;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
+						break;
+					default:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_UNREGISTERED;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_SWITCH;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_SWITCH;
+						break;
+				}
+				laddrs.num_log_addrs++;
+
+				if (ioctl(hdmiFd, CEC_ADAP_S_LOG_ADDRS, &laddrs) < 0)
+					hal_info(RED "[CEC] %s: et log addr failed (%m)\n" NORMAL, __func__);
 			}
-			laddrs.num_log_addrs++;
 
-			if (ioctl(hdmiFd, CEC_ADAP_S_LOG_ADDRS, &laddrs) < 0)
-				hal_debug("[CEC] %s: et log addr failed (%m)\n", __func__);
-		}
+			if (ioctl(hdmiFd, CEC_S_MODE, &monitor) < 0)
+				hal_info(RED "[CEC] %s: monitor failed (%m)\n" NORMAL, __func__);
 
-		if (ioctl(hdmiFd, CEC_S_MODE, &monitor) < 0)
-			hal_debug("[CEC] %s: monitor failed (%m)\n", __func__);
+		}
+	}
 
+	if (hdmiFd >= 0)
+	{
 		GetCECAddressInfo();
 
-		if(autoview_cec_activ)
+		if (autoview_cec_activ)
 			SetCECState(false);
 
 		Start();
@@ -200,48 +234,62 @@
 {
 	if (hdmiFd >= 0)
 	{
+		bool hasdata = false;
 		struct addressinfo addressinfo;
 
-		__u16 phys_addr;
-		struct cec_log_addrs laddrs = {};
+		if (fallback)
+		{
+			__u16 phys_addr;
+			struct cec_log_addrs laddrs = {};
 
-		::ioctl(hdmiFd, CEC_ADAP_G_PHYS_ADDR, &phys_addr);
-		addressinfo.physical[0] = (phys_addr >> 8) & 0xff;
-		addressinfo.physical[1] = phys_addr & 0xff;
+			::ioctl(hdmiFd, CEC_ADAP_G_PHYS_ADDR, &phys_addr);
+			addressinfo.physical[0] = (phys_addr >> 8) & 0xff;
+			addressinfo.physical[1] = phys_addr & 0xff;
 
-		::ioctl(hdmiFd, CEC_ADAP_G_LOG_ADDRS, &laddrs);
-		addressinfo.logical = laddrs.log_addr[0];
+			::ioctl(hdmiFd, CEC_ADAP_G_LOG_ADDRS, &laddrs);
+			addressinfo.logical = laddrs.log_addr[0];
 
-		switch (laddrs.log_addr_type[0])
+			switch (laddrs.log_addr_type[0])
+			{
+				case CEC_LOG_ADDR_TYPE_TV:
+					addressinfo.type = CEC_LOG_ADDR_TV;
+					break;
+				case CEC_LOG_ADDR_TYPE_RECORD:
+					addressinfo.type = CEC_LOG_ADDR_RECORD_1;
+					break;
+				case CEC_LOG_ADDR_TYPE_TUNER:
+					addressinfo.type = CEC_LOG_ADDR_TUNER_1;
+					break;
+				case CEC_LOG_ADDR_TYPE_PLAYBACK:
+					addressinfo.type = CEC_LOG_ADDR_PLAYBACK_1;
+					break;
+				case CEC_LOG_ADDR_TYPE_AUDIOSYSTEM:
+					addressinfo.type = CEC_LOG_ADDR_AUDIOSYSTEM;
+					break;
+				case CEC_LOG_ADDR_TYPE_UNREGISTERED:
+				default:
+					addressinfo.type = CEC_LOG_ADDR_UNREGISTERED;
+					break;
+			}
+			hasdata = true;
+		}
+		else
 		{
-		case CEC_LOG_ADDR_TYPE_TV:
-			addressinfo.type = CEC_LOG_ADDR_TV;
-			break;
-		case CEC_LOG_ADDR_TYPE_RECORD:
-			addressinfo.type = CEC_LOG_ADDR_RECORD_1;
-			break;
-		case CEC_LOG_ADDR_TYPE_TUNER:
-			addressinfo.type = CEC_LOG_ADDR_TUNER_1;
-			break;
-		case CEC_LOG_ADDR_TYPE_PLAYBACK:
-			addressinfo.type = CEC_LOG_ADDR_PLAYBACK_1;
-			break;
-		case CEC_LOG_ADDR_TYPE_AUDIOSYSTEM:
-			addressinfo.type = CEC_LOG_ADDR_AUDIOSYSTEM;
-			break;
-		case CEC_LOG_ADDR_TYPE_UNREGISTERED:
-		default:
-			addressinfo.type = CEC_LOG_ADDR_UNREGISTERED;
-			break;
+			if (::ioctl(hdmiFd, 1, &addressinfo) >= 0)
+			{
+				hasdata = true;
+			}
 		}
-
-		deviceType = addressinfo.type;
-		logicalAddress = addressinfo.logical;
-		if (memcmp(physicalAddress, addressinfo.physical, sizeof(physicalAddress)))
+		if (hasdata)
 		{
-			hal_info("[CEC] %s: detected physical address change: %02X%02X --> %02X%02X\n", __func__, physicalAddress[0], physicalAddress[1], addressinfo.physical[0], addressinfo.physical[1]);
-			memcpy(physicalAddress, addressinfo.physical, sizeof(physicalAddress));
-			ReportPhysicalAddress();
+			deviceType = addressinfo.type;
+			logicalAddress = addressinfo.logical;
+			if (memcmp(physicalAddress, addressinfo.physical, sizeof(physicalAddress)))
+			{
+				hal_info(GREEN "[CEC] %s: detected physical address change: %02X%02X --> %02X%02X\n" NORMAL, __func__, physicalAddress[0], physicalAddress[1], addressinfo.physical[0], addressinfo.physical[1]);
+				memcpy(physicalAddress, addressinfo.physical, sizeof(physicalAddress));
+				ReportPhysicalAddress();
+			}
 		}
 	}
 }
@@ -259,21 +307,36 @@
 	SendCECMessage(txmessage);
 }
 
-void hdmi_cec::SendCECMessage(struct cec_message &txmessage)
+void hdmi_cec::SendCECMessage(struct cec_message &txmessage, int sleeptime)
 {
 	if (hdmiFd >= 0)
 	{
-		char str[txmessage.length*6];
+
+		char str[txmessage.length * 6];
 		for (int i = 0; i < txmessage.length; i++)
 		{
-			sprintf(str+(i*6),"[0x%02X]", txmessage.data[i]);
+			sprintf(str + (i * 6), "[0x%02X]", txmessage.data[i]);
 		}
-		hal_info("[CEC] send message %s to %s (0x%02X>>0x%02X) '%s' (%s)\n",ToString((cec_logical_address)txmessage.initiator), txmessage.destination == 0xf ? "all" : ToString((cec_logical_address)txmessage.destination), txmessage.initiator, txmessage.destination, ToString((cec_opcode)txmessage.data[0]), str);
-		struct cec_msg msg;
-		cec_msg_init(&msg, txmessage.initiator, txmessage.destination);
-		memcpy(&msg.msg[1], txmessage.data, txmessage.length);
-		msg.len = txmessage.length + 1;
-		ioctl(hdmiFd, CEC_TRANSMIT, &msg);
+		hal_info(GREEN "[CEC] send message %s to %s (0x%02X>>0x%02X) '%s' (%s)\n" NORMAL, ToString((cec_logical_address)txmessage.initiator), txmessage.destination == 0xf ? "all" : ToString((cec_logical_address)txmessage.destination), txmessage.initiator, txmessage.destination, ToString((cec_opcode)txmessage.data[0]), str);
+
+		if (fallback)
+		{
+			struct cec_msg msg;
+			cec_msg_init(&msg, txmessage.initiator, txmessage.destination);
+			memcpy(&msg.msg[1], txmessage.data, txmessage.length);
+			msg.len = txmessage.length + 1;
+			ioctl(hdmiFd, CEC_TRANSMIT, &msg);
+		}
+		else
+		{
+			struct cec_message_fb message;
+			message.address = txmessage.destination;
+			message.length = txmessage.length;
+			memcpy(&message.data, txmessage.data, txmessage.length);
+			::write(hdmiFd, &message, 2 + message.length);
+		}
+
+		usleep(sleeptime * 1000);
 	}
 }
 
@@ -300,23 +363,53 @@
 		message.data[0] = CEC_MSG_STANDBY;
 		message.length = 1;
 		SendCECMessage(message);
+
+		message.initiator = logicalAddress;
+		message.destination = CEC_OP_PRIM_DEVTYPE_TV;
+		message.data[0] = CEC_MSG_GIVE_DEVICE_POWER_STATUS;
+		message.length = 1;
+		SendCECMessage(message);
 	}
 
 	if ((autoview_cec_activ) && !state)
 	{
 		message.initiator = logicalAddress;
-		message.destination = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
-		message.data[0] = CEC_MSG_GIVE_SYSTEM_AUDIO_MODE_STATUS;
+		message.destination = CEC_OP_PRIM_DEVTYPE_TV;
+		message.data[0] = CEC_MSG_GET_CEC_VERSION;
 		message.length = 1;
 		SendCECMessage(message);
-		usleep(10000);
 
 		message.initiator = logicalAddress;
 		message.destination = CEC_OP_PRIM_DEVTYPE_TV;
-		message.data[0] = CEC_MSG_IMAGE_VIEW_ON;
+		message.data[0] = CEC_MSG_GIVE_DEVICE_POWER_STATUS;
 		message.length = 1;
 		SendCECMessage(message);
-		usleep(10000);
+
+#if BOXMODEL_VUPLUS_ALL
+		int cnt = 0;
+
+		while (tv_off && (cnt < 5))
+		{
+#endif
+
+			message.initiator = logicalAddress;
+			message.destination = CEC_OP_PRIM_DEVTYPE_TV;
+			message.data[0] = CEC_MSG_IMAGE_VIEW_ON;
+			message.length = 1;
+			SendCECMessage(message);
+
+			message.initiator = logicalAddress;
+			message.destination = CEC_OP_PRIM_DEVTYPE_TV;
+			message.data[0] = CEC_MSG_GIVE_DEVICE_POWER_STATUS;
+			message.length = 1;
+			SendCECMessage(message);
+
+#if BOXMODEL_VUPLUS_ALL
+			cnt++;
+		}
+#endif
+
+		GetCECAddressInfo();
 
 		message.initiator = logicalAddress;
 		message.destination = CEC_LOG_ADDR_BROADCAST;
@@ -325,7 +418,20 @@
 		message.data[2] = physicalAddress[1];
 		message.length = 3;
 		SendCECMessage(message);
-		usleep(10000);
+
+		message.initiator = logicalAddress;
+		message.destination = CEC_LOG_ADDR_BROADCAST;
+		message.data[0] = CEC_OPCODE_SET_OSD_NAME;
+		message.data[1] = 0x6e; //n
+		message.data[2] = 0x65; //e
+		message.data[3] = 0x75; //u
+		message.data[4] = 0x74; //t
+		message.data[5] = 0x72; //r
+		message.data[6] = 0x69; //i
+		message.data[7] = 0x6e; //n
+		message.data[8] = 0x6f; //o
+		message.length = 9;
+		SendCECMessage(message);
 
 		request_audio_status();
 	}
@@ -337,114 +443,114 @@
 	long key = 0;
 	switch (code)
 	{
-	case CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL:
-		key = KEY_MENU;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER0:
-		key = KEY_0;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER1:
-		key = KEY_1;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER2:
-		key = KEY_2;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER3:
-		key = KEY_3;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER4:
-		key = KEY_4;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER5:
-		key = KEY_5;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER6:
-		key = KEY_6;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER7:
-		key = KEY_7;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER8:
-		key = KEY_8;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER9:
-		key = KEY_9;
-		break;
-	case CEC_USER_CONTROL_CODE_CHANNEL_UP:
-		key = KEY_CHANNELUP;
-		break;
-	case CEC_USER_CONTROL_CODE_CHANNEL_DOWN:
-		key = KEY_CHANNELDOWN;
-		break;
-	case CEC_USER_CONTROL_CODE_PLAY:
-		key = KEY_PLAY;
-		break;
-	case CEC_USER_CONTROL_CODE_STOP:
-		key = KEY_STOP;
-		break;
-	case CEC_USER_CONTROL_CODE_PAUSE:
-		key = KEY_PAUSE;
-		break;
-	case CEC_USER_CONTROL_CODE_RECORD:
-		key = KEY_RECORD;
-		break;
-	case CEC_USER_CONTROL_CODE_REWIND:
-		key = KEY_REWIND;
-		break;
-	case CEC_USER_CONTROL_CODE_FAST_FORWARD:
-		key = KEY_FASTFORWARD;
-		break;
-	case CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE:
-		key = KEY_INFO;
-		break;
-	case CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING:
-		key = KEY_PROGRAM;
-		break;
-	case CEC_USER_CONTROL_CODE_PLAY_FUNCTION:
-		key = KEY_PLAY;
-		break;
-	case CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION:
-		key = KEY_PLAYPAUSE;
-		break;
-	case CEC_USER_CONTROL_CODE_RECORD_FUNCTION:
-		key = KEY_RECORD;
-		break;
-	case CEC_USER_CONTROL_CODE_STOP_FUNCTION:
-		key = KEY_STOP;
-		break;
-	case CEC_USER_CONTROL_CODE_SELECT:
-		key = KEY_OK;
-		break;
-	case CEC_USER_CONTROL_CODE_LEFT:
-		key = KEY_LEFT;
-		break;
-	case CEC_USER_CONTROL_CODE_RIGHT:
-		key = KEY_RIGHT;
-		break;
-	case CEC_USER_CONTROL_CODE_UP:
-		key = KEY_UP;
-		break;
-	case CEC_USER_CONTROL_CODE_DOWN:
-		key = KEY_DOWN;
-		break;
-	case CEC_USER_CONTROL_CODE_EXIT:
-		key = KEY_EXIT;
-		break;
-	case CEC_USER_CONTROL_CODE_F2_RED:
-		key = KEY_RED;
-		break;
-	case CEC_USER_CONTROL_CODE_F3_GREEN:
-		key = KEY_GREEN;
-		break;
-	case CEC_USER_CONTROL_CODE_F4_YELLOW:
-		key = KEY_YELLOW;
-		break;
-	case CEC_USER_CONTROL_CODE_F1_BLUE:
-		key = KEY_BLUE;
-		break;
-	default:
-		key = KEY_MENU;
-		break;
+		case CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL:
+			key = KEY_MENU;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER0:
+			key = KEY_0;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER1:
+			key = KEY_1;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER2:
+			key = KEY_2;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER3:
+			key = KEY_3;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER4:
+			key = KEY_4;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER5:
+			key = KEY_5;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER6:
+			key = KEY_6;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER7:
+			key = KEY_7;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER8:
+			key = KEY_8;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER9:
+			key = KEY_9;
+			break;
+		case CEC_USER_CONTROL_CODE_CHANNEL_UP:
+			key = KEY_CHANNELUP;
+			break;
+		case CEC_USER_CONTROL_CODE_CHANNEL_DOWN:
+			key = KEY_CHANNELDOWN;
+			break;
+		case CEC_USER_CONTROL_CODE_PLAY:
+			key = KEY_PLAY;
+			break;
+		case CEC_USER_CONTROL_CODE_STOP:
+			key = KEY_STOP;
+			break;
+		case CEC_USER_CONTROL_CODE_PAUSE:
+			key = KEY_PAUSE;
+			break;
+		case CEC_USER_CONTROL_CODE_RECORD:
+			key = KEY_RECORD;
+			break;
+		case CEC_USER_CONTROL_CODE_REWIND:
+			key = KEY_REWIND;
+			break;
+		case CEC_USER_CONTROL_CODE_FAST_FORWARD:
+			key = KEY_FASTFORWARD;
+			break;
+		case CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE:
+			key = KEY_INFO;
+			break;
+		case CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING:
+			key = KEY_PROGRAM;
+			break;
+		case CEC_USER_CONTROL_CODE_PLAY_FUNCTION:
+			key = KEY_PLAY;
+			break;
+		case CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION:
+			key = KEY_PLAYPAUSE;
+			break;
+		case CEC_USER_CONTROL_CODE_RECORD_FUNCTION:
+			key = KEY_RECORD;
+			break;
+		case CEC_USER_CONTROL_CODE_STOP_FUNCTION:
+			key = KEY_STOP;
+			break;
+		case CEC_USER_CONTROL_CODE_SELECT:
+			key = KEY_OK;
+			break;
+		case CEC_USER_CONTROL_CODE_LEFT:
+			key = KEY_LEFT;
+			break;
+		case CEC_USER_CONTROL_CODE_RIGHT:
+			key = KEY_RIGHT;
+			break;
+		case CEC_USER_CONTROL_CODE_UP:
+			key = KEY_UP;
+			break;
+		case CEC_USER_CONTROL_CODE_DOWN:
+			key = KEY_DOWN;
+			break;
+		case CEC_USER_CONTROL_CODE_EXIT:
+			key = KEY_EXIT;
+			break;
+		case CEC_USER_CONTROL_CODE_F2_RED:
+			key = KEY_RED;
+			break;
+		case CEC_USER_CONTROL_CODE_F3_GREEN:
+			key = KEY_GREEN;
+			break;
+		case CEC_USER_CONTROL_CODE_F4_YELLOW:
+			key = KEY_YELLOW;
+			break;
+		case CEC_USER_CONTROL_CODE_F1_BLUE:
+			key = KEY_BLUE;
+			break;
+		default:
+			key = KEY_MENU;
+			break;
 	}
 	return key;
 }
@@ -458,6 +564,7 @@
 		return false;
 
 	running = true;
+	OpenThreads::Thread::setSchedulePriority(THREAD_PRIORITY_MIN);
 	return (OpenThreads::Thread::start() == 0);
 }
 
@@ -467,7 +574,7 @@
 		return false;
 
 	running = false;
-	
+
 	OpenThreads::Thread::cancel();
 
 	if (hdmiFd >= 0)
@@ -482,90 +589,157 @@
 void hdmi_cec::run()
 {
 	OpenThreads::Thread::setCancelModeAsynchronous();
-	struct pollfd pfd;
+	int n;
+	int epollfd = epoll_create1(0);
+	struct epoll_event event;
+	event.data.fd = hdmiFd;
+	event.events = EPOLLIN;
+
+	epoll_ctl(epollfd, EPOLL_CTL_ADD, hdmiFd, &event);
 
-	pfd.fd = hdmiFd;
-	pfd.events = (POLLIN | POLLPRI);
+	std::array<struct epoll_event, EPOLL_MAX_EVENTS> events;
 
 	while (running)
 	{
-		if (poll(&pfd, 1, 0) > 0)
-			Receive();
+		n = epoll_wait(epollfd, events.data(), EPOLL_MAX_EVENTS, EPOLL_WAIT_TIMEOUT);
+		for (int i = 0; i < n; ++i)
+		{
+			if (events[i].events & EPOLLIN)
+				Receive(events[i].events);
+		}
 	}
 }
 
-void hdmi_cec::Receive()
+void hdmi_cec::Receive(int what)
 {
-	bool hasdata = false;
-	struct cec_message rxmessage;
-	struct cec_message txmessage;
-
-	struct cec_msg msg;
-	if (::ioctl(hdmiFd, CEC_RECEIVE, &msg) >= 0)
-	{
-		rxmessage.length = msg.len - 1;
-		rxmessage.initiator = cec_msg_initiator(&msg);
-		rxmessage.destination = cec_msg_destination(&msg);
-		rxmessage.opcode = cec_msg_opcode(&msg);
-		memcpy(&rxmessage.data, &msg.msg[1], rxmessage.length);
-		hasdata = true;
-	}
-
-	if (hasdata)
+	if (what & EPOLLIN)
 	{
-		bool keypressed = false;
-		static unsigned char pressedkey = 0;
 
-		char str[rxmessage.length*6];
-		for (int i = 0; i < rxmessage.length; i++)
-		{
-			sprintf(str+(i*6),"[0x%02X]", rxmessage.data[i]);
-		}
-		hal_info("[CEC] received message %s to %s (0x%02X>>0x%02X) '%s' (%s)\n",ToString((cec_logical_address)rxmessage.initiator), rxmessage.destination == 0xf ? "all" : ToString((cec_logical_address)rxmessage.destination), rxmessage.initiator, rxmessage.destination, ToString((cec_opcode)rxmessage.opcode), str);
+		bool hasdata = false;
+		struct cec_message rxmessage;
+		struct cec_message txmessage;
 
-		switch (rxmessage.opcode)
+		if (fallback)
 		{
-		case CEC_OPCODE_REPORT_AUDIO_STATUS:
-		{
-			muted = ((rxmessage.data[1] & 0x80) == 0x80);
-			volume = ((rxmessage.data[1] & 0x7F) / 127.0) * 100.0;
-			if (muted)
-				hal_debug("[CEC] %s volume muted\n", ToString((cec_logical_address)rxmessage.initiator));
-			else
-				hal_debug("[CEC] %s volume %d \n", ToString((cec_logical_address)rxmessage.initiator), volume);
-			break;
-		}
-		case CEC_OPCODE_DEVICE_VENDOR_ID:
-		case CEC_OPCODE_VENDOR_COMMAND_WITH_ID:
-		{
-			uint64_t iVendorId =	((uint64_t)rxmessage.data[1] << 16) +
-			                        ((uint64_t)rxmessage.data[2] << 8) +
-			                        (uint64_t)rxmessage.data[3];
-			hal_debug("[CEC] decoded message '%s' (%s)\n", ToString((cec_opcode)rxmessage.opcode), ToString((cec_vendor_id)iVendorId));
-			break;
+			struct cec_msg msg;
+			if (::ioctl(hdmiFd, CEC_RECEIVE, &msg) >= 0)
+			{
+				rxmessage.length = msg.len - 1;
+				rxmessage.initiator = cec_msg_initiator(&msg);
+				rxmessage.destination = cec_msg_destination(&msg);
+				rxmessage.opcode = cec_msg_opcode(&msg);
+				memcpy(&rxmessage.data, &msg.msg[1], rxmessage.length);
+				hasdata = true;
+			}
 		}
-		case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
+		else
 		{
-			txmessage.destination = rxmessage.initiator;
-			txmessage.initiator = rxmessage.destination;
-			txmessage.data[0] = GetResponseOpcode((cec_opcode)rxmessage.opcode);
-			txmessage.data[1] = standby ? CEC_POWER_STATUS_STANDBY : CEC_POWER_STATUS_ON;
-			txmessage.length = 2;
-			SendCECMessage(txmessage);
-			break;
+			struct cec_message_fb rx_message;
+			if (::read(hdmiFd, &rx_message, 2) == 2)
+			{
+				if (::read(hdmiFd, &rx_message.data, rx_message.length) == rx_message.length)
+				{
+					rxmessage.length = rx_message.length;
+					rxmessage.initiator = rx_message.address;
+					rxmessage.destination = logicalAddress;
+					rxmessage.opcode = rx_message.data[0];
+					memcpy(&rxmessage.data, rx_message.data, rx_message.length);
+					hasdata = true;
+				}
+			}
 		}
-		case CEC_OPCODE_USER_CONTROL_PRESSED: /* key pressed */
-		{
-			keypressed = true;
-			pressedkey = rxmessage.data[1];
-		} // fall through
-		case CEC_OPCODE_USER_CONTROL_RELEASE: /* key released */
+
+		if (hasdata)
 		{
-			long code = translateKey(pressedkey);
-			hal_debug("[CEC] decoded key %s (%ld)\n",ToString((cec_user_control_code)pressedkey), code);
-			handleCode(code,keypressed);
-			break;
-		}
+			bool keypressed = false;
+			static unsigned char pressedkey = 0;
+
+			char str[rxmessage.length * 6];
+			for (int i = 0; i < rxmessage.length; i++)
+			{
+				sprintf(str + (i * 6), "[0x%02X]", rxmessage.data[i]);
+			}
+			hal_info(GREEN "[CEC] received message %s to %s (0x%02X>>0x%02X) '%s' (%s)\n" NORMAL, ToString((cec_logical_address)rxmessage.initiator), rxmessage.destination == 0xf ? "all" : ToString((cec_logical_address)rxmessage.destination), rxmessage.initiator, rxmessage.destination, ToString((cec_opcode)rxmessage.opcode), str);
+
+			switch (rxmessage.opcode)
+			{
+				//case CEC_OPCODE_ACTIVE_SOURCE:
+				case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
+				{
+					txmessage.destination = CEC_LOG_ADDR_BROADCAST; //rxmessage.initiator;
+					txmessage.initiator = logicalAddress; //rxmessage.destination;
+					txmessage.data[0] = CEC_MSG_ACTIVE_SOURCE;
+					txmessage.data[1] = physicalAddress[0];
+					txmessage.data[2] = physicalAddress[1];
+					txmessage.length = 3;
+					if (!standby)
+						SendCECMessage(txmessage);
+					break;
+				}
+				case CEC_OPCODE_REPORT_AUDIO_STATUS:
+				{
+					muted = ((rxmessage.data[1] & 0x80) == 0x80);
+					volume = ((rxmessage.data[1] & 0x7F) / 127.0) * 100.0;
+					if (muted)
+						hal_info(GREEN "[CEC] %s volume muted\n" NORMAL, ToString((cec_logical_address)rxmessage.initiator));
+					else
+						hal_info(GREEN "[CEC] %s volume %d \n" NORMAL, ToString((cec_logical_address)rxmessage.initiator), volume);
+					break;
+				}
+				case CEC_OPCODE_DEVICE_VENDOR_ID:
+				case CEC_OPCODE_VENDOR_COMMAND_WITH_ID:
+				{
+					uint64_t iVendorId = ((uint64_t)rxmessage.data[1] << 16) +
+					    ((uint64_t)rxmessage.data[2] << 8) +
+					    (uint64_t)rxmessage.data[3];
+					hal_info(GREEN "[CEC] decoded message '%s' (%s)\n" NORMAL, ToString((cec_opcode)rxmessage.opcode), ToString((cec_vendor_id)iVendorId));
+					break;
+				}
+				case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
+				{
+					txmessage.destination = rxmessage.initiator;
+					txmessage.initiator = rxmessage.destination;
+					txmessage.data[0] = GetResponseOpcode((cec_opcode)rxmessage.opcode);
+					txmessage.data[1] = standby ? CEC_POWER_STATUS_STANDBY : CEC_POWER_STATUS_ON;
+					txmessage.length = 2;
+					SendCECMessage(txmessage);
+					break;
+				}
+				case CEC_OPCODE_REPORT_POWER_STATUS:
+				{
+					if ((rxmessage.data[1] == CEC_POWER_STATUS_ON) || (rxmessage.data[1] == CEC_POWER_STATUS_IN_TRANSITION_STANDBY_TO_ON))
+					{
+						hal_info(GREEN "[CEC] %s reporting state on (%d)\n" NORMAL, ToString((cec_logical_address)rxmessage.initiator), rxmessage.data[1]);
+						if (rxmessage.initiator == CEC_OP_PRIM_DEVTYPE_TV)
+							tv_off = false;
+					}
+					else
+					{
+						hal_info(GREEN "[CEC] %s reporting state off (%d)\n" NORMAL, ToString((cec_logical_address)rxmessage.initiator), rxmessage.data[1]);
+						if (rxmessage.initiator == CEC_OP_PRIM_DEVTYPE_TV)
+							tv_off = true;
+					}
+					break;
+				}
+				case CEC_OPCODE_STANDBY:
+				{
+					if (rxmessage.initiator == CEC_OP_PRIM_DEVTYPE_TV)
+						tv_off = true;
+					break;
+				}
+				case CEC_OPCODE_USER_CONTROL_PRESSED: /* key pressed */
+				{
+					keypressed = true;
+					pressedkey = rxmessage.data[1];
+				} // fall through
+				case CEC_OPCODE_USER_CONTROL_RELEASE: /* key released */
+				{
+					long code = translateKey(pressedkey);
+					hal_info(GREEN "[CEC] decoded key %s (%ld)\n" NORMAL, ToString((cec_user_control_code)pressedkey), code);
+					handleCode(code, keypressed);
+					break;
+				}
+			}
 		}
 	}
 }
@@ -575,14 +749,14 @@
 	int evd = open(RC_DEVICE, O_RDWR);
 	if (evd < 0)
 	{
-		hal_debug("[CEC] opening " RC_DEVICE " failed");
+		hal_info(RED "[CEC] opening " RC_DEVICE " failed" NORMAL);
 		return;
 	}
 	if (keypressed)
 	{
 		if (rc_send(evd, code, CEC_KEY_PRESSED) < 0)
 		{
-			hal_debug("[CEC] writing 'KEY_PRESSED' event failed");
+			hal_info(RED "[CEC] writing 'KEY_PRESSED' event failed" NORMAL);
 			close(evd);
 			return;
 		}
@@ -592,7 +766,7 @@
 	{
 		if (rc_send(evd, code, CEC_KEY_RELEASED) < 0)
 		{
-			hal_debug("[CEC] writing 'KEY_RELEASED' event failed");
+			hal_info(RED "[CEC] writing 'KEY_RELEASED' event failed" NORMAL);
 			close(evd);
 			return;
 		}
@@ -630,41 +804,52 @@
 	txmessage.data[0] = CEC_OPCODE_USER_CONTROL_PRESSED;
 	txmessage.data[1] = key;
 	txmessage.length = 2;
-	SendCECMessage(txmessage);
-	usleep(10000);
+	SendCECMessage(txmessage, 1);
 
 	txmessage.destination = destination;
 	txmessage.initiator = logicalAddress;
 	txmessage.data[0] = CEC_OPCODE_USER_CONTROL_RELEASE;
 	txmessage.length = 1;
-	SendCECMessage(txmessage);
+	SendCECMessage(txmessage, 0);
 }
 
 void hdmi_cec::request_audio_status()
 {
 	struct cec_message txmessage;
-	txmessage.destination = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
+	txmessage.destination = audio_destination;
 	txmessage.initiator = logicalAddress;
 	txmessage.data[0] = CEC_OPCODE_GIVE_AUDIO_STATUS;
 	txmessage.length = 1;
-	SendCECMessage(txmessage);
+	SendCECMessage(txmessage, 0);
 }
 
 void hdmi_cec::vol_up()
 {
-	send_key(CEC_USER_CONTROL_CODE_VOLUME_UP, CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM);
-	usleep(50000);
+	send_key(CEC_USER_CONTROL_CODE_VOLUME_UP, audio_destination);
 	request_audio_status();
 }
 void hdmi_cec::vol_down()
 {
-	send_key(CEC_USER_CONTROL_CODE_VOLUME_DOWN, CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM);
-	usleep(50000);
+	send_key(CEC_USER_CONTROL_CODE_VOLUME_DOWN, audio_destination);
 	request_audio_status();
 }
 void hdmi_cec::toggle_mute()
 {
-	send_key(CEC_USER_CONTROL_CODE_MUTE, CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM);
-	usleep(50000);
+	send_key(CEC_USER_CONTROL_CODE_MUTE, audio_destination);
 	request_audio_status();
 }
+
+void hdmi_cec::SetAudioDestination(int audio_dest)
+{
+	switch (audio_dest)
+	{
+		case 2:
+			audio_destination = CEC_OP_PRIM_DEVTYPE_TV;
+			break;
+		case 1:
+		default:
+			audio_destination = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
+			break;
+	}
+}
+
diff -Nur libstb-hal-ddt.git.orig/libarmbox/hdmi_cec.h libstb-hal-ddt.git/libarmbox/hdmi_cec.h
--- libstb-hal-ddt.git.orig/libarmbox/hdmi_cec.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libarmbox/hdmi_cec.h	2022-07-23 18:18:31.499773109 +0200
@@ -2,22 +2,22 @@
 #define __HDMI_CEC_H__
 
 /*
-	Copyright (C) 2018 TangoCash
+    Copyright (C) 2018-2021 TangoCash
 
-	License: GPLv2
+    License: GPLv2
 
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation;
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation;
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include <OpenThreads/Thread>
@@ -34,6 +34,13 @@
 	unsigned char length;
 } __attribute__((packed));
 
+struct cec_message_fb
+{
+	unsigned char address;
+	unsigned char length;
+	unsigned char data[256];
+} __attribute__((packed));
+
 struct addressinfo
 {
 	unsigned char logical;
@@ -50,50 +57,58 @@
 
 class hdmi_cec : public OpenThreads::Thread
 {
-private:
-	hdmi_cec();
-	static hdmi_cec *hdmi_cec_instance;
-	void run();
-	bool Start();
-	bool Stop();
-	void Receive();
-	unsigned char physicalAddress[2];
-	bool autoview_cec_activ;
-	unsigned char deviceType, logicalAddress;
-	int hdmiFd;
-	long translateKey(unsigned char code);
-	void handleCode(long code, bool keypressed);
-	int rc_send(int fd, unsigned int code, unsigned int value);
-	void rc_sync(int fd);
-	bool standby;
-	void send_key(unsigned char key, unsigned char destination);
-	void request_audio_status();
-	bool muted;
-	int volume;
-protected:
-	bool running;
-public:
-	~hdmi_cec();
-	static hdmi_cec* getInstance();
-	bool SetCECMode(VIDEO_HDMI_CEC_MODE);
-	void SetCECAutoView(bool);
-	void SetCECAutoStandby(bool);
-	void GetCECAddressInfo();
-	void SendCECMessage(struct cec_message &message);
-	void SetCECState(bool state);
-	void ReportPhysicalAddress();
-	bool standby_cec_activ;
-	void vol_up();
-	void vol_down();
-	void toggle_mute();
-	int GetVolume()
-	{
-		return volume;
-	};
-	bool isMuted()
-	{
-		return muted;
-	};
+	private:
+		hdmi_cec();
+		static hdmi_cec *hdmi_cec_instance;
+		void run();
+		bool Start();
+		bool Stop();
+		void Receive(int what);
+		unsigned char physicalAddress[2];
+		bool autoview_cec_activ;
+		unsigned char deviceType, logicalAddress;
+		int hdmiFd;
+		long translateKey(unsigned char code);
+		void handleCode(long code, bool keypressed);
+		int rc_send(int fd, unsigned int code, unsigned int value);
+		void rc_sync(int fd);
+		bool standby;
+		void send_key(unsigned char key, unsigned char destination);
+		void request_audio_status();
+		bool muted;
+		int volume;
+		bool fallback;
+		bool tv_off;
+		unsigned char audio_destination;
+	protected:
+		bool running;
+	public:
+		~hdmi_cec();
+		static hdmi_cec *getInstance();
+		bool SetCECMode(VIDEO_HDMI_CEC_MODE);
+		void SetCECAutoView(bool);
+		void SetCECAutoStandby(bool);
+		void GetCECAddressInfo();
+		void SendCECMessage(struct cec_message &message, int sleeptime = 250);
+		void SetCECState(bool state);
+		void ReportPhysicalAddress();
+		bool standby_cec_activ;
+		void vol_up();
+		void vol_down();
+		void toggle_mute();
+		int GetVolume()
+		{
+			return volume;
+		};
+		bool isMuted()
+		{
+			return muted;
+		};
+		int GetAudioDestination()
+		{
+			return (int)audio_destination;
+		}
+		void SetAudioDestination(int audio_dest);
 };
 
 #endif // __HDMI_CEC_H__
diff -Nur libstb-hal-ddt.git.orig/libarmbox/hdmi_cec_types.h libstb-hal-ddt.git/libarmbox/hdmi_cec_types.h
--- libstb-hal-ddt.git.orig/libarmbox/hdmi_cec_types.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libarmbox/hdmi_cec_types.h	2022-07-23 18:18:31.499773109 +0200
@@ -245,148 +245,148 @@
 {
 	switch (opcode)
 	{
-	case CEC_OPCODE_ACTIVE_SOURCE:
-		return "active source";
-	case CEC_OPCODE_IMAGE_VIEW_ON:
-		return "image view on";
-	case CEC_OPCODE_TEXT_VIEW_ON:
-		return "text view on";
-	case CEC_OPCODE_INACTIVE_SOURCE:
-		return "inactive source";
-	case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
-		return "request active source";
-	case CEC_OPCODE_ROUTING_CHANGE:
-		return "routing change";
-	case CEC_OPCODE_ROUTING_INFORMATION:
-		return "routing information";
-	case CEC_OPCODE_SET_STREAM_PATH:
-		return "set stream path";
-	case CEC_OPCODE_STANDBY:
-		return "standby";
-	case CEC_OPCODE_RECORD_OFF:
-		return "record off";
-	case CEC_OPCODE_RECORD_ON:
-		return "record on";
-	case CEC_OPCODE_RECORD_STATUS:
-		return "record status";
-	case CEC_OPCODE_RECORD_TV_SCREEN:
-		return "record tv screen";
-	case CEC_OPCODE_CLEAR_ANALOGUE_TIMER:
-		return "clear analogue timer";
-	case CEC_OPCODE_CLEAR_DIGITAL_TIMER:
-		return "clear digital timer";
-	case CEC_OPCODE_CLEAR_EXTERNAL_TIMER:
-		return "clear external timer";
-	case CEC_OPCODE_SET_ANALOGUE_TIMER:
-		return "set analogue timer";
-	case CEC_OPCODE_SET_DIGITAL_TIMER:
-		return "set digital timer";
-	case CEC_OPCODE_SET_EXTERNAL_TIMER:
-		return "set external timer";
-	case CEC_OPCODE_SET_TIMER_PROGRAM_TITLE:
-		return "set timer program title";
-	case CEC_OPCODE_TIMER_CLEARED_STATUS:
-		return "timer cleared status";
-	case CEC_OPCODE_TIMER_STATUS:
-		return "timer status";
-	case CEC_OPCODE_CEC_VERSION:
-		return "cec version";
-	case CEC_OPCODE_GET_CEC_VERSION:
-		return "get cec version";
-	case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
-		return "give physical address";
-	case CEC_OPCODE_GET_MENU_LANGUAGE:
-		return "get menu language";
-	case CEC_OPCODE_REPORT_PHYSICAL_ADDRESS:
-		return "report physical address";
-	case CEC_OPCODE_SET_MENU_LANGUAGE:
-		return "set menu language";
-	case CEC_OPCODE_DECK_CONTROL:
-		return "deck control";
-	case CEC_OPCODE_DECK_STATUS:
-		return "deck status";
-	case CEC_OPCODE_GIVE_DECK_STATUS:
-		return "give deck status";
-	case CEC_OPCODE_PLAY:
-		return "play";
-	case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS:
-		return "give tuner status";
-	case CEC_OPCODE_SELECT_ANALOGUE_SERVICE:
-		return "select analogue service";
-	case CEC_OPCODE_SELECT_DIGITAL_SERVICE:
-		return "set digital service";
-	case CEC_OPCODE_TUNER_DEVICE_STATUS:
-		return "tuner device status";
-	case CEC_OPCODE_TUNER_STEP_DECREMENT:
-		return "tuner step decrement";
-	case CEC_OPCODE_TUNER_STEP_INCREMENT:
-		return "tuner step increment";
-	case CEC_OPCODE_DEVICE_VENDOR_ID:
-		return "device vendor id";
-	case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
-		return "give device vendor id";
-	case CEC_OPCODE_VENDOR_COMMAND:
-		return "vendor command";
-	case CEC_OPCODE_VENDOR_COMMAND_WITH_ID:
-		return "vendor command with id";
-	case CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN:
-		return "vendor remote button down";
-	case CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP:
-		return "vendor remote button up";
-	case CEC_OPCODE_SET_OSD_STRING:
-		return "set osd string";
-	case CEC_OPCODE_GIVE_OSD_NAME:
-		return "give osd name";
-	case CEC_OPCODE_SET_OSD_NAME:
-		return "set osd name";
-	case CEC_OPCODE_MENU_REQUEST:
-		return "menu request";
-	case CEC_OPCODE_MENU_STATUS:
-		return "menu status";
-	case CEC_OPCODE_USER_CONTROL_PRESSED:
-		return "user control pressed";
-	case CEC_OPCODE_USER_CONTROL_RELEASE:
-		return "user control release";
-	case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
-		return "give device power status";
-	case CEC_OPCODE_REPORT_POWER_STATUS:
-		return "report power status";
-	case CEC_OPCODE_FEATURE_ABORT:
-		return "feature abort";
-	case CEC_OPCODE_ABORT:
-		return "abort";
-	case CEC_OPCODE_GIVE_AUDIO_STATUS:
-		return "give audio status";
-	case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS:
-		return "give audio mode status";
-	case CEC_OPCODE_REPORT_AUDIO_STATUS:
-		return "report audio status";
-	case CEC_OPCODE_SET_SYSTEM_AUDIO_MODE:
-		return "set system audio mode";
-	case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST:
-		return "system audio mode request";
-	case CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS:
-		return "system audio mode status";
-	case CEC_OPCODE_SET_AUDIO_RATE:
-		return "set audio rate";
-	case CEC_OPCODE_START_ARC:
-		return "start ARC";
-	case CEC_OPCODE_REPORT_ARC_STARTED:
-		return "report ARC started";
-	case CEC_OPCODE_REPORT_ARC_ENDED:
-		return "report ARC ended";
-	case CEC_OPCODE_REQUEST_ARC_START:
-		return "request ARC start";
-	case CEC_OPCODE_REQUEST_ARC_END:
-		return "request ARC end";
-	case CEC_OPCODE_END_ARC:
-		return "end ARC";
-	case CEC_OPCODE_CDC:
-		return "CDC";
-	case CEC_OPCODE_NONE:
-		return "poll";
-	default:
-		return "UNKNOWN";
+		case CEC_OPCODE_ACTIVE_SOURCE:
+			return "active source";
+		case CEC_OPCODE_IMAGE_VIEW_ON:
+			return "image view on";
+		case CEC_OPCODE_TEXT_VIEW_ON:
+			return "text view on";
+		case CEC_OPCODE_INACTIVE_SOURCE:
+			return "inactive source";
+		case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
+			return "request active source";
+		case CEC_OPCODE_ROUTING_CHANGE:
+			return "routing change";
+		case CEC_OPCODE_ROUTING_INFORMATION:
+			return "routing information";
+		case CEC_OPCODE_SET_STREAM_PATH:
+			return "set stream path";
+		case CEC_OPCODE_STANDBY:
+			return "standby";
+		case CEC_OPCODE_RECORD_OFF:
+			return "record off";
+		case CEC_OPCODE_RECORD_ON:
+			return "record on";
+		case CEC_OPCODE_RECORD_STATUS:
+			return "record status";
+		case CEC_OPCODE_RECORD_TV_SCREEN:
+			return "record tv screen";
+		case CEC_OPCODE_CLEAR_ANALOGUE_TIMER:
+			return "clear analogue timer";
+		case CEC_OPCODE_CLEAR_DIGITAL_TIMER:
+			return "clear digital timer";
+		case CEC_OPCODE_CLEAR_EXTERNAL_TIMER:
+			return "clear external timer";
+		case CEC_OPCODE_SET_ANALOGUE_TIMER:
+			return "set analogue timer";
+		case CEC_OPCODE_SET_DIGITAL_TIMER:
+			return "set digital timer";
+		case CEC_OPCODE_SET_EXTERNAL_TIMER:
+			return "set external timer";
+		case CEC_OPCODE_SET_TIMER_PROGRAM_TITLE:
+			return "set timer program title";
+		case CEC_OPCODE_TIMER_CLEARED_STATUS:
+			return "timer cleared status";
+		case CEC_OPCODE_TIMER_STATUS:
+			return "timer status";
+		case CEC_OPCODE_CEC_VERSION:
+			return "cec version";
+		case CEC_OPCODE_GET_CEC_VERSION:
+			return "get cec version";
+		case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
+			return "give physical address";
+		case CEC_OPCODE_GET_MENU_LANGUAGE:
+			return "get menu language";
+		case CEC_OPCODE_REPORT_PHYSICAL_ADDRESS:
+			return "report physical address";
+		case CEC_OPCODE_SET_MENU_LANGUAGE:
+			return "set menu language";
+		case CEC_OPCODE_DECK_CONTROL:
+			return "deck control";
+		case CEC_OPCODE_DECK_STATUS:
+			return "deck status";
+		case CEC_OPCODE_GIVE_DECK_STATUS:
+			return "give deck status";
+		case CEC_OPCODE_PLAY:
+			return "play";
+		case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS:
+			return "give tuner status";
+		case CEC_OPCODE_SELECT_ANALOGUE_SERVICE:
+			return "select analogue service";
+		case CEC_OPCODE_SELECT_DIGITAL_SERVICE:
+			return "set digital service";
+		case CEC_OPCODE_TUNER_DEVICE_STATUS:
+			return "tuner device status";
+		case CEC_OPCODE_TUNER_STEP_DECREMENT:
+			return "tuner step decrement";
+		case CEC_OPCODE_TUNER_STEP_INCREMENT:
+			return "tuner step increment";
+		case CEC_OPCODE_DEVICE_VENDOR_ID:
+			return "device vendor id";
+		case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
+			return "give device vendor id";
+		case CEC_OPCODE_VENDOR_COMMAND:
+			return "vendor command";
+		case CEC_OPCODE_VENDOR_COMMAND_WITH_ID:
+			return "vendor command with id";
+		case CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN:
+			return "vendor remote button down";
+		case CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP:
+			return "vendor remote button up";
+		case CEC_OPCODE_SET_OSD_STRING:
+			return "set osd string";
+		case CEC_OPCODE_GIVE_OSD_NAME:
+			return "give osd name";
+		case CEC_OPCODE_SET_OSD_NAME:
+			return "set osd name";
+		case CEC_OPCODE_MENU_REQUEST:
+			return "menu request";
+		case CEC_OPCODE_MENU_STATUS:
+			return "menu status";
+		case CEC_OPCODE_USER_CONTROL_PRESSED:
+			return "user control pressed";
+		case CEC_OPCODE_USER_CONTROL_RELEASE:
+			return "user control release";
+		case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
+			return "give device power status";
+		case CEC_OPCODE_REPORT_POWER_STATUS:
+			return "report power status";
+		case CEC_OPCODE_FEATURE_ABORT:
+			return "feature abort";
+		case CEC_OPCODE_ABORT:
+			return "abort";
+		case CEC_OPCODE_GIVE_AUDIO_STATUS:
+			return "give audio status";
+		case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+			return "give audio mode status";
+		case CEC_OPCODE_REPORT_AUDIO_STATUS:
+			return "report audio status";
+		case CEC_OPCODE_SET_SYSTEM_AUDIO_MODE:
+			return "set system audio mode";
+		case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST:
+			return "system audio mode request";
+		case CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS:
+			return "system audio mode status";
+		case CEC_OPCODE_SET_AUDIO_RATE:
+			return "set audio rate";
+		case CEC_OPCODE_START_ARC:
+			return "start ARC";
+		case CEC_OPCODE_REPORT_ARC_STARTED:
+			return "report ARC started";
+		case CEC_OPCODE_REPORT_ARC_ENDED:
+			return "report ARC ended";
+		case CEC_OPCODE_REQUEST_ARC_START:
+			return "request ARC start";
+		case CEC_OPCODE_REQUEST_ARC_END:
+			return "request ARC end";
+		case CEC_OPCODE_END_ARC:
+			return "end ARC";
+		case CEC_OPCODE_CDC:
+			return "CDC";
+		case CEC_OPCODE_NONE:
+			return "poll";
+		default:
+			return "UNKNOWN";
 	}
 }
 
@@ -394,59 +394,59 @@
 {
 	switch (vendor)
 	{
-	case CEC_VENDOR_SAMSUNG:
-		return "Samsung";
-	case CEC_VENDOR_LG:
-		return "LG";
-	case CEC_VENDOR_PANASONIC:
-		return "Panasonic";
-	case CEC_VENDOR_PIONEER:
-		return "Pioneer";
-	case CEC_VENDOR_ONKYO:
-		return "Onkyo";
-	case CEC_VENDOR_YAMAHA:
-		return "Yamaha";
-	case CEC_VENDOR_PHILIPS:
-		return "Philips";
-	case CEC_VENDOR_SONY:
-		return "Sony";
-	case CEC_VENDOR_TOSHIBA:
-	case CEC_VENDOR_TOSHIBA2:
-		return "Toshiba";
-	case CEC_VENDOR_AKAI:
-		return "Akai";
-	case CEC_VENDOR_AOC:
-		return "AOC";
-	case CEC_VENDOR_BENQ:
-		return "Benq";
-	case CEC_VENDOR_DAEWOO:
-		return "Daewoo";
-	case CEC_VENDOR_GRUNDIG:
-		return "Grundig";
-	case CEC_VENDOR_MEDION:
-		return "Medion";
-	case CEC_VENDOR_SHARP:
-	case CEC_VENDOR_SHARP2:
-		return "Sharp";
-	case CEC_VENDOR_VIZIO:
-		return "Vizio";
-	case CEC_VENDOR_BROADCOM:
-		return "Broadcom";
-	case CEC_VENDOR_LOEWE:
-		return "Loewe";
-	case CEC_VENDOR_DENON:
-		return "Denon";
-	case CEC_VENDOR_MARANTZ:
-		return "Marantz";
-	case CEC_VENDOR_HARMAN_KARDON:
-	case CEC_VENDOR_HARMAN_KARDON2:
-		return "Harman/Kardon";
-	case CEC_VENDOR_PULSE_EIGHT:
-		return "Pulse Eight";
-	case CEC_VENDOR_GOOGLE:
-		return "Google";
-	default:
-		return "Unknown";
+		case CEC_VENDOR_SAMSUNG:
+			return "Samsung";
+		case CEC_VENDOR_LG:
+			return "LG";
+		case CEC_VENDOR_PANASONIC:
+			return "Panasonic";
+		case CEC_VENDOR_PIONEER:
+			return "Pioneer";
+		case CEC_VENDOR_ONKYO:
+			return "Onkyo";
+		case CEC_VENDOR_YAMAHA:
+			return "Yamaha";
+		case CEC_VENDOR_PHILIPS:
+			return "Philips";
+		case CEC_VENDOR_SONY:
+			return "Sony";
+		case CEC_VENDOR_TOSHIBA:
+		case CEC_VENDOR_TOSHIBA2:
+			return "Toshiba";
+		case CEC_VENDOR_AKAI:
+			return "Akai";
+		case CEC_VENDOR_AOC:
+			return "AOC";
+		case CEC_VENDOR_BENQ:
+			return "Benq";
+		case CEC_VENDOR_DAEWOO:
+			return "Daewoo";
+		case CEC_VENDOR_GRUNDIG:
+			return "Grundig";
+		case CEC_VENDOR_MEDION:
+			return "Medion";
+		case CEC_VENDOR_SHARP:
+		case CEC_VENDOR_SHARP2:
+			return "Sharp";
+		case CEC_VENDOR_VIZIO:
+			return "Vizio";
+		case CEC_VENDOR_BROADCOM:
+			return "Broadcom";
+		case CEC_VENDOR_LOEWE:
+			return "Loewe";
+		case CEC_VENDOR_DENON:
+			return "Denon";
+		case CEC_VENDOR_MARANTZ:
+			return "Marantz";
+		case CEC_VENDOR_HARMAN_KARDON:
+		case CEC_VENDOR_HARMAN_KARDON2:
+			return "Harman/Kardon";
+		case CEC_VENDOR_PULSE_EIGHT:
+			return "Pulse Eight";
+		case CEC_VENDOR_GOOGLE:
+			return "Google";
+		default:
+			return "Unknown";
 	}
 }
 
@@ -454,182 +454,182 @@
 {
 	switch (key)
 	{
-	case CEC_USER_CONTROL_CODE_SELECT:
-		return "select";
-	case CEC_USER_CONTROL_CODE_UP:
-		return "up";
-	case CEC_USER_CONTROL_CODE_DOWN:
-		return "down";
-	case CEC_USER_CONTROL_CODE_LEFT:
-		return "left";
-	case CEC_USER_CONTROL_CODE_RIGHT:
-		return "right";
-	case CEC_USER_CONTROL_CODE_RIGHT_UP:
-		return "right+up";
-	case CEC_USER_CONTROL_CODE_RIGHT_DOWN:
-		return "right+down";
-	case CEC_USER_CONTROL_CODE_LEFT_UP:
-		return "left+up";
-	case CEC_USER_CONTROL_CODE_LEFT_DOWN:
-		return "left+down";
-	case CEC_USER_CONTROL_CODE_ROOT_MENU:
-		return "root menu";
-	case CEC_USER_CONTROL_CODE_SETUP_MENU:
-		return "setup menu";
-	case CEC_USER_CONTROL_CODE_CONTENTS_MENU:
-		return "contents menu";
-	case CEC_USER_CONTROL_CODE_FAVORITE_MENU:
-		return "favourite menu";
-	case CEC_USER_CONTROL_CODE_EXIT:
-		return "exit";
-	case CEC_USER_CONTROL_CODE_TOP_MENU:
-		return "top menu";
-	case CEC_USER_CONTROL_CODE_DVD_MENU:
-		return "dvd menu";
-	case CEC_USER_CONTROL_CODE_NUMBER_ENTRY_MODE:
-		return "number entry mode";
-	case CEC_USER_CONTROL_CODE_NUMBER11:
-		return "11";
-	case CEC_USER_CONTROL_CODE_NUMBER12:
-		return "12";
-	case CEC_USER_CONTROL_CODE_NUMBER0:
-		return "0";
-	case CEC_USER_CONTROL_CODE_NUMBER1:
-		return "1";
-	case CEC_USER_CONTROL_CODE_NUMBER2:
-		return "2";
-	case CEC_USER_CONTROL_CODE_NUMBER3:
-		return "3";
-	case CEC_USER_CONTROL_CODE_NUMBER4:
-		return "4";
-	case CEC_USER_CONTROL_CODE_NUMBER5:
-		return "5";
-	case CEC_USER_CONTROL_CODE_NUMBER6:
-		return "6";
-	case CEC_USER_CONTROL_CODE_NUMBER7:
-		return "7";
-	case CEC_USER_CONTROL_CODE_NUMBER8:
-		return "8";
-	case CEC_USER_CONTROL_CODE_NUMBER9:
-		return "9";
-	case CEC_USER_CONTROL_CODE_DOT:
-		return ".";
-	case CEC_USER_CONTROL_CODE_ENTER:
-		return "enter";
-	case CEC_USER_CONTROL_CODE_CLEAR:
-		return "clear";
-	case CEC_USER_CONTROL_CODE_NEXT_FAVORITE:
-		return "next favourite";
-	case CEC_USER_CONTROL_CODE_CHANNEL_UP:
-		return "channel up";
-	case CEC_USER_CONTROL_CODE_CHANNEL_DOWN:
-		return "channel down";
-	case CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL:
-		return "previous channel";
-	case CEC_USER_CONTROL_CODE_SOUND_SELECT:
-		return "sound select";
-	case CEC_USER_CONTROL_CODE_INPUT_SELECT:
-		return "input select";
-	case CEC_USER_CONTROL_CODE_DISPLAY_INFORMATION:
-		return "display information";
-	case CEC_USER_CONTROL_CODE_HELP:
-		return "help";
-	case CEC_USER_CONTROL_CODE_PAGE_UP:
-		return "page up";
-	case CEC_USER_CONTROL_CODE_PAGE_DOWN:
-		return "page down";
-	case CEC_USER_CONTROL_CODE_POWER:
-		return "power";
-	case CEC_USER_CONTROL_CODE_VOLUME_UP:
-		return "volume up";
-	case CEC_USER_CONTROL_CODE_VOLUME_DOWN:
-		return "volume down";
-	case CEC_USER_CONTROL_CODE_MUTE:
-		return "mute";
-	case CEC_USER_CONTROL_CODE_PLAY:
-		return "play";
-	case CEC_USER_CONTROL_CODE_STOP:
-		return "stop";
-	case CEC_USER_CONTROL_CODE_PAUSE:
-		return "pause";
-	case CEC_USER_CONTROL_CODE_RECORD:
-		return "record";
-	case CEC_USER_CONTROL_CODE_REWIND:
-		return "rewind";
-	case CEC_USER_CONTROL_CODE_FAST_FORWARD:
-		return "Fast forward";
-	case CEC_USER_CONTROL_CODE_EJECT:
-		return "eject";
-	case CEC_USER_CONTROL_CODE_FORWARD:
-		return "forward";
-	case CEC_USER_CONTROL_CODE_BACKWARD:
-		return "backward";
-	case CEC_USER_CONTROL_CODE_STOP_RECORD:
-		return "stop record";
-	case CEC_USER_CONTROL_CODE_PAUSE_RECORD:
-		return "pause record";
-	case CEC_USER_CONTROL_CODE_ANGLE:
-		return "angle";
-	case CEC_USER_CONTROL_CODE_SUB_PICTURE:
-		return "sub picture";
-	case CEC_USER_CONTROL_CODE_VIDEO_ON_DEMAND:
-		return "video on demand";
-	case CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE:
-		return "electronic program guide";
-	case CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING:
-		return "timer programming";
-	case CEC_USER_CONTROL_CODE_INITIAL_CONFIGURATION:
-		return "initial configuration";
-	case CEC_USER_CONTROL_CODE_SELECT_BROADCAST_TYPE:
-		return "select broadcast type";
-	case CEC_USER_CONTROL_CODE_SELECT_SOUND_PRESENTATION:
-		return "select sound presentation";
-	case CEC_USER_CONTROL_CODE_PLAY_FUNCTION:
-		return "play (function)";
-	case CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION:
-		return "pause play (function)";
-	case CEC_USER_CONTROL_CODE_RECORD_FUNCTION:
-		return "record (function)";
-	case CEC_USER_CONTROL_CODE_PAUSE_RECORD_FUNCTION:
-		return "pause record (function)";
-	case CEC_USER_CONTROL_CODE_STOP_FUNCTION:
-		return "stop (function)";
-	case CEC_USER_CONTROL_CODE_MUTE_FUNCTION:
-		return "mute (function)";
-	case CEC_USER_CONTROL_CODE_RESTORE_VOLUME_FUNCTION:
-		return "restore volume";
-	case CEC_USER_CONTROL_CODE_TUNE_FUNCTION:
-		return "tune";
-	case CEC_USER_CONTROL_CODE_SELECT_MEDIA_FUNCTION:
-		return "select media";
-	case CEC_USER_CONTROL_CODE_SELECT_AV_INPUT_FUNCTION:
-		return "select AV input";
-	case CEC_USER_CONTROL_CODE_SELECT_AUDIO_INPUT_FUNCTION:
-		return "select audio input";
-	case CEC_USER_CONTROL_CODE_POWER_TOGGLE_FUNCTION:
-		return "power toggle";
-	case CEC_USER_CONTROL_CODE_POWER_OFF_FUNCTION:
-		return "power off";
-	case CEC_USER_CONTROL_CODE_POWER_ON_FUNCTION:
-		return "power on";
-	case CEC_USER_CONTROL_CODE_F1_BLUE:
-		return "F1 (blue)";
-	case CEC_USER_CONTROL_CODE_F2_RED:
-		return "F2 (red)";
-	case CEC_USER_CONTROL_CODE_F3_GREEN:
-		return "F3 (green)";
-	case CEC_USER_CONTROL_CODE_F4_YELLOW:
-		return "F4 (yellow)";
-	case CEC_USER_CONTROL_CODE_F5:
-		return "F5";
-	case CEC_USER_CONTROL_CODE_DATA:
-		return "data";
-	case CEC_USER_CONTROL_CODE_AN_RETURN:
-		return "return (Samsung)";
-	case CEC_USER_CONTROL_CODE_AN_CHANNELS_LIST:
-		return "channels list (Samsung)";
-	default:
-		return "unknown";
+		case CEC_USER_CONTROL_CODE_SELECT:
+			return "select";
+		case CEC_USER_CONTROL_CODE_UP:
+			return "up";
+		case CEC_USER_CONTROL_CODE_DOWN:
+			return "down";
+		case CEC_USER_CONTROL_CODE_LEFT:
+			return "left";
+		case CEC_USER_CONTROL_CODE_RIGHT:
+			return "right";
+		case CEC_USER_CONTROL_CODE_RIGHT_UP:
+			return "right+up";
+		case CEC_USER_CONTROL_CODE_RIGHT_DOWN:
+			return "right+down";
+		case CEC_USER_CONTROL_CODE_LEFT_UP:
+			return "left+up";
+		case CEC_USER_CONTROL_CODE_LEFT_DOWN:
+			return "left+down";
+		case CEC_USER_CONTROL_CODE_ROOT_MENU:
+			return "root menu";
+		case CEC_USER_CONTROL_CODE_SETUP_MENU:
+			return "setup menu";
+		case CEC_USER_CONTROL_CODE_CONTENTS_MENU:
+			return "contents menu";
+		case CEC_USER_CONTROL_CODE_FAVORITE_MENU:
+			return "favourite menu";
+		case CEC_USER_CONTROL_CODE_EXIT:
+			return "exit";
+		case CEC_USER_CONTROL_CODE_TOP_MENU:
+			return "top menu";
+		case CEC_USER_CONTROL_CODE_DVD_MENU:
+			return "dvd menu";
+		case CEC_USER_CONTROL_CODE_NUMBER_ENTRY_MODE:
+			return "number entry mode";
+		case CEC_USER_CONTROL_CODE_NUMBER11:
+			return "11";
+		case CEC_USER_CONTROL_CODE_NUMBER12:
+			return "12";
+		case CEC_USER_CONTROL_CODE_NUMBER0:
+			return "0";
+		case CEC_USER_CONTROL_CODE_NUMBER1:
+			return "1";
+		case CEC_USER_CONTROL_CODE_NUMBER2:
+			return "2";
+		case CEC_USER_CONTROL_CODE_NUMBER3:
+			return "3";
+		case CEC_USER_CONTROL_CODE_NUMBER4:
+			return "4";
+		case CEC_USER_CONTROL_CODE_NUMBER5:
+			return "5";
+		case CEC_USER_CONTROL_CODE_NUMBER6:
+			return "6";
+		case CEC_USER_CONTROL_CODE_NUMBER7:
+			return "7";
+		case CEC_USER_CONTROL_CODE_NUMBER8:
+			return "8";
+		case CEC_USER_CONTROL_CODE_NUMBER9:
+			return "9";
+		case CEC_USER_CONTROL_CODE_DOT:
+			return ".";
+		case CEC_USER_CONTROL_CODE_ENTER:
+			return "enter";
+		case CEC_USER_CONTROL_CODE_CLEAR:
+			return "clear";
+		case CEC_USER_CONTROL_CODE_NEXT_FAVORITE:
+			return "next favourite";
+		case CEC_USER_CONTROL_CODE_CHANNEL_UP:
+			return "channel up";
+		case CEC_USER_CONTROL_CODE_CHANNEL_DOWN:
+			return "channel down";
+		case CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL:
+			return "previous channel";
+		case CEC_USER_CONTROL_CODE_SOUND_SELECT:
+			return "sound select";
+		case CEC_USER_CONTROL_CODE_INPUT_SELECT:
+			return "input select";
+		case CEC_USER_CONTROL_CODE_DISPLAY_INFORMATION:
+			return "display information";
+		case CEC_USER_CONTROL_CODE_HELP:
+			return "help";
+		case CEC_USER_CONTROL_CODE_PAGE_UP:
+			return "page up";
+		case CEC_USER_CONTROL_CODE_PAGE_DOWN:
+			return "page down";
+		case CEC_USER_CONTROL_CODE_POWER:
+			return "power";
+		case CEC_USER_CONTROL_CODE_VOLUME_UP:
+			return "volume up";
+		case CEC_USER_CONTROL_CODE_VOLUME_DOWN:
+			return "volume down";
+		case CEC_USER_CONTROL_CODE_MUTE:
+			return "mute";
+		case CEC_USER_CONTROL_CODE_PLAY:
+			return "play";
+		case CEC_USER_CONTROL_CODE_STOP:
+			return "stop";
+		case CEC_USER_CONTROL_CODE_PAUSE:
+			return "pause";
+		case CEC_USER_CONTROL_CODE_RECORD:
+			return "record";
+		case CEC_USER_CONTROL_CODE_REWIND:
+			return "rewind";
+		case CEC_USER_CONTROL_CODE_FAST_FORWARD:
+			return "Fast forward";
+		case CEC_USER_CONTROL_CODE_EJECT:
+			return "eject";
+		case CEC_USER_CONTROL_CODE_FORWARD:
+			return "forward";
+		case CEC_USER_CONTROL_CODE_BACKWARD:
+			return "backward";
+		case CEC_USER_CONTROL_CODE_STOP_RECORD:
+			return "stop record";
+		case CEC_USER_CONTROL_CODE_PAUSE_RECORD:
+			return "pause record";
+		case CEC_USER_CONTROL_CODE_ANGLE:
+			return "angle";
+		case CEC_USER_CONTROL_CODE_SUB_PICTURE:
+			return "sub picture";
+		case CEC_USER_CONTROL_CODE_VIDEO_ON_DEMAND:
+			return "video on demand";
+		case CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE:
+			return "electronic program guide";
+		case CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING:
+			return "timer programming";
+		case CEC_USER_CONTROL_CODE_INITIAL_CONFIGURATION:
+			return "initial configuration";
+		case CEC_USER_CONTROL_CODE_SELECT_BROADCAST_TYPE:
+			return "select broadcast type";
+		case CEC_USER_CONTROL_CODE_SELECT_SOUND_PRESENTATION:
+			return "select sound presentation";
+		case CEC_USER_CONTROL_CODE_PLAY_FUNCTION:
+			return "play (function)";
+		case CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION:
+			return "pause play (function)";
+		case CEC_USER_CONTROL_CODE_RECORD_FUNCTION:
+			return "record (function)";
+		case CEC_USER_CONTROL_CODE_PAUSE_RECORD_FUNCTION:
+			return "pause record (function)";
+		case CEC_USER_CONTROL_CODE_STOP_FUNCTION:
+			return "stop (function)";
+		case CEC_USER_CONTROL_CODE_MUTE_FUNCTION:
+			return "mute (function)";
+		case CEC_USER_CONTROL_CODE_RESTORE_VOLUME_FUNCTION:
+			return "restore volume";
+		case CEC_USER_CONTROL_CODE_TUNE_FUNCTION:
+			return "tune";
+		case CEC_USER_CONTROL_CODE_SELECT_MEDIA_FUNCTION:
+			return "select media";
+		case CEC_USER_CONTROL_CODE_SELECT_AV_INPUT_FUNCTION:
+			return "select AV input";
+		case CEC_USER_CONTROL_CODE_SELECT_AUDIO_INPUT_FUNCTION:
+			return "select audio input";
+		case CEC_USER_CONTROL_CODE_POWER_TOGGLE_FUNCTION:
+			return "power toggle";
+		case CEC_USER_CONTROL_CODE_POWER_OFF_FUNCTION:
+			return "power off";
+		case CEC_USER_CONTROL_CODE_POWER_ON_FUNCTION:
+			return "power on";
+		case CEC_USER_CONTROL_CODE_F1_BLUE:
+			return "F1 (blue)";
+		case CEC_USER_CONTROL_CODE_F2_RED:
+			return "F2 (red)";
+		case CEC_USER_CONTROL_CODE_F3_GREEN:
+			return "F3 (green)";
+		case CEC_USER_CONTROL_CODE_F4_YELLOW:
+			return "F4 (yellow)";
+		case CEC_USER_CONTROL_CODE_F5:
+			return "F5";
+		case CEC_USER_CONTROL_CODE_DATA:
+			return "data";
+		case CEC_USER_CONTROL_CODE_AN_RETURN:
+			return "return (Samsung)";
+		case CEC_USER_CONTROL_CODE_AN_CHANNELS_LIST:
+			return "channels list (Samsung)";
+		default:
+			return "unknown";
 	}
 }
 
@@ -637,39 +637,39 @@
 {
 	switch (la & 0xf)
 	{
-	case CECDEVICE_TV:
-		return "TV";
-	case CECDEVICE_RECORDINGDEVICE1:
-		return "Recording Device 1";
-	case CECDEVICE_RECORDINGDEVICE2:
-		return "Recording Device 2";
-	case CECDEVICE_TUNER1:
-		return "Tuner 1";
-	case CECDEVICE_PLAYBACKDEVICE1:
-		return "Playback Device 1";
-	case CECDEVICE_AUDIOSYSTEM:
-		return "Audio System";
-	case CECDEVICE_TUNER2:
-		return "Tuner 2";
-	case CECDEVICE_TUNER3:
-		return "Tuner 3";
-	case CECDEVICE_PLAYBACKDEVICE2:
-		return "Playback Device 2";
-	case CECDEVICE_RECORDINGDEVICE3:
-		return "Recording Device 3";
-	case CECDEVICE_TUNER4:
-		return "Tuner 4";
-	case CECDEVICE_PLAYBACKDEVICE3:
-		return "Playback Device 3";
-	case CECDEVICE_RESERVED1:
-		return "Reserved 1";
-	case CECDEVICE_RESERVED2:
-		return "Reserved 2";
-	case CECDEVICE_FREEUSE:
-		return "Free use";
-	case CECDEVICE_UNREGISTERED:
-	default:
-		return "Unregistered";
+		case CECDEVICE_TV:
+			return "TV";
+		case CECDEVICE_RECORDINGDEVICE1:
+			return "Recording Device 1";
+		case CECDEVICE_RECORDINGDEVICE2:
+			return "Recording Device 2";
+		case CECDEVICE_TUNER1:
+			return "Tuner 1";
+		case CECDEVICE_PLAYBACKDEVICE1:
+			return "Playback Device 1";
+		case CECDEVICE_AUDIOSYSTEM:
+			return "Audio System";
+		case CECDEVICE_TUNER2:
+			return "Tuner 2";
+		case CECDEVICE_TUNER3:
+			return "Tuner 3";
+		case CECDEVICE_PLAYBACKDEVICE2:
+			return "Playback Device 2";
+		case CECDEVICE_RECORDINGDEVICE3:
+			return "Recording Device 3";
+		case CECDEVICE_TUNER4:
+			return "Tuner 4";
+		case CECDEVICE_PLAYBACKDEVICE3:
+			return "Playback Device 3";
+		case CECDEVICE_RESERVED1:
+			return "Reserved 1";
+		case CECDEVICE_RESERVED2:
+			return "Reserved 2";
+		case CECDEVICE_FREEUSE:
+			return "Free use";
+		case CECDEVICE_UNREGISTERED:
+		default:
+			return "Unregistered";
 	}
 }
 
@@ -677,34 +677,34 @@
 {
 	switch (opcode)
 	{
-	case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
-		return CEC_OPCODE_ACTIVE_SOURCE;
-	case CEC_OPCODE_GET_CEC_VERSION:
-		return CEC_OPCODE_CEC_VERSION;
-	case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
-		return CEC_OPCODE_REPORT_PHYSICAL_ADDRESS;
-	case CEC_OPCODE_GET_MENU_LANGUAGE:
-		return CEC_OPCODE_SET_MENU_LANGUAGE;
-	case CEC_OPCODE_GIVE_DECK_STATUS:
-		return CEC_OPCODE_DECK_STATUS;
-	case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS:
-		return CEC_OPCODE_TUNER_DEVICE_STATUS;
-	case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
-		return CEC_OPCODE_DEVICE_VENDOR_ID;
-	case CEC_OPCODE_GIVE_OSD_NAME:
-		return CEC_OPCODE_SET_OSD_NAME;
-	case CEC_OPCODE_MENU_REQUEST:
-		return CEC_OPCODE_MENU_STATUS;
-	case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
-		return CEC_OPCODE_REPORT_POWER_STATUS;
-	case CEC_OPCODE_GIVE_AUDIO_STATUS:
-		return CEC_OPCODE_REPORT_AUDIO_STATUS;
-	case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS:
-		return CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS;
-	case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST:
-		return CEC_OPCODE_SET_SYSTEM_AUDIO_MODE;
-	default:
-		break;
+		case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
+			return CEC_OPCODE_ACTIVE_SOURCE;
+		case CEC_OPCODE_GET_CEC_VERSION:
+			return CEC_OPCODE_CEC_VERSION;
+		case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
+			return CEC_OPCODE_REPORT_PHYSICAL_ADDRESS;
+		case CEC_OPCODE_GET_MENU_LANGUAGE:
+			return CEC_OPCODE_SET_MENU_LANGUAGE;
+		case CEC_OPCODE_GIVE_DECK_STATUS:
+			return CEC_OPCODE_DECK_STATUS;
+		case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS:
+			return CEC_OPCODE_TUNER_DEVICE_STATUS;
+		case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
+			return CEC_OPCODE_DEVICE_VENDOR_ID;
+		case CEC_OPCODE_GIVE_OSD_NAME:
+			return CEC_OPCODE_SET_OSD_NAME;
+		case CEC_OPCODE_MENU_REQUEST:
+			return CEC_OPCODE_MENU_STATUS;
+		case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
+			return CEC_OPCODE_REPORT_POWER_STATUS;
+		case CEC_OPCODE_GIVE_AUDIO_STATUS:
+			return CEC_OPCODE_REPORT_AUDIO_STATUS;
+		case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+			return CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS;
+		case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST:
+			return CEC_OPCODE_SET_SYSTEM_AUDIO_MODE;
+		default:
+			break;
 	}
 
 	return CEC_OPCODE_NONE;
diff -Nur libstb-hal-ddt.git.orig/libarmbox/init.cpp libstb-hal-ddt.git/libarmbox/init.cpp
--- libstb-hal-ddt.git.orig/libarmbox/init.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libarmbox/init.cpp	2022-07-23 18:18:31.499773109 +0200
@@ -26,8 +26,6 @@
 	hal_info("%s begin, initialized=%d, debug=0x%02x\n", __FUNCTION__, (int)initialized, debuglevel);
 	if (!initialized)
 	{
-		cCpuFreqManager f;
-		f.SetCpuFreq(0);	/* CPUFREQ == 0 is the trigger for leaving standby */
 		char buffer[64];
 		sprintf(buffer, "%x", 0);
 		proc_put("/proc/stb/fb/dst_top", buffer, strlen(buffer));
@@ -38,9 +36,10 @@
 		proc_put("/proc/stb/fb/dst_width", buffer, strlen(buffer));
 		sprintf(buffer, "%x", 1);
 		proc_put("/proc/stb/fb/dst_apply", buffer, strlen(buffer));
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 		sprintf(buffer, "%s", "enable");
 		proc_put("/proc/stb/frontend/fbc/fcc", buffer, strlen(buffer));
+		proc_put("/proc/stb/video/decodermode", "normal", strlen("normal"));
 #endif
 	}
 	initialized = true;
diff -Nur libstb-hal-ddt.git.orig/libarmbox/linux-uapi-cec.h libstb-hal-ddt.git/libarmbox/linux-uapi-cec.h
--- libstb-hal-ddt.git.orig/libarmbox/linux-uapi-cec.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libarmbox/linux-uapi-cec.h	2022-07-23 18:18:31.499773109 +0200
@@ -44,50 +44,51 @@
 
 #include <linux/types.h>
 
-#define CEC_MAX_MSG_SIZE	16
+#define CEC_MAX_MSG_SIZE    16
 
 /**
  * struct cec_msg - CEC message structure.
- * @tx_ts:	Timestamp in nanoseconds using CLOCK_MONOTONIC. Set by the
- *		driver when the message transmission has finished.
- * @rx_ts:	Timestamp in nanoseconds using CLOCK_MONOTONIC. Set by the
- *		driver when the message was received.
- * @len:	Length in bytes of the message.
- * @timeout:	The timeout (in ms) that is used to timeout CEC_RECEIVE.
- *		Set to 0 if you want to wait forever. This timeout can also be
- *		used with CEC_TRANSMIT as the timeout for waiting for a reply.
- *		If 0, then it will use a 1 second timeout instead of waiting
- *		forever as is done with CEC_RECEIVE.
- * @sequence:	The framework assigns a sequence number to messages that are
- *		sent. This can be used to track replies to previously sent
- *		messages.
- * @flags:	Set to 0.
- * @msg:	The message payload.
- * @reply:	This field is ignored with CEC_RECEIVE and is only used by
- *		CEC_TRANSMIT. If non-zero, then wait for a reply with this
- *		opcode. Set to CEC_MSG_FEATURE_ABORT if you want to wait for
- *		a possible ABORT reply. If there was an error when sending the
- *		msg or FeatureAbort was returned, then reply is set to 0.
- *		If reply is non-zero upon return, then len/msg are set to
- *		the received message.
- *		If reply is zero upon return and status has the
- *		CEC_TX_STATUS_FEATURE_ABORT bit set, then len/msg are set to
- *		the received feature abort message.
- *		If reply is zero upon return and status has the
- *		CEC_TX_STATUS_MAX_RETRIES bit set, then no reply was seen at
- *		all. If reply is non-zero for CEC_TRANSMIT and the message is a
- *		broadcast, then -EINVAL is returned.
- *		if reply is non-zero, then timeout is set to 1000 (the required
- *		maximum response time).
- * @rx_status:	The message receive status bits. Set by the driver.
- * @tx_status:	The message transmit status bits. Set by the driver.
+ * @tx_ts:  Timestamp in nanoseconds using CLOCK_MONOTONIC. Set by the
+ *      driver when the message transmission has finished.
+ * @rx_ts:  Timestamp in nanoseconds using CLOCK_MONOTONIC. Set by the
+ *      driver when the message was received.
+ * @len:    Length in bytes of the message.
+ * @timeout:    The timeout (in ms) that is used to timeout CEC_RECEIVE.
+ *      Set to 0 if you want to wait forever. This timeout can also be
+ *      used with CEC_TRANSMIT as the timeout for waiting for a reply.
+ *      If 0, then it will use a 1 second timeout instead of waiting
+ *      forever as is done with CEC_RECEIVE.
+ * @sequence:   The framework assigns a sequence number to messages that are
+ *      sent. This can be used to track replies to previously sent
+ *      messages.
+ * @flags:  Set to 0.
+ * @msg:    The message payload.
+ * @reply:  This field is ignored with CEC_RECEIVE and is only used by
+ *      CEC_TRANSMIT. If non-zero, then wait for a reply with this
+ *      opcode. Set to CEC_MSG_FEATURE_ABORT if you want to wait for
+ *      a possible ABORT reply. If there was an error when sending the
+ *      msg or FeatureAbort was returned, then reply is set to 0.
+ *      If reply is non-zero upon return, then len/msg are set to
+ *      the received message.
+ *      If reply is zero upon return and status has the
+ *      CEC_TX_STATUS_FEATURE_ABORT bit set, then len/msg are set to
+ *      the received feature abort message.
+ *      If reply is zero upon return and status has the
+ *      CEC_TX_STATUS_MAX_RETRIES bit set, then no reply was seen at
+ *      all. If reply is non-zero for CEC_TRANSMIT and the message is a
+ *      broadcast, then -EINVAL is returned.
+ *      if reply is non-zero, then timeout is set to 1000 (the required
+ *      maximum response time).
+ * @rx_status:  The message receive status bits. Set by the driver.
+ * @tx_status:  The message transmit status bits. Set by the driver.
  * @tx_arb_lost_cnt: The number of 'Arbitration Lost' events. Set by the driver.
  * @tx_nack_cnt: The number of 'Not Acknowledged' events. Set by the driver.
  * @tx_low_drive_cnt: The number of 'Low Drive Detected' events. Set by the
- *		driver.
+ *      driver.
  * @tx_error_cnt: The number of 'Error' events. Set by the driver.
  */
-struct cec_msg {
+struct cec_msg
+{
 	__u64 tx_ts;
 	__u64 rx_ts;
 	__u32 len;
@@ -106,7 +107,7 @@
 
 /**
  * cec_msg_initiator - return the initiator's logical address.
- * @msg:	the message structure
+ * @msg:    the message structure
  */
 static inline __u8 cec_msg_initiator(const struct cec_msg *msg)
 {
@@ -115,7 +116,7 @@
 
 /**
  * cec_msg_destination - return the destination's logical address.
- * @msg:	the message structure
+ * @msg:    the message structure
  */
 static inline __u8 cec_msg_destination(const struct cec_msg *msg)
 {
@@ -124,7 +125,7 @@
 
 /**
  * cec_msg_opcode - return the opcode of the message, -1 for poll
- * @msg:	the message structure
+ * @msg:    the message structure
  */
 static inline int cec_msg_opcode(const struct cec_msg *msg)
 {
@@ -133,7 +134,7 @@
 
 /**
  * cec_msg_is_broadcast - return true if this is a broadcast message.
- * @msg:	the message structure
+ * @msg:    the message structure
  */
 static inline bool cec_msg_is_broadcast(const struct cec_msg *msg)
 {
@@ -142,15 +143,15 @@
 
 /**
  * cec_msg_init - initialize the message structure.
- * @msg:	the message structure
- * @initiator:	the logical address of the initiator
+ * @msg:    the message structure
+ * @initiator:  the logical address of the initiator
  * @destination:the logical address of the destination (0xf for broadcast)
  *
  * The whole structure is zeroed, the len field is set to 1 (i.e. a poll
  * message) and the initiator and destination are filled in.
  */
 static inline void cec_msg_init(struct cec_msg *msg,
-				__u8 initiator, __u8 destination)
+    __u8 initiator, __u8 destination)
 {
 	memset(msg, 0, sizeof(*msg));
 	msg->msg[0] = (initiator << 4) | destination;
@@ -159,33 +160,33 @@
 
 /**
  * cec_msg_set_reply_to - fill in destination/initiator in a reply message.
- * @msg:	the message structure for the reply
- * @orig:	the original message structure
+ * @msg:    the message structure for the reply
+ * @orig:   the original message structure
  *
  * Set the msg destination to the orig initiator and the msg initiator to the
  * orig destination. Note that msg and orig may be the same pointer, in which
  * case the change is done in place.
  */
 static inline void cec_msg_set_reply_to(struct cec_msg *msg,
-					struct cec_msg *orig)
+    struct cec_msg *orig)
 {
 	/* The destination becomes the initiator and vice versa */
 	msg->msg[0] = (cec_msg_destination(orig) << 4) |
-		      cec_msg_initiator(orig);
+	    cec_msg_initiator(orig);
 	msg->reply = msg->timeout = 0;
 }
 
 /* cec status field */
-#define CEC_TX_STATUS_OK		(1 << 0)
-#define CEC_TX_STATUS_ARB_LOST		(1 << 1)
-#define CEC_TX_STATUS_NACK		(1 << 2)
-#define CEC_TX_STATUS_LOW_DRIVE		(1 << 3)
-#define CEC_TX_STATUS_ERROR		(1 << 4)
-#define CEC_TX_STATUS_MAX_RETRIES	(1 << 5)
-
-#define CEC_RX_STATUS_OK		(1 << 0)
-#define CEC_RX_STATUS_TIMEOUT		(1 << 1)
-#define CEC_RX_STATUS_FEATURE_ABORT	(1 << 2)
+#define CEC_TX_STATUS_OK        (1 << 0)
+#define CEC_TX_STATUS_ARB_LOST      (1 << 1)
+#define CEC_TX_STATUS_NACK      (1 << 2)
+#define CEC_TX_STATUS_LOW_DRIVE     (1 << 3)
+#define CEC_TX_STATUS_ERROR     (1 << 4)
+#define CEC_TX_STATUS_MAX_RETRIES   (1 << 5)
+
+#define CEC_RX_STATUS_OK        (1 << 0)
+#define CEC_RX_STATUS_TIMEOUT       (1 << 1)
+#define CEC_RX_STATUS_FEATURE_ABORT (1 << 2)
 
 static inline bool cec_msg_status_is_ok(const struct cec_msg *msg)
 {
@@ -198,8 +199,8 @@
 	return !(msg->rx_status & CEC_RX_STATUS_FEATURE_ABORT);
 }
 
-#define CEC_LOG_ADDR_INVALID		0xff
-#define CEC_PHYS_ADDR_INVALID		0xffff
+#define CEC_LOG_ADDR_INVALID        0xff
+#define CEC_PHYS_ADDR_INVALID       0xffff
 
 /*
  * The maximum number of logical addresses one device can be assigned to.
@@ -209,53 +210,53 @@
 #define CEC_MAX_LOG_ADDRS 4
 
 /* The logical addresses defined by CEC 2.0 */
-#define CEC_LOG_ADDR_TV			0
-#define CEC_LOG_ADDR_RECORD_1		1
-#define CEC_LOG_ADDR_RECORD_2		2
-#define CEC_LOG_ADDR_TUNER_1		3
-#define CEC_LOG_ADDR_PLAYBACK_1		4
-#define CEC_LOG_ADDR_AUDIOSYSTEM	5
-#define CEC_LOG_ADDR_TUNER_2		6
-#define CEC_LOG_ADDR_TUNER_3		7
-#define CEC_LOG_ADDR_PLAYBACK_2		8
-#define CEC_LOG_ADDR_RECORD_3		9
-#define CEC_LOG_ADDR_TUNER_4		10
-#define CEC_LOG_ADDR_PLAYBACK_3		11
-#define CEC_LOG_ADDR_BACKUP_1		12
-#define CEC_LOG_ADDR_BACKUP_2		13
-#define CEC_LOG_ADDR_SPECIFIC		14
-#define CEC_LOG_ADDR_UNREGISTERED	15 /* as initiator address */
-#define CEC_LOG_ADDR_BROADCAST		15 /* ad destination address */
+#define CEC_LOG_ADDR_TV         0
+#define CEC_LOG_ADDR_RECORD_1       1
+#define CEC_LOG_ADDR_RECORD_2       2
+#define CEC_LOG_ADDR_TUNER_1        3
+#define CEC_LOG_ADDR_PLAYBACK_1     4
+#define CEC_LOG_ADDR_AUDIOSYSTEM    5
+#define CEC_LOG_ADDR_TUNER_2        6
+#define CEC_LOG_ADDR_TUNER_3        7
+#define CEC_LOG_ADDR_PLAYBACK_2     8
+#define CEC_LOG_ADDR_RECORD_3       9
+#define CEC_LOG_ADDR_TUNER_4        10
+#define CEC_LOG_ADDR_PLAYBACK_3     11
+#define CEC_LOG_ADDR_BACKUP_1       12
+#define CEC_LOG_ADDR_BACKUP_2       13
+#define CEC_LOG_ADDR_SPECIFIC       14
+#define CEC_LOG_ADDR_UNREGISTERED   15 /* as initiator address */
+#define CEC_LOG_ADDR_BROADCAST      15 /* ad destination address */
 
 /* The logical address types that the CEC device wants to claim */
-#define CEC_LOG_ADDR_TYPE_TV		0
-#define CEC_LOG_ADDR_TYPE_RECORD	1
-#define CEC_LOG_ADDR_TYPE_TUNER		2
-#define CEC_LOG_ADDR_TYPE_PLAYBACK	3
-#define CEC_LOG_ADDR_TYPE_AUDIOSYSTEM	4
-#define CEC_LOG_ADDR_TYPE_SPECIFIC	5
-#define CEC_LOG_ADDR_TYPE_UNREGISTERED	6
+#define CEC_LOG_ADDR_TYPE_TV        0
+#define CEC_LOG_ADDR_TYPE_RECORD    1
+#define CEC_LOG_ADDR_TYPE_TUNER     2
+#define CEC_LOG_ADDR_TYPE_PLAYBACK  3
+#define CEC_LOG_ADDR_TYPE_AUDIOSYSTEM   4
+#define CEC_LOG_ADDR_TYPE_SPECIFIC  5
+#define CEC_LOG_ADDR_TYPE_UNREGISTERED  6
 /*
  * Switches should use UNREGISTERED.
  * Processors should use SPECIFIC.
  */
 
-#define CEC_LOG_ADDR_MASK_TV		(1 << CEC_LOG_ADDR_TV)
-#define CEC_LOG_ADDR_MASK_RECORD	((1 << CEC_LOG_ADDR_RECORD_1) | \
-					 (1 << CEC_LOG_ADDR_RECORD_2) | \
-					 (1 << CEC_LOG_ADDR_RECORD_3))
-#define CEC_LOG_ADDR_MASK_TUNER		((1 << CEC_LOG_ADDR_TUNER_1) | \
-					 (1 << CEC_LOG_ADDR_TUNER_2) | \
-					 (1 << CEC_LOG_ADDR_TUNER_3) | \
-					 (1 << CEC_LOG_ADDR_TUNER_4))
-#define CEC_LOG_ADDR_MASK_PLAYBACK	((1 << CEC_LOG_ADDR_PLAYBACK_1) | \
-					 (1 << CEC_LOG_ADDR_PLAYBACK_2) | \
-					 (1 << CEC_LOG_ADDR_PLAYBACK_3))
-#define CEC_LOG_ADDR_MASK_AUDIOSYSTEM	(1 << CEC_LOG_ADDR_AUDIOSYSTEM)
-#define CEC_LOG_ADDR_MASK_BACKUP	((1 << CEC_LOG_ADDR_BACKUP_1) | \
-					 (1 << CEC_LOG_ADDR_BACKUP_2))
-#define CEC_LOG_ADDR_MASK_SPECIFIC	(1 << CEC_LOG_ADDR_SPECIFIC)
-#define CEC_LOG_ADDR_MASK_UNREGISTERED	(1 << CEC_LOG_ADDR_UNREGISTERED)
+#define CEC_LOG_ADDR_MASK_TV        (1 << CEC_LOG_ADDR_TV)
+#define CEC_LOG_ADDR_MASK_RECORD    ((1 << CEC_LOG_ADDR_RECORD_1) | \
+                     (1 << CEC_LOG_ADDR_RECORD_2) | \
+                     (1 << CEC_LOG_ADDR_RECORD_3))
+#define CEC_LOG_ADDR_MASK_TUNER     ((1 << CEC_LOG_ADDR_TUNER_1) | \
+                     (1 << CEC_LOG_ADDR_TUNER_2) | \
+                     (1 << CEC_LOG_ADDR_TUNER_3) | \
+                     (1 << CEC_LOG_ADDR_TUNER_4))
+#define CEC_LOG_ADDR_MASK_PLAYBACK  ((1 << CEC_LOG_ADDR_PLAYBACK_1) | \
+                     (1 << CEC_LOG_ADDR_PLAYBACK_2) | \
+                     (1 << CEC_LOG_ADDR_PLAYBACK_3))
+#define CEC_LOG_ADDR_MASK_AUDIOSYSTEM   (1 << CEC_LOG_ADDR_AUDIOSYSTEM)
+#define CEC_LOG_ADDR_MASK_BACKUP    ((1 << CEC_LOG_ADDR_BACKUP_1) | \
+                     (1 << CEC_LOG_ADDR_BACKUP_2))
+#define CEC_LOG_ADDR_MASK_SPECIFIC  (1 << CEC_LOG_ADDR_SPECIFIC)
+#define CEC_LOG_ADDR_MASK_UNREGISTERED  (1 << CEC_LOG_ADDR_UNREGISTERED)
 
 static inline bool cec_has_tv(__u16 log_addr_mask)
 {
@@ -306,38 +307,38 @@
  * Use this if there is no vendor ID (CEC_G_VENDOR_ID) or if the vendor ID
  * should be disabled (CEC_S_VENDOR_ID)
  */
-#define CEC_VENDOR_ID_NONE		0xffffffff
+#define CEC_VENDOR_ID_NONE      0xffffffff
 
 /* The message handling modes */
 /* Modes for initiator */
-#define CEC_MODE_NO_INITIATOR		(0x0 << 0)
-#define CEC_MODE_INITIATOR		(0x1 << 0)
-#define CEC_MODE_EXCL_INITIATOR		(0x2 << 0)
-#define CEC_MODE_INITIATOR_MSK		0x0f
+#define CEC_MODE_NO_INITIATOR       (0x0 << 0)
+#define CEC_MODE_INITIATOR      (0x1 << 0)
+#define CEC_MODE_EXCL_INITIATOR     (0x2 << 0)
+#define CEC_MODE_INITIATOR_MSK      0x0f
 
 /* Modes for follower */
-#define CEC_MODE_NO_FOLLOWER		(0x0 << 4)
-#define CEC_MODE_FOLLOWER		(0x1 << 4)
-#define CEC_MODE_EXCL_FOLLOWER		(0x2 << 4)
-#define CEC_MODE_EXCL_FOLLOWER_PASSTHRU	(0x3 << 4)
-#define CEC_MODE_MONITOR		(0xe << 4)
-#define CEC_MODE_MONITOR_ALL		(0xf << 4)
-#define CEC_MODE_FOLLOWER_MSK		0xf0
+#define CEC_MODE_NO_FOLLOWER        (0x0 << 4)
+#define CEC_MODE_FOLLOWER       (0x1 << 4)
+#define CEC_MODE_EXCL_FOLLOWER      (0x2 << 4)
+#define CEC_MODE_EXCL_FOLLOWER_PASSTHRU (0x3 << 4)
+#define CEC_MODE_MONITOR        (0xe << 4)
+#define CEC_MODE_MONITOR_ALL        (0xf << 4)
+#define CEC_MODE_FOLLOWER_MSK       0xf0
 
 /* Userspace has to configure the physical address */
-#define CEC_CAP_PHYS_ADDR	(1 << 0)
+#define CEC_CAP_PHYS_ADDR   (1 << 0)
 /* Userspace has to configure the logical addresses */
-#define CEC_CAP_LOG_ADDRS	(1 << 1)
+#define CEC_CAP_LOG_ADDRS   (1 << 1)
 /* Userspace can transmit messages (and thus become follower as well) */
-#define CEC_CAP_TRANSMIT	(1 << 2)
+#define CEC_CAP_TRANSMIT    (1 << 2)
 /*
  * Passthrough all messages instead of processing them.
  */
-#define CEC_CAP_PASSTHROUGH	(1 << 3)
+#define CEC_CAP_PASSTHROUGH (1 << 3)
 /* Supports remote control */
-#define CEC_CAP_RC		(1 << 4)
+#define CEC_CAP_RC      (1 << 4)
 /* Hardware can monitor all messages, not just directed and broadcast. */
-#define CEC_CAP_MONITOR_ALL	(1 << 5)
+#define CEC_CAP_MONITOR_ALL (1 << 5)
 
 /**
  * struct cec_caps - CEC capabilities structure.
@@ -347,7 +348,8 @@
  * @capabilities: capabilities of the CEC adapter.
  * @version: version of the CEC adapter framework.
  */
-struct cec_caps {
+struct cec_caps
+{
 	char driver[32];
 	char name[32];
 	__u32 available_log_addrs;
@@ -360,20 +362,21 @@
  * @log_addr: the claimed logical addresses. Set by the driver.
  * @log_addr_mask: current logical address mask. Set by the driver.
  * @cec_version: the CEC version that the adapter should implement. Set by the
- *	caller.
+ *  caller.
  * @num_log_addrs: how many logical addresses should be claimed. Set by the
- *	caller.
+ *  caller.
  * @vendor_id: the vendor ID of the device. Set by the caller.
  * @flags: flags.
  * @osd_name: the OSD name of the device. Set by the caller.
  * @primary_device_type: the primary device type for each logical address.
- *	Set by the caller.
+ *  Set by the caller.
  * @log_addr_type: the logical address types. Set by the caller.
  * @all_device_types: CEC 2.0: all device types represented by the logical
- *	address. Set by the caller.
- * @features:	CEC 2.0: The logical address features. Set by the caller.
+ *  address. Set by the caller.
+ * @features:   CEC 2.0: The logical address features. Set by the caller.
  */
-struct cec_log_addrs {
+struct cec_log_addrs
+{
 	__u8 log_addr[CEC_MAX_LOG_ADDRS];
 	__u16 log_addr_mask;
 	__u8 cec_version;
@@ -390,26 +393,27 @@
 };
 
 /* Allow a fallback to unregistered */
-#define CEC_LOG_ADDRS_FL_ALLOW_UNREG_FALLBACK	(1 << 0)
+#define CEC_LOG_ADDRS_FL_ALLOW_UNREG_FALLBACK   (1 << 0)
 
 /* Events */
 
 /* Event that occurs when the adapter state changes */
-#define CEC_EVENT_STATE_CHANGE		1
+#define CEC_EVENT_STATE_CHANGE      1
 /*
  * This event is sent when messages are lost because the application
  * didn't empty the message queue in time
  */
-#define CEC_EVENT_LOST_MSGS		2
+#define CEC_EVENT_LOST_MSGS     2
 
-#define CEC_EVENT_FL_INITIAL_STATE	(1 << 0)
+#define CEC_EVENT_FL_INITIAL_STATE  (1 << 0)
 
 /**
  * struct cec_event_state_change - used when the CEC adapter changes state.
  * @phys_addr: the current physical address
  * @log_addr_mask: the current logical address mask
  */
-struct cec_event_state_change {
+struct cec_event_state_change
+{
 	__u16 phys_addr;
 	__u16 log_addr_mask;
 };
@@ -418,7 +422,8 @@
  * struct cec_event_lost_msgs - tells you how many messages were lost due.
  * @lost_msgs: how many messages were lost.
  */
-struct cec_event_lost_msgs {
+struct cec_event_lost_msgs
+{
 	__u32 lost_msgs;
 };
 
@@ -431,11 +436,13 @@
  * @lost_msgs: the event payload for CEC_EVENT_LOST_MSGS.
  * @raw: array to pad the union.
  */
-struct cec_event {
+struct cec_event
+{
 	__u64 ts;
 	__u32 event;
 	__u32 flags;
-	union {
+	union
+	{
 		struct cec_event_state_change state_change;
 		struct cec_event_lost_msgs lost_msgs;
 		__u32 raw[16];
@@ -445,7 +452,7 @@
 /* ioctls */
 
 /* Adapter capabilities */
-#define CEC_ADAP_G_CAPS		_IOWR('a',  0, struct cec_caps)
+#define CEC_ADAP_G_CAPS     _IOWR('a',  0, struct cec_caps)
 
 /*
  * phys_addr is either 0 (if this is the CEC root device)
@@ -459,8 +466,8 @@
  * The CEC_ADAP_S_PHYS_ADDR ioctl may not be available if that is handled
  * internally.
  */
-#define CEC_ADAP_G_PHYS_ADDR	_IOR('a',  1, __u16)
-#define CEC_ADAP_S_PHYS_ADDR	_IOW('a',  2, __u16)
+#define CEC_ADAP_G_PHYS_ADDR    _IOR('a',  1, __u16)
+#define CEC_ADAP_S_PHYS_ADDR    _IOW('a',  2, __u16)
 
 /*
  * Configure the CEC adapter. It sets the device type and which
@@ -470,21 +477,21 @@
  * is no physical address assigned.
  */
 
-#define CEC_ADAP_G_LOG_ADDRS	_IOR('a',  3, struct cec_log_addrs)
-#define CEC_ADAP_S_LOG_ADDRS	_IOWR('a',  4, struct cec_log_addrs)
+#define CEC_ADAP_G_LOG_ADDRS    _IOR('a',  3, struct cec_log_addrs)
+#define CEC_ADAP_S_LOG_ADDRS    _IOWR('a',  4, struct cec_log_addrs)
 
 /* Transmit/receive a CEC command */
-#define CEC_TRANSMIT		_IOWR('a',  5, struct cec_msg)
-#define CEC_RECEIVE		_IOWR('a',  6, struct cec_msg)
+#define CEC_TRANSMIT        _IOWR('a',  5, struct cec_msg)
+#define CEC_RECEIVE     _IOWR('a',  6, struct cec_msg)
 
 /* Dequeue CEC events */
-#define CEC_DQEVENT		_IOWR('a',  7, struct cec_event)
+#define CEC_DQEVENT     _IOWR('a',  7, struct cec_event)
 
 /*
  * Get and set the message handling mode for this filehandle.
  */
-#define CEC_G_MODE		_IOR('a',  8, __u32)
-#define CEC_S_MODE		_IOW('a',  9, __u32)
+#define CEC_G_MODE      _IOR('a',  8, __u32)
+#define CEC_S_MODE      _IOW('a',  9, __u32)
 
 /*
  * The remainder of this header defines all CEC messages and operands.
@@ -504,511 +511,511 @@
 /* Messages */
 
 /* One Touch Play Feature */
-#define CEC_MSG_ACTIVE_SOURCE				0x82
-#define CEC_MSG_IMAGE_VIEW_ON				0x04
-#define CEC_MSG_TEXT_VIEW_ON				0x0d
+#define CEC_MSG_ACTIVE_SOURCE               0x82
+#define CEC_MSG_IMAGE_VIEW_ON               0x04
+#define CEC_MSG_TEXT_VIEW_ON                0x0d
 
 
 /* Routing Control Feature */
 
 /*
  * Has also:
- *	CEC_MSG_ACTIVE_SOURCE
+ *  CEC_MSG_ACTIVE_SOURCE
  */
 
-#define CEC_MSG_INACTIVE_SOURCE				0x9d
-#define CEC_MSG_REQUEST_ACTIVE_SOURCE			0x85
-#define CEC_MSG_ROUTING_CHANGE				0x80
-#define CEC_MSG_ROUTING_INFORMATION			0x81
-#define CEC_MSG_SET_STREAM_PATH				0x86
+#define CEC_MSG_INACTIVE_SOURCE             0x9d
+#define CEC_MSG_REQUEST_ACTIVE_SOURCE           0x85
+#define CEC_MSG_ROUTING_CHANGE              0x80
+#define CEC_MSG_ROUTING_INFORMATION         0x81
+#define CEC_MSG_SET_STREAM_PATH             0x86
 
 
 /* Standby Feature */
-#define CEC_MSG_STANDBY					0x36
+#define CEC_MSG_STANDBY                 0x36
 
 
 /* One Touch Record Feature */
-#define CEC_MSG_RECORD_OFF				0x0b
-#define CEC_MSG_RECORD_ON				0x09
+#define CEC_MSG_RECORD_OFF              0x0b
+#define CEC_MSG_RECORD_ON               0x09
 /* Record Source Type Operand (rec_src_type) */
-#define CEC_OP_RECORD_SRC_OWN				1
-#define CEC_OP_RECORD_SRC_DIGITAL			2
-#define CEC_OP_RECORD_SRC_ANALOG			3
-#define CEC_OP_RECORD_SRC_EXT_PLUG			4
-#define CEC_OP_RECORD_SRC_EXT_PHYS_ADDR			5
+#define CEC_OP_RECORD_SRC_OWN               1
+#define CEC_OP_RECORD_SRC_DIGITAL           2
+#define CEC_OP_RECORD_SRC_ANALOG            3
+#define CEC_OP_RECORD_SRC_EXT_PLUG          4
+#define CEC_OP_RECORD_SRC_EXT_PHYS_ADDR         5
 /* Service Identification Method Operand (service_id_method) */
-#define CEC_OP_SERVICE_ID_METHOD_BY_DIG_ID		0
-#define CEC_OP_SERVICE_ID_METHOD_BY_CHANNEL		1
+#define CEC_OP_SERVICE_ID_METHOD_BY_DIG_ID      0
+#define CEC_OP_SERVICE_ID_METHOD_BY_CHANNEL     1
 /* Digital Service Broadcast System Operand (dig_bcast_system) */
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_GEN	0x00
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_GEN	0x01
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_GEN		0x02
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_BS		0x08
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_CS		0x09
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_T		0x0a
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_CABLE	0x10
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_SAT	0x11
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_T		0x12
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_C		0x18
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_S		0x19
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_S2		0x1a
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_T		0x1b
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_GEN    0x00
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_GEN    0x01
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_GEN     0x02
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_BS     0x08
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_CS     0x09
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_T      0x0a
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_CABLE  0x10
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_SAT    0x11
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_T      0x12
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_C       0x18
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_S       0x19
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_S2      0x1a
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_T       0x1b
 /* Analogue Broadcast Type Operand (ana_bcast_type) */
-#define CEC_OP_ANA_BCAST_TYPE_CABLE			0
-#define CEC_OP_ANA_BCAST_TYPE_SATELLITE			1
-#define CEC_OP_ANA_BCAST_TYPE_TERRESTRIAL		2
+#define CEC_OP_ANA_BCAST_TYPE_CABLE         0
+#define CEC_OP_ANA_BCAST_TYPE_SATELLITE         1
+#define CEC_OP_ANA_BCAST_TYPE_TERRESTRIAL       2
 /* Broadcast System Operand (bcast_system) */
-#define CEC_OP_BCAST_SYSTEM_PAL_BG			0x00
-#define CEC_OP_BCAST_SYSTEM_SECAM_LQ			0x01 /* SECAM L' */
-#define CEC_OP_BCAST_SYSTEM_PAL_M			0x02
-#define CEC_OP_BCAST_SYSTEM_NTSC_M			0x03
-#define CEC_OP_BCAST_SYSTEM_PAL_I			0x04
-#define CEC_OP_BCAST_SYSTEM_SECAM_DK			0x05
-#define CEC_OP_BCAST_SYSTEM_SECAM_BG			0x06
-#define CEC_OP_BCAST_SYSTEM_SECAM_L			0x07
-#define CEC_OP_BCAST_SYSTEM_PAL_DK			0x08
-#define CEC_OP_BCAST_SYSTEM_OTHER			0x1f
+#define CEC_OP_BCAST_SYSTEM_PAL_BG          0x00
+#define CEC_OP_BCAST_SYSTEM_SECAM_LQ            0x01 /* SECAM L' */
+#define CEC_OP_BCAST_SYSTEM_PAL_M           0x02
+#define CEC_OP_BCAST_SYSTEM_NTSC_M          0x03
+#define CEC_OP_BCAST_SYSTEM_PAL_I           0x04
+#define CEC_OP_BCAST_SYSTEM_SECAM_DK            0x05
+#define CEC_OP_BCAST_SYSTEM_SECAM_BG            0x06
+#define CEC_OP_BCAST_SYSTEM_SECAM_L         0x07
+#define CEC_OP_BCAST_SYSTEM_PAL_DK          0x08
+#define CEC_OP_BCAST_SYSTEM_OTHER           0x1f
 /* Channel Number Format Operand (channel_number_fmt) */
-#define CEC_OP_CHANNEL_NUMBER_FMT_1_PART		0x01
-#define CEC_OP_CHANNEL_NUMBER_FMT_2_PART		0x02
+#define CEC_OP_CHANNEL_NUMBER_FMT_1_PART        0x01
+#define CEC_OP_CHANNEL_NUMBER_FMT_2_PART        0x02
 
-#define CEC_MSG_RECORD_STATUS				0x0a
+#define CEC_MSG_RECORD_STATUS               0x0a
 /* Record Status Operand (rec_status) */
-#define CEC_OP_RECORD_STATUS_CUR_SRC			0x01
-#define CEC_OP_RECORD_STATUS_DIG_SERVICE		0x02
-#define CEC_OP_RECORD_STATUS_ANA_SERVICE		0x03
-#define CEC_OP_RECORD_STATUS_EXT_INPUT			0x04
-#define CEC_OP_RECORD_STATUS_NO_DIG_SERVICE		0x05
-#define CEC_OP_RECORD_STATUS_NO_ANA_SERVICE		0x06
-#define CEC_OP_RECORD_STATUS_NO_SERVICE			0x07
-#define CEC_OP_RECORD_STATUS_INVALID_EXT_PLUG		0x09
-#define CEC_OP_RECORD_STATUS_INVALID_EXT_PHYS_ADDR	0x0a
-#define CEC_OP_RECORD_STATUS_UNSUP_CA			0x0b
-#define CEC_OP_RECORD_STATUS_NO_CA_ENTITLEMENTS		0x0c
-#define CEC_OP_RECORD_STATUS_CANT_COPY_SRC		0x0d
-#define CEC_OP_RECORD_STATUS_NO_MORE_COPIES		0x0e
-#define CEC_OP_RECORD_STATUS_NO_MEDIA			0x10
-#define CEC_OP_RECORD_STATUS_PLAYING			0x11
-#define CEC_OP_RECORD_STATUS_ALREADY_RECORDING		0x12
-#define CEC_OP_RECORD_STATUS_MEDIA_PROT			0x13
-#define CEC_OP_RECORD_STATUS_NO_SIGNAL			0x14
-#define CEC_OP_RECORD_STATUS_MEDIA_PROBLEM		0x15
-#define CEC_OP_RECORD_STATUS_NO_SPACE			0x16
-#define CEC_OP_RECORD_STATUS_PARENTAL_LOCK		0x17
-#define CEC_OP_RECORD_STATUS_TERMINATED_OK		0x1a
-#define CEC_OP_RECORD_STATUS_ALREADY_TERM		0x1b
-#define CEC_OP_RECORD_STATUS_OTHER			0x1f
+#define CEC_OP_RECORD_STATUS_CUR_SRC            0x01
+#define CEC_OP_RECORD_STATUS_DIG_SERVICE        0x02
+#define CEC_OP_RECORD_STATUS_ANA_SERVICE        0x03
+#define CEC_OP_RECORD_STATUS_EXT_INPUT          0x04
+#define CEC_OP_RECORD_STATUS_NO_DIG_SERVICE     0x05
+#define CEC_OP_RECORD_STATUS_NO_ANA_SERVICE     0x06
+#define CEC_OP_RECORD_STATUS_NO_SERVICE         0x07
+#define CEC_OP_RECORD_STATUS_INVALID_EXT_PLUG       0x09
+#define CEC_OP_RECORD_STATUS_INVALID_EXT_PHYS_ADDR  0x0a
+#define CEC_OP_RECORD_STATUS_UNSUP_CA           0x0b
+#define CEC_OP_RECORD_STATUS_NO_CA_ENTITLEMENTS     0x0c
+#define CEC_OP_RECORD_STATUS_CANT_COPY_SRC      0x0d
+#define CEC_OP_RECORD_STATUS_NO_MORE_COPIES     0x0e
+#define CEC_OP_RECORD_STATUS_NO_MEDIA           0x10
+#define CEC_OP_RECORD_STATUS_PLAYING            0x11
+#define CEC_OP_RECORD_STATUS_ALREADY_RECORDING      0x12
+#define CEC_OP_RECORD_STATUS_MEDIA_PROT         0x13
+#define CEC_OP_RECORD_STATUS_NO_SIGNAL          0x14
+#define CEC_OP_RECORD_STATUS_MEDIA_PROBLEM      0x15
+#define CEC_OP_RECORD_STATUS_NO_SPACE           0x16
+#define CEC_OP_RECORD_STATUS_PARENTAL_LOCK      0x17
+#define CEC_OP_RECORD_STATUS_TERMINATED_OK      0x1a
+#define CEC_OP_RECORD_STATUS_ALREADY_TERM       0x1b
+#define CEC_OP_RECORD_STATUS_OTHER          0x1f
 
-#define CEC_MSG_RECORD_TV_SCREEN			0x0f
+#define CEC_MSG_RECORD_TV_SCREEN            0x0f
 
 
 /* Timer Programming Feature */
-#define CEC_MSG_CLEAR_ANALOGUE_TIMER			0x33
+#define CEC_MSG_CLEAR_ANALOGUE_TIMER            0x33
 /* Recording Sequence Operand (recording_seq) */
-#define CEC_OP_REC_SEQ_SUNDAY				0x01
-#define CEC_OP_REC_SEQ_MONDAY				0x02
-#define CEC_OP_REC_SEQ_TUESDAY				0x04
-#define CEC_OP_REC_SEQ_WEDNESDAY			0x08
-#define CEC_OP_REC_SEQ_THURSDAY				0x10
-#define CEC_OP_REC_SEQ_FRIDAY				0x20
-#define CEC_OP_REC_SEQ_SATERDAY				0x40
-#define CEC_OP_REC_SEQ_ONCE_ONLY			0x00
+#define CEC_OP_REC_SEQ_SUNDAY               0x01
+#define CEC_OP_REC_SEQ_MONDAY               0x02
+#define CEC_OP_REC_SEQ_TUESDAY              0x04
+#define CEC_OP_REC_SEQ_WEDNESDAY            0x08
+#define CEC_OP_REC_SEQ_THURSDAY             0x10
+#define CEC_OP_REC_SEQ_FRIDAY               0x20
+#define CEC_OP_REC_SEQ_SATERDAY             0x40
+#define CEC_OP_REC_SEQ_ONCE_ONLY            0x00
 
-#define CEC_MSG_CLEAR_DIGITAL_TIMER			0x99
+#define CEC_MSG_CLEAR_DIGITAL_TIMER         0x99
 
-#define CEC_MSG_CLEAR_EXT_TIMER				0xa1
+#define CEC_MSG_CLEAR_EXT_TIMER             0xa1
 /* External Source Specifier Operand (ext_src_spec) */
-#define CEC_OP_EXT_SRC_PLUG				0x04
-#define CEC_OP_EXT_SRC_PHYS_ADDR			0x05
+#define CEC_OP_EXT_SRC_PLUG             0x04
+#define CEC_OP_EXT_SRC_PHYS_ADDR            0x05
 
-#define CEC_MSG_SET_ANALOGUE_TIMER			0x34
-#define CEC_MSG_SET_DIGITAL_TIMER			0x97
-#define CEC_MSG_SET_EXT_TIMER				0xa2
+#define CEC_MSG_SET_ANALOGUE_TIMER          0x34
+#define CEC_MSG_SET_DIGITAL_TIMER           0x97
+#define CEC_MSG_SET_EXT_TIMER               0xa2
 
-#define CEC_MSG_SET_TIMER_PROGRAM_TITLE			0x67
-#define CEC_MSG_TIMER_CLEARED_STATUS			0x43
+#define CEC_MSG_SET_TIMER_PROGRAM_TITLE         0x67
+#define CEC_MSG_TIMER_CLEARED_STATUS            0x43
 /* Timer Cleared Status Data Operand (timer_cleared_status) */
-#define CEC_OP_TIMER_CLR_STAT_RECORDING			0x00
-#define CEC_OP_TIMER_CLR_STAT_NO_MATCHING		0x01
-#define CEC_OP_TIMER_CLR_STAT_NO_INFO			0x02
-#define CEC_OP_TIMER_CLR_STAT_CLEARED			0x80
+#define CEC_OP_TIMER_CLR_STAT_RECORDING         0x00
+#define CEC_OP_TIMER_CLR_STAT_NO_MATCHING       0x01
+#define CEC_OP_TIMER_CLR_STAT_NO_INFO           0x02
+#define CEC_OP_TIMER_CLR_STAT_CLEARED           0x80
 
-#define CEC_MSG_TIMER_STATUS				0x35
+#define CEC_MSG_TIMER_STATUS                0x35
 /* Timer Overlap Warning Operand (timer_overlap_warning) */
-#define CEC_OP_TIMER_OVERLAP_WARNING_NO_OVERLAP		0
-#define CEC_OP_TIMER_OVERLAP_WARNING_OVERLAP		1
+#define CEC_OP_TIMER_OVERLAP_WARNING_NO_OVERLAP     0
+#define CEC_OP_TIMER_OVERLAP_WARNING_OVERLAP        1
 /* Media Info Operand (media_info) */
-#define CEC_OP_MEDIA_INFO_UNPROT_MEDIA			0
-#define CEC_OP_MEDIA_INFO_PROT_MEDIA			1
-#define CEC_OP_MEDIA_INFO_NO_MEDIA			2
+#define CEC_OP_MEDIA_INFO_UNPROT_MEDIA          0
+#define CEC_OP_MEDIA_INFO_PROT_MEDIA            1
+#define CEC_OP_MEDIA_INFO_NO_MEDIA          2
 /* Programmed Indicator Operand (prog_indicator) */
-#define CEC_OP_PROG_IND_NOT_PROGRAMMED			0
-#define CEC_OP_PROG_IND_PROGRAMMED			1
+#define CEC_OP_PROG_IND_NOT_PROGRAMMED          0
+#define CEC_OP_PROG_IND_PROGRAMMED          1
 /* Programmed Info Operand (prog_info) */
-#define CEC_OP_PROG_INFO_ENOUGH_SPACE			0x08
-#define CEC_OP_PROG_INFO_NOT_ENOUGH_SPACE		0x09
-#define CEC_OP_PROG_INFO_MIGHT_NOT_BE_ENOUGH_SPACE	0x0b
-#define CEC_OP_PROG_INFO_NONE_AVAILABLE			0x0a
+#define CEC_OP_PROG_INFO_ENOUGH_SPACE           0x08
+#define CEC_OP_PROG_INFO_NOT_ENOUGH_SPACE       0x09
+#define CEC_OP_PROG_INFO_MIGHT_NOT_BE_ENOUGH_SPACE  0x0b
+#define CEC_OP_PROG_INFO_NONE_AVAILABLE         0x0a
 /* Not Programmed Error Info Operand (prog_error) */
-#define CEC_OP_PROG_ERROR_NO_FREE_TIMER			0x01
-#define CEC_OP_PROG_ERROR_DATE_OUT_OF_RANGE		0x02
-#define CEC_OP_PROG_ERROR_REC_SEQ_ERROR			0x03
-#define CEC_OP_PROG_ERROR_INV_EXT_PLUG			0x04
-#define CEC_OP_PROG_ERROR_INV_EXT_PHYS_ADDR		0x05
-#define CEC_OP_PROG_ERROR_CA_UNSUPP			0x06
-#define CEC_OP_PROG_ERROR_INSUF_CA_ENTITLEMENTS		0x07
-#define CEC_OP_PROG_ERROR_RESOLUTION_UNSUPP		0x08
-#define CEC_OP_PROG_ERROR_PARENTAL_LOCK			0x09
-#define CEC_OP_PROG_ERROR_CLOCK_FAILURE			0x0a
-#define CEC_OP_PROG_ERROR_DUPLICATE			0x0e
+#define CEC_OP_PROG_ERROR_NO_FREE_TIMER         0x01
+#define CEC_OP_PROG_ERROR_DATE_OUT_OF_RANGE     0x02
+#define CEC_OP_PROG_ERROR_REC_SEQ_ERROR         0x03
+#define CEC_OP_PROG_ERROR_INV_EXT_PLUG          0x04
+#define CEC_OP_PROG_ERROR_INV_EXT_PHYS_ADDR     0x05
+#define CEC_OP_PROG_ERROR_CA_UNSUPP         0x06
+#define CEC_OP_PROG_ERROR_INSUF_CA_ENTITLEMENTS     0x07
+#define CEC_OP_PROG_ERROR_RESOLUTION_UNSUPP     0x08
+#define CEC_OP_PROG_ERROR_PARENTAL_LOCK         0x09
+#define CEC_OP_PROG_ERROR_CLOCK_FAILURE         0x0a
+#define CEC_OP_PROG_ERROR_DUPLICATE         0x0e
 
 
 /* System Information Feature */
-#define CEC_MSG_CEC_VERSION				0x9e
+#define CEC_MSG_CEC_VERSION             0x9e
 /* CEC Version Operand (cec_version) */
-#define CEC_OP_CEC_VERSION_1_3A				4
-#define CEC_OP_CEC_VERSION_1_4				5
-#define CEC_OP_CEC_VERSION_2_0				6
-
-#define CEC_MSG_GET_CEC_VERSION				0x9f
-#define CEC_MSG_GIVE_PHYSICAL_ADDR			0x83
-#define CEC_MSG_GET_MENU_LANGUAGE			0x91
-#define CEC_MSG_REPORT_PHYSICAL_ADDR			0x84
+#define CEC_OP_CEC_VERSION_1_3A             4
+#define CEC_OP_CEC_VERSION_1_4              5
+#define CEC_OP_CEC_VERSION_2_0              6
+
+#define CEC_MSG_GET_CEC_VERSION             0x9f
+#define CEC_MSG_GIVE_PHYSICAL_ADDR          0x83
+#define CEC_MSG_GET_MENU_LANGUAGE           0x91
+#define CEC_MSG_REPORT_PHYSICAL_ADDR            0x84
 /* Primary Device Type Operand (prim_devtype) */
-#define CEC_OP_PRIM_DEVTYPE_TV				0
-#define CEC_OP_PRIM_DEVTYPE_RECORD			1
-#define CEC_OP_PRIM_DEVTYPE_TUNER			3
-#define CEC_OP_PRIM_DEVTYPE_PLAYBACK			4
-#define CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM			5
-#define CEC_OP_PRIM_DEVTYPE_SWITCH			6
-#define CEC_OP_PRIM_DEVTYPE_PROCESSOR			7
+#define CEC_OP_PRIM_DEVTYPE_TV              0
+#define CEC_OP_PRIM_DEVTYPE_RECORD          1
+#define CEC_OP_PRIM_DEVTYPE_TUNER           3
+#define CEC_OP_PRIM_DEVTYPE_PLAYBACK            4
+#define CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM         5
+#define CEC_OP_PRIM_DEVTYPE_SWITCH          6
+#define CEC_OP_PRIM_DEVTYPE_PROCESSOR           7
 
-#define CEC_MSG_SET_MENU_LANGUAGE			0x32
-#define CEC_MSG_REPORT_FEATURES				0xa6	/* HDMI 2.0 */
+#define CEC_MSG_SET_MENU_LANGUAGE           0x32
+#define CEC_MSG_REPORT_FEATURES             0xa6    /* HDMI 2.0 */
 /* All Device Types Operand (all_device_types) */
-#define CEC_OP_ALL_DEVTYPE_TV				0x80
-#define CEC_OP_ALL_DEVTYPE_RECORD			0x40
-#define CEC_OP_ALL_DEVTYPE_TUNER			0x20
-#define CEC_OP_ALL_DEVTYPE_PLAYBACK			0x10
-#define CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM			0x08
-#define CEC_OP_ALL_DEVTYPE_SWITCH			0x04
+#define CEC_OP_ALL_DEVTYPE_TV               0x80
+#define CEC_OP_ALL_DEVTYPE_RECORD           0x40
+#define CEC_OP_ALL_DEVTYPE_TUNER            0x20
+#define CEC_OP_ALL_DEVTYPE_PLAYBACK         0x10
+#define CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM          0x08
+#define CEC_OP_ALL_DEVTYPE_SWITCH           0x04
 /*
  * And if you wondering what happened to PROCESSOR devices: those should
  * be mapped to a SWITCH.
  */
 
 /* Valid for RC Profile and Device Feature operands */
-#define CEC_OP_FEAT_EXT					0x80	/* Extension bit */
+#define CEC_OP_FEAT_EXT                 0x80    /* Extension bit */
 /* RC Profile Operand (rc_profile) */
-#define CEC_OP_FEAT_RC_TV_PROFILE_NONE			0x00
-#define CEC_OP_FEAT_RC_TV_PROFILE_1			0x02
-#define CEC_OP_FEAT_RC_TV_PROFILE_2			0x06
-#define CEC_OP_FEAT_RC_TV_PROFILE_3			0x0a
-#define CEC_OP_FEAT_RC_TV_PROFILE_4			0x0e
-#define CEC_OP_FEAT_RC_SRC_HAS_DEV_ROOT_MENU		0x50
-#define CEC_OP_FEAT_RC_SRC_HAS_DEV_SETUP_MENU		0x48
-#define CEC_OP_FEAT_RC_SRC_HAS_CONTENTS_MENU		0x44
-#define CEC_OP_FEAT_RC_SRC_HAS_MEDIA_TOP_MENU		0x42
-#define CEC_OP_FEAT_RC_SRC_HAS_MEDIA_CONTEXT_MENU	0x41
+#define CEC_OP_FEAT_RC_TV_PROFILE_NONE          0x00
+#define CEC_OP_FEAT_RC_TV_PROFILE_1         0x02
+#define CEC_OP_FEAT_RC_TV_PROFILE_2         0x06
+#define CEC_OP_FEAT_RC_TV_PROFILE_3         0x0a
+#define CEC_OP_FEAT_RC_TV_PROFILE_4         0x0e
+#define CEC_OP_FEAT_RC_SRC_HAS_DEV_ROOT_MENU        0x50
+#define CEC_OP_FEAT_RC_SRC_HAS_DEV_SETUP_MENU       0x48
+#define CEC_OP_FEAT_RC_SRC_HAS_CONTENTS_MENU        0x44
+#define CEC_OP_FEAT_RC_SRC_HAS_MEDIA_TOP_MENU       0x42
+#define CEC_OP_FEAT_RC_SRC_HAS_MEDIA_CONTEXT_MENU   0x41
 /* Device Feature Operand (dev_features) */
-#define CEC_OP_FEAT_DEV_HAS_RECORD_TV_SCREEN		0x40
-#define CEC_OP_FEAT_DEV_HAS_SET_OSD_STRING		0x20
-#define CEC_OP_FEAT_DEV_HAS_DECK_CONTROL		0x10
-#define CEC_OP_FEAT_DEV_HAS_SET_AUDIO_RATE		0x08
-#define CEC_OP_FEAT_DEV_SINK_HAS_ARC_TX			0x04
-#define CEC_OP_FEAT_DEV_SOURCE_HAS_ARC_RX		0x02
+#define CEC_OP_FEAT_DEV_HAS_RECORD_TV_SCREEN        0x40
+#define CEC_OP_FEAT_DEV_HAS_SET_OSD_STRING      0x20
+#define CEC_OP_FEAT_DEV_HAS_DECK_CONTROL        0x10
+#define CEC_OP_FEAT_DEV_HAS_SET_AUDIO_RATE      0x08
+#define CEC_OP_FEAT_DEV_SINK_HAS_ARC_TX         0x04
+#define CEC_OP_FEAT_DEV_SOURCE_HAS_ARC_RX       0x02
 
-#define CEC_MSG_GIVE_FEATURES				0xa5	/* HDMI 2.0 */
+#define CEC_MSG_GIVE_FEATURES               0xa5    /* HDMI 2.0 */
 
 
 /* Deck Control Feature */
-#define CEC_MSG_DECK_CONTROL				0x42
+#define CEC_MSG_DECK_CONTROL                0x42
 /* Deck Control Mode Operand (deck_control_mode) */
-#define CEC_OP_DECK_CTL_MODE_SKIP_FWD			1
-#define CEC_OP_DECK_CTL_MODE_SKIP_REV			2
-#define CEC_OP_DECK_CTL_MODE_STOP			3
-#define CEC_OP_DECK_CTL_MODE_EJECT			4
+#define CEC_OP_DECK_CTL_MODE_SKIP_FWD           1
+#define CEC_OP_DECK_CTL_MODE_SKIP_REV           2
+#define CEC_OP_DECK_CTL_MODE_STOP           3
+#define CEC_OP_DECK_CTL_MODE_EJECT          4
 
-#define CEC_MSG_DECK_STATUS				0x1b
+#define CEC_MSG_DECK_STATUS             0x1b
 /* Deck Info Operand (deck_info) */
-#define CEC_OP_DECK_INFO_PLAY				0x11
-#define CEC_OP_DECK_INFO_RECORD				0x12
-#define CEC_OP_DECK_INFO_PLAY_REV			0x13
-#define CEC_OP_DECK_INFO_STILL				0x14
-#define CEC_OP_DECK_INFO_SLOW				0x15
-#define CEC_OP_DECK_INFO_SLOW_REV			0x16
-#define CEC_OP_DECK_INFO_FAST_FWD			0x17
-#define CEC_OP_DECK_INFO_FAST_REV			0x18
-#define CEC_OP_DECK_INFO_NO_MEDIA			0x19
-#define CEC_OP_DECK_INFO_STOP				0x1a
-#define CEC_OP_DECK_INFO_SKIP_FWD			0x1b
-#define CEC_OP_DECK_INFO_SKIP_REV			0x1c
-#define CEC_OP_DECK_INFO_INDEX_SEARCH_FWD		0x1d
-#define CEC_OP_DECK_INFO_INDEX_SEARCH_REV		0x1e
-#define CEC_OP_DECK_INFO_OTHER				0x1f
+#define CEC_OP_DECK_INFO_PLAY               0x11
+#define CEC_OP_DECK_INFO_RECORD             0x12
+#define CEC_OP_DECK_INFO_PLAY_REV           0x13
+#define CEC_OP_DECK_INFO_STILL              0x14
+#define CEC_OP_DECK_INFO_SLOW               0x15
+#define CEC_OP_DECK_INFO_SLOW_REV           0x16
+#define CEC_OP_DECK_INFO_FAST_FWD           0x17
+#define CEC_OP_DECK_INFO_FAST_REV           0x18
+#define CEC_OP_DECK_INFO_NO_MEDIA           0x19
+#define CEC_OP_DECK_INFO_STOP               0x1a
+#define CEC_OP_DECK_INFO_SKIP_FWD           0x1b
+#define CEC_OP_DECK_INFO_SKIP_REV           0x1c
+#define CEC_OP_DECK_INFO_INDEX_SEARCH_FWD       0x1d
+#define CEC_OP_DECK_INFO_INDEX_SEARCH_REV       0x1e
+#define CEC_OP_DECK_INFO_OTHER              0x1f
 
-#define CEC_MSG_GIVE_DECK_STATUS			0x1a
+#define CEC_MSG_GIVE_DECK_STATUS            0x1a
 /* Status Request Operand (status_req) */
-#define CEC_OP_STATUS_REQ_ON				1
-#define CEC_OP_STATUS_REQ_OFF				2
-#define CEC_OP_STATUS_REQ_ONCE				3
+#define CEC_OP_STATUS_REQ_ON                1
+#define CEC_OP_STATUS_REQ_OFF               2
+#define CEC_OP_STATUS_REQ_ONCE              3
 
-#define CEC_MSG_PLAY					0x41
+#define CEC_MSG_PLAY                    0x41
 /* Play Mode Operand (play_mode) */
-#define CEC_OP_PLAY_MODE_PLAY_FWD			0x24
-#define CEC_OP_PLAY_MODE_PLAY_REV			0x20
-#define CEC_OP_PLAY_MODE_PLAY_STILL			0x25
-#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MIN		0x05
-#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MED		0x06
-#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MAX		0x07
-#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MIN		0x09
-#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MED		0x0a
-#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MAX		0x0b
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MIN		0x15
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MED		0x16
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MAX		0x17
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MIN		0x19
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MED		0x1a
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MAX		0x1b
+#define CEC_OP_PLAY_MODE_PLAY_FWD           0x24
+#define CEC_OP_PLAY_MODE_PLAY_REV           0x20
+#define CEC_OP_PLAY_MODE_PLAY_STILL         0x25
+#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MIN      0x05
+#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MED      0x06
+#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MAX      0x07
+#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MIN      0x09
+#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MED      0x0a
+#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MAX      0x0b
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MIN      0x15
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MED      0x16
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MAX      0x17
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MIN      0x19
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MED      0x1a
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MAX      0x1b
 
 
 /* Tuner Control Feature */
-#define CEC_MSG_GIVE_TUNER_DEVICE_STATUS		0x08
-#define CEC_MSG_SELECT_ANALOGUE_SERVICE			0x92
-#define CEC_MSG_SELECT_DIGITAL_SERVICE			0x93
-#define CEC_MSG_TUNER_DEVICE_STATUS			0x07
+#define CEC_MSG_GIVE_TUNER_DEVICE_STATUS        0x08
+#define CEC_MSG_SELECT_ANALOGUE_SERVICE         0x92
+#define CEC_MSG_SELECT_DIGITAL_SERVICE          0x93
+#define CEC_MSG_TUNER_DEVICE_STATUS         0x07
 /* Recording Flag Operand (rec_flag) */
-#define CEC_OP_REC_FLAG_USED				0
-#define CEC_OP_REC_FLAG_NOT_USED			1
+#define CEC_OP_REC_FLAG_USED                0
+#define CEC_OP_REC_FLAG_NOT_USED            1
 /* Tuner Display Info Operand (tuner_display_info) */
-#define CEC_OP_TUNER_DISPLAY_INFO_DIGITAL		0
-#define CEC_OP_TUNER_DISPLAY_INFO_NONE			1
-#define CEC_OP_TUNER_DISPLAY_INFO_ANALOGUE		2
+#define CEC_OP_TUNER_DISPLAY_INFO_DIGITAL       0
+#define CEC_OP_TUNER_DISPLAY_INFO_NONE          1
+#define CEC_OP_TUNER_DISPLAY_INFO_ANALOGUE      2
 
-#define CEC_MSG_TUNER_STEP_DECREMENT			0x06
-#define CEC_MSG_TUNER_STEP_INCREMENT			0x05
+#define CEC_MSG_TUNER_STEP_DECREMENT            0x06
+#define CEC_MSG_TUNER_STEP_INCREMENT            0x05
 
 
 /* Vendor Specific Commands Feature */
 
 /*
  * Has also:
- *	CEC_MSG_CEC_VERSION
- *	CEC_MSG_GET_CEC_VERSION
+ *  CEC_MSG_CEC_VERSION
+ *  CEC_MSG_GET_CEC_VERSION
  */
-#define CEC_MSG_DEVICE_VENDOR_ID			0x87
-#define CEC_MSG_GIVE_DEVICE_VENDOR_ID			0x8c
-#define CEC_MSG_VENDOR_COMMAND				0x89
-#define CEC_MSG_VENDOR_COMMAND_WITH_ID			0xa0
-#define CEC_MSG_VENDOR_REMOTE_BUTTON_DOWN		0x8a
-#define CEC_MSG_VENDOR_REMOTE_BUTTON_UP			0x8b
+#define CEC_MSG_DEVICE_VENDOR_ID            0x87
+#define CEC_MSG_GIVE_DEVICE_VENDOR_ID           0x8c
+#define CEC_MSG_VENDOR_COMMAND              0x89
+#define CEC_MSG_VENDOR_COMMAND_WITH_ID          0xa0
+#define CEC_MSG_VENDOR_REMOTE_BUTTON_DOWN       0x8a
+#define CEC_MSG_VENDOR_REMOTE_BUTTON_UP         0x8b
 
 
 /* OSD Display Feature */
-#define CEC_MSG_SET_OSD_STRING				0x64
+#define CEC_MSG_SET_OSD_STRING              0x64
 /* Display Control Operand (disp_ctl) */
-#define CEC_OP_DISP_CTL_DEFAULT				0x00
-#define CEC_OP_DISP_CTL_UNTIL_CLEARED			0x40
-#define CEC_OP_DISP_CTL_CLEAR				0x80
+#define CEC_OP_DISP_CTL_DEFAULT             0x00
+#define CEC_OP_DISP_CTL_UNTIL_CLEARED           0x40
+#define CEC_OP_DISP_CTL_CLEAR               0x80
 
 
 /* Device OSD Transfer Feature */
-#define CEC_MSG_GIVE_OSD_NAME				0x46
-#define CEC_MSG_SET_OSD_NAME				0x47
+#define CEC_MSG_GIVE_OSD_NAME               0x46
+#define CEC_MSG_SET_OSD_NAME                0x47
 
 
 /* Device Menu Control Feature */
-#define CEC_MSG_MENU_REQUEST				0x8d
+#define CEC_MSG_MENU_REQUEST                0x8d
 /* Menu Request Type Operand (menu_req) */
-#define CEC_OP_MENU_REQUEST_ACTIVATE			0x00
-#define CEC_OP_MENU_REQUEST_DEACTIVATE			0x01
-#define CEC_OP_MENU_REQUEST_QUERY			0x02
+#define CEC_OP_MENU_REQUEST_ACTIVATE            0x00
+#define CEC_OP_MENU_REQUEST_DEACTIVATE          0x01
+#define CEC_OP_MENU_REQUEST_QUERY           0x02
 
-#define CEC_MSG_MENU_STATUS				0x8e
+#define CEC_MSG_MENU_STATUS             0x8e
 /* Menu State Operand (menu_state) */
-#define CEC_OP_MENU_STATE_ACTIVATED			0x00
-#define CEC_OP_MENU_STATE_DEACTIVATED			0x01
+#define CEC_OP_MENU_STATE_ACTIVATED         0x00
+#define CEC_OP_MENU_STATE_DEACTIVATED           0x01
 
-#define CEC_MSG_USER_CONTROL_PRESSED			0x44
+#define CEC_MSG_USER_CONTROL_PRESSED            0x44
 /* UI Broadcast Type Operand (ui_bcast_type) */
-#define CEC_OP_UI_BCAST_TYPE_TOGGLE_ALL			0x00
-#define CEC_OP_UI_BCAST_TYPE_TOGGLE_DIG_ANA		0x01
-#define CEC_OP_UI_BCAST_TYPE_ANALOGUE			0x10
-#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_T			0x20
-#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_CABLE		0x30
-#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_SAT		0x40
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL			0x50
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL_T			0x60
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL_CABLE		0x70
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL_SAT		0x80
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL_COM_SAT		0x90
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL_COM_SAT2		0x91
-#define CEC_OP_UI_BCAST_TYPE_IP				0xa0
+#define CEC_OP_UI_BCAST_TYPE_TOGGLE_ALL         0x00
+#define CEC_OP_UI_BCAST_TYPE_TOGGLE_DIG_ANA     0x01
+#define CEC_OP_UI_BCAST_TYPE_ANALOGUE           0x10
+#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_T         0x20
+#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_CABLE     0x30
+#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_SAT       0x40
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL            0x50
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL_T          0x60
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL_CABLE      0x70
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL_SAT        0x80
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL_COM_SAT        0x90
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL_COM_SAT2       0x91
+#define CEC_OP_UI_BCAST_TYPE_IP             0xa0
 /* UI Sound Presentation Control Operand (ui_snd_pres_ctl) */
-#define CEC_OP_UI_SND_PRES_CTL_DUAL_MONO		0x10
-#define CEC_OP_UI_SND_PRES_CTL_KARAOKE			0x20
-#define CEC_OP_UI_SND_PRES_CTL_DOWNMIX			0x80
-#define CEC_OP_UI_SND_PRES_CTL_REVERB			0x90
-#define CEC_OP_UI_SND_PRES_CTL_EQUALIZER		0xa0
-#define CEC_OP_UI_SND_PRES_CTL_BASS_UP			0xb1
-#define CEC_OP_UI_SND_PRES_CTL_BASS_NEUTRAL		0xb2
-#define CEC_OP_UI_SND_PRES_CTL_BASS_DOWN		0xb3
-#define CEC_OP_UI_SND_PRES_CTL_TREBLE_UP		0xc1
-#define CEC_OP_UI_SND_PRES_CTL_TREBLE_NEUTRAL		0xc2
-#define CEC_OP_UI_SND_PRES_CTL_TREBLE_DOWN		0xc3
+#define CEC_OP_UI_SND_PRES_CTL_DUAL_MONO        0x10
+#define CEC_OP_UI_SND_PRES_CTL_KARAOKE          0x20
+#define CEC_OP_UI_SND_PRES_CTL_DOWNMIX          0x80
+#define CEC_OP_UI_SND_PRES_CTL_REVERB           0x90
+#define CEC_OP_UI_SND_PRES_CTL_EQUALIZER        0xa0
+#define CEC_OP_UI_SND_PRES_CTL_BASS_UP          0xb1
+#define CEC_OP_UI_SND_PRES_CTL_BASS_NEUTRAL     0xb2
+#define CEC_OP_UI_SND_PRES_CTL_BASS_DOWN        0xb3
+#define CEC_OP_UI_SND_PRES_CTL_TREBLE_UP        0xc1
+#define CEC_OP_UI_SND_PRES_CTL_TREBLE_NEUTRAL       0xc2
+#define CEC_OP_UI_SND_PRES_CTL_TREBLE_DOWN      0xc3
 
-#define CEC_MSG_USER_CONTROL_RELEASED			0x45
+#define CEC_MSG_USER_CONTROL_RELEASED           0x45
 
 
 /* Remote Control Passthrough Feature */
 
 /*
  * Has also:
- *	CEC_MSG_USER_CONTROL_PRESSED
- *	CEC_MSG_USER_CONTROL_RELEASED
+ *  CEC_MSG_USER_CONTROL_PRESSED
+ *  CEC_MSG_USER_CONTROL_RELEASED
  */
 
 
 /* Power Status Feature */
-#define CEC_MSG_GIVE_DEVICE_POWER_STATUS		0x8f
-#define CEC_MSG_REPORT_POWER_STATUS			0x90
+#define CEC_MSG_GIVE_DEVICE_POWER_STATUS        0x8f
+#define CEC_MSG_REPORT_POWER_STATUS         0x90
 /* Power Status Operand (pwr_state) */
-#define CEC_OP_POWER_STATUS_ON				0
-#define CEC_OP_POWER_STATUS_STANDBY			1
-#define CEC_OP_POWER_STATUS_TO_ON			2
-#define CEC_OP_POWER_STATUS_TO_STANDBY			3
+#define CEC_OP_POWER_STATUS_ON              0
+#define CEC_OP_POWER_STATUS_STANDBY         1
+#define CEC_OP_POWER_STATUS_TO_ON           2
+#define CEC_OP_POWER_STATUS_TO_STANDBY          3
 
 
 /* General Protocol Messages */
-#define CEC_MSG_FEATURE_ABORT				0x00
+#define CEC_MSG_FEATURE_ABORT               0x00
 /* Abort Reason Operand (reason) */
-#define CEC_OP_ABORT_UNRECOGNIZED_OP			0
-#define CEC_OP_ABORT_INCORRECT_MODE			1
-#define CEC_OP_ABORT_NO_SOURCE				2
-#define CEC_OP_ABORT_INVALID_OP				3
-#define CEC_OP_ABORT_REFUSED				4
-#define CEC_OP_ABORT_UNDETERMINED			5
+#define CEC_OP_ABORT_UNRECOGNIZED_OP            0
+#define CEC_OP_ABORT_INCORRECT_MODE         1
+#define CEC_OP_ABORT_NO_SOURCE              2
+#define CEC_OP_ABORT_INVALID_OP             3
+#define CEC_OP_ABORT_REFUSED                4
+#define CEC_OP_ABORT_UNDETERMINED           5
 
-#define CEC_MSG_ABORT					0xff
+#define CEC_MSG_ABORT                   0xff
 
 
 /* System Audio Control Feature */
 
 /*
  * Has also:
- *	CEC_MSG_USER_CONTROL_PRESSED
- *	CEC_MSG_USER_CONTROL_RELEASED
+ *  CEC_MSG_USER_CONTROL_PRESSED
+ *  CEC_MSG_USER_CONTROL_RELEASED
  */
-#define CEC_MSG_GIVE_AUDIO_STATUS			0x71
-#define CEC_MSG_GIVE_SYSTEM_AUDIO_MODE_STATUS		0x7d
-#define CEC_MSG_REPORT_AUDIO_STATUS			0x7a
+#define CEC_MSG_GIVE_AUDIO_STATUS           0x71
+#define CEC_MSG_GIVE_SYSTEM_AUDIO_MODE_STATUS       0x7d
+#define CEC_MSG_REPORT_AUDIO_STATUS         0x7a
 /* Audio Mute Status Operand (aud_mute_status) */
-#define CEC_OP_AUD_MUTE_STATUS_OFF			0
-#define CEC_OP_AUD_MUTE_STATUS_ON			1
+#define CEC_OP_AUD_MUTE_STATUS_OFF          0
+#define CEC_OP_AUD_MUTE_STATUS_ON           1
 
-#define CEC_MSG_REPORT_SHORT_AUDIO_DESCRIPTOR		0xa3
-#define CEC_MSG_REQUEST_SHORT_AUDIO_DESCRIPTOR		0xa4
-#define CEC_MSG_SET_SYSTEM_AUDIO_MODE			0x72
+#define CEC_MSG_REPORT_SHORT_AUDIO_DESCRIPTOR       0xa3
+#define CEC_MSG_REQUEST_SHORT_AUDIO_DESCRIPTOR      0xa4
+#define CEC_MSG_SET_SYSTEM_AUDIO_MODE           0x72
 /* System Audio Status Operand (sys_aud_status) */
-#define CEC_OP_SYS_AUD_STATUS_OFF			0
-#define CEC_OP_SYS_AUD_STATUS_ON			1
+#define CEC_OP_SYS_AUD_STATUS_OFF           0
+#define CEC_OP_SYS_AUD_STATUS_ON            1
 
-#define CEC_MSG_SYSTEM_AUDIO_MODE_REQUEST		0x70
-#define CEC_MSG_SYSTEM_AUDIO_MODE_STATUS		0x7e
+#define CEC_MSG_SYSTEM_AUDIO_MODE_REQUEST       0x70
+#define CEC_MSG_SYSTEM_AUDIO_MODE_STATUS        0x7e
 /* Audio Format ID Operand (audio_format_id) */
-#define CEC_OP_AUD_FMT_ID_CEA861			0
-#define CEC_OP_AUD_FMT_ID_CEA861_CXT			1
+#define CEC_OP_AUD_FMT_ID_CEA861            0
+#define CEC_OP_AUD_FMT_ID_CEA861_CXT            1
 
 
 /* Audio Rate Control Feature */
-#define CEC_MSG_SET_AUDIO_RATE				0x9a
+#define CEC_MSG_SET_AUDIO_RATE              0x9a
 /* Audio Rate Operand (audio_rate) */
-#define CEC_OP_AUD_RATE_OFF				0
-#define CEC_OP_AUD_RATE_WIDE_STD			1
-#define CEC_OP_AUD_RATE_WIDE_FAST			2
-#define CEC_OP_AUD_RATE_WIDE_SLOW			3
-#define CEC_OP_AUD_RATE_NARROW_STD			4
-#define CEC_OP_AUD_RATE_NARROW_FAST			5
-#define CEC_OP_AUD_RATE_NARROW_SLOW			6
+#define CEC_OP_AUD_RATE_OFF             0
+#define CEC_OP_AUD_RATE_WIDE_STD            1
+#define CEC_OP_AUD_RATE_WIDE_FAST           2
+#define CEC_OP_AUD_RATE_WIDE_SLOW           3
+#define CEC_OP_AUD_RATE_NARROW_STD          4
+#define CEC_OP_AUD_RATE_NARROW_FAST         5
+#define CEC_OP_AUD_RATE_NARROW_SLOW         6
 
 
 /* Audio Return Channel Control Feature */
-#define CEC_MSG_INITIATE_ARC				0xc0
-#define CEC_MSG_REPORT_ARC_INITIATED			0xc1
-#define CEC_MSG_REPORT_ARC_TERMINATED			0xc2
-#define CEC_MSG_REQUEST_ARC_INITIATION			0xc3
-#define CEC_MSG_REQUEST_ARC_TERMINATION			0xc4
-#define CEC_MSG_TERMINATE_ARC				0xc5
+#define CEC_MSG_INITIATE_ARC                0xc0
+#define CEC_MSG_REPORT_ARC_INITIATED            0xc1
+#define CEC_MSG_REPORT_ARC_TERMINATED           0xc2
+#define CEC_MSG_REQUEST_ARC_INITIATION          0xc3
+#define CEC_MSG_REQUEST_ARC_TERMINATION         0xc4
+#define CEC_MSG_TERMINATE_ARC               0xc5
 
 
 /* Dynamic Audio Lipsync Feature */
 /* Only for CEC 2.0 and up */
-#define CEC_MSG_REQUEST_CURRENT_LATENCY			0xa7
-#define CEC_MSG_REPORT_CURRENT_LATENCY			0xa8
+#define CEC_MSG_REQUEST_CURRENT_LATENCY         0xa7
+#define CEC_MSG_REPORT_CURRENT_LATENCY          0xa8
 /* Low Latency Mode Operand (low_latency_mode) */
-#define CEC_OP_LOW_LATENCY_MODE_OFF			0
-#define CEC_OP_LOW_LATENCY_MODE_ON			1
+#define CEC_OP_LOW_LATENCY_MODE_OFF         0
+#define CEC_OP_LOW_LATENCY_MODE_ON          1
 /* Audio Output Compensated Operand (audio_out_compensated) */
-#define CEC_OP_AUD_OUT_COMPENSATED_NA			0
-#define CEC_OP_AUD_OUT_COMPENSATED_DELAY		1
-#define CEC_OP_AUD_OUT_COMPENSATED_NO_DELAY		2
-#define CEC_OP_AUD_OUT_COMPENSATED_PARTIAL_DELAY	3
+#define CEC_OP_AUD_OUT_COMPENSATED_NA           0
+#define CEC_OP_AUD_OUT_COMPENSATED_DELAY        1
+#define CEC_OP_AUD_OUT_COMPENSATED_NO_DELAY     2
+#define CEC_OP_AUD_OUT_COMPENSATED_PARTIAL_DELAY    3
 
 
 /* Capability Discovery and Control Feature */
-#define CEC_MSG_CDC_MESSAGE				0xf8
+#define CEC_MSG_CDC_MESSAGE             0xf8
 /* Ethernet-over-HDMI: nobody ever does this... */
-#define CEC_MSG_CDC_HEC_INQUIRE_STATE			0x00
-#define CEC_MSG_CDC_HEC_REPORT_STATE			0x01
+#define CEC_MSG_CDC_HEC_INQUIRE_STATE           0x00
+#define CEC_MSG_CDC_HEC_REPORT_STATE            0x01
 /* HEC Functionality State Operand (hec_func_state) */
-#define CEC_OP_HEC_FUNC_STATE_NOT_SUPPORTED		0
-#define CEC_OP_HEC_FUNC_STATE_INACTIVE			1
-#define CEC_OP_HEC_FUNC_STATE_ACTIVE			2
-#define CEC_OP_HEC_FUNC_STATE_ACTIVATION_FIELD		3
+#define CEC_OP_HEC_FUNC_STATE_NOT_SUPPORTED     0
+#define CEC_OP_HEC_FUNC_STATE_INACTIVE          1
+#define CEC_OP_HEC_FUNC_STATE_ACTIVE            2
+#define CEC_OP_HEC_FUNC_STATE_ACTIVATION_FIELD      3
 /* Host Functionality State Operand (host_func_state) */
-#define CEC_OP_HOST_FUNC_STATE_NOT_SUPPORTED		0
-#define CEC_OP_HOST_FUNC_STATE_INACTIVE			1
-#define CEC_OP_HOST_FUNC_STATE_ACTIVE			2
+#define CEC_OP_HOST_FUNC_STATE_NOT_SUPPORTED        0
+#define CEC_OP_HOST_FUNC_STATE_INACTIVE         1
+#define CEC_OP_HOST_FUNC_STATE_ACTIVE           2
 /* ENC Functionality State Operand (enc_func_state) */
-#define CEC_OP_ENC_FUNC_STATE_EXT_CON_NOT_SUPPORTED	0
-#define CEC_OP_ENC_FUNC_STATE_EXT_CON_INACTIVE		1
-#define CEC_OP_ENC_FUNC_STATE_EXT_CON_ACTIVE		2
+#define CEC_OP_ENC_FUNC_STATE_EXT_CON_NOT_SUPPORTED 0
+#define CEC_OP_ENC_FUNC_STATE_EXT_CON_INACTIVE      1
+#define CEC_OP_ENC_FUNC_STATE_EXT_CON_ACTIVE        2
 /* CDC Error Code Operand (cdc_errcode) */
-#define CEC_OP_CDC_ERROR_CODE_NONE			0
-#define CEC_OP_CDC_ERROR_CODE_CAP_UNSUPPORTED		1
-#define CEC_OP_CDC_ERROR_CODE_WRONG_STATE		2
-#define CEC_OP_CDC_ERROR_CODE_OTHER			3
+#define CEC_OP_CDC_ERROR_CODE_NONE          0
+#define CEC_OP_CDC_ERROR_CODE_CAP_UNSUPPORTED       1
+#define CEC_OP_CDC_ERROR_CODE_WRONG_STATE       2
+#define CEC_OP_CDC_ERROR_CODE_OTHER         3
 /* HEC Support Operand (hec_support) */
-#define CEC_OP_HEC_SUPPORT_NO				0
-#define CEC_OP_HEC_SUPPORT_YES				1
+#define CEC_OP_HEC_SUPPORT_NO               0
+#define CEC_OP_HEC_SUPPORT_YES              1
 /* HEC Activation Operand (hec_activation) */
-#define CEC_OP_HEC_ACTIVATION_ON			0
-#define CEC_OP_HEC_ACTIVATION_OFF			1
+#define CEC_OP_HEC_ACTIVATION_ON            0
+#define CEC_OP_HEC_ACTIVATION_OFF           1
 
-#define CEC_MSG_CDC_HEC_SET_STATE_ADJACENT		0x02
-#define CEC_MSG_CDC_HEC_SET_STATE			0x03
+#define CEC_MSG_CDC_HEC_SET_STATE_ADJACENT      0x02
+#define CEC_MSG_CDC_HEC_SET_STATE           0x03
 /* HEC Set State Operand (hec_set_state) */
-#define CEC_OP_HEC_SET_STATE_DEACTIVATE			0
-#define CEC_OP_HEC_SET_STATE_ACTIVATE			1
+#define CEC_OP_HEC_SET_STATE_DEACTIVATE         0
+#define CEC_OP_HEC_SET_STATE_ACTIVATE           1
 
-#define CEC_MSG_CDC_HEC_REQUEST_DEACTIVATION		0x04
-#define CEC_MSG_CDC_HEC_NOTIFY_ALIVE			0x05
-#define CEC_MSG_CDC_HEC_DISCOVER			0x06
+#define CEC_MSG_CDC_HEC_REQUEST_DEACTIVATION        0x04
+#define CEC_MSG_CDC_HEC_NOTIFY_ALIVE            0x05
+#define CEC_MSG_CDC_HEC_DISCOVER            0x06
 /* Hotplug Detect messages */
-#define CEC_MSG_CDC_HPD_SET_STATE			0x10
+#define CEC_MSG_CDC_HPD_SET_STATE           0x10
 /* HPD State Operand (hpd_state) */
-#define CEC_OP_HPD_STATE_CP_EDID_DISABLE		0
-#define CEC_OP_HPD_STATE_CP_EDID_ENABLE			1
-#define CEC_OP_HPD_STATE_CP_EDID_DISABLE_ENABLE		2
-#define CEC_OP_HPD_STATE_EDID_DISABLE			3
-#define CEC_OP_HPD_STATE_EDID_ENABLE			4
-#define CEC_OP_HPD_STATE_EDID_DISABLE_ENABLE		5
-#define CEC_MSG_CDC_HPD_REPORT_STATE			0x11
+#define CEC_OP_HPD_STATE_CP_EDID_DISABLE        0
+#define CEC_OP_HPD_STATE_CP_EDID_ENABLE         1
+#define CEC_OP_HPD_STATE_CP_EDID_DISABLE_ENABLE     2
+#define CEC_OP_HPD_STATE_EDID_DISABLE           3
+#define CEC_OP_HPD_STATE_EDID_ENABLE            4
+#define CEC_OP_HPD_STATE_EDID_DISABLE_ENABLE        5
+#define CEC_MSG_CDC_HPD_REPORT_STATE            0x11
 /* HPD Error Code Operand (hpd_error) */
-#define CEC_OP_HPD_ERROR_NONE				0
-#define CEC_OP_HPD_ERROR_INITIATOR_NOT_CAPABLE		1
-#define CEC_OP_HPD_ERROR_INITIATOR_WRONG_STATE		2
-#define CEC_OP_HPD_ERROR_OTHER				3
-#define CEC_OP_HPD_ERROR_NONE_NO_VIDEO			4
+#define CEC_OP_HPD_ERROR_NONE               0
+#define CEC_OP_HPD_ERROR_INITIATOR_NOT_CAPABLE      1
+#define CEC_OP_HPD_ERROR_INITIATOR_WRONG_STATE      2
+#define CEC_OP_HPD_ERROR_OTHER              3
+#define CEC_OP_HPD_ERROR_NONE_NO_VIDEO          4
 
 #endif
diff -Nur libstb-hal-ddt.git.orig/libarmbox/playback_gst.cpp libstb-hal-ddt.git/libarmbox/playback_gst.cpp
--- libstb-hal-ddt.git.orig/libarmbox/playback_gst.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libarmbox/playback_gst.cpp	2022-07-23 18:18:31.499773109 +0200
@@ -41,9 +41,9 @@
 #define hal_debug_c(args...) _hal_debug(HAL_DEBUG_PLAYBACK, NULL, args)
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_PLAYBACK, NULL, args)
 
-static const char * FILENAME = "[playback_gst.cpp]";
-extern cVideo * videoDecoder;
-extern cAudio * audioDecoder;
+static const char *FILENAME = "[playback_gst.cpp]";
+extern cVideo *videoDecoder;
+extern cAudio *audioDecoder;
 
 #include <gst/gst.h>
 #include <gst/tag/tag.h>
@@ -67,11 +67,11 @@
 } GstPlayFlags;
 
 
-GstElement * m_gst_playbin = NULL;
-GstElement * audioSink = NULL;
-GstElement * videoSink = NULL;
-gchar * uri = NULL;
-GstTagList * m_stream_tags = NULL;
+GstElement *m_gst_playbin = NULL;
+GstElement *audioSink = NULL;
+GstElement *videoSink = NULL;
+gchar *uri = NULL;
+GstTagList *m_stream_tags = NULL;
 pthread_mutex_t mutex_tag_ist;
 
 static int end_eof = 0;
@@ -88,21 +88,25 @@
 
 void resetPids()
 {
-	for (unsigned int i = 0; i < REC_MAX_APIDS; i++) {
+	for (unsigned int i = 0; i < REC_MAX_APIDS; i++)
+	{
 		real_apids[i] = 0;
 	}
 }
 
-void processMpegTsSection(GstMpegtsSection* section)
+void processMpegTsSection(GstMpegtsSection *section)
 {
 	resetPids();
 	int cnt = 0;
-    if (section->section_type == GST_MPEGTS_SECTION_PMT) {
-        const GstMpegtsPMT* pmt = gst_mpegts_section_get_pmt(section);
-        for (guint i = 0; i < pmt->streams->len; ++i) {
-            const GstMpegtsPMTStream* stream = static_cast<const GstMpegtsPMTStream*>(g_ptr_array_index(pmt->streams, i));
-			if (stream->stream_type == 0x05 || stream->stream_type >= 0x80) {
-				hal_info_c( "%s:%s Audio Stream pid: %d\n", FILENAME, __FUNCTION__, stream->pid);
+	if (section->section_type == GST_MPEGTS_SECTION_PMT)
+	{
+		const GstMpegtsPMT *pmt = gst_mpegts_section_get_pmt(section);
+		for (guint i = 0; i < pmt->streams->len; ++i)
+		{
+			const GstMpegtsPMTStream *stream = static_cast<const GstMpegtsPMTStream *>(g_ptr_array_index(pmt->streams, i));
+			if (stream->stream_type == 0x05 || stream->stream_type >= 0x80)
+			{
+				hal_info_c("%s:%s Audio Stream pid: %d\n", FILENAME, __FUNCTION__, stream->pid);
 				real_apids[cnt] = stream->pid;
 				cnt++;
 			}
@@ -113,7 +117,7 @@
 void playbinNotifySource(GObject *object, GParamSpec *param_spec, gpointer user_data)
 {
 	GstElement *source = NULL;
-	cPlayback *_this = (cPlayback*)user_data;
+	cPlayback *_this = (cPlayback *)user_data;
 	g_object_get(object, "source", &source, NULL);
 
 	if (source)
@@ -166,7 +170,7 @@
 				if (!name.empty() && !value.empty())
 				{
 					GValue header;
-					hal_info_c( "%s:%s setting extra-header '%s:%s'\n", FILENAME, __FUNCTION__, name.c_str(), value.c_str());
+					hal_info_c("%s:%s setting extra-header '%s:%s'\n", FILENAME, __FUNCTION__, name.c_str(), value.c_str());
 					memset(&header, 0, sizeof(GValue));
 					g_value_init(&header, G_TYPE_STRING);
 					g_value_set_string(&header, value.c_str());
@@ -174,7 +178,7 @@
 				}
 				else
 				{
-					hal_info_c( "%s:%s Invalid header format %s\n", FILENAME, __FUNCTION__, _this->extra_headers.c_str());
+					hal_info_c("%s:%s Invalid header format %s\n", FILENAME, __FUNCTION__, _this->extra_headers.c_str());
 					break;
 				}
 			}
@@ -191,7 +195,7 @@
 GstBusSyncReply Gst_bus_call(GstBus *bus, GstMessage *msg, gpointer user_data)
 {
 	// source
-	GstObject * source;
+	GstObject *source;
 	source = GST_MESSAGE_SRC(msg);
 
 	if (!GST_IS_OBJECT(source))
@@ -199,210 +203,211 @@
 
 	switch (GST_MESSAGE_TYPE(msg))
 	{
-	case GST_MESSAGE_EOS:
-	{
-		g_message("End-of-stream");
-		end_eof = 1;
-		break;
-	}
+		case GST_MESSAGE_EOS:
+		{
+			g_message("End-of-stream");
+			end_eof = 1;
+			break;
+		}
 
-	case GST_MESSAGE_ERROR:
-	{
-		gchar * debug;
-		GError *err;
-		gst_message_parse_error(msg, &err, &debug);
-		g_free (debug);
-		gchar * sourceName = gst_object_get_name(source);
-		hal_info_c( "%s:%s - GST_MESSAGE_ERROR: %s (%i) from %s\n", FILENAME, __FUNCTION__, err->message, err->code, sourceName );
-		if ( err->domain == GST_STREAM_ERROR )
+		case GST_MESSAGE_ERROR:
 		{
-			if ( err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND )
+			gchar *debug;
+			GError *err;
+			gst_message_parse_error(msg, &err, &debug);
+			g_free(debug);
+			gchar *sourceName = gst_object_get_name(source);
+			hal_info_c("%s:%s - GST_MESSAGE_ERROR: %s (%i) from %s\n", FILENAME, __FUNCTION__, err->message, err->code, sourceName);
+			if (err->domain == GST_STREAM_ERROR)
 			{
-				if ( g_strrstr(sourceName, "videosink") )
-					hal_info_c( "%s:%s - GST_MESSAGE_ERROR: videosink\n", FILENAME, __FUNCTION__ ); //FIXME: how shall playback handle this event???
-				else if ( g_strrstr(sourceName, "audiosink") )
-					hal_info_c( "%s:%s - GST_MESSAGE_ERROR: audioSink\n", FILENAME, __FUNCTION__ ); //FIXME: how shall playback handle this event???
+				if (err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND)
+				{
+					if (g_strrstr(sourceName, "videosink"))
+						hal_info_c("%s:%s - GST_MESSAGE_ERROR: videosink\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
+					else if (g_strrstr(sourceName, "audiosink"))
+						hal_info_c("%s:%s - GST_MESSAGE_ERROR: audioSink\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
+				}
 			}
-		}
-		g_error_free(err);
-		if(sourceName)
-			g_free(sourceName);
-
-		end_eof = 1; 		// NOTE: just to exit
-
-		break;
-	}
-
-	case GST_MESSAGE_INFO:
-	{
-		gchar *debug;
-		GError *inf;
-
-		gst_message_parse_info (msg, &inf, &debug);
-		g_free (debug);
-		if ( inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE )
-		{
-			gchar * sourceName = gst_object_get_name(source);
-			if ( g_strrstr(sourceName, "videosink") )
-				hal_info_c( "%s:%s - GST_MESSAGE_INFO: videosink\n", FILENAME, __FUNCTION__ ); //FIXME: how shall playback handle this event???
-			if(sourceName)
+			g_error_free(err);
+			if (sourceName)
 				g_free(sourceName);
 
-		}
-		g_error_free(inf);
-		break;
-	}
-
-	case GST_MESSAGE_TAG:
-	{
-		GstTagList *tags = NULL, *result = NULL;
-		gst_message_parse_tag(msg, &tags);
+			end_eof = 1;        // NOTE: just to exit
 
-		if(tags == NULL)
 			break;
-		if(!GST_IS_TAG_LIST(tags))
-			break;
-
-		pthread_mutex_lock (&mutex_tag_ist);
+		}
 
-		result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
-		if (result)
+		case GST_MESSAGE_INFO:
 		{
-			if (m_stream_tags && gst_tag_list_is_equal(m_stream_tags, result))
+			gchar *debug;
+			GError *inf;
+
+			gst_message_parse_info(msg, &inf, &debug);
+			g_free(debug);
+			if (inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE)
 			{
-				gst_tag_list_unref(tags);
-				gst_tag_list_unref(result);
+				gchar *sourceName = gst_object_get_name(source);
+				if (g_strrstr(sourceName, "videosink"))
+					hal_info_c("%s:%s - GST_MESSAGE_INFO: videosink\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
+				if (sourceName)
+					g_free(sourceName);
 
-				pthread_mutex_unlock (&mutex_tag_ist);
-				break;
 			}
-			if (m_stream_tags)
-				gst_tag_list_unref(m_stream_tags);
-			m_stream_tags = gst_tag_list_copy(result);
-			gst_tag_list_unref(result);
-		}
-
-		pthread_mutex_unlock (&mutex_tag_ist);
-
-		const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
-		if ( gv_image )
-		{
-			GstBuffer *buf_image;
-			GstSample *sample;
-			sample = (GstSample *)g_value_get_boxed(gv_image);
-			buf_image = gst_sample_get_buffer(sample);
-			int fd = open("/tmp/.id3coverart", O_CREAT|O_WRONLY|O_TRUNC, 0644);
-			if (fd >= 0)
-			{
-				guint8 *data;
-				gsize size;
-				GstMapInfo map;
-				gst_buffer_map(buf_image, &map, GST_MAP_READ);
-				data = map.data;
-				size = map.size;
-				int ret = write(fd, data, size);
-				gst_buffer_unmap(buf_image, &map);
-				close(fd);
-				hal_info_c("%s:%s - /tmp/.id3coverart %d bytes written\n", FILENAME, __FUNCTION__, ret);
-			}
-		}
-		if (tags)
-			gst_tag_list_unref(tags);
-		hal_debug_c( "%s:%s - GST_MESSAGE_INFO: update info tags\n", FILENAME, __FUNCTION__);  //FIXME: how shall playback handle this event???
-		break;
-	}
-    case GST_MESSAGE_ELEMENT:
-	{
-		GstMpegtsSection* section = gst_message_parse_mpegts_section(msg);
-		if (section) {
-			processMpegTsSection(section);
-			gst_mpegts_section_unref(section);
-		}
-	}
-	case GST_MESSAGE_STATE_CHANGED:
-	{
-		if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+			g_error_free(inf);
 			break;
+		}
 
-		GstState old_state, new_state;
-		gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
-
-		if(old_state == new_state)
-			break;
-		hal_info_c( "%s:%s - GST_MESSAGE_STATE_CHANGED: state transition %s -> %s\n", FILENAME, __FUNCTION__, gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
+		case GST_MESSAGE_TAG:
+		{
+			GstTagList *tags = NULL, *result = NULL;
+			gst_message_parse_tag(msg, &tags);
 
-		GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
+			if (tags == NULL)
+				break;
+			if (!GST_IS_TAG_LIST(tags))
+				break;
 
-		switch(transition)
-		{
-		case GST_STATE_CHANGE_NULL_TO_READY:
-		{
-		}	break;
-		case GST_STATE_CHANGE_READY_TO_PAUSED:
-		{
-			GstIterator *children;
-			GValue r = G_VALUE_INIT;
+			pthread_mutex_lock(&mutex_tag_ist);
 
-			if (audioSink)
+			result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
+			if (result)
 			{
-				gst_object_unref(GST_OBJECT(audioSink));
-				audioSink = NULL;
-			}
+				if (m_stream_tags && gst_tag_list_is_equal(m_stream_tags, result))
+				{
+					gst_tag_list_unref(tags);
+					gst_tag_list_unref(result);
 
-			if (videoSink)
-			{
-				gst_object_unref(GST_OBJECT(videoSink));
-				videoSink = NULL;
-			}
-			children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
-			if (children && gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &r, (gpointer)"GstDVBAudioSink"))
-			{
-				audioSink = GST_ELEMENT_CAST(g_value_dup_object (&r));
-				g_value_unset (&r);
-				hal_info_c( "%s %s - audio sink created\n", FILENAME, __FUNCTION__);
+					pthread_mutex_unlock(&mutex_tag_ist);
+					break;
+				}
+				if (m_stream_tags)
+					gst_tag_list_unref(m_stream_tags);
+				m_stream_tags = gst_tag_list_copy(result);
+				gst_tag_list_unref(result);
 			}
 
-			gst_iterator_free(children);
-			children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
-			if (children && gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &r, (gpointer)"GstDVBVideoSink"))
+			pthread_mutex_unlock(&mutex_tag_ist);
+
+			const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
+			if (gv_image)
 			{
-				videoSink = GST_ELEMENT_CAST(g_value_dup_object (&r));
-				g_value_unset (&r);
-				hal_info_c( "%s %s - video sink created\n", FILENAME, __FUNCTION__);
+				GstBuffer *buf_image;
+				GstSample *sample;
+				sample = (GstSample *)g_value_get_boxed(gv_image);
+				buf_image = gst_sample_get_buffer(sample);
+				int fd = open("/tmp/.id3coverart", O_CREAT | O_WRONLY | O_TRUNC, 0644);
+				if (fd >= 0)
+				{
+					guint8 *data;
+					gsize size;
+					GstMapInfo map;
+					gst_buffer_map(buf_image, &map, GST_MAP_READ);
+					data = map.data;
+					size = map.size;
+					int ret = write(fd, data, size);
+					gst_buffer_unmap(buf_image, &map);
+					close(fd);
+					hal_info_c("%s:%s - /tmp/.id3coverart %d bytes written\n", FILENAME, __FUNCTION__, ret);
+				}
 			}
-			gst_iterator_free(children);
-
+			if (tags)
+				gst_tag_list_unref(tags);
+			hal_debug_c("%s:%s - GST_MESSAGE_INFO: update info tags\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
+			break;
 		}
-		break;
-		case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
-		{
-		}	break;
-		case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+		case GST_MESSAGE_ELEMENT:
 		{
-		}	break;
-		case GST_STATE_CHANGE_PAUSED_TO_READY:
-		{
-			if (audioSink)
-			{
-				gst_object_unref(GST_OBJECT(audioSink));
-				audioSink = NULL;
-			}
-			if (videoSink)
+			GstMpegtsSection *section = gst_message_parse_mpegts_section(msg);
+			if (section)
 			{
-				gst_object_unref(GST_OBJECT(videoSink));
-				videoSink = NULL;
+				processMpegTsSection(section);
+				gst_mpegts_section_unref(section);
 			}
 		}
-		break;
-		case GST_STATE_CHANGE_READY_TO_NULL:
+		case GST_MESSAGE_STATE_CHANGED:
 		{
-		}	break;
+			if (GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+				break;
+
+			GstState old_state, new_state;
+			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
+
+			if (old_state == new_state)
+				break;
+			hal_info_c("%s:%s - GST_MESSAGE_STATE_CHANGED: state transition %s -> %s\n", FILENAME, __FUNCTION__, gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
+
+			GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
+
+			switch (transition)
+			{
+				case GST_STATE_CHANGE_NULL_TO_READY:
+				{
+				}   break;
+				case GST_STATE_CHANGE_READY_TO_PAUSED:
+				{
+					GstIterator *children;
+					GValue r = G_VALUE_INIT;
+
+					if (audioSink)
+					{
+						gst_object_unref(GST_OBJECT(audioSink));
+						audioSink = NULL;
+					}
+
+					if (videoSink)
+					{
+						gst_object_unref(GST_OBJECT(videoSink));
+						videoSink = NULL;
+					}
+					children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
+					if (children && gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &r, (gpointer)"GstDVBAudioSink"))
+					{
+						audioSink = GST_ELEMENT_CAST(g_value_dup_object(&r));
+						g_value_unset(&r);
+						hal_info_c("%s %s - audio sink created\n", FILENAME, __FUNCTION__);
+					}
+
+					gst_iterator_free(children);
+					children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
+					if (children && gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &r, (gpointer)"GstDVBVideoSink"))
+					{
+						videoSink = GST_ELEMENT_CAST(g_value_dup_object(&r));
+						g_value_unset(&r);
+						hal_info_c("%s %s - video sink created\n", FILENAME, __FUNCTION__);
+					}
+					gst_iterator_free(children);
+
+				}
+				break;
+				case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+				{
+				}   break;
+				case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+				{
+				}   break;
+				case GST_STATE_CHANGE_PAUSED_TO_READY:
+				{
+					if (audioSink)
+					{
+						gst_object_unref(GST_OBJECT(audioSink));
+						audioSink = NULL;
+					}
+					if (videoSink)
+					{
+						gst_object_unref(GST_OBJECT(videoSink));
+						videoSink = NULL;
+					}
+				}
+				break;
+				case GST_STATE_CHANGE_READY_TO_NULL:
+				{
+				}   break;
+			}
+			break;
 		}
 		break;
-	}
-	break;
-	default:
-		break;
+		default:
+			break;
 	}
 
 	return GST_BUS_DROP;
@@ -411,17 +416,17 @@
 
 cPlayback::cPlayback(int num)
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 	const gchar *nano_str;
 	guint major, minor, micro, nano;
 
 	gst_init(NULL, NULL);
 
-	gst_version (&major, &minor, &micro, &nano);
+	gst_version(&major, &minor, &micro, &nano);
 
 	gst_mpegts_initialize();
 
-	pthread_mutex_init (&mutex_tag_ist, NULL);
+	pthread_mutex_init(&mutex_tag_ist, NULL);
 
 	if (nano == 1)
 		nano_str = "(CVS)";
@@ -430,9 +435,9 @@
 	else
 		nano_str = "";
 
-	hal_info( "%s:%s - This program is linked against GStreamer %d.%d.%d %s\n",
-	         FILENAME, __FUNCTION__,
-	         major, minor, micro, nano_str);
+	hal_info("%s:%s - This program is linked against GStreamer %d.%d.%d %s\n",
+	    FILENAME, __FUNCTION__,
+	    major, minor, micro, nano_str);
 
 	mAudioStream = 0;
 	mSpeed = 0;
@@ -445,12 +450,12 @@
 
 cPlayback::~cPlayback()
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 	//FIXME: all deleting stuff is done in Close()
-	pthread_mutex_lock (&mutex_tag_ist);
+	pthread_mutex_lock(&mutex_tag_ist);
 	if (m_stream_tags)
 		gst_tag_list_unref(m_stream_tags);
-	pthread_mutex_unlock (&mutex_tag_ist);
+	pthread_mutex_unlock(&mutex_tag_ist);
 }
 
 //Used by Fileplay
@@ -472,7 +477,7 @@
 // used by movieplay
 void cPlayback::Close(void)
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 
 	Stop();
 
@@ -480,11 +485,11 @@
 	if (m_gst_playbin)
 	{
 		// disconnect sync handler callback
-		GstBus * bus = gst_pipeline_get_bus(GST_PIPELINE (m_gst_playbin));
+		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(m_gst_playbin));
 		gst_bus_set_sync_handler(bus, NULL, NULL, NULL);
 		if (bus)
 			gst_object_unref(bus);
-		hal_info( "%s:%s - GST bus handler closed\n", FILENAME, __FUNCTION__);
+		hal_info("%s:%s - GST bus handler closed\n", FILENAME, __FUNCTION__);
 	}
 
 	// close gst
@@ -495,7 +500,7 @@
 			gst_object_unref(GST_OBJECT(audioSink));
 			audioSink = NULL;
 
-			hal_info( "%s:%s - GST audio Sink closed\n", FILENAME, __FUNCTION__);
+			hal_info("%s:%s - GST audio Sink closed\n", FILENAME, __FUNCTION__);
 		}
 
 		if (videoSink)
@@ -503,12 +508,12 @@
 			gst_object_unref(GST_OBJECT(videoSink));
 			videoSink = NULL;
 
-			hal_info( "%s:%s - GST video Sink closed\n", FILENAME, __FUNCTION__);
+			hal_info("%s:%s - GST video Sink closed\n", FILENAME, __FUNCTION__);
 		}
 
 		// unref m_gst_playbin
-		gst_object_unref (GST_OBJECT (m_gst_playbin));
-		hal_info( "%s:%s - GST playbin closed\n", FILENAME, __FUNCTION__);
+		gst_object_unref(GST_OBJECT(m_gst_playbin));
+		hal_info("%s:%s - GST playbin closed\n", FILENAME, __FUNCTION__);
 
 		m_gst_playbin = NULL;
 
@@ -525,12 +530,12 @@
 // start
 bool cPlayback::Start(std::string filename, std::string headers)
 {
-	return Start((char*) filename.c_str(),0,0,0,0,0, headers);
+	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers);
 }
 
 bool cPlayback::Start(char *filename, int /*vpid*/, int /*vtype*/, int /*apid*/, int /*ac3*/, int /*duration*/, std::string headers)
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 
 	if (!headers.empty())
 		extra_headers = headers;
@@ -542,68 +547,68 @@
 	mAudioStream = 0;
 	init_jump = -1;
 
-	pthread_mutex_lock (&mutex_tag_ist);
+	pthread_mutex_lock(&mutex_tag_ist);
 	if (m_stream_tags)
 		gst_tag_list_unref(m_stream_tags);
 	m_stream_tags = NULL;
-	pthread_mutex_unlock (&mutex_tag_ist);
+	pthread_mutex_unlock(&mutex_tag_ist);
 
 	unlink("/tmp/.id3coverart");
 
 	//create playback path
 	bool isHTTP = false;
 
-	if(!strncmp("http://", filename, 7))
+	if (!strncmp("http://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("https://", filename, 8))
+	else if (!strncmp("https://", filename, 8))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("file://", filename, 7))
+	else if (!strncmp("file://", filename, 7))
 	{
 		isHTTP = false;
 	}
-	else if(!strncmp("upnp://", filename, 7))
+	else if (!strncmp("upnp://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("rtmp://", filename, 7))
+	else if (!strncmp("rtmp://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("rtsp://", filename, 7))
+	else if (!strncmp("rtsp://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("mms://", filename, 6))
+	else if (!strncmp("mms://", filename, 6))
 	{
 		isHTTP = true;
 	}
 
 	if (isHTTP)
-		uri = g_strdup_printf ("%s", filename);
+		uri = g_strdup_printf("%s", filename);
 	else
 		uri = g_filename_to_uri(filename, NULL, NULL);
 
 	hal_info("%s:%s - filename=%s\n", FILENAME, __FUNCTION__, filename);
 
-	guint flags =	GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_NATIVE_VIDEO;
+	guint flags =   GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_NATIVE_VIDEO;
 
 	/* increase the default 2 second / 2 MB buffer limitations to 5s / 5MB */
-	int m_buffer_size = 5*1024*1024;
+	int m_buffer_size = 5 * 1024 * 1024;
 
 	// create gst pipeline
-	m_gst_playbin = gst_element_factory_make ("playbin", "playbin");
+	m_gst_playbin = gst_element_factory_make("playbin", "playbin");
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		hal_info("%s:%s - m_gst_playbin\n", FILENAME, __FUNCTION__);
 
-		if(isHTTP)
+		if (isHTTP)
 		{
-			g_signal_connect (G_OBJECT (m_gst_playbin), "notify::source", G_CALLBACK (playbinNotifySource), this);
+			g_signal_connect(G_OBJECT(m_gst_playbin), "notify::source", G_CALLBACK(playbinNotifySource), this);
 
 			// set buffer size
 			g_object_set(G_OBJECT(m_gst_playbin), "buffer-size", m_buffer_size, NULL);
@@ -611,12 +616,12 @@
 			flags |= GST_PLAY_FLAG_BUFFERING;
 		}
 
-		g_object_set(G_OBJECT (m_gst_playbin), "flags", flags, NULL);
+		g_object_set(G_OBJECT(m_gst_playbin), "flags", flags, NULL);
 
-		g_object_set(G_OBJECT (m_gst_playbin), "uri", uri, NULL);
+		g_object_set(G_OBJECT(m_gst_playbin), "uri", uri, NULL);
 
 		//gstbus handler
-		GstBus * bus = gst_pipeline_get_bus( GST_PIPELINE(m_gst_playbin) );
+		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(m_gst_playbin));
 		gst_bus_set_sync_handler(bus, Gst_bus_call, NULL, NULL);
 		if (bus)
 			gst_object_unref(bus);
@@ -624,7 +629,7 @@
 		first = true;
 
 		// state playing
-		if(isHTTP)
+		if (isHTTP)
 		{
 			gst_element_set_state(GST_ELEMENT(m_gst_playbin), GST_STATE_PLAYING);
 			playstate = STATE_PLAY;
@@ -652,12 +657,12 @@
 
 bool cPlayback::Play(void)
 {
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
-	if(playing == true)
+	if (playing == true)
 		return true;
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		gst_element_set_state(GST_ELEMENT(m_gst_playbin), GST_STATE_PLAYING);
 
@@ -671,19 +676,19 @@
 
 bool cPlayback::Stop(void)
 {
-	if(playing == false)
+	if (playing == false)
 		return false;
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
 	// stop
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
 	}
 
 	playing = false;
 
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
 	playstate = STATE_STOP;
 
@@ -696,15 +701,16 @@
 
 	int to_audio = pid;
 
-	for (unsigned int i = 0; i < REC_MAX_APIDS; i++) {
+	for (unsigned int i = 0; i < REC_MAX_APIDS; i++)
+	{
 		if (real_apids[i])
 			if (real_apids[i] == pid)
 				to_audio = i;
 	}
 
-	if(to_audio != mAudioStream)
+	if (to_audio != mAudioStream)
 	{
-		g_object_set (G_OBJECT (m_gst_playbin), "current-audio", to_audio, NULL);
+		g_object_set(G_OBJECT(m_gst_playbin), "current-audio", to_audio, NULL);
 		printf("%s: switched to audio stream %i\n", __FUNCTION__, to_audio);
 		mAudioStream = to_audio;
 	}
@@ -721,7 +727,7 @@
 
 	if (gst_element_query_position(m_gst_playbin, fmt, &pos))
 	{
-		if(ratio >= 0.0)
+		if (ratio >= 0.0)
 			gst_element_seek(m_gst_playbin, ratio, fmt, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, pos, GST_SEEK_TYPE_SET, -1);
 		else
 			gst_element_seek(m_gst_playbin, ratio, fmt, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_SET, pos);
@@ -730,7 +736,7 @@
 
 bool cPlayback::SetSpeed(int speed)
 {
-	hal_info( "%s:%s speed %d\n", FILENAME, __FUNCTION__, speed);
+	hal_info("%s:%s speed %d\n", FILENAME, __FUNCTION__, speed);
 
 	if (!decoders_closed)
 	{
@@ -740,20 +746,20 @@
 		usleep(500000);
 	}
 
-	if(playing == false)
+	if (playing == false)
 		return false;
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		// pause
-		if(speed == 0)
+		if (speed == 0)
 		{
 			gst_element_set_state(m_gst_playbin, GST_STATE_PAUSED);
 			//trickSeek(0);
 			playstate = STATE_PAUSE;
 		}
 		// play/continue
-		else if(speed == 1)
+		else if (speed == 1)
 		{
 			trickSeek(1);
 			//gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
@@ -761,14 +767,14 @@
 			playstate = STATE_PLAY;
 		}
 		//ff
-		else if(speed > 1)
+		else if (speed > 1)
 		{
 			trickSeek(speed);
 			//
 			playstate = STATE_FF;
 		}
 		//rf
-		else if(speed < 0)
+		else if (speed < 0)
 		{
 			trickSeek(speed);
 			//
@@ -777,7 +783,7 @@
 
 		if (init_jump > -1)
 		{
-			SetPosition(init_jump,true);
+			SetPosition(init_jump, true);
 			init_jump = -1;
 		}
 	}
@@ -789,12 +795,12 @@
 
 bool cPlayback::SetSlow(int slow)
 {
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
-	if(playing == false)
+	if (playing == false)
 		return false;
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		trickSeek(0.5);
 	}
@@ -816,17 +822,17 @@
 // in milliseconds
 bool cPlayback::GetPosition(int &position, int &duration)
 {
-	if(playing == false)
+	if (playing == false)
 		return false;
 
 	//EOF
-	if(end_eof)
+	if (end_eof)
 	{
 		end_eof = 0;
 		return false;
 	}
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		//position
 		GstFormat fmt = GST_FORMAT_TIME; //Returns time in nanosecs
@@ -836,14 +842,14 @@
 			g_signal_emit_by_name(audioSink ? audioSink : videoSink, "get-decoder-time", &pts);
 			if (!GST_CLOCK_TIME_IS_VALID(pts))
 			{
-				hal_info( "%s - %d failed\n", __FUNCTION__, __LINE__);
+				hal_info("%s - %d failed\n", __FUNCTION__, __LINE__);
 			}
 		}
 		else
 		{
-			if(!gst_element_query_position(m_gst_playbin, fmt, &pts))
+			if (!gst_element_query_position(m_gst_playbin, fmt, &pts))
 			{
-				hal_info( "%s - %d failed\n", __FUNCTION__, __LINE__);
+				hal_info("%s - %d failed\n", __FUNCTION__, __LINE__);
 			}
 		}
 		position = pts /  1000000.0;
@@ -854,7 +860,7 @@
 
 		gst_element_query_duration(m_gst_playbin, fmt_d, &len);
 		length = len / 1000000.0;
-		if(length < 0)
+		if (length < 0)
 			length = 0;
 
 		duration = (int)(length);
@@ -868,12 +874,13 @@
 	hal_info("%s: pos %d abs %d playing %d\n", __func__, position, absolute, playing);
 
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
-		if(first){
+		if (first)
+		{
 			GstState state;
 			gst_element_get_state(m_gst_playbin, &state, NULL, GST_CLOCK_TIME_NONE);
-			if ( (state == GST_STATE_PAUSED) && first)
+			if ((state == GST_STATE_PAUSED) && first)
 			{
 				init_jump = position;
 				first = false;
@@ -888,7 +895,7 @@
 		{
 			gst_element_query_position(m_gst_playbin, fmt, &pos);
 			time_nanoseconds = pos + (position * 1000000.0);
-			if(time_nanoseconds < 0)
+			if (time_nanoseconds < 0)
 				time_nanoseconds = 0;
 		}
 		else
@@ -902,82 +909,82 @@
 	return true;
 }
 
-void cPlayback::FindAllPids(int *apids, unsigned int *ac3flags, unsigned int *numpida, std::string * language)
+void cPlayback::FindAllPids(int *apids, unsigned int *ac3flags, unsigned int *numpida, std::string *language)
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 
 	language->clear();
 	*numpida = 0;
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		gint i, n_audio = 0;
 
 		// get audio
-		g_object_get (m_gst_playbin, "n-audio", &n_audio, NULL);
+		g_object_get(m_gst_playbin, "n-audio", &n_audio, NULL);
 		hal_info("%s: %d audio\n", __FUNCTION__, n_audio);
 
-		if(n_audio == 0)
+		if (n_audio == 0)
 			return;
 
 		for (i = 0; i < n_audio && i < REC_MAX_APIDS; i++)
 		{
 			// apids
-			apids[i]= real_apids[i] ? real_apids[i] : i;
+			apids[i] = real_apids[i] ? real_apids[i] : i;
 
-			GstPad * pad = 0;
-			g_signal_emit_by_name (m_gst_playbin, "get-audio-pad", i, &pad);
+			GstPad *pad = 0;
+			g_signal_emit_by_name(m_gst_playbin, "get-audio-pad", i, &pad);
 
-			GstCaps * caps = gst_pad_get_current_caps(pad);
+			GstCaps *caps = gst_pad_get_current_caps(pad);
 			if (pad)
 				gst_object_unref(pad);
 
 			if (!caps)
 				continue;
 
-			GstStructure * structure = gst_caps_get_structure(caps, 0);
-			GstTagList * tags = NULL;
-			gchar * g_lang = NULL;
+			GstStructure *structure = gst_caps_get_structure(caps, 0);
+			GstTagList *tags = NULL;
+			gchar *g_lang = NULL;
 
 			// ac3flags
-			if ( gst_structure_has_name (structure, "audio/mpeg"))
+			if (gst_structure_has_name(structure, "audio/mpeg"))
 			{
 				gint mpegversion;
 
-				if (!gst_structure_get_int (structure, "mpegversion", &mpegversion))
+				if (!gst_structure_get_int(structure, "mpegversion", &mpegversion))
 					ac3flags[i] = 0;
 
 				switch (mpegversion)
 				{
-				case 1:
-					ac3flags[i] = 4;
-				case 2:
-					//return atAAC;
-					ac3flags[i] = 5;
-				case 4:
-					//return atAAC;
-					ac3flags[i] = 5;
-				default:
-					//return atUnknown;
-					ac3flags[i] = 0;
+					case 1:
+						ac3flags[i] = 4;
+					case 2:
+						//return atAAC;
+						ac3flags[i] = 5;
+					case 4:
+						//return atAAC;
+						ac3flags[i] = 5;
+					default:
+						//return atUnknown;
+						ac3flags[i] = 0;
 				}
 			}
-			else if ( gst_structure_has_name (structure, "audio/x-ac3") || gst_structure_has_name (structure, "audio/ac3") )
+			else if (gst_structure_has_name(structure, "audio/x-ac3") || gst_structure_has_name(structure, "audio/ac3"))
 				//return atAC3;
 				ac3flags[i] = 1;
-			else if ( gst_structure_has_name (structure, "audio/x-dts") || gst_structure_has_name (structure, "audio/dts") )
+			else if (gst_structure_has_name(structure, "audio/x-dts") || gst_structure_has_name(structure, "audio/dts"))
 				//return atDTS;
 				ac3flags[i] = 6;
-			else if ( gst_structure_has_name (structure, "audio/x-raw-int") )
+			else if (gst_structure_has_name(structure, "audio/x-raw-int"))
 				//return atPCM;
 				ac3flags[i] = 0;
 
 			if (caps)
 				gst_caps_unref(caps);
 
-			//(ac3flags[i] > 2) ?	ac3flags[i] = 1 : ac3flags[i] = 0;
+			//(ac3flags[i] > 2) ?   ac3flags[i] = 1 : ac3flags[i] = 0;
 
-			g_signal_emit_by_name (m_gst_playbin, "get-audio-tags", i, &tags);
+			g_signal_emit_by_name(m_gst_playbin, "get-audio-tags", i, &tags);
 			if (tags)
 			{
 				if (GST_IS_TAG_LIST(tags) && gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang))
@@ -997,21 +1004,21 @@
 				gst_tag_list_free(tags);
 			}
 		}
-		*numpida=i;
+		*numpida = i;
 	}
 }
 
 void cPlayback::getMeta()
 {
-	if(playing)
+	if (playing)
 		return;
 }
 
 bool cPlayback::SyncAV(void)
 {
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
-	if(playing == false )
+	if (playing == false)
 		return false;
 
 	return true;
@@ -1045,18 +1052,20 @@
 	values.clear();
 
 	GstTagList *meta_list = NULL;
-	pthread_mutex_lock (&mutex_tag_ist);
+	pthread_mutex_lock(&mutex_tag_ist);
 
-	if(m_stream_tags){
+	if (m_stream_tags)
+	{
 		meta_list = gst_tag_list_copy(m_stream_tags);
 	}
 
-	pthread_mutex_unlock (&mutex_tag_ist);
+	pthread_mutex_unlock(&mutex_tag_ist);
 
 	if (meta_list == NULL)
 		return;
 
-	if (gst_tag_list_is_empty(meta_list)){
+	if (gst_tag_list_is_empty(meta_list))
+	{
 		gst_tag_list_unref(meta_list);
 		return;
 	}
@@ -1087,14 +1096,14 @@
 			{
 				char buffer [50];
 				keys.push_back(name);
-				sprintf (buffer, "%u", g_value_get_uint(val));
+				sprintf(buffer, "%u", g_value_get_uint(val));
 				values.push_back(buffer);
 			}
 			else if (G_VALUE_HOLDS_DOUBLE(val))
 			{
 				char buffer [50];
 				keys.push_back(name);
-				sprintf (buffer, "%f", g_value_get_double(val));
+				sprintf(buffer, "%f", g_value_get_double(val));
 				values.push_back(buffer);
 			}
 			else if (G_VALUE_HOLDS_BOOLEAN(val))
@@ -1152,7 +1161,7 @@
 int cPlayback::GetAPid(void)
 {
 	gint current_audio = 0;
-	g_object_get (m_gst_playbin, "current-audio", &current_audio, NULL);
+	g_object_get(m_gst_playbin, "current-audio", &current_audio, NULL);
 	hal_info("%s: %d audio\n", __FUNCTION__, current_audio);
 	return real_apids[current_audio] ? real_apids[current_audio] : current_audio;
 }
@@ -1160,7 +1169,7 @@
 int cPlayback::GetVPid(void)
 {
 	gint current_video = 0;
-	g_object_get (m_gst_playbin, "current-video", &current_video, NULL);
+	g_object_get(m_gst_playbin, "current-video", &current_video, NULL);
 	hal_info("%s: %d video\n", __FUNCTION__, current_video);
 	return current_video;
 }
diff -Nur libstb-hal-ddt.git.orig/libarmbox/playback_gst.h libstb-hal-ddt.git/libarmbox/playback_gst.h
--- libstb-hal-ddt.git.orig/libarmbox/playback_gst.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libarmbox/playback_gst.h	2022-07-23 18:18:31.499773109 +0200
@@ -46,57 +46,57 @@
 
 class cPlayback
 {
-private:
-	bool playing, first;
-	bool decoders_closed;
-
-	int mSpeed;
-	int mAudioStream;
-	int init_jump;
-
-public:
-	playstate_t playstate;
-
-	cPlayback(int);
-	bool Open(playmode_t PlayMode);
-	void Close(void);
-	bool Start(char *filename, int vpid, int vtype, int apid, int ac3, int duration, std::string headers = "");
-	bool Start(std::string filename, std::string headers = "");
-	bool Play(void);
-	bool SyncAV(void);
-
-	bool Stop(void);
-	bool SetAPid(int pid, bool ac3);
-	bool SetSubtitlePid(int pid);
-	bool SetTeletextPid(int pid);
-
-	void trickSeek(int ratio);
-	bool SetSpeed(int speed);
-	bool SetSlow(int slow);
-	bool GetSpeed(int &speed) const;
-	bool GetPosition(int &position, int &duration);
-	void GetPts(uint64_t &pts);
-	int GetAPid(void);
-	int GetVPid(void);
-	int GetSubtitlePid(void);
-	bool SetPosition(int position, bool absolute = false);
-	void FindAllPids(int *apids, unsigned int *ac3flags, unsigned int *numpida, std::string *language);
-	void FindAllSubtitlePids(int *pids, unsigned int *numpids, std::string *language);
-	void FindAllTeletextsubtitlePids(int *pids, unsigned int *numpidt, std::string *tlanguage, int *mags, int *pages);
-	void RequestAbort(void);
-	void FindAllSubs(uint16_t *pids, unsigned short *supported, uint16_t *numpida, std::string *language);
-	bool SelectSubtitles(int pid);
-	uint64_t GetReadCount(void);
-	void GetChapters(std::vector<int> &positions, std::vector<std::string> &titles);
-	void GetMetadata(std::vector<std::string> &keys, std::vector<std::string> &values);
-	AVFormatContext *GetAVFormatContext();
-	void ReleaseAVFormatContext();
-	std::string extra_headers;
-	std::string user_agent;
-
-	//
-	~cPlayback();
-	void getMeta();
+	private:
+		bool playing, first;
+		bool decoders_closed;
+
+		int mSpeed;
+		int mAudioStream;
+		int init_jump;
+
+	public:
+		playstate_t playstate;
+
+		cPlayback(int);
+		bool Open(playmode_t PlayMode);
+		void Close(void);
+		bool Start(char *filename, int vpid, int vtype, int apid, int ac3, int duration, std::string headers = "");
+		bool Start(std::string filename, std::string headers = "");
+		bool Play(void);
+		bool SyncAV(void);
+
+		bool Stop(void);
+		bool SetAPid(int pid, bool ac3);
+		bool SetSubtitlePid(int pid);
+		bool SetTeletextPid(int pid);
+
+		void trickSeek(int ratio);
+		bool SetSpeed(int speed);
+		bool SetSlow(int slow);
+		bool GetSpeed(int &speed) const;
+		bool GetPosition(int &position, int &duration);
+		void GetPts(uint64_t &pts);
+		int GetAPid(void);
+		int GetVPid(void);
+		int GetSubtitlePid(void);
+		bool SetPosition(int position, bool absolute = false);
+		void FindAllPids(int *apids, unsigned int *ac3flags, unsigned int *numpida, std::string *language);
+		void FindAllSubtitlePids(int *pids, unsigned int *numpids, std::string *language);
+		void FindAllTeletextsubtitlePids(int *pids, unsigned int *numpidt, std::string *tlanguage, int *mags, int *pages);
+		void RequestAbort(void);
+		void FindAllSubs(uint16_t *pids, unsigned short *supported, uint16_t *numpida, std::string *language);
+		bool SelectSubtitles(int pid);
+		uint64_t GetReadCount(void);
+		void GetChapters(std::vector<int> &positions, std::vector<std::string> &titles);
+		void GetMetadata(std::vector<std::string> &keys, std::vector<std::string> &values);
+		AVFormatContext *GetAVFormatContext();
+		void ReleaseAVFormatContext();
+		std::string extra_headers;
+		std::string user_agent;
+
+		//
+		~cPlayback();
+		void getMeta();
 };
 
 #endif // __PLAYBACK_GST_H__
diff -Nur libstb-hal-ddt.git.orig/libarmbox/playback_libeplayer3.cpp libstb-hal-ddt.git/libarmbox/playback_libeplayer3.cpp
--- libstb-hal-ddt.git.orig/libarmbox/playback_libeplayer3.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libarmbox/playback_libeplayer3.cpp	2022-07-23 18:18:31.503773029 +0200
@@ -11,11 +11,11 @@
 
 extern "C" {
 #include <common.h>
-extern OutputHandler_t      OutputHandler;
-extern PlaybackHandler_t    PlaybackHandler;
-extern ContainerHandler_t   ContainerHandler;
-extern ManagerHandler_t     ManagerHandler;
-extern int32_t ffmpeg_av_dict_set( const char *key, const char *value, int32_t flags);
+	extern OutputHandler_t      OutputHandler;
+	extern PlaybackHandler_t    PlaybackHandler;
+	extern ContainerHandler_t   ContainerHandler;
+	extern ManagerHandler_t     ManagerHandler;
+	extern int32_t ffmpeg_av_dict_set(const char *key, const char *value, int32_t flags);
 }
 
 #include "playback_libeplayer3.h"
@@ -54,6 +54,7 @@
 	last_size = 0;
 	nPlaybackSpeed = 0;
 	init_jump = -1;
+	avft = avformat_alloc_context();
 
 	if (!player)
 	{
@@ -87,7 +88,7 @@
 
 	//Dagobert: movieplayer does not call stop, it calls close ;)
 	mutex.lock();
-	if(playing)
+	if (playing)
 		Stop();
 	mutex.unlock();
 
@@ -101,7 +102,7 @@
 
 bool cPlayback::Start(std::string filename, std::string headers, std::string filename2)
 {
-	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers,filename2);
+	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers, filename2);
 }
 
 bool cPlayback::Start(char *filename, int vpid, int vtype, int apid, int ac3, int, std::string headers, std::string filename2)
@@ -117,7 +118,6 @@
 	mAudioStream = 0;
 	mSubtitleStream = -1;
 	mTeletextStream = -1;
-	unlink("/tmp/.id3coverart");
 	std::string file;
 
 	if (*filename == '/')
@@ -140,7 +140,7 @@
 	else
 		isHTTP = true;
 
-	if(isHTTP && headers.empty())
+	if (isHTTP && headers.empty())
 	{
 		size_t pos = file.find('#');
 		if (pos != std::string::npos)
@@ -148,17 +148,19 @@
 			headers = file.substr(pos + 1);
 			pos = headers.find("User-Agent=");
 			if (pos != std::string::npos)
-				headers.replace(pos+10, 1, ": ");
+				headers.replace(pos + 10, 1, ": ");
 		}
 	}
-	if(!headers.empty()){
+	if (!headers.empty())
+	{
 		const char hkey[] = "headers";
 		ffmpeg_av_dict_set(hkey, headers.c_str(), 0);
 	}
 
 	std::string szSecondFile;
 	char *file2 = NULL;
-	if(!filename2.empty()){
+	if (!filename2.empty())
+	{
 		szSecondFile = filename2;
 		file2 = (char *) szSecondFile.c_str();
 	}
@@ -180,7 +182,7 @@
 			//AUDIO
 			if (player && player->manager && player->manager->audio)
 			{
-				char ** TrackList = NULL;
+				char **TrackList = NULL;
 				player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
 				if (TrackList != NULL)
 				{
@@ -199,13 +201,13 @@
 			//SUB
 			if (player && player->manager && player->manager->subtitle)
 			{
-				char ** TrackList = NULL;
+				char **TrackList = NULL;
 				player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
 				if (TrackList != NULL)
 				{
 					printf("SubtitleTrack List\n");
 					int i = 0;
-					for (i = 0; TrackList[i] != NULL; i+=2)
+					for (i = 0; TrackList[i] != NULL; i += 2)
 					{
 						printf("\t%s - %s\n", TrackList[i], TrackList[i + 1]);
 						free(TrackList[i]);
@@ -219,27 +221,27 @@
 			//Teletext
 			if (player && player->manager && player->manager->teletext)
 			{
-				char ** TrackList = NULL;
-				player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
-				if (TrackList != NULL)
-				{
-					printf("TeletextTrack List\n");
-					 int i = 0;
-					for (i = 0; TrackList[i] != NULL; i += 2)
-					{
-						printf("\t%s - %s\n", TrackList[i], TrackList[i + 1]);
-						free(TrackList[i]);
-						free(TrackList[i + 1]);
-					}
-					free(TrackList);
-				}
+			    char ** TrackList = NULL;
+			    player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
+			    if (TrackList != NULL)
+			    {
+			        printf("TeletextTrack List\n");
+			         int i = 0;
+			        for (i = 0; TrackList[i] != NULL; i += 2)
+			        {
+			            printf("\t%s - %s\n", TrackList[i], TrackList[i + 1]);
+			            free(TrackList[i]);
+			            free(TrackList[i + 1]);
+			        }
+			        free(TrackList);
+			    }
 			}
 
 			*/
 			//Chapters
 			if (player && player->manager && player->manager->chapter)
 			{
-				char ** TrackList = NULL;
+				char **TrackList = NULL;
 				player->manager->chapter->Command(player, MANAGER_LIST, &TrackList);
 				if (TrackList != NULL)
 				{
@@ -334,7 +336,7 @@
 	if (pid != mTeletextStream)
 	{
 		//if (player && player->playback)
-		//	player->playback->Command(player, PLAYBACK_SWITCH_TELETEXT, (void*)&i);
+		//  player->playback->Command(player, PLAYBACK_SWITCH_TELETEXT, (void*)&i);
 		mTeletextStream = pid;
 	}
 	return true;
@@ -364,6 +366,11 @@
 	if (player && player->playback)
 	{
 		int result = 0;
+		if (nPlaybackSpeed == 0 && speed > 1)
+		{
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+		}
+
 		nPlaybackSpeed = speed;
 
 		if (speed > 1)
@@ -649,36 +656,36 @@
 	//int max_numpids = *numpids;
 	*numpids = 0;
 
-/*	if (player && player->manager && player->manager->teletext)
-	{
-		char **TrackList = NULL;
-		player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
-		if (TrackList != NULL)
-		{
-			printf("Teletext List\n");
-			int i = 0, j = 0;
-			for (i = 0, j = 0; TrackList[i] != NULL; i += 2)
-			{
-				int type = 0;
-				printf("\t%s - %s\n", TrackList[i], TrackList[i + 1]);
-				if (j < max_numpids)
-				{
-					int _pid;
-					if (2 != sscanf(TrackList[i], "%d %*s %d %*d %*d", &_pid, &type))
-						continue;
-					if (type != 2 && type != 5) // return subtitles only
-						continue;
-					pids[j] = _pid;
-					language[j] = std::string(TrackList[i]);
-					j++;
-				}
-				free(TrackList[i]);
-				free(TrackList[i + 1]);
-			}
-			free(TrackList);
-			*numpids = j;
-		}
-	} */
+	/*  if (player && player->manager && player->manager->teletext)
+	    {
+	        char **TrackList = NULL;
+	        player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
+	        if (TrackList != NULL)
+	        {
+	            printf("Teletext List\n");
+	            int i = 0, j = 0;
+	            for (i = 0, j = 0; TrackList[i] != NULL; i += 2)
+	            {
+	                int type = 0;
+	                printf("\t%s - %s\n", TrackList[i], TrackList[i + 1]);
+	                if (j < max_numpids)
+	                {
+	                    int _pid;
+	                    if (2 != sscanf(TrackList[i], "%d %*s %d %*d %*d", &_pid, &type))
+	                        continue;
+	                    if (type != 2 && type != 5) // return subtitles only
+	                        continue;
+	                    pids[j] = _pid;
+	                    language[j] = std::string(TrackList[i]);
+	                    j++;
+	                }
+	                free(TrackList[i]);
+	                free(TrackList[i + 1]);
+	            }
+	            free(TrackList);
+	            *numpids = j;
+	        }
+	    } */
 }
 
 int cPlayback::GetTeletextPid(void)
@@ -686,31 +693,31 @@
 	hal_info("%s\n", __func__);
 	int pid = -1;
 
-/*	if (player && player->manager && player->manager->teletext)
-	{
-		char **TrackList = NULL;
-		player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
-		if (TrackList != NULL)
-		{
-			printf("Teletext List\n");
-			int i = 0;
-			for (i = 0; TrackList[i] != NULL; i += 2)
-			{
-				int type = 0;
-				printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
-				if (pid < 0)
-				{
-					if (2 != sscanf(TrackList[i], "%*d %d %*s %d %*d %*d", &pid, &type))
-						continue;
-					if (type != 1)
-						pid = -1;
-				}
-				free(TrackList[i]);
-				free(TrackList[i + 1]);
-			}
-			free(TrackList);
-		}
-	} */
+	/*  if (player && player->manager && player->manager->teletext)
+	    {
+	        char **TrackList = NULL;
+	        player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
+	        if (TrackList != NULL)
+	        {
+	            printf("Teletext List\n");
+	            int i = 0;
+	            for (i = 0; TrackList[i] != NULL; i += 2)
+	            {
+	                int type = 0;
+	                printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+	                if (pid < 0)
+	                {
+	                    if (2 != sscanf(TrackList[i], "%*d %d %*s %d %*d %*d", &pid, &type))
+	                        continue;
+	                    if (type != 1)
+	                        pid = -1;
+	                }
+	                free(TrackList[i]);
+	                free(TrackList[i + 1]);
+	            }
+	            free(TrackList);
+	        }
+	    } */
 
 	printf("teletext pid id %d (0x%x)\n", pid, pid);
 	return pid;
@@ -814,9 +821,9 @@
 			Stop();
 			player->playback->abortRequested = 1;
 		}
-		else if(player->playback->isHttp && !player->playback->isPlaying &&!player->playback->abortRequested)
+		else if (player->playback->isHttp && !player->playback->isPlaying && !player->playback->abortRequested)
 		{
-				player->playback->abortRequested = 1;
+			player->playback->abortRequested = 1;
 		}
 
 		mutex.unlock();
@@ -842,11 +849,17 @@
 
 AVFormatContext *cPlayback::GetAVFormatContext()
 {
-	return NULL;
+	if (player && player->container && player->container->selectedContainer)
+	{
+		player->container->selectedContainer->Command(player, CONTAINER_GET_AVFCONTEXT, avft);
+	}
+	return avft;
 }
 
 void cPlayback::ReleaseAVFormatContext()
 {
+	avft->streams = NULL;
+	avft->nb_streams = 0;
 }
 
 #if 0
diff -Nur libstb-hal-ddt.git.orig/libarmbox/playback_libeplayer3.h libstb-hal-ddt.git/libarmbox/playback_libeplayer3.h
--- libstb-hal-ddt.git.orig/libarmbox/playback_libeplayer3.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libarmbox/playback_libeplayer3.h	2022-07-23 18:18:31.503773029 +0200
@@ -15,7 +15,7 @@
 
 class cPlayback
 {
-	friend class CStreamInfo2;
+		friend class CStreamInfo2;
 
 	private:
 		static OpenThreads::Mutex mutex;
@@ -35,6 +35,7 @@
 		std::string fn_xml;
 		off64_t last_size;
 		int init_jump;
+		AVFormatContext *avft;
 	public:
 		cPlayback(int num = 0);
 		~cPlayback();
@@ -47,9 +48,18 @@
 		bool SetVPid(int /*pid*/);
 		bool SetSubtitlePid(int pid);
 		bool SetTeletextPid(int pid);
-		int GetAPid(void) { return mAudioStream; }
-		int GetVPid(void) { return 0; }
-		int GetSubtitlePid(void) { return mSubtitleStream; }
+		int GetAPid(void)
+		{
+			return mAudioStream;
+		}
+		int GetVPid(void)
+		{
+			return 0;
+		}
+		int GetSubtitlePid(void)
+		{
+			return mSubtitleStream;
+		}
 		int GetTeletextPid(void);
 		bool SetSpeed(int speed);
 		bool GetSpeed(int &speed) const;
diff -Nur libstb-hal-ddt.git.orig/libarmbox/record.cpp libstb-hal-ddt.git/libarmbox/record.cpp
--- libstb-hal-ddt.git.orig/libarmbox/record.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libarmbox/record.cpp	2022-07-23 18:18:31.503773029 +0200
@@ -1,5 +1,5 @@
 /*
- * (C) 
+ * (C)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -150,17 +150,21 @@
 	bool found;
 	unsigned short pid;
 	hal_info("%s\n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
 	/* the first PID is the video pid, so start with the second PID... */
-	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+	{
 		found = false;
 		pid = (*i).pid;
-		for (j = 0; j < numapids; j++) {
-			if (pid == apids[j]) {
+		for (j = 0; j < numapids; j++)
+		{
+			if (pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -168,10 +172,13 @@
 		if (!found)
 			dmx->removePid(pid);
 	}
-	for (j = 0; j < numapids; j++) {
+	for (j = 0; j < numapids; j++)
+	{
 		found = false;
-		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
-			if ((*i).pid == apids[j]) {
+		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+		{
+			if ((*i).pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -186,12 +193,14 @@
 {
 	std::vector<pes_pids> pids;
 	hal_info("%s: \n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
-	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i)
+	{
 		if ((*i).pid == pid)
 			return true; /* or is it an error to try to add the same PID twice? */
 	}
@@ -203,14 +212,16 @@
 	char threadname[17];
 	strncpy(threadname, "WriterThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	unsigned int chunk = 0;
-	while (!sem_wait(&sem)) {
+	while (!sem_wait(&sem))
+	{
 		if (!io_len[chunk]) // empty, assume end of recording
 			return;
 		unsigned char *p_buf = io_buf[chunk];
 		size_t p_len = io_len[chunk];
-		while (p_len) {
+		while (p_len)
+		{
 			ssize_t written = write(file_fd, p_buf, p_len);
 			if (written < 0)
 				break;
@@ -230,7 +241,7 @@
 	char threadname[17];
 	strncpy(threadname, "RecordThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	int readsize = bufsize / 16;
 	int buf_pos = 0;
 	int count = 0;
@@ -251,7 +262,7 @@
 	}
 
 	int val = fcntl(file_fd, F_GETFL);
-	if (fcntl(file_fd, F_SETFL, val|O_APPEND))
+	if (fcntl(file_fd, F_SETFL, val | O_APPEND))
 		hal_info("%s: O_APPEND? (%m)\n", __func__);
 
 	memset(&a, 0, sizeof(a));
@@ -266,7 +277,8 @@
 	{
 		if (buf_pos < bufsize)
 		{
-			if (overflow_count) {
+			if (overflow_count)
+			{
 				hal_info("%s: Overflow cleared after %d iterations\n", __func__, overflow_count);
 				overflow_count = 0;
 			}
@@ -275,7 +287,7 @@
 				toread = readsize;
 			ssize_t s = dmx->Read(buf + buf_pos, toread, 50);
 			hal_debug("%s: buf_pos %6d s %6d / %6d\n", __func__,
-				buf_pos, (int)s, bufsize - buf_pos);
+			    buf_pos, (int)s, bufsize - buf_pos);
 			if (s < 0)
 			{
 				if (errno != EAGAIN && (errno != EOVERFLOW || !overflow))
@@ -378,9 +390,9 @@
 	eventServer.registerEvent2(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, "/tmp/neutrino.sock");
 	stream2file_status2_t s;
 	s.status = exit_flag;
-	strncpy(s.filename,basename(myfilename),512);
+	strncpy(s.filename, basename(myfilename), 512);
 	s.filename[511] = '\0';
-	strncpy(s.dir,dirname(myfilename),100);
+	strncpy(s.dir, dirname(myfilename), 100);
 	s.dir[99] = '\0';
 	eventServer.sendEvent(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, &s, sizeof(s));
 	printf("[stream2file]: pthreads exit code: %i, dir: '%s', filename: '%s' myfilename: '%s'\n", exit_flag, s.dir, s.filename, myfilename);
diff -Nur libstb-hal-ddt.git.orig/libarmbox/record_lib.h libstb-hal-ddt.git/libarmbox/record_lib.h
--- libstb-hal-ddt.git.orig/libarmbox/record_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libarmbox/record_lib.h	2022-07-23 18:18:31.503773029 +0200
@@ -9,13 +9,14 @@
 #define REC_STATUS_OVERFLOW 2
 #define REC_STATUS_STOPPED 4
 
-typedef enum {
+typedef enum
+{
 	RECORD_RUNNING,
 	RECORD_STOPPED,
-	RECORD_FAILED_READ,	/* failed to read from DMX */
-	RECORD_FAILED_OVERFLOW,	/* cannot write fast enough */
-	RECORD_FAILED_FILE,	/* cannot write to file */
-	RECORD_FAILED_MEMORY	/* out of memory */
+	RECORD_FAILED_READ, /* failed to read from DMX */
+	RECORD_FAILED_OVERFLOW, /* cannot write fast enough */
+	RECORD_FAILED_FILE, /* cannot write to file */
+	RECORD_FAILED_MEMORY    /* out of memory */
 } record_state_t;
 
 class cRecord
@@ -38,8 +39,12 @@
 		unsigned char *io_buf[RECORD_WRITER_CHUNKS];
 		size_t io_len[RECORD_WRITER_CHUNKS];
 	public:
-		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024); 
-		void setFailureCallback(void (*f)(void *), void *d) { failureCallback = f; failureData = d; }
+		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024);
+		void setFailureCallback(void (*f)(void *), void *d)
+		{
+			failureCallback = f;
+			failureData = d;
+		}
 		~cRecord();
 
 		bool Open();
diff -Nur libstb-hal-ddt.git.orig/libarmbox/video.cpp libstb-hal-ddt.git/libarmbox/video.cpp
--- libstb-hal-ddt.git.orig/libarmbox/video.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libarmbox/video.cpp	2022-07-23 18:18:31.503773029 +0200
@@ -38,6 +38,7 @@
 #include "hal_debug.h"
 #include "hdmi_cec.h"
 
+#include <hardware_caps.h>
 #include <proc_tools.h>
 
 extern "C"
@@ -53,16 +54,16 @@
 #define hal_debug_c(args...) _hal_debug(HAL_DEBUG_VIDEO, NULL, args)
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_VIDEO, NULL, args)
 
-#define fop(cmd, args...) ({				\
-	int _r;						\
-	if (fd >= 0) { 					\
-		if ((_r = ::cmd(fd, args)) < 0)		\
-			hal_info(#cmd"(fd, "#args")\n");	\
-		else					\
-			hal_debug(#cmd"(fd, "#args")\n");\
-	}						\
-	else { _r = fd; } 				\
-	_r;						\
+#define fop(cmd, args...) ({                \
+    int _r;                     \
+    if (fd >= 0) {                  \
+        if ((_r = ::cmd(fd, args)) < 0)     \
+            hal_info(#cmd"(fd, "#args")\n");\
+        else                    \
+            hal_debug(#cmd"(fd, "#args")\n");\
+    }                       \
+    else { _r = fd; }               \
+    _r;                     \
 })
 
 #ifndef VIDEO_GET_SIZE
@@ -72,97 +73,129 @@
 #define VIDEO_GET_FRAME_RATE       _IOR('o', 56, unsigned int)
 #endif
 
-cVideo * videoDecoder = NULL;
-cVideo * pipDecoder = NULL;
+enum
+{
+	ENCODER,
+	AUX
+};
+
+cVideo *videoDecoder = NULL;
+cVideo *pipVideoDecoder[3] = { NULL, NULL, NULL };
 
 int system_rev = 0;
 
 static bool stillpicture = false;
 
-static const char *VDEV[] = {
+static const char *VDEV[] =
+{
 	"/dev/dvb/adapter0/video0",
 	"/dev/dvb/adapter0/video1",
 	"/dev/dvb/adapter0/video2",
 	"/dev/dvb/adapter0/video3"
 };
-static const char *VMPEG_aspect[] = {
+static const char *VMPEG_aspect[] =
+{
 	"/proc/stb/vmpeg/0/aspect",
 	"/proc/stb/vmpeg/1/aspect",
 	"/proc/stb/vmpeg/2/aspect",
 	"/proc/stb/vmpeg/3/aspect"
 };
 
-static const char *VMPEG_xres[] = {
+static const char *VMPEG_xres[] =
+{
 	"/proc/stb/vmpeg/0/xres",
 	"/proc/stb/vmpeg/1/xres",
 	"/proc/stb/vmpeg/2/xres",
 	"/proc/stb/vmpeg/3/xres"
 };
 
-static const char *VMPEG_yres[] = {
+static const char *VMPEG_yres[] =
+{
 	"/proc/stb/vmpeg/0/yres",
 	"/proc/stb/vmpeg/1/yres",
 	"/proc/stb/vmpeg/2/yres",
 	"/proc/stb/vmpeg/3/yres"
 };
 
-static const char *VMPEG_dst_height[] = {
+static const char *VMPEG_dst_height[] =
+{
 	"/proc/stb/vmpeg/0/dst_height",
 	"/proc/stb/vmpeg/1/dst_height",
 	"/proc/stb/vmpeg/2/dst_height",
 	"/proc/stb/vmpeg/3/dst_height"
 };
 
-static const char *VMPEG_dst_width[] = {
+static const char *VMPEG_dst_width[] =
+{
 	"/proc/stb/vmpeg/0/dst_width",
 	"/proc/stb/vmpeg/1/dst_width",
 	"/proc/stb/vmpeg/2/dst_width",
 	"/proc/stb/vmpeg/3/dst_width"
 };
 
-static const char *VMPEG_dst_top[] = {
+static const char *VMPEG_dst_top[] =
+{
 	"/proc/stb/vmpeg/0/dst_top",
 	"/proc/stb/vmpeg/1/dst_top",
 	"/proc/stb/vmpeg/2/dst_top",
 	"/proc/stb/vmpeg/3/dst_top"
 };
 
-static const char *VMPEG_dst_left[] = {
+static const char *VMPEG_dst_left[] =
+{
 	"/proc/stb/vmpeg/0/dst_left",
 	"/proc/stb/vmpeg/1/dst_left",
 	"/proc/stb/vmpeg/2/dst_left",
 	"/proc/stb/vmpeg/3/dst_left"
 };
 
-static const char *VMPEG_framerate[] = {
+static const char *VMPEG_dst_apply[] =
+{
+	"/proc/stb/vmpeg/0/dst_apply",
+	"/proc/stb/vmpeg/1/dst_apply",
+	"/proc/stb/vmpeg/2/dst_apply",
+	"/proc/stb/vmpeg/3/dst_apply"
+};
+
+static const char *VMPEG_framerate[] =
+{
 	"/proc/stb/vmpeg/0/framerate",
 	"/proc/stb/vmpeg/1/framerate",
 	"/proc/stb/vmpeg/2/framerate",
 	"/proc/stb/vmpeg/3/framerate"
 };
 
-static const char *vid_modes[] = {
-	"pal",		// VIDEO_STD_NTSC
-	"pal",		// VIDEO_STD_SECAM
-	"pal",		// VIDEO_STD_PAL
-	"480p",		// VIDEO_STD_480P
-	"576p50",	// VIDEO_STD_576P
-	"720p60",	// VIDEO_STD_720P60
-	"1080i60",	// VIDEO_STD_1080I60
-	"720p50",	// VIDEO_STD_720P50
-	"1080i50",	// VIDEO_STD_1080I50
-	"1080p30",	// VIDEO_STD_1080P30
-	"1080p24",	// VIDEO_STD_1080P24
-	"1080p25",	// VIDEO_STD_1080P25
-	"1080p50",	// VIDEO_STD_1080P50
-	"1080p60",	// VIDEO_STD_1080P60
-	"1080p2397",	// VIDEO_STD_1080P2397
-	"1080p2997",	// VIDEO_STD_1080P2997
-	"2160p24",	// VIDEO_STD_2160P24
-	"2160p25",	// VIDEO_STD_2160P25
-	"2160p30",	// VIDEO_STD_2160P30
-	"2160p50",	// VIDEO_STD_2160P50
-	"720p50"	// VIDEO_STD_AUTO
+static const char *VMPEG_visible[] =
+{
+	"/proc/stb/vmpeg/0/visible",
+	"/proc/stb/vmpeg/1/visible",
+	"/proc/stb/vmpeg/2/visible",
+	"/proc/stb/vmpeg/3/visible"
+};
+
+static const char *vid_modes[] =
+{
+	"pal",      // VIDEO_STD_NTSC
+	"pal",      // VIDEO_STD_SECAM
+	"pal",      // VIDEO_STD_PAL
+	"480p",     // VIDEO_STD_480P
+	"576p50",   // VIDEO_STD_576P
+	"720p60",   // VIDEO_STD_720P60
+	"1080i60",  // VIDEO_STD_1080I60
+	"720p50",   // VIDEO_STD_720P50
+	"1080i50",  // VIDEO_STD_1080I50
+	"1080p30",  // VIDEO_STD_1080P30
+	"1080p24",  // VIDEO_STD_1080P24
+	"1080p25",  // VIDEO_STD_1080P25
+	"1080p50",  // VIDEO_STD_1080P50
+	"1080p60",  // VIDEO_STD_1080P60
+	"1080p2397",    // VIDEO_STD_1080P2397
+	"1080p2997",    // VIDEO_STD_1080P2997
+	"2160p24",  // VIDEO_STD_2160P24
+	"2160p25",  // VIDEO_STD_2160P25
+	"2160p30",  // VIDEO_STD_2160P30
+	"2160p50",  // VIDEO_STD_2160P50
+	"720p50"    // VIDEO_STD_AUTO
 };
 
 #define VIDEO_STREAMTYPE_MPEG2 0
@@ -177,7 +210,7 @@
 ssize_t write_all(int fd, const void *buf, size_t count)
 {
 	int retval;
-	char *ptr = (char*)buf;
+	char *ptr = (char *)buf;
 	size_t handledcount = 0;
 	while (handledcount < count)
 	{
@@ -195,65 +228,81 @@
 	return handledcount;
 }
 
-void init_parameters(AVFrame* in_frame, AVCodecContext *codec_context)
+void init_parameters(AVFrame *in_frame, AVCodecContext *codec_context)
 {
 	/* put sample parameters */
 	codec_context->bit_rate = 400000;
 	/* resolution must be a multiple of two */
-	codec_context->width = (in_frame->width/2)*2;
-	codec_context->height = (in_frame->height/2)*2;
+	codec_context->width = (in_frame->width / 2) * 2;
+	codec_context->height = (in_frame->height / 2) * 2;
 	/* frames per second */
-	codec_context->time_base = (AVRational ) { 1, 60 };
+	codec_context->time_base = (AVRational)
+	{
+		1, 60
+	};
 	codec_context->gop_size = 10; /* emit one intra frame every ten frames */
 	codec_context->max_b_frames = 1;
 	codec_context->pix_fmt = AV_PIX_FMT_YUV420P;
 }
 
-void write_frame(AVFrame* in_frame, int fd)
+void write_frame(AVFrame *in_frame, int fd)
 {
-	if(in_frame == NULL)
+	if (in_frame == NULL)
 		return;
 	static const unsigned char pes_header[] = {0x0, 0x0, 0x1, 0xe0, 0x00, 0x00, 0x80, 0x80, 0x5, 0x21, 0x0, 0x1, 0x0, 0x1};
 
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
 	AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MPEG2VIDEO);
+#else
+	const AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MPEG2VIDEO);
+#endif
 	if (codec)
 	{
 		AVCodecContext *codec_context = avcodec_alloc_context3(codec);
 		if (codec_context)
 		{
 			init_parameters(in_frame, codec_context);
-			if (avcodec_open2(codec_context, codec, 0) != -1){
+			if (avcodec_open2(codec_context, codec, 0) != -1)
+			{
 				AVPacket pkt;
 				av_init_packet(&pkt);
 				/* encode the image */
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 				int got_output = 0;
 				int ret = avcodec_encode_video2(codec_context, &pkt, in_frame, &got_output);
-				if (ret != -1){
+				if (ret != -1)
+				{
 #else
 				int ret = avcodec_send_frame(codec_context, in_frame);
-				if (!ret) {
+				if (!ret)
+				{
 					/* signalling end of stream */
 					ret = avcodec_send_frame(codec_context, NULL);
 				}
-				if (!ret) {
+				if (!ret)
+				{
 #endif
 					int i = 1;
 					/* get the delayed frames */
 					in_frame->pts = i;
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 					ret = avcodec_encode_video2(codec_context, &pkt, 0, &got_output);
-					if (ret != -1 && got_output){
+					if (ret != -1 && got_output)
+					{
 #else
 					ret = avcodec_receive_packet(codec_context, &pkt);
-					if (!ret) {
+					if (!ret)
+					{
 #endif
-						if ((pkt.data[3] >> 4) != 0xE){
+						if ((pkt.data[3] >> 4) != 0xE)
+						{
 							write_all(fd, pes_header, sizeof(pes_header));
-						}else{
+						}
+						else
+						{
 							pkt.data[4] = pkt.data[5] = 0x00;
 						}
-						write_all(fd,pkt.data, pkt.size);
+						write_all(fd, pkt.data, pkt.size);
 						av_packet_unref(&pkt);
 					}
 				}
@@ -264,13 +313,15 @@
 	}
 }
 
-int decode_frame(AVCodecContext *codecContext,AVPacket &packet, int fd)
+int decode_frame(AVCodecContext *codecContext, AVPacket &packet, int fd)
 {
 	AVFrame *frame = av_frame_alloc();
-	if(frame){
+	if (frame)
+	{
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 		int decode_ok = 0;
-		if ((avcodec_decode_video2(codecContext, frame, &decode_ok, &packet)) < 0 || !decode_ok){
+		if ((avcodec_decode_video2(codecContext, frame, &decode_ok, &packet)) < 0 || !decode_ok)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
@@ -279,25 +330,29 @@
 		ret = avcodec_send_packet(codecContext, &packet);
 		// In particular, we don't expect AVERROR(EAGAIN), because we read all
 		// decoded frames with avcodec_receive_frame() until done.
-		if (ret < 0) {
+		if (ret < 0)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
 		ret = avcodec_receive_frame(codecContext, frame);
-		if (ret < 0) {
+		if (ret < 0)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
 #endif
 		AVFrame *dest_frame = av_frame_alloc();
-		if(dest_frame){
-			dest_frame->height = (frame->height/2)*2;
-			dest_frame->width = (frame->width/2)*2;
+		if (dest_frame)
+		{
+			dest_frame->height = (frame->height / 2) * 2;
+			dest_frame->width = (frame->width / 2) * 2;
 			dest_frame->format = AV_PIX_FMT_YUV420P;
 			av_frame_get_buffer(dest_frame, 32);
 			struct SwsContext *convert = NULL;
 			convert = sws_getContext(frame->width, frame->height, (AVPixelFormat)frame->format, dest_frame->width, dest_frame->height, AV_PIX_FMT_YUVJ420P, SWS_FAST_BILINEAR, NULL, NULL, NULL);
-			if(convert){
+			if (convert)
+			{
 				sws_scale(convert, frame->data, frame->linesize, 0, frame->height, dest_frame->data, dest_frame->linesize);
 				sws_freeContext(convert);
 			}
@@ -310,19 +365,27 @@
 
 }
 
-AVCodecContext* open_codec(AVMediaType mediaType, AVFormatContext* formatContext)
+AVCodecContext *open_codec(AVMediaType mediaType, AVFormatContext *formatContext)
 {
-	AVCodec * codec = NULL;
-	AVCodecContext * codecContext = NULL;
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
+	AVCodec *codec = NULL;
+#else
+	const AVCodec *codec = NULL;
+#endif
+	AVCodecContext *codecContext = NULL;
 	int stream_index;
-#if (LIBAVFORMAT_VERSION_INT < AV_VERSION_INT( 57,25,101 ))
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(57,25,101)
 	stream_index = av_find_best_stream(formatContext, mediaType, -1, -1, NULL, 0);
-	if (stream_index >= 0) {
+	if (stream_index >= 0)
+	{
 		codecContext = formatContext->streams[stream_index]->codec;
-		if (codecContext) {
+		if (codecContext)
+		{
 			codec = avcodec_find_decoder(codecContext->codec_id);
-			if (codec) {
-				if ((avcodec_open2(codecContext, codec, NULL)) != 0) {
+			if (codec)
+			{
+				if ((avcodec_open2(codecContext, codec, NULL)) != 0)
+				{
 					return NULL;
 				}
 			}
@@ -332,13 +395,17 @@
 	return NULL;
 #else
 	stream_index = av_find_best_stream(formatContext, mediaType, -1, -1, &codec, 0);
-	if (stream_index >= 0) {
+	if (stream_index >= 0)
+	{
 		codec = avcodec_find_decoder(formatContext->streams[stream_index]->codecpar->codec_id);
-		if (codec) {
+		if (codec)
+		{
 			codecContext = avcodec_alloc_context3(codec);
 		}
-		if (codecContext) {
-			if ((avcodec_open2(codecContext, codec, NULL)) != 0) {
+		if (codecContext)
+		{
+			if ((avcodec_open2(codecContext, codec, NULL)) != 0)
+			{
 				return NULL;
 			}
 			return codecContext;
@@ -357,16 +424,20 @@
 #endif
 
 	AVFormatContext *formatContext = avformat_alloc_context();
-	if (formatContext && (ret = avformat_open_input(&formatContext, image_name, NULL, NULL)) == 0){
+	if (formatContext && (ret = avformat_open_input(&formatContext, image_name, NULL, NULL)) == 0)
+	{
 		AVCodecContext *codecContext = open_codec(AVMEDIA_TYPE_VIDEO, formatContext);
-		if(codecContext){
+		if (codecContext)
+		{
 			AVPacket packet;
 			av_init_packet(&packet);
-			if ((ret = av_read_frame(formatContext, &packet)) !=-1){
-				if((ret = decode_frame(codecContext, packet, fd)) != 1){
-				/* add sequence end code to have a real mpeg file */
+			if ((ret = av_read_frame(formatContext, &packet)) != -1)
+			{
+				if ((ret = decode_frame(codecContext, packet, fd)) != 1)
+				{
+					/* add sequence end code to have a real mpeg file */
 					uint8_t endcode[] = { 0, 0, 1, 0xb7 };
-					write_all(fd,endcode, sizeof(endcode));
+					write_all(fd, endcode, sizeof(endcode));
 				}
 				av_packet_unref(&packet);
 			}
@@ -378,15 +449,62 @@
 	av_free(formatContext);
 	return ret;
 }
-enum{ENCODER,AUX};
-void setAVInput(int val)
+
+#ifndef VIDEO_SOURCE_HDMI
+#define VIDEO_SOURCE_HDMI 2
+#endif
+
+void cVideo::open_AVInput_Device(void)
+{
+	hal_debug("%s\n", __func__);
+
+	if (fdd) /* already open */
+		return;
+
+	fop(ioctl, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_HDMI);
+	fop(ioctl, VIDEO_PLAY);
+	fdd = true;
+}
+
+void cVideo::close_AVInput_Device(void)
+{
+	hal_debug("%s\n", __func__);
+
+	if (fdd)
+	{
+		fop(ioctl, VIDEO_STOP);
+		fop(ioctl, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
+	}
+	fdd = false;
+}
+
+void cVideo::setAVInput(int val)
 {
+	hal_info("%s - switching to: %s\n", __func__, val == AUX ? "AUX" : "ENCODER");
+
+	if (val == AUX)
+	{
+		setBlank(1);
+		open_AVInput_Device();
+	}
+	else
+	{
+		if (fdd)
+		{
+			close_AVInput_Device();
+			setBlank(0);
+		}
+	}
+
+#if 0 // not working
 	int input_fd = open("/proc/stb/avs/0/input", O_WRONLY);
-	if(input_fd){
+	if (input_fd)
+	{
 		const char *input[] = {"encoder", "aux"};
 		write(input_fd, input[val], strlen(input[val]));
 		close(input_fd);
 	}
+#endif
 }
 
 cVideo::cVideo(int, void *, void *, unsigned int unit)
@@ -398,20 +516,29 @@
 	saturation = -1;
 	hue = -1;
 	video_standby = 0;
-	if (unit > 1) {
+	blank_mode = 0;
+	hw_caps_t *hwcaps = get_hwcaps();
+	if (unit > (unsigned int) hwcaps->pip_devs)
+	{
 		hal_info("%s: unit %d out of range, setting to 0\n", __func__, unit);
 		devnum = 0;
-	} else
+	}
+	else
 		devnum = unit;
 	fd = -1;
+	fdd = false;
 	openDevice();
+#if 0
 	setAVInput(ENCODER);
+#endif
 }
 
 cVideo::~cVideo(void)
 {
-	if(fd >= 0)
+#if 0
+	if (fd >= 0)
 		setAVInput(AUX);
+#endif
 	if (hdmi_cec::getInstance()->standby_cec_activ && fd >= 0)
 		hdmi_cec::getInstance()->SetCECState(true);
 
@@ -426,7 +553,7 @@
 	if (fd != -1) /* already open */
 		return;
 retry:
-	if ((fd = open(VDEV[devnum], O_RDWR|O_CLOEXEC)) < 0)
+	if ((fd = open(VDEV[devnum], O_RDWR | O_CLOEXEC)) < 0)
 	{
 		if (errno == EBUSY)
 		{
@@ -453,12 +580,12 @@
 
 int cVideo::setAspectRatio(int aspect, int mode)
 {
-	static const char *a[] = { "n/a", "4:3", "14:9", "16:9" };
+	static const char *a[] = { "n/a", "4:3", "16:9" };
 //	static const char *m[] = { "panscan", "letterbox", "bestfit", "nonlinear", "(unset)" };
 	static const char *m[] = { "letterbox", "panscan", "bestfit", "nonlinear", "(unset)" };
 	int n;
 
-	int mo = (mode < 0||mode > 3) ? 4 : mode;
+	int mo = (mode < 0 || mode > 3) ? 4 : mode;
 	hal_debug("%s: a:%d m:%d  %s\n", __func__, aspect, mode, m[mo]);
 
 	if (aspect > 3 || aspect == 0)
@@ -525,7 +652,8 @@
 		fop(ioctl, MPEG_VID_CONTINUE);
 #endif
 	/* implicitly do StopPicture() on video->Start() */
-	if (stillpicture) {
+	if (stillpicture)
+	{
 		hal_info("%s: stillpicture == true, doing implicit StopPicture()\n", __func__);
 		stillpicture = false;
 		Stop(1);
@@ -533,22 +661,27 @@
 	playstate = VIDEO_PLAYING;
 	fop(ioctl, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
 	int res = fop(ioctl, VIDEO_PLAY);
-	if (brightness > -1) {
+	if (brightness > -1)
+	{
 		SetControl(VIDEO_CONTROL_BRIGHTNESS, brightness);
 		brightness = -1;
 	}
-	if (contrast > -1) {
+	if (contrast > -1)
+	{
 		SetControl(VIDEO_CONTROL_CONTRAST, contrast);
 		contrast = -1;
 	}
-	if (saturation > -1) {
+	if (saturation > -1)
+	{
 		SetControl(VIDEO_CONTROL_SATURATION, saturation);
 		saturation = -1;
 	}
-	if (hue > -1) {
+	if (hue > -1)
+	{
 		SetControl(VIDEO_CONTROL_HUE, hue);
 		hue = -1;
 	}
+	blank_mode = 0;
 	return res;
 }
 
@@ -561,16 +694,22 @@
 		return -1;
 	}
 	playstate = blank ? VIDEO_STOPPED : VIDEO_FREEZED;
+	blank_mode = blank;
 	return fop(ioctl, VIDEO_STOP, blank ? 1 : 0);
 }
 
-int cVideo::setBlank(int)
+int cVideo::setBlank(int enable)
 {
 	fop(ioctl, VIDEO_PLAY);
 	fop(ioctl, VIDEO_CONTINUE);
-	video_still_picture sp = { NULL, 0 };
-	fop(ioctl, VIDEO_STILLPICTURE, &sp);
-	return Stop(1);
+	if (enable)
+	{
+		video_still_picture sp = { NULL, 0 };
+		fop(ioctl, VIDEO_STILLPICTURE, &sp);
+		return Stop(1);
+	}
+	else
+		return Start();
 }
 
 int cVideo::SetVideoSystem(int video_system, bool remember)
@@ -597,7 +736,7 @@
 		Stop();
 		stopped = true;
 	}
-	ret = proc_put("/proc/stb/video/videomode", vid_modes[video_system],strlen(vid_modes[video_system]));
+	ret = proc_put("/proc/stb/video/videomode", vid_modes[video_system], strlen(vid_modes[video_system]));
 	if (stopped)
 		Start();
 
@@ -621,10 +760,12 @@
 {
 	if (system == -1)
 		system = GetVideoSystem();
-	if (system < 0 || system > VIDEO_STD_1080P50) {
+	if (system < 0 || system > VIDEO_STD_1080P50)
+	{
 		hal_info("%s: invalid system %d\n", __func__, system);
 		strcpy(format->format, "invalid");
-	} else
+	}
+	else
 		strcpy(format->format, vid_modes[system]);
 }
 
@@ -633,43 +774,27 @@
 	return playstate;
 }
 
-void cVideo::SetVideoMode(analog_mode_t mode)
+bool cVideo::ShowPicture(const char *fname)
 {
-	hal_debug("#%d: %s(%d)\n", devnum, __func__, mode);
-	if (!(mode & ANALOG_SCART_MASK))
-	{
-		hal_debug("%s: non-SCART mode ignored\n", __func__);
-		return;
-	}
-	const char *m;
-	switch(mode)
-	{
-		case ANALOG_SD_YPRPB_SCART:
-			m = "yuv";
-			break;
-		case ANALOG_SD_RGB_SCART:
-			m = "rgb";
-			break;
-		default:
-			hal_info("%s unknown mode %d\n", __func__, mode);
-			m = "rgb";
-			break; /* default to rgb */
-	}
-	proc_put("/proc/stb/avs/0/colorformat", m, strlen(m));
-}
-
-void cVideo::ShowPicture(const char * fname)
-{
-	hal_info("%s(%s)\n", __func__, fname);
+	bool ret = false;
+	hal_debug("%s(%s)\n", __func__, fname);
 	if (video_standby)
 	{
 		/* does not work and the driver does not seem to like it */
 		hal_info("%s: video_standby == true\n", __func__);
-		return;
+		return ret;
 	}
+	/* in movieplayer mode, fd is not opened */
+	if (fd == -1)
+	{
+		hal_info("%s: decoder not opened\n", __func__);
+		return ret;
+	}
+
 	struct stat st;
-	if (stat(fname, &st)){
-		return;
+	if (stat(fname, &st))
+	{
+		return ret;
 	}
 	closeDevice();
 	openDevice();
@@ -684,13 +809,14 @@
 		ioctl(fd, VIDEO_CLEAR_BUFFER);
 		image_to_mpeg2(fname, fd);
 		unsigned char iframe[8192];
-		memset(iframe,0xff,sizeof(iframe));
+		memset(iframe, 0xff, sizeof(iframe));
 		write_all(fd, iframe, 8192);
 		usleep(150000);
 		ioctl(fd, VIDEO_STOP, 0);
 		ioctl(fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
+		ret = true;
 	}
-	return;
+	return ret;
 }
 
 void cVideo::StopPicture()
@@ -708,12 +834,16 @@
 	if (bOn)
 	{
 		closeDevice();
+#if 0
 		setAVInput(AUX);
+#endif
 	}
 	else
 	{
 		openDevice();
+#if 0
 		setAVInput(ENCODER);
+#endif
 	}
 	video_standby = bOn;
 	hdmi_cec::getInstance()->SetCECState(video_standby);
@@ -721,9 +851,60 @@
 
 int cVideo::getBlank(void)
 {
+#if 0
 	int ret = proc_get_hex(VMPEG_xres[devnum]);
 	hal_debug("%s => %d\n", __func__, !ret);
 	return !ret;
+#else
+	hal_debug("%s => %d\n", __func__, blank_mode);
+	return blank_mode;
+#endif
+}
+
+void cVideo::QuadPiP(bool active, int _x, int _y, int _w, int _h)
+{
+	char buffer[64];
+	int _a = 1;
+	if (active) {
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+		proc_put("/proc/stb/video/decodermode", "mosaic", strlen("mosaic"));
+#endif
+		for (unsigned int i = 0; i < 4; i++) {
+			sprintf(buffer, "%x", _x);
+			proc_put(VMPEG_dst_left[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", _y);
+			proc_put(VMPEG_dst_top[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", _w);
+			proc_put(VMPEG_dst_width[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", _h);
+			proc_put(VMPEG_dst_height[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", _a);
+			proc_put(VMPEG_dst_apply[i], buffer, strlen(buffer));
+		}
+	} else {
+		for (unsigned int i = 0; i < 4; i++) {
+			sprintf(buffer, "%x", 0);
+			proc_put(VMPEG_dst_left[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", 0);
+			proc_put(VMPEG_dst_top[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", 0);
+			proc_put(VMPEG_dst_width[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", 0);
+			proc_put(VMPEG_dst_height[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", _a);
+			proc_put(VMPEG_dst_apply[i], buffer, strlen(buffer));
+		}
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+		proc_put("/proc/stb/video/decodermode", "normal", strlen("normal"));
+#endif
+	}
+}
+
+void cVideo::ShowPig(int _x)
+{
+	char buffer[64];
+	sprintf(buffer, "%d", _x);
+	proc_put(VMPEG_visible[devnum], buffer, strlen(buffer));
 }
 
 void cVideo::Pig(int x, int y, int w, int h, int osd_w, int osd_h, int startx, int starty, int endx, int endy)
@@ -772,6 +953,9 @@
 
 	sprintf(buffer, "%x", _h);
 	proc_put(VMPEG_dst_height[devnum], buffer, strlen(buffer));
+
+	sprintf(buffer, "%x", 1);
+	proc_put(VMPEG_dst_apply[devnum], buffer, strlen(buffer));
 }
 
 static inline int rate2csapi(int rate)
@@ -836,7 +1020,8 @@
 
 int cVideo::SetStreamType(VIDEO_FORMAT type)
 {
-	static const char *VF[] = {
+	static const char *VF[] =
+	{
 		"VIDEO_FORMAT_MPEG2",
 		"VIDEO_FORMAT_MPEG4",
 		"VIDEO_FORMAT_VC1",
@@ -888,67 +1073,69 @@
 void cVideo::SetControl(int control, int value)
 {
 	const char *p = NULL;
-	switch (control) {
-	case VIDEO_CONTROL_BRIGHTNESS:
-		brightness = value;
-		p = "/proc/stb/vmpeg/0/pep_brightness";
-		break;
-	case VIDEO_CONTROL_CONTRAST:
-		contrast = value;
-		p = "/proc/stb/vmpeg/0/pep_contrast";
-		break;
-	case VIDEO_CONTROL_SATURATION:
-		saturation = value;
-		p = "/proc/stb/vmpeg/0/pep_saturation";
-		break;
-	case VIDEO_CONTROL_HUE:
-		hue = value;
-		p = "/proc/stb/vmpeg/0/pep_hue";
-		break;
-	case VIDEO_CONTROL_SHARPNESS:
-		sharpness = value;
-		p = "/proc/stb/vmpeg/0/pep_sharpness";
-		break;
-	case VIDEO_CONTROL_BLOCK_NOISE_REDUCTION:
-		block_noise_reduction = value;
-		p = "/proc/stb/vmpeg/0/pep_block_noise_reduction";
-		break;
-	case VIDEO_CONTROL_MOSQUITO_NOISE_REDUCTION:
-		mosquito_noise_reduction = value;
-		p = "/proc/stb/vmpeg/0/pep_mosquito_noise_reduction";
-		break;
-	case VIDEO_CONTROL_DIGITAL_CONTOUR_REMOVAL:
-		digital_contour_removal = value;
-		p = "/proc/stb/vmpeg/0/pep_digital_contour_removal";
-		break;
-	case VIDEO_CONTROL_AUTO_FLESH:
-		auto_flesh = value;
-		p = "/proc/stb/vmpeg/0/pep_auto_flesh";
-		break;
-	case VIDEO_CONTROL_GREEN_BOOST:
-		green_boost = value;
-		p = "/proc/stb/vmpeg/0/pep_green_boost";
-		break;
-	case VIDEO_CONTROL_BLUE_BOOST:
-		blue_boost = value;
-		p = "/proc/stb/vmpeg/0/pep_blue_boost";
-		break;
-	case VIDEO_CONTROL_DYNAMIC_CONTRAST:
-		dynamic_contrast = value;
-		p = "/proc/stb/vmpeg/0/pep_dynamic_contrast";
-		break;
-	case VIDEO_CONTROL_SCALER_SHARPNESS:
-		scaler_sharpness = value;
-		p = "/proc/stb/vmpeg/0/pep_scaler_sharpness";
-		break;
-	case VIDEO_CONTROL_ZAPPING_MODE:
-		zapping_mode = value;
-		const char *mode_zapping[] = { "mute", "hold", "mutetilllock", "holdtilllock"};
-		proc_put("/proc/stb/video/zapmode", mode_zapping[zapping_mode], strlen(mode_zapping[zapping_mode]));
+	switch (control)
+	{
+		case VIDEO_CONTROL_BRIGHTNESS:
+			brightness = value;
+			p = "/proc/stb/vmpeg/0/pep_brightness";
+			break;
+		case VIDEO_CONTROL_CONTRAST:
+			contrast = value;
+			p = "/proc/stb/vmpeg/0/pep_contrast";
+			break;
+		case VIDEO_CONTROL_SATURATION:
+			saturation = value;
+			p = "/proc/stb/vmpeg/0/pep_saturation";
+			break;
+		case VIDEO_CONTROL_HUE:
+			hue = value;
+			p = "/proc/stb/vmpeg/0/pep_hue";
+			break;
+		case VIDEO_CONTROL_SHARPNESS:
+			sharpness = value;
+			p = "/proc/stb/vmpeg/0/pep_sharpness";
+			break;
+		case VIDEO_CONTROL_BLOCK_NOISE_REDUCTION:
+			block_noise_reduction = value;
+			p = "/proc/stb/vmpeg/0/pep_block_noise_reduction";
+			break;
+		case VIDEO_CONTROL_MOSQUITO_NOISE_REDUCTION:
+			mosquito_noise_reduction = value;
+			p = "/proc/stb/vmpeg/0/pep_mosquito_noise_reduction";
+			break;
+		case VIDEO_CONTROL_DIGITAL_CONTOUR_REMOVAL:
+			digital_contour_removal = value;
+			p = "/proc/stb/vmpeg/0/pep_digital_contour_removal";
+			break;
+		case VIDEO_CONTROL_AUTO_FLESH:
+			auto_flesh = value;
+			p = "/proc/stb/vmpeg/0/pep_auto_flesh";
+			break;
+		case VIDEO_CONTROL_GREEN_BOOST:
+			green_boost = value;
+			p = "/proc/stb/vmpeg/0/pep_green_boost";
+			break;
+		case VIDEO_CONTROL_BLUE_BOOST:
+			blue_boost = value;
+			p = "/proc/stb/vmpeg/0/pep_blue_boost";
+			break;
+		case VIDEO_CONTROL_DYNAMIC_CONTRAST:
+			dynamic_contrast = value;
+			p = "/proc/stb/vmpeg/0/pep_dynamic_contrast";
+			break;
+		case VIDEO_CONTROL_SCALER_SHARPNESS:
+			scaler_sharpness = value;
+			p = "/proc/stb/vmpeg/0/pep_scaler_sharpness";
+			break;
+		case VIDEO_CONTROL_ZAPPING_MODE:
+			zapping_mode = value;
+			const char *mode_zapping[] = { "mute", "hold", "mutetilllock", "holdtilllock"};
+			proc_put("/proc/stb/video/zapmode", mode_zapping[zapping_mode], strlen(mode_zapping[zapping_mode]));
 //		proc_put("/proc/stb/video/zapping_mode", mode_zapping[zapping_mode], strlen(mode_zapping[zapping_mode]));
-		break;
+			break;
 	}
-	if (p) {
+	if (p)
+	{
 		char buf[20];
 		int fix_value = value * 256;
 		int len = snprintf(buf, sizeof(buf), "%.8X", fix_value);
@@ -957,55 +1144,64 @@
 	}
 }
 
-void cVideo::SetColorFormat(COLOR_FORMAT color_format)
+#if BOXMODEL_VUPLUS_ARM
+void cVideo::SetHDMIColorimetry(HDMI_COLORIMETRY hdmi_colorimetry)
 {
 	const char *p = NULL;
-	switch(color_format) {
-	case COLORFORMAT_RGB:
-		p = "rgb";
-		break;
-	case COLORFORMAT_YUV:
-		p = "yuv";
-		break;
-	case COLORFORMAT_CVBS:
-		p = "cvbs";
-		break;
-	case COLORFORMAT_SVIDEO:
-		p = "svideo";
-		break;
-	case COLORFORMAT_HDMI_AUTO:
-		p = "Edid(Auto)";
-		break;
-	case COLORFORMAT_HDMI_RGB:
-		p = "Hdmi_Rgb";
-		break;
-	case COLORFORMAT_HDMI_YCBCR444:
-		p = "444";
-		break;
-	case COLORFORMAT_HDMI_YCBCR422:
-		p = "422";
-		break;
-	case COLORFORMAT_HDMI_YCBCR420:
-		p = "420";
-		break;
+	switch (hdmi_colorimetry)
+	{
+		case HDMI_COLORIMETRY_AUTO:
+			p = "Edit(Auto)";
+			break;
+		case HDMI_COLORIMETRY_BT709:
+			p = "Itu_R_BT_709";
+			break;
+		case HDMI_COLORIMETRY_BT470:
+			p = "Itu_R_BT_470_2_BG";
+			break;
 	}
 	if (p)
 		proc_put("/proc/stb/video/hdmi_colorspace", p, strlen(p));
 }
+#else
+void cVideo::SetHDMIColorimetry(HDMI_COLORIMETRY hdmi_colorimetry)
+{
+	const char *p = NULL;
+	switch (hdmi_colorimetry)
+	{
+		case HDMI_COLORIMETRY_AUTO:
+			p = "auto";
+			break;
+		case HDMI_COLORIMETRY_BT2020NCL:
+			p = "bt2020ncl";
+			break;
+		case HDMI_COLORIMETRY_BT2020CL:
+			p = "bt2020cl";
+			break;
+		case HDMI_COLORIMETRY_BT709:
+			p = "bt709";
+			break;
+	}
+	if (p)
+		proc_put("/proc/stb/video/hdmi_colorimetry", p, strlen(p));
+}
+#endif
 
 bool getvideo2(unsigned char *video, int xres, int yres)
 {
 	bool ret = false;
-	if(video ==  NULL)
+	if (video ==  NULL)
 		return ret;
 	char videosnapshot[] = "/dev/dvb/adapter0/video0";
 	int fd_video = open(videosnapshot, O_RDONLY);
-	if (fd_video < 0) {
+	if (fd_video < 0)
+	{
 		perror(videosnapshot);
 		return ret;
 	}
 	ssize_t r = read(fd_video, video, xres * yres * 3);
-	if(r){
+	if (r)
+	{
 		ret = true;
 	}
 	close(fd_video);
@@ -1017,42 +1213,49 @@
 	int len = 0;
 	struct SwsContext *scale = NULL;
 	scale = sws_getCachedContext(scale, sw, sh, sfmt, dw, dh, AV_PIX_FMT_RGB32, SWS_BICUBIC, 0, 0, 0);
-	if (!scale) {
+	if (!scale)
+	{
 		hal_info_c("%s: ERROR setting up SWS context\n", __func__);
 		return ret;
 	}
 	AVFrame *sframe = av_frame_alloc();
 	AVFrame *dframe = av_frame_alloc();
-	if (sframe && dframe) {
+	if (sframe && dframe)
+	{
 		len = av_image_fill_arrays(sframe->data, sframe->linesize, &(src)[0], sfmt, sw, sh, 1);
-		if(len>-1)
+		if (len > -1)
 			ret = true;
 
-		if(ret && (len = av_image_fill_arrays(dframe->data, dframe->linesize, &(dst)[0], AV_PIX_FMT_RGB32, dw, dh, 1)<0))
+		if (ret && (len = av_image_fill_arrays(dframe->data, dframe->linesize, &(dst)[0], AV_PIX_FMT_RGB32, dw, dh, 1) < 0))
 			ret = false;
 
-		if(ret && (len = sws_scale(scale, sframe->data, sframe->linesize, 0, sh, dframe->data, dframe->linesize)<0))
+		if (ret && (len = sws_scale(scale, sframe->data, sframe->linesize, 0, sh, dframe->data, dframe->linesize) < 0))
 			ret = false;
 		else
 			ret = true;
-	}else{
+	}
+	else
+	{
 		hal_info_c("%s: could not alloc sframe (%p) or dframe (%p)\n", __func__, sframe, dframe);
 		ret = false;
 	}
 
-	if(sframe){
+	if (sframe)
+	{
 		av_frame_free(&sframe);
 		sframe = NULL;
 	}
-	if(dframe){
+	if (dframe)
+	{
 		av_frame_free(&dframe);
 		dframe = NULL;
 	}
-	if(scale){
+	if (scale)
+	{
 		sws_freeContext(scale);
 		scale = NULL;
 	}
-	hal_info_c("%s: %s scale %ix%i to %ix%i ,len %i\n",ret?" ":"ERROR",__func__, sw, sh, dw, dh,len);
+	hal_info_c("%s: %s scale %ix%i to %ix%i ,len %i\n", ret ? " " : "ERROR", __func__, sw, sh, dw, dh, len);
 
 	return ret;
 }
@@ -1060,7 +1263,7 @@
 // grabing the osd picture
 void get_osd_size(int &xres, int &yres, int &bits_per_pixel)
 {
-	int fb=open("/dev/fb/0", O_RDWR);
+	int fb = open("/dev/fb/0", O_RDWR);
 	if (fb == -1)
 	{
 		fprintf(stderr, "Framebuffer failed\n");
@@ -1068,7 +1271,7 @@
 	}
 
 	struct fb_var_screeninfo var_screeninfo;
-	if(ioctl(fb, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
+	if (ioctl(fb, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
 	{
 		fprintf(stderr, "Framebuffer: <FBIOGET_VSCREENINFO failed>\n");
 		close(fb);
@@ -1077,9 +1280,9 @@
 	close(fb);
 
 	bits_per_pixel = var_screeninfo.bits_per_pixel;
-	xres=var_screeninfo.xres;
-	yres=var_screeninfo.yres;
-	fprintf(stderr, "... Framebuffer-Size: %d x %d\n",xres,yres);
+	xres = var_screeninfo.xres;
+	yres = var_screeninfo.yres;
+	fprintf(stderr, "... Framebuffer-Size: %d x %d\n", xres, yres);
 
 }
 void get_osd_buf(unsigned char *osd_data)
@@ -1088,45 +1291,47 @@
 	struct fb_fix_screeninfo fix_screeninfo;
 	struct fb_var_screeninfo var_screeninfo;
 
-	int fb=open("/dev/fb/0", O_RDWR);
+	int fb = open("/dev/fb/0", O_RDWR);
 	if (fb == -1)
 	{
 		fprintf(stderr, "Framebuffer failed\n");
 		return;
 	}
 
-	if(ioctl(fb, FBIOGET_FSCREENINFO, &fix_screeninfo) == -1)
+	if (ioctl(fb, FBIOGET_FSCREENINFO, &fix_screeninfo) == -1)
 	{
 		fprintf(stderr, "Framebuffer: <FBIOGET_FSCREENINFO failed>\n");
 		close(fb);
 		return;
 	}
 
-	if(ioctl(fb, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
+	if (ioctl(fb, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
 	{
 		fprintf(stderr, "Framebuffer: <FBIOGET_VSCREENINFO failed>\n");
 		close(fb);
 		return;
 	}
 
-	if(!(lfb = (unsigned char*)mmap(0, fix_screeninfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb, 0)))
+	if (!(lfb = (unsigned char *)mmap(0, fix_screeninfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb, 0)))
 	{
 		fprintf(stderr, "Framebuffer: <Memmapping failed>\n");
 		close(fb);
 		return;
 	}
 
-	if ( var_screeninfo.bits_per_pixel == 32 )
+	if (var_screeninfo.bits_per_pixel == 32)
 	{
 		fprintf(stderr, "Grabbing 32bit Framebuffer ...\n");
 		// get 32bit framebuffer
-		memcpy(osd_data,lfb,fix_screeninfo.line_length*var_screeninfo.yres);
+		memcpy(osd_data, lfb, fix_screeninfo.line_length * var_screeninfo.yres);
 	}
 	close(fb);
 }
 
-inline void rgb24torgb32(unsigned char  *src, unsigned char *dest,int picsize) {
-	for (int i = 0; i < picsize; i++) {
+inline void rgb24torgb32(unsigned char  *src, unsigned char *dest, int picsize)
+{
+	for (int i = 0; i < picsize; i++)
+	{
 		*dest++ = *src++;
 		*dest++ = *src++;
 		*dest++ = *src++;
@@ -1135,30 +1340,32 @@
 }
 
 /* TODO: aspect ratio correction and PIP */
-bool cVideo::GetScreenImage(unsigned char * &out_data, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
+bool cVideo::GetScreenImage(unsigned char*&out_data, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
 {
 #define VDEC_PIXFMT AV_PIX_FMT_BGR24
 
 	hal_info("%s: out_data 0x%p xres %d yres %d vid %d osd %d scale %d\n",
-		__func__, out_data, xres, yres, get_video, get_osd, scale_to_video);
+	    __func__, out_data, xres, yres, get_video, get_osd, scale_to_video);
 	int aspect = 0;
 	getPictureInfo(xres, yres, aspect); /* aspect is dummy here */
 	aspect = getAspectRatio();
-	if(xres < 1 || yres < 1 )
+	if (xres < 1 || yres < 1)
 		get_video = false;
 
 
-	if(!get_video && !get_osd)
+	if (!get_video && !get_osd)
 		return false;
 
 	int osd_w = 0;
 	int osd_h = 0;
 	int bits_per_pixel = 0;
-	if(get_osd){
+	if (get_osd)
+	{
 		get_osd_size(osd_w, osd_h, bits_per_pixel);
-		if(osd_w < 1 || osd_h < 1 || bits_per_pixel != 32)
+		if (osd_w < 1 || osd_h < 1 || bits_per_pixel != 32)
 			get_osd = false;
-		if(!scale_to_video && get_osd){
+		if (!scale_to_video && get_osd)
+		{
 			xres = osd_w;
 			yres = osd_h;
 		}
@@ -1168,41 +1375,52 @@
 	if (out_data == NULL)
 		return false;
 
-	if (get_video) {
-		const int grab_w = 1920; const int grab_h = 1080; //hd51 video0 is always 1920x1080 
+	if (get_video)
+	{
+		const int grab_w = 1920;
+		const int grab_h = 1080; //hd51 video0 is always 1920x1080
 		unsigned char *video_src = (unsigned char *)malloc(grab_w * grab_h * 3);
 		if (video_src == NULL)
 			return false;
-		if(getvideo2(video_src, grab_w,grab_h) == false){
+		if (getvideo2(video_src, grab_w, grab_h) == false)
+		{
 			free(out_data);
 			free(video_src);
 			return false;
 		}
-		if (grab_w != xres || grab_h != yres){ /* scale video into data... */
-			bool ret = swscale(video_src, out_data, grab_w, grab_h, xres, yres,VDEC_PIXFMT);
-			if(!ret){
+		if (grab_w != xres || grab_h != yres)  /* scale video into data... */
+		{
+			bool ret = swscale(video_src, out_data, grab_w, grab_h, xres, yres, VDEC_PIXFMT);
+			if (!ret)
+			{
 				free(out_data);
 				free(video_src);
 				return false;
 			}
-		}else{ /* get_video and no fancy scaling needed */
+		}
+		else   /* get_video and no fancy scaling needed */
+		{
 			rgb24torgb32(video_src, out_data, grab_w * grab_h);
 		}
 		free(video_src);
 	}
 
-	if(get_osd){
+	if (get_osd)
+	{
 		osd_data = (unsigned char *)malloc(osd_w * osd_h * 4);
-		if(osd_data)
+		if (osd_data)
 			get_osd_buf(osd_data);
 	}
 
-	if (get_osd && (osd_w != xres || osd_h != yres)) {
+	if (get_osd && (osd_w != xres || osd_h != yres))
+	{
 		/* rescale osd */
 		unsigned char *osd_src = (unsigned char *)malloc(xres * yres * 4);
-		if(osd_src){
-			bool ret = swscale(osd_data, osd_src, osd_w, osd_h, xres, yres,AV_PIX_FMT_RGB32);
-			if(!ret){
+		if (osd_src)
+		{
+			bool ret = swscale(osd_data, osd_src, osd_w, osd_h, xres, yres, AV_PIX_FMT_RGB32);
+			if (!ret)
+			{
 				free(out_data);
 				free(osd_data);
 				free(osd_src);
@@ -1211,30 +1429,38 @@
 			free(osd_data);
 			osd_data = NULL;
 			osd_data = osd_src;
-		}else{
+		}
+		else
+		{
 			free(out_data);
 			free(osd_data);
 			return false;
 		}
 	}
 
-	if (get_video && get_osd) {
+	if (get_video && get_osd)
+	{
 		/* alpha blend osd onto out_data (video). TODO: maybe libavcodec can do this? */
 		uint32_t *d = (uint32_t *)out_data;
 		uint32_t *pixpos = (uint32_t *) osd_data;
-		for (int count = 0; count < yres; count++) {
-			for (int count2 = 0; count2 < xres; count2++ ) {
+		for (int count = 0; count < yres; count++)
+		{
+			for (int count2 = 0; count2 < xres; count2++)
+			{
 				uint32_t pix = *pixpos;
 				if ((pix & 0xff000000) == 0xff000000)
 					*d = pix;
-				else {
+				else
+				{
 					uint8_t *in = (uint8_t *)(pixpos);
 					uint8_t *out = (uint8_t *)d;
-					int a = in[3];	/* TODO: big/little endian? */
+					int a = in[3];  /* TODO: big/little endian? */
 					*out = (*out + ((*in - *out) * a) / 256);
-					in++; out++;
+					in++;
+					out++;
 					*out = (*out + ((*in - *out) * a) / 256);
-					in++; out++;
+					in++;
+					out++;
 					*out = (*out + ((*in - *out) * a) / 256);
 				}
 				d++;
@@ -1245,7 +1471,7 @@
 	else if (get_osd) /* only get_osd, out_data is not yet populated */
 		memcpy(out_data, osd_data, xres * yres * sizeof(uint32_t));
 
-	if(osd_data)
+	if (osd_data)
 		free(osd_data);
 
 	return true;
@@ -1265,3 +1491,13 @@
 {
 	hdmi_cec::getInstance()->SetCECAutoView(state);
 }
+
+int cVideo::GetAudioDestination()
+{
+	return (int)hdmi_cec::getInstance()->GetAudioDestination();
+}
+
+void cVideo::SetAudioDestination(int audio_dest)
+{
+	hdmi_cec::getInstance()->SetAudioDestination(audio_dest);
+}
diff -Nur libstb-hal-ddt.git.orig/libarmbox/video_lib.h libstb-hal-ddt.git/libarmbox/video_lib.h
--- libstb-hal-ddt.git.orig/libarmbox/video_lib.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libarmbox/video_lib.h	2022-07-23 18:18:31.503773029 +0200
@@ -10,31 +10,25 @@
 	char format[16];
 } cs_vs_format_struct_t;
 
-typedef enum {
-	ANALOG_SD_RGB_CINCH = 0x00,
-	ANALOG_SD_YPRPB_CINCH,
-	ANALOG_HD_RGB_CINCH,
-	ANALOG_HD_YPRPB_CINCH,
-	ANALOG_SD_RGB_SCART = 0x10,
-	ANALOG_SD_YPRPB_SCART,
-	ANALOG_HD_RGB_SCART,
-	ANALOG_HD_YPRPB_SCART,
-	ANALOG_SCART_MASK = 0x10
-} analog_mode_t;
-
-typedef enum {
-	COLORFORMAT_RGB = 0x10, // keep compatible with analog_mode_t
-	COLORFORMAT_YUV,
-	COLORFORMAT_CVBS,
-	COLORFORMAT_SVIDEO,
-	COLORFORMAT_HDMI_AUTO,
-	COLORFORMAT_HDMI_RGB,
-	COLORFORMAT_HDMI_YCBCR444,
-	COLORFORMAT_HDMI_YCBCR422,
-	COLORFORMAT_HDMI_YCBCR420
-} COLOR_FORMAT;
+#if BOXMODEL_VUPLUS_ARM
+typedef enum
+{
+	HDMI_COLORIMETRY_AUTO,
+	HDMI_COLORIMETRY_BT709,
+	HDMI_COLORIMETRY_BT470
+} HDMI_COLORIMETRY;
+#else
+typedef enum
+{
+	HDMI_COLORIMETRY_AUTO,
+	HDMI_COLORIMETRY_BT2020NCL,
+	HDMI_COLORIMETRY_BT2020CL,
+	HDMI_COLORIMETRY_BT709
+} HDMI_COLORIMETRY;
+#endif
 
-typedef enum {
+typedef enum
+{
 	VIDEO_FORMAT_MPEG2 = 0,
 	VIDEO_FORMAT_MPEG4_H264,
 	VIDEO_FORMAT_VC1,
@@ -45,16 +39,8 @@
 	VIDEO_FORMAT_AVS = 16
 } VIDEO_FORMAT;
 
-typedef enum {
-	VIDEO_SD = 0,
-	VIDEO_HD,
-	VIDEO_120x60i,
-	VIDEO_320x240i,
-	VIDEO_1440x800i,
-	VIDEO_360x288i
-} VIDEO_DEFINITION;
-
-typedef enum {
+typedef enum
+{
 	VIDEO_FRAME_RATE_23_976 = 0,
 	VIDEO_FRAME_RATE_24,
 	VIDEO_FRAME_RATE_25,
@@ -65,29 +51,24 @@
 	VIDEO_FRAME_RATE_60
 } VIDEO_FRAME_RATE;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_1_1,
 	DISPLAY_AR_4_3,
-	DISPLAY_AR_14_9,
 	DISPLAY_AR_16_9,
 	DISPLAY_AR_20_9,
 	DISPLAY_AR_RAW
 } DISPLAY_AR;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_MODE_PANSCAN = 0,
 	DISPLAY_AR_MODE_LETTERBOX,
-	DISPLAY_AR_MODE_NONE,
-	DISPLAY_AR_MODE_PANSCAN2
+	DISPLAY_AR_MODE_NONE
 } DISPLAY_AR_MODE;
 
-typedef enum {
-	VIDEO_DB_DR_NEITHER = 0,
-	VIDEO_DB_ON,
-	VIDEO_DB_DR_BOTH
-} VIDEO_DB_DR;
-
-typedef enum {
+typedef enum
+{
 	VIDEO_PLAY_STILL = 0,
 	VIDEO_PLAY_CLIP,
 	VIDEO_PLAY_TRICK,
@@ -95,7 +76,8 @@
 	VIDEO_PLAY_MOTION_NO_SYNC
 } VIDEO_PLAY_MODE;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_STD_NTSC,
 	VIDEO_STD_SECAM,
 	VIDEO_STD_PAL,
@@ -120,7 +102,8 @@
 	VIDEO_STD_MAX = VIDEO_STD_AUTO
 } VIDEO_STD;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_HDMI_CEC_MODE_OFF = 0,
 	VIDEO_HDMI_CEC_MODE_TUNER = 3,
 	VIDEO_HDMI_CEC_MODE_RECORDER = 1
@@ -128,6 +111,13 @@
 
 typedef enum
 {
+	VIDEO_HDMI_CEC_VOL_OFF = 0,
+	VIDEO_HDMI_CEC_VOL_AUDIOSYSTEM = 1,
+	VIDEO_HDMI_CEC_VOL_TV = 2
+} VIDEO_HDMI_CEC_VOL;
+
+typedef enum
+{
 	VIDEO_CONTROL_BRIGHTNESS = 0,
 	VIDEO_CONTROL_CONTRAST,
 	VIDEO_CONTROL_SATURATION,
@@ -150,11 +140,12 @@
 
 class cVideo
 {
-	friend class cPlayback;
-	friend class cDemux;
+		friend class cPlayback;
+		friend class cDemux;
 	private:
 		/* video device */
 		int fd;
+		bool fdd;
 		unsigned int devnum;
 		/* apparently we cannot query the driver's state
 		   => remember it */
@@ -163,11 +154,9 @@
 		int /*vidOutFmt_t*/ outputformat;
 
 		VIDEO_FORMAT StreamType;
-		VIDEO_DEFINITION VideoDefinition;
 		DISPLAY_AR DisplayAR;
 		VIDEO_PLAY_MODE SyncMode;
 		DISPLAY_AR_MODE ARMode;
-		VIDEO_DB_DR eDbDr;
 		DISPLAY_AR PictureAR;
 		VIDEO_FRAME_RATE FrameRate;
 		int video_standby;
@@ -185,10 +174,10 @@
 		int dynamic_contrast;
 		int scaler_sharpness;
 		int zapping_mode;
+		int blank_mode;
 
 		/* used internally by dmx */
 		int64_t GetPTS(void);
-
 	public:
 		/* constructor & destructor */
 		cVideo(int mode, void *, void *, unsigned int unit = 0);
@@ -198,8 +187,19 @@
 		void openDevice(void);
 		void closeDevice(void);
 
-		void * GetTVEnc() { return NULL; };
-		void * GetTVEncSD() { return NULL; };
+		void open_AVInput_Device(void);
+		void close_AVInput_Device(void);
+
+		void setAVInput(int val);
+
+		void *GetTVEnc()
+		{
+			return NULL;
+		};
+		void *GetTVEncSD()
+		{
+			return NULL;
+		};
 
 		/* aspect ratio */
 		int getAspectRatio(void);
@@ -224,7 +224,7 @@
 		/* get video system infos */
 		int GetVideoSystem(void);
 		/* when system = -1 then use current video system */
-		void GetVideoSystemFormatName(cs_vs_format_t* format, int system);
+		void GetVideoSystemFormatName(cs_vs_format_t *format, int system);
 
 		/* set video_system */
 		int SetVideoSystem(int video_system, bool remember = true);
@@ -233,23 +233,40 @@
 		bool SetCECMode(VIDEO_HDMI_CEC_MODE);
 		void SetCECAutoView(bool);
 		void SetCECAutoStandby(bool);
-		void ShowPicture(const char * fname);
+		int  GetAudioDestination();
+		void SetAudioDestination(int audio_dest);
+		bool ShowPicture(const char *fname);
 		void StopPicture();
 		void Standby(unsigned int bOn);
+		void ShowPig(int _x);
 		void Pig(int x, int y, int w, int h, int osd_w = 1064, int osd_h = 600, int startx = 0, int starty = 0, int endx = 1279, int endy = 719);
 		void SetControl(int, int);
 		void setContrast(int val);
-		void SetVideoMode(analog_mode_t mode);
-		void SetDBDR(int) { return; };
-		void SetAudioHandle(void *) { return; };
-		void SetAutoModes(int [VIDEO_STD_MAX]) { return; };
-		int  OpenVBI(int) { return 0; };
-		int  CloseVBI(void) { return 0; };
-		int  StartVBI(unsigned short) { return 0; };
-		int  StopVBI(void) { return 0; };
+		void QuadPiP(bool active = false, int _x = 0, int _y = 0, int _w = 360, int _h = 288);
+
+		void SetAudioHandle(void *)
+		{
+			return;
+		};
+		int  OpenVBI(int)
+		{
+			return 0;
+		};
+		int  CloseVBI(void)
+		{
+			return 0;
+		};
+		int  StartVBI(unsigned short)
+		{
+			return 0;
+		};
+		int  StopVBI(void)
+		{
+			return 0;
+		};
 		void SetDemux(cDemux *dmx);
-		void SetColorFormat(COLOR_FORMAT color_format);
-		bool GetScreenImage(unsigned char * &data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
+		void SetHDMIColorimetry(HDMI_COLORIMETRY hdmi_colorimetry);
+		bool GetScreenImage(unsigned char*&data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
 };
 
 #endif // __VIDEO_LIB_H__
diff -Nur libstb-hal-ddt.git.orig/libazbox/audio.cpp libstb-hal-ddt.git/libazbox/audio.cpp
--- libstb-hal-ddt.git.orig/libazbox/audio.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/audio.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,398 +0,0 @@
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <sys/fcntl.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-
-#include <linux/dvb/audio.h>
-
-#include <proc_tools.h>
-
-#include "audio_lib.h"
-#include "hal_debug.h"
-
-#define AUDIO_DEVICE	"/dev/dvb/adapter0/audio0"
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_AUDIO, this, args)
-#define hal_info(args...) _hal_info(HAL_DEBUG_AUDIO, this, args)
-
-#include <linux/soundcard.h>
-
-cAudio * audioDecoder = NULL;
-
-cAudio::cAudio(void *, void *, void *)
-{
-	fd = -1;
-	clipfd = -1;
-	mixer_fd = -1;
-	openDevice();
-	Muted = false;
-}
-
-cAudio::~cAudio(void)
-{
-	closeDevice();
-}
-
-void cAudio::openDevice(void)
-{
-	hal_debug("%s\n", __func__);
-	if (fd < 0)
-	{
-		if ((fd = open(AUDIO_DEVICE, O_RDONLY|O_CLOEXEC)) < 0)
-			hal_info("openDevice: open failed (%m)\n");
-		do_mute(true, false);
-	}
-	else
-		hal_info("openDevice: already open (fd = %d)\n", fd);
-}
-
-void cAudio::closeDevice(void)
-{
-	hal_debug("%s\n", __func__);
-	ioctl(fd, AUDIO_CONTINUE); /* enigma2 also does CONTINUE before close... */
-	if (fd >= 0)
-		close(fd);
-	fd = -1;
-	if (clipfd >= 0)
-		close(clipfd);
-	clipfd = -1;
-	if (mixer_fd >= 0)
-		close(mixer_fd);
-	mixer_fd = -1;
-}
-
-int cAudio::do_mute(bool enable, bool remember)
-{
-	hal_debug("%s(%d, %d)\n", __func__, enable, remember);
-
-	if (remember)
-		Muted = enable;
-#if 0
-	/* does not work? */
-	if (ioctl(fd, AUDIO_SET_MUTE, enable) < 0 )
-		hal_info("%s: AUDIO_SET_MUTE failed (%m)\n", __func__);
-#else
-	char s[2] = { 0, 0 };
-	s[0] = '0' + (int)enable;
-	proc_put("/proc/stb/audio/j1_mute", s, 2);
-#endif
-	return 0;
-}
-
-int map_volume(const int volume)
-{
-	unsigned char vol = volume;
-	if (vol > 100)
-		vol = 100;
-
-	vol = 63 - vol * 63 / 100;
-	return vol;
-}
-
-
-int cAudio::setVolume(unsigned int left, unsigned int right)
-{
-	hal_debug("%s(%d, %d)\n", __func__, left, right);
-
-	volume = (left + right) / 2;
-	if (clipfd != -1 && mixer_fd != -1) {
-		int tmp = 0;
-		/* not sure if left / right is correct here, but it is always the same anyways ;-) */
-		if (! Muted)
-			tmp = left << 8 | right;
-		int ret = ioctl(mixer_fd, MIXER_WRITE(mixer_num), &tmp);
-		if (ret == -1)
-			hal_info("%s: MIXER_WRITE(%d),%04x: %m\n", __func__, mixer_num, tmp);
-		return ret;
-	}
-
-	audio_mixer_t mixer;
-	mixer.volume_left  = map_volume(left);
-	mixer.volume_right = map_volume(right);
-
-	if (ioctl(fd, AUDIO_SET_MIXER, &mixer) < 0)
-		hal_info("%s: AUDIO_SET_MIXER failed (%m)\n", __func__);
-
-	return 0;
-}
-
-int cAudio::Start(void)
-{
-	hal_debug("%s\n", __func__);
-	int ret;
-	ioctl(fd, AUDIO_CONTINUE);
-	ret = ioctl(fd, AUDIO_PLAY);
-	return ret;
-}
-
-int cAudio::Stop(void)
-{
-	hal_debug("%s\n", __func__);
-	ioctl(fd, AUDIO_STOP);
-	ioctl(fd, AUDIO_CONTINUE); /* no idea why we have to stop and then continue => enigma2 does it, too */
-	return 0;
-}
-
-bool cAudio::Pause(bool /*Pcm*/)
-{
-	return true;
-};
-
-void cAudio::SetSyncMode(AVSYNC_TYPE Mode)
-{
-	hal_debug("%s %d\n", __func__, Mode);
-	ioctl(fd, AUDIO_SET_AV_SYNC, Mode);
-};
-
-//AUDIO_ENCODING_AC3
-#define AUDIO_STREAMTYPE_AC3 0
-//AUDIO_ENCODING_MPEG2
-#define AUDIO_STREAMTYPE_MPEG 1
-//AUDIO_ENCODING_DTS
-#define AUDIO_STREAMTYPE_DTS 2
-
-#define AUDIO_ENCODING_LPCM 2
-#define AUDIO_ENCODING_LPCMA 11
-void cAudio::SetStreamType(AUDIO_FORMAT type)
-{
-	int bypass = AUDIO_STREAMTYPE_MPEG;
-	hal_debug("%s %d\n", __func__, type);
-	StreamType = type;
-
-	switch (type)
-	{
-		case AUDIO_FMT_DOLBY_DIGITAL:
-			bypass = AUDIO_STREAMTYPE_AC3;
-			break;
-		case AUDIO_FMT_DTS:
-			bypass = AUDIO_STREAMTYPE_DTS;
-			break;
-		case AUDIO_FMT_MPEG:
-		default:
-			break;
-	}
-
-	// Normaly the encoding should be set using AUDIO_SET_ENCODING
-	// But as we implemented the behavior to bypass (cause of e2) this is correct here
-	if (ioctl(fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
-		hal_info("%s: AUDIO_SET_BYPASS_MODE failed (%m)\n", __func__);
-};
-
-int cAudio::setChannel(int channel)
-{
-	return 0;
-};
-
-int cAudio::PrepareClipPlay(int ch, int srate, int bits, int little_endian)
-{
-	int fmt;
-	unsigned int devmask, stereo, usable;
-	const char *dsp_dev = getenv("DSP_DEVICE");
-	const char *mix_dev = getenv("MIX_DEVICE");
-	hal_debug("%s ch %d srate %d bits %d le %d\n", __FUNCTION__, ch, srate, bits, little_endian);
-	if (clipfd >= 0) {
-		hal_info("%s: clipfd already opened (%d)\n", __FUNCTION__, clipfd);
-		return -1;
-	}
-	mixer_num = -1;
-	mixer_fd = -1;
-	/* a different DSP device can be given with DSP_DEVICE and MIX_DEVICE
-	 * if this device cannot be opened, we fall back to the internal OSS device
-	 * Example:
-	 *   modprobe snd-usb-audio
-	 *   export DSP_DEVICE=/dev/sound/dsp2
-	 *   export MIX_DEVICE=/dev/sound/mixer2
-	 *   neutrino
-	 */
-	if ((!dsp_dev) || (access(dsp_dev, W_OK))) {
-		if (dsp_dev)
-			hal_info("%s: DSP_DEVICE is set (%s) but cannot be opened,"
-				" fall back to /dev/dsp1\n", __func__, dsp_dev);
-		dsp_dev = "/dev/dsp1";
-	}
-	hal_info("%s: dsp_dev %s mix_dev %s\n", __func__, dsp_dev, mix_dev); /* NULL mix_dev is ok */
-	/* the tdoss dsp driver seems to work only on the second open(). really. */
-	clipfd = open(dsp_dev, O_WRONLY|O_CLOEXEC);
-	if (clipfd < 0) {
-		hal_info("%s open %s: %m\n", dsp_dev, __FUNCTION__);
-		return -1;
-	}
-	/* no idea if we ever get little_endian == 0 */
-	if (little_endian)
-		fmt = AFMT_S16_BE;
-	else
-		fmt = AFMT_S16_LE;
-	if (ioctl(clipfd, SNDCTL_DSP_SETFMT, &fmt))
-		perror("SNDCTL_DSP_SETFMT");
-	if (ioctl(clipfd, SNDCTL_DSP_CHANNELS, &ch))
-		perror("SNDCTL_DSP_CHANNELS");
-	if (ioctl(clipfd, SNDCTL_DSP_SPEED, &srate))
-		perror("SNDCTL_DSP_SPEED");
-	if (ioctl(clipfd, SNDCTL_DSP_RESET))
-		perror("SNDCTL_DSP_RESET");
-
-	if (!mix_dev)
-		return 0;
-
-	mixer_fd = open(mix_dev, O_RDWR|O_CLOEXEC);
-	if (mixer_fd < 0) {
-		hal_info("%s: open mixer %s failed (%m)\n", __func__, mix_dev);
-		/* not a real error */
-		return 0;
-	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_DEVMASK, &devmask) == -1) {
-		hal_info("%s: SOUND_MIXER_READ_DEVMASK %m\n", __func__);
-		devmask = 0;
-	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_STEREODEVS, &stereo) == -1) {
-		hal_info("%s: SOUND_MIXER_READ_STEREODEVS %m\n", __func__);
-		stereo = 0;
-	}
-	usable = devmask & stereo;
-	if (usable == 0) {
-		hal_info("%s: devmask: %08x stereo: %08x, no usable dev :-(\n",
-			__func__, devmask, stereo);
-		close(mixer_fd);
-		mixer_fd = -1;
-		return 0; /* TODO: should we treat this as error? */
-	}
-	/* __builtin_popcount needs GCC, it counts the set bits... */
-	if (__builtin_popcount (usable) != 1) {
-		/* TODO: this code is not yet tested as I have only single-mixer devices... */
-		hal_info("%s: more than one mixer control: devmask %08x stereo %08x\n"
-			"%s: querying MIX_NUMBER environment variable...\n",
-			__func__, devmask, stereo, __func__);
-		const char *tmp = getenv("MIX_NUMBER");
-		if (tmp)
-			mixer_num = atoi(tmp);
-		hal_info("%s: mixer_num is %d -> device %08x\n",
-			__func__, mixer_num, (mixer_num >= 0) ? (1 << mixer_num) : 0);
-		/* no error checking, you'd better know what you are doing... */
-	} else {
-		mixer_num = 0;
-		while (!(usable & 0x01)) {
-			mixer_num++;
-			usable >>= 1;
-		}
-	}
-	setVolume(volume, volume);
-
-	return 0;
-};
-
-int cAudio::WriteClip(unsigned char *buffer, int size)
-{
-	int ret;
-	// hal_debug("cAudio::%s\n", __FUNCTION__);
-	if (clipfd <= 0) {
-		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
-		return -1;
-	}
-	ret = write(clipfd, buffer, size);
-	if (ret < 0)
-		hal_info("%s: write error (%m)\n", __FUNCTION__);
-	return ret;
-};
-
-int cAudio::StopClip()
-{
-	hal_debug("%s\n", __FUNCTION__);
-	if (clipfd <= 0) {
-		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
-		return -1;
-	}
-	close(clipfd);
-	clipfd = -1;
-	if (mixer_fd >= 0)
-		close(mixer_fd);
-	mixer_fd = -1;
-	setVolume(volume, volume);
-	return 0;
-};
-
-void cAudio::getAudioInfo(int &type, int &layer, int &freq, int &bitrate, int &mode)
-{
-	hal_debug("%s\n", __FUNCTION__);
-	type = 0;
-	layer = 0;
-	freq = 0;
-	bitrate = 0;
-	mode = 0;
-#if 0
-	unsigned int atype;
-	static const int freq_mpg[] = {44100, 48000, 32000, 0};
-	static const int freq_ac3[] = {48000, 44100, 32000, 0};
-	scratchl2 i;
-	if (ioctl(fd, MPEG_AUD_GET_DECTYP, &atype) < 0)
-		perror("cAudio::getAudioInfo MPEG_AUD_GET_DECTYP");
-	if (ioctl(fd, MPEG_AUD_GET_STATUS, &i) < 0)
-		perror("cAudio::getAudioInfo MPEG_AUD_GET_STATUS");
-
-	type = atype;
-#if 0
-/* this does not work, some of the values are negative?? */
-	AMPEGStatus A;
-	memcpy(&A, &i.word00, sizeof(i.word00));
-	layer   = A.audio_mpeg_layer;
-	mode    = A.audio_mpeg_mode;
-	bitrate = A.audio_mpeg_bitrate;
-	switch(A.audio_mpeg_frequency)
-#endif
-	/* layer and bitrate are not used anyway... */
-	layer   = 0; //(i.word00 >> 17) & 3;
-	bitrate = 0; //(i.word00 >> 12) & 3;
-	switch (type)
-	{
-		case 0:	/* MPEG */
-			mode = (i.word00 >> 6) & 3;
-			freq = freq_mpg[(i.word00 >> 10) & 3];
-			break;
-		case 1:	/* AC3 */
-			mode = (i.word00 >> 28) & 7;
-			freq = freq_ac3[(i.word00 >> 16) & 3];
-			break;
-		default:
-			mode = 0;
-			freq = 0;
-	}
-	//fprintf(stderr, "type: %d layer: %d freq: %d bitrate: %d mode: %d\n", type, layer, freq, bitrate, mode);
-#endif
-};
-
-void cAudio::SetSRS(int /*iq_enable*/, int /*nmgr_enable*/, int /*iq_mode*/, int /*iq_level*/)
-{
-	hal_debug("%s\n", __FUNCTION__);
-};
-
-void cAudio::SetHdmiDD(bool enable)
-{
-	hal_debug("%s %d\n", __func__, enable);
-};
-
-void cAudio::SetSpdifDD(bool enable)
-{
-	hal_debug("%s %d\n", __func__, enable);
-	setBypassMode(!enable);
-};
-
-void cAudio::ScheduleMute(bool On)
-{
-	hal_debug("%s %d\n", __FUNCTION__, On);
-};
-
-void cAudio::EnableAnalogOut(bool enable)
-{
-	hal_debug("%s %d\n", __FUNCTION__, enable);
-};
-
-#define AUDIO_BYPASS_ON  0
-#define AUDIO_BYPASS_OFF 1
-void cAudio::setBypassMode(bool disable)
-{
-	hal_debug("%s %d\n", __func__, disable);
-	int mode = disable ? AUDIO_BYPASS_OFF : AUDIO_BYPASS_ON;
-	if (ioctl(fd, AUDIO_SET_BYPASS_MODE, mode) < 0)
-		hal_info("%s AUDIO_SET_BYPASS_MODE %d: %m\n", __func__, mode);
-	return;
-}
diff -Nur libstb-hal-ddt.git.orig/libazbox/audio_lib.h libstb-hal-ddt.git/libazbox/audio_lib.h
--- libstb-hal-ddt.git.orig/libazbox/audio_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/audio_lib.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,97 +0,0 @@
-/* public header file */
-
-#ifndef __AUDIO_LIB_H__
-#define __AUDIO_LIB_H__
-
-#include "../common/cs_types.h"
-
-typedef enum
-{
-  AUDIO_SYNC_WITH_PTS,
-  AUDIO_NO_SYNC,
-  AUDIO_SYNC_AUDIO_MASTER
-} AUDIO_SYNC_MODE;
-
-typedef enum {
-	HDMI_ENCODED_OFF,
-	HDMI_ENCODED_AUTO,
-	HDMI_ENCODED_FORCED
-} HDMI_ENCODED_MODE;
-
-typedef enum
-{
-   AUDIO_FMT_AUTO = 0,
-   AUDIO_FMT_MPEG,
-   AUDIO_FMT_MP3,
-   AUDIO_FMT_DOLBY_DIGITAL,
-   AUDIO_FMT_BASIC = AUDIO_FMT_DOLBY_DIGITAL,
-   AUDIO_FMT_AAC,
-   AUDIO_FMT_AAC_PLUS,
-   AUDIO_FMT_DD_PLUS,
-   AUDIO_FMT_DTS,
-   AUDIO_FMT_AVS,
-   AUDIO_FMT_MLP,
-   AUDIO_FMT_WMA,
-   AUDIO_FMT_MPG1, // TD only. For Movieplayer / cPlayback
-   AUDIO_FMT_ADVANCED = AUDIO_FMT_MLP
-} AUDIO_FORMAT;
-
-class cAudio
-{
-	friend class cPlayback;
-	private:
-		int fd;
-		bool Muted;
-
-		int clipfd; /* for pcm playback */
-		int mixer_fd;  /* if we are using the OSS mixer */
-		int mixer_num; /* oss mixer to use, if any */
-
-		AUDIO_FORMAT	StreamType;
-		AUDIO_SYNC_MODE    SyncMode;
-		bool started;
-
-		int volume;
-
-		void openDevice(void);
-		void closeDevice(void);
-
-		int do_mute(bool enable, bool remember);
-		void setBypassMode(bool disable);
-	public:
-		/* construct & destruct */
-		cAudio(void *, void *, void *);
-		~cAudio(void);
-
-		void *GetHandle() { return NULL; };
-		/* shut up */
-		int mute(bool remember = true) { return do_mute(true, remember); };
-		int unmute(bool remember = true) { return do_mute(false, remember); };
-
-		/* volume, min = 0, max = 255 */
-		int setVolume(unsigned int left, unsigned int right);
-		int getVolume(void) { return volume;}
-		bool getMuteStatus(void) { return Muted; };
-
-		/* start and stop audio */
-		int Start(void);
-		int Stop(void);
-		bool Pause(bool Pcm = true);
-		void SetStreamType(AUDIO_FORMAT type);
-		void SetSyncMode(AVSYNC_TYPE Mode);
-
-		/* select channels */
-		int setChannel(int channel);
-		int PrepareClipPlay(int uNoOfChannels, int uSampleRate, int uBitsPerSample, int bLittleEndian);
-		int WriteClip(unsigned char * buffer, int size);
-		int StopClip();
-		void getAudioInfo(int &type, int &layer, int& freq, int &bitrate, int &mode);
-		void SetSRS(int iq_enable, int nmgr_enable, int iq_mode, int iq_level);
-		bool IsHdmiDDSupported();
-		void SetHdmiDD(bool enable);
-		void SetSpdifDD(bool enable);
-		void ScheduleMute(bool On);
-		void EnableAnalogOut(bool enable);
-};
-
-#endif // __AUDIO_LIB_H__
diff -Nur libstb-hal-ddt.git.orig/libazbox/dmx.cpp libstb-hal-ddt.git/libazbox/dmx.cpp
--- libstb-hal-ddt.git.orig/libazbox/dmx.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/dmx.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,519 +0,0 @@
-/*
- * cDemux implementation for azbox receivers (tested on azbox me and minime)
- *
- * derived from libtriple/dmx_td.cpp
- *
- * (C) 2010-2013 Stefan Seyfried
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "config.h"
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <poll.h>
-#include <errno.h>
-#include <inttypes.h>
-
-#include <cstring>
-#include <cstdio>
-#include <string>
-#include <sys/ioctl.h>
-#include "dmx_hal.h"
-#include "hal_debug.h"
-
-#include "video_lib.h"
-/* needed for getSTC... */
-extern cVideo *videoDecoder;
-
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_DEMUX, this, args)
-#define hal_info(args...) _hal_info(HAL_DEBUG_DEMUX, this, args)
-#define hal_info_c(args...) _hal_info(HAL_DEBUG_DEMUX, NULL, args)
-
-#define dmx_err(_errfmt, _errstr, _revents) do { \
-	hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
-		__func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
-} while(0);
-
-cDemux *videoDemux = NULL;
-cDemux *audioDemux = NULL;
-//cDemux *pcrDemux = NULL;
-
-static const char *DMX_T[] = {
-	"DMX_INVALID",
-	"DMX_VIDEO",
-	"DMX_AUDIO",
-	"DMX_PES",
-	"DMX_PSI",
-	"DMX_PIP",
-	"DMX_TP",
-	"DMX_PCR"
-};
-
-/* map the device numbers. for now only demux0 is used */
-static const char *devname[] = {
-	"/dev/dvb/adapter0/demux0",
-	"/dev/dvb/adapter0/demux0",
-	"/dev/dvb/adapter0/demux0"
-};
-
-/* uuuugly */
-static int dmx_tp_count = 0;
-#define MAX_TS_COUNT 8
-
-cDemux::cDemux(int n)
-{
-	if (n < 0 || n > 2)
-	{
-		hal_info("%s ERROR: n invalid (%d)\n", __FUNCTION__, n);
-		num = 0;
-	}
-	else
-		num = n;
-	fd = -1;
-}
-
-cDemux::~cDemux()
-{
-	hal_debug("%s #%d fd: %d\n", __FUNCTION__, num, fd);
-	Close();
-	/* in zapit.cpp, videoDemux is deleted after videoDecoder
-	 * in the video watchdog, we access videoDecoder
-	 * the thread still runs after videoDecoder has been deleted
-	 * => set videoDecoder to NULL here to make the check in the
-	 * watchdog thread pick this up.
-	 * This is ugly, but it saves me from changing neutrino
-	 *
-	 * if the delete order in neutrino will ever be changed, this
-	 * will blow up badly :-(
-	 */
-	if (dmx_type == DMX_VIDEO_CHANNEL)
-		videoDecoder = NULL;
-}
-
-bool cDemux::Open(DMX_CHANNEL_TYPE pes_type, void * /*hVideoBuffer*/, int uBufferSize)
-{
-	int devnum = num;
-	int flags = O_RDWR|O_CLOEXEC;
-	if (fd > -1)
-		hal_info("%s FD ALREADY OPENED? fd = %d\n", __FUNCTION__, fd);
-
-	if (pes_type != DMX_PSI_CHANNEL)
-		flags |= O_NONBLOCK;
-
-	fd = open(devname[devnum], flags);
-	if (fd < 0)
-	{
-		hal_info("%s %s: %m\n", __FUNCTION__, devname[devnum]);
-		return false;
-	}
-	hal_debug("%s #%d pes_type: %s(%d), uBufferSize: %d fd: %d\n", __func__,
-		 num, DMX_T[pes_type], pes_type, uBufferSize, fd);
-
-	dmx_type = pes_type;
-#if 0
-	if (!pesfds.empty())
-	{
-		hal_info("%s ERROR! pesfds not empty!\n", __FUNCTION__); /* TODO: error handling */
-		return false;
-	}
-	int n = DMX_SOURCE_FRONT0;
-	if (ioctl(fd, DMX_SET_SOURCE, &n) < 0)
-		hal_info("%s DMX_SET_SOURCE failed!\n", __func__);
-#endif
-	if (uBufferSize > 0)
-	{
-		/* probably uBufferSize == 0 means "use default size". TODO: find a reasonable default */
-		if (ioctl(fd, DMX_SET_BUFFER_SIZE, uBufferSize) < 0)
-			hal_info("%s DMX_SET_BUFFER_SIZE failed (%m)\n", __func__);
-	}
-	buffersize = uBufferSize;
-
-	return true;
-}
-
-void cDemux::Close(void)
-{
-	hal_debug("%s #%d, fd = %d\n", __FUNCTION__, num, fd);
-	if (fd < 0)
-	{
-		hal_info("%s #%d: not open!\n", __FUNCTION__, num);
-		return;
-	}
-
-	pesfds.clear();
-	ioctl(fd, DMX_STOP);
-	close(fd);
-	fd = -1;
-	if (dmx_type == DMX_TP_CHANNEL)
-	{
-		dmx_tp_count--;
-		if (dmx_tp_count < 0)
-		{
-			hal_info("%s dmx_tp_count < 0!!\n", __func__);
-			dmx_tp_count = 0;
-		}
-	}
-}
-
-bool cDemux::Start(bool)
-{
-	hal_debug("%s #%d fd: %d type: %s\n", __func__, num, fd, DMX_T[dmx_type]);
-	if (fd < 0)
-	{
-		hal_info("%s #%d: not open!\n", __FUNCTION__, num);
-		return false;
-	}
-	ioctl(fd, DMX_START);
-	return true;
-}
-
-bool cDemux::Stop(void)
-{
-	hal_debug("%s #%d fd: %d type: %s\n", __func__, num, fd, DMX_T[dmx_type]);
-	if (fd < 0)
-	{
-		hal_info("%s #%d: not open!\n", __FUNCTION__, num);
-		return false;
-	}
-	ioctl(fd, DMX_STOP);
-	return true;
-}
-
-int cDemux::Read(unsigned char *buff, int len, int timeout)
-{
-#if 0
-	if (len != 4095 && timeout != 100)
-		fprintf(stderr, "cDemux::%s #%d fd: %d type: %s len: %d timeout: %d\n",
-			__FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
-#endif
-	int rc;
-	int to = timeout;
-	/* using a one-dimensional array seems to avoid strange segfaults / memory corruption?? */
-	struct pollfd ufds[1];
-	ufds[0].fd = fd;
-	ufds[0].events = POLLIN|POLLPRI|POLLERR;
-	ufds[0].revents = 0;
-
-	/* hack: if the frontend loses and regains lock, the demuxer often will not
-	 * return from read(), so as a "emergency exit" for e.g. NIT scan, set a (long)
-	 * timeout here */
-	if (dmx_type == DMX_PSI_CHANNEL && timeout <= 0)
-		to = 60 * 1000;
-
-	if (to > 0)
-	{
- retry:
-		rc = ::poll(ufds, 1, to);
-		if (!rc)
-		{
-			if (timeout == 0) /* we took the emergency exit */
-			{
-				dmx_err("timed out for timeout=0!, %s", "", 0);
-				return -1; /* this timeout is an error */
-			}
-			return 0; // timeout
-		}
-		else if (rc < 0)
-		{
-			dmx_err("poll: %s,", strerror(errno), 0)
-			//hal_info("%s poll: %m\n", __FUNCTION__);
-			/* happens, when running under gdb... */
-			if (errno == EINTR)
-				goto retry;
-			return -1;
-		}
-#if 0
-		if (ufds.revents & POLLERR) /* POLLERR means buffer error, i.e. buffer overflow */
-		{
-			dmx_err("received %s,", "POLLERR", ufds.revents);
-			/* this seems to happen sometimes at recording start, without bad effects */
-			return 0;
-		}
-#endif
-		if (ufds[0].revents & POLLHUP) /* we get POLLHUP if e.g. a too big DMX_BUFFER_SIZE was set */
-		{
-			dmx_err("received %s,", "POLLHUP", ufds[0].revents);
-			return -1;
-		}
-		if (!(ufds[0].revents & POLLIN)) /* we requested POLLIN but did not get it? */
-		{
-			dmx_err("received %s, please report!", "POLLIN", ufds[0].revents);
-			return 0;
-		}
-	}
-
-	rc = ::read(fd, buff, len);
-	//fprintf(stderr, "fd %d ret: %d\n", fd, rc);
-	if (rc < 0)
-		dmx_err("read: %s", strerror(errno), 0);
-
-	return rc;
-}
-
-bool cDemux::sectionFilter(unsigned short _pid, const unsigned char * const filter,
-			   const unsigned char * const mask, int len, int timeout,
-			   const unsigned char * const negmask)
-{
-	struct dmx_sct_filter_params s_flt;
-	memset(&s_flt, 0, sizeof(s_flt));
-	pid = _pid;
-
-	if (len > DMX_FILTER_SIZE)
-	{
-		hal_info("%s #%d: len too long: %d, DMX_FILTER_SIZE %d\n", __func__, num, len, DMX_FILTER_SIZE);
-		len = DMX_FILTER_SIZE;
-	}
-	s_flt.pid = pid;
-	s_flt.timeout = timeout;
-	flt = filter[0];
-	memcpy(s_flt.filter.filter, filter, len);
-	memcpy(s_flt.filter.mask,   mask,   len);
-	if (negmask != NULL)
-		memcpy(s_flt.filter.mode, negmask, len);
-
-	s_flt.flags = DMX_IMMEDIATE_START|DMX_CHECK_CRC;
-
-	int to = 0;
-	switch (filter[0]) {
-	case 0x00: /* program_association_section */
-		to = 2000;
-		break;
-	case 0x01: /* conditional_access_section */
-		to = 6000;
-		break;
-	case 0x02: /* program_map_section */
-		to = 1500;
-		break;
-	case 0x03: /* transport_stream_description_section */
-		to = 10000;
-		break;
-	/* 0x04 - 0x3F: reserved */
-	case 0x40: /* network_information_section - actual_network */
-		to = 10000;
-		break;
-	case 0x41: /* network_information_section - other_network */
-		to = 15000;
-		break;
-	case 0x42: /* service_description_section - actual_transport_stream */
-		to = 10000;
-		break;
-	/* 0x43 - 0x45: reserved for future use */
-	case 0x46: /* service_description_section - other_transport_stream */
-		to = 10000;
-		break;
-	/* 0x47 - 0x49: reserved for future use */
-	case 0x4A: /* bouquet_association_section */
-		to = 11000;
-		break;
-	/* 0x4B - 0x4D: reserved for future use */
-	case 0x4E: /* event_information_section - actual_transport_stream, present/following */
-		to = 2000;
-		break;
-	case 0x4F: /* event_information_section - other_transport_stream, present/following */
-		to = 10000;
-		break;
-	/* 0x50 - 0x5F: event_information_section - actual_transport_stream, schedule */
-	/* 0x60 - 0x6F: event_information_section - other_transport_stream, schedule */
-	case 0x70: /* time_date_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		s_flt.flags |= DMX_ONESHOT;
-		//s_flt.pid     = 0x0014;
-		to = 30000;
-		break;
-	case 0x71: /* running_status_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		to = 0;
-		break;
-	case 0x72: /* stuffing_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		to = 0;
-		break;
-	case 0x73: /* time_offset_section */
-		s_flt.flags |= DMX_ONESHOT;
-		//s_flt.pid     = 0x0014;
-		to = 30000;
-		break;
-	/* 0x74 - 0x7D: reserved for future use */
-	case 0x7E: /* discontinuity_information_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		to = 0;
-		break;
-	case 0x7F: /* selection_information_section */
-		to = 0;
-		break;
-	/* 0x80 - 0x8F: ca_message_section */
-	/* 0x90 - 0xFE: user defined */
-	/*        0xFF: reserved */
-	default:
-		break;
-//		return -1;
-	}
-	/* the negmask == NULL is a hack: the users of negmask are PMT-update
-	 * and sectionsd EIT-Version change. And they really want no timeout
-	 * if timeout == 0 instead of "default timeout" */
-	if (timeout == 0 && negmask == NULL)
-		s_flt.timeout = to;
-
-	hal_debug("%s #%d pid:0x%04hx fd:%d type:%s len:%d to:%d flags:%x flt[0]:%02x\n", __func__, num,
-		pid, fd, DMX_T[dmx_type], len, s_flt.timeout,s_flt.flags, s_flt.filter.filter[0]);
-#if 0
-	fprintf(stderr,"filt: ");for(int i=0;i<DMX_FILTER_SIZE;i++)fprintf(stderr,"%02hhx ",s_flt.filter.filter[i]);fprintf(stderr,"\n");
-	fprintf(stderr,"mask: ");for(int i=0;i<DMX_FILTER_SIZE;i++)fprintf(stderr,"%02hhx ",s_flt.filter.mask  [i]);fprintf(stderr,"\n");
-	fprintf(stderr,"mode: ");for(int i=0;i<DMX_FILTER_SIZE;i++)fprintf(stderr,"%02hhx ",s_flt.filter.mode  [i]);fprintf(stderr,"\n");
-#endif
-	ioctl (fd, DMX_STOP);
-	if (ioctl(fd, DMX_SET_FILTER, &s_flt) < 0)
-		return false;
-	ioctl(fd, DMX_START);
-
-	return true;
-}
-
-bool cDemux::pesFilter(const unsigned short _pid)
-{
-	struct dmx_pes_filter_params p_flt;
-	pid = _pid;
-	flt = 0;
-	/* allow PID 0 for web streaming e.g.
-	 * this check originally is from tuxbox cvs but I'm not sure
-	 * what it is good for...
-	if (pid <= 0x0001 && dmx_type != DMX_PCR_ONLY_CHANNEL)
-		return false;
-	 */
-	if ((pid >= 0x0002 && pid <= 0x000f) || pid >= 0x1fff)
-		return false;
-
-	hal_debug("%s #%d pid: 0x%04hx fd: %d type: %s\n", __FUNCTION__, num, pid, fd, DMX_T[dmx_type]);
-
-	memset(&p_flt, 0, sizeof(p_flt));
-	p_flt.pid = pid;
-	p_flt.output = DMX_OUT_DECODER;
-	p_flt.input  = DMX_IN_FRONTEND;
-
-	switch (dmx_type) {
-	case DMX_PCR_ONLY_CHANNEL:
-		p_flt.pes_type = DMX_PES_PCR;
-		break;
-	case DMX_AUDIO_CHANNEL:
-		p_flt.pes_type = DMX_PES_AUDIO;
-		break;
-	case DMX_VIDEO_CHANNEL:
-		p_flt.pes_type = DMX_PES_VIDEO;
-		break;
-	case DMX_PES_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TAP;
-		break;
-	case DMX_TP_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TSDEMUX_TAP;
-		break;
-	default:
-		hal_info("%s #%d invalid dmx_type %d!\n", __func__, num, dmx_type);
-		return false;
-	}
-	return (ioctl(fd, DMX_SET_PES_FILTER, &p_flt) >= 0);
-}
-
-void cDemux::SetSyncMode(AVSYNC_TYPE /*mode*/)
-{
-	hal_debug("%s #%d\n", __FUNCTION__, num);
-}
-
-void *cDemux::getBuffer()
-{
-	hal_debug("%s #%d\n", __FUNCTION__, num);
-	return NULL;
-}
-
-void *cDemux::getChannel()
-{
-	hal_debug("%s #%d\n", __FUNCTION__, num);
-	return NULL;
-}
-
-bool cDemux::addPid(unsigned short Pid)
-{
-	hal_debug("%s: pid 0x%04hx\n", __func__, Pid);
-	pes_pids pfd;
-	int ret;
-	if (dmx_type != DMX_TP_CHANNEL)
-	{
-		hal_info("%s pes_type %s not implemented yet! pid=%hx\n", __FUNCTION__, DMX_T[dmx_type], Pid);
-		return false;
-	}
-	if (fd == -1)
-		hal_info("%s bucketfd not yet opened? pid=%hx\n", __FUNCTION__, Pid);
-	pfd.fd = fd; /* dummy */
-	pfd.pid = Pid;
-	pesfds.push_back(pfd);
-	ret = (ioctl(fd, DMX_ADD_PID, &Pid));
-	if (ret < 0)
-		hal_info("%s: DMX_ADD_PID (%m)\n", __func__);
-	return (ret != -1);
-}
-
-void cDemux::removePid(unsigned short Pid)
-{
-	if (dmx_type != DMX_TP_CHANNEL)
-	{
-		hal_info("%s pes_type %s not implemented yet! pid=%hx\n", __FUNCTION__, DMX_T[dmx_type], Pid);
-		return;
-	}
-	for (std::vector<pes_pids>::iterator i = pesfds.begin(); i != pesfds.end(); ++i)
-	{
-		if ((*i).pid == Pid) {
-			hal_debug("removePid: removing demux fd %d pid 0x%04x\n", fd, Pid);
-			if (ioctl(fd, DMX_REMOVE_PID, Pid) < 0)
-				hal_info("%s: (DMX_REMOVE_PID, 0x%04hx): %m\n", __func__, Pid);
-			pesfds.erase(i);
-			return; /* TODO: what if the same PID is there multiple times */
-		}
-	}
-	hal_info("%s pid 0x%04x not found\n", __FUNCTION__, Pid);
-}
-
-void cDemux::getSTC(int64_t * STC)
-{
-	/* apparently I can only get the PTS of the video decoder,
-	 * but that's good enough for dvbsub */
-	hal_debug("%s #%d\n", __func__, num);
-	int64_t pts = 0;
-	if (videoDecoder)
-		pts = videoDecoder->GetPTS();
-	*STC = pts;
-}
-
-int cDemux::getUnit(void)
-{
-	hal_debug("%s #%d\n", __FUNCTION__, num);
-	/* just guessed that this is the right thing to do.
-	   right now this is only used by the CA code which is stubbed out
-	   anyway */
-	return num;
-}
-
-bool cDemux::SetSource(int unit, int source)
-{
-	hal_info_c("%s(%d, %d): not implemented yet\n", __func__, unit, source);
-	return true;
-}
-
-int cDemux::GetSource(int unit)
-{
-	hal_info_c("%s(%d): not implemented yet\n", __func__, unit);
-	return 0;
-}
diff -Nur libstb-hal-ddt.git.orig/libazbox/e2mruainclude.h libstb-hal-ddt.git/libazbox/e2mruainclude.h
--- libstb-hal-ddt.git.orig/libazbox/e2mruainclude.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/e2mruainclude.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,83 +0,0 @@
-//Additional Azbox
-enum key_command {
-KEY_COMMAND_QUIT_ALL = 100,
-KEY_COMMAND_QUIT,
-KEY_COMMAND_PLAY,
-KEY_COMMAND_PAUSE,
-KEY_COMMAND_RESUME,
-KEY_COMMAND_STOP,
-KEY_COMMAND_SEEK_TO_TIME,
-KEY_COMMAND_SEEK_TO_PERCENT,
-KEY_COMMAND_NEXT_PICT,
-KEY_COMMAND_FAST_FWD_ALL_FRAMES,
-KEY_COMMAND_SLOW_FWD_ALL_FRAMES,
-KEY_COMMAND_IFRAMES_FWD,
-KEY_COMMAND_IFRAMES_BWD,
-KEY_COMMAND_SILENT_FWD,
-KEY_COMMAND_SILENT_BWD,
-KEY_COMMAND_SWITCH_VIDEO,
-KEY_COMMAND_SWITCH_AUDIO,
-KEY_COMMAND_SWITCH_PROGRAM,
-KEY_COMMAND_SWITCH_SUBS,
-KEY_COMMAND_SWITCH_MULTICAST,
-KEY_COMMAND_APPLY_AV_DELAY,
-KEY_COMMAND_SUBS_CHANGE_DELAY,
-KEY_COMMAND_SUBS_INCREASE_FONT_SIZE,
-KEY_COMMAND_SUBS_DECREASE_FONT_SIZE,
-KEY_COMMAND_SUBS_INCREASE_POS_Y,
-KEY_COMMAND_SUBS_DECREASE_POS_Y,
-KEY_COMMAND_SUBS_SWITCH_ENCODING,
-KEY_COMMAND_SUBS_RESET_ALL,
-KEY_COMMAND_SUBS_CHANGE_COLOR,
-KEY_COMMAND_DEBUG,
-KEY_COMMAND_PRINT_INFO,
-KEY_COMMAND_FULL_SCREEN,
-KEY_COMMAND_HALF_SCREEN,
-KEY_COMMAND_INCREASE_SIZE,
-KEY_COMMAND_DECREASE_SIZE,
-KEY_COMMAND_MOVE_LEFT,
-KEY_COMMAND_MOVE_RIGHT,
-KEY_COMMAND_MOVE_TOP,
-KEY_COMMAND_MOVE_BOTTOM,
-KEY_COMMAND_NONLINEAR_WIDTH,
-KEY_COMMAND_NONLINEAR_LEVEL,
-KEY_COMMAND_SWITCH_SCALER,
-KEY_COMMAND_HELP,
-KEY_COMMAND_FAST_FWD_WITH_AUDIO,
-KEY_COMMAND_SLOW_FWD_WITH_AUDIO,
-KEY_COMMAND_PRINT_TXT,
-SPECIAL_KEY_COMMAND_IFRAMES_FWD,
-SPECIAL_KEY_COMMAND_IFRAMES_BWD,
-SPECIAL_KEY_COMMAND_NEXT_AUDIO,
-SPECIAL_KEY_COMMAND_NEXT_SUBS,
-};
-
-enum custom_command {
-CUSTOM_COMMAND_GETLENGTH  = 200,
-CUSTOM_COMMAND_GETPOSITION,
-CUSTOM_COMMAND_AUDIOGETPOSITION,
-CUSTOM_COMMAND_SEEK_RELATIVE_FWD,
-CUSTOM_COMMAND_SEEK_RELATIVE_BWD,
-CUSTOM_COMMAND_SUBS_COUNT,
-CUSTOM_COMMAND_GET_SUB_BY_ID,
-CUSTOM_COMMAND_AUDIO_COUNT,
-CUSTOM_COMMAND_GET_AUDIO_BY_ID,
-CUSTOM_COMMAND_AUDIO_CUR_STREAM,
-CUSTOM_COMMAND_SUBS_CUR_STREAM,
-CUSTOM_COMMAND_TRICK_SEEK,
-CUSTOM_COMMAND_SET_SUB_SIZE,
-CUSTOM_COMMAND_SET_SUB_ENCODING,
-CUSTOM_COMMAND_SET_SUB_POS,
-};
-
-enum event_msg {
-EVENT_MSG_FDOPEN = 300,
-EVENT_MSG_PLAYBACK_STARTED,
-EVENT_MSG_STOPPED,
-EVENT_MSG_PAUSED,
-EVENT_MSG_BUFFERING,
-EVENT_MSG_EOS,
-EVENT_MSG_SUB_CHANGED,
-};
-
-//int fd_cmd, fd_in, fd_out, fd_event, msg;
diff -Nur libstb-hal-ddt.git.orig/libazbox/hardware_caps.c libstb-hal-ddt.git/libazbox/hardware_caps.c
--- libstb-hal-ddt.git.orig/libazbox/hardware_caps.c	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/hardware_caps.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,52 +0,0 @@
-/*
- * determine the capabilities of the hardware.
- * part of libstb-hal
- *
- * (C) 2010-2012 Stefan Seyfried
- *
- * License: GPL v2 or later
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <hardware_caps.h>
-
-static int initialized = 0;
-static hw_caps_t caps;
-
-hw_caps_t *get_hwcaps(void)
-{
-	if (initialized)
-		return &caps;
-
-	memset(&caps, 0, sizeof(hw_caps_t));
-
-	initialized = 1;
-	caps.can_shutdown = 1;
-	caps.display_type = HW_DISPLAY_LINE_TEXT;
-	caps.has_HDMI = 1;
-	caps.display_xres = 8;
-	caps.display_can_deepstandby = 0;
-	caps.display_has_statusline = 0;
-	strcpy(caps.boxvendor, "AZBox");
-	const char *tmp;
-	char buf[64];
-	int len = -1;
-	int fd = open("/proc/stb/info/model", O_RDONLY);
-	if (fd != -1) {
-		len = read(fd, buf, sizeof(buf) - 1);
-		close(fd);
-	}
-	if (len > 0) {
-		buf[len] = 0;
-		strcpy(caps.boxname, buf);
-	}
-	else
-		strcpy(caps.boxname, "(unknown model)");
-
-	return &caps;
-}
diff -Nur libstb-hal-ddt.git.orig/libazbox/init.cpp libstb-hal-ddt.git/libazbox/init.cpp
--- libstb-hal-ddt.git.orig/libazbox/init.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/init.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
-#include <unistd.h>
-
-#include "init.h"
-
-#include "hal_debug.h"
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_INIT, NULL, args)
-#define hal_info(args...) _hal_info(HAL_DEBUG_INIT, NULL, args)
-
-static bool initialized = false;
-
-void hal_api_init()
-{
-	if (!initialized)
-		hal_debug_init();
-	hal_info("%s begin, initialized=%d, debug=0x%02x\n", __func__, (int)initialized, debuglevel);
-	initialized = true;
-}
-
-void hal_api_exit()
-{
-	hal_info("%s, initialized = %d\n", __func__, (int)initialized);
-	initialized = false;
-}
diff -Nur libstb-hal-ddt.git.orig/libazbox/Makefile.am libstb-hal-ddt.git/libazbox/Makefile.am
--- libstb-hal-ddt.git.orig/libazbox/Makefile.am	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/Makefile.am	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-noinst_LTLIBRARIES = libazbox.la
-
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/common \
-	-I$(top_srcdir)/include
-
-AM_CXXFLAGS = -fno-rtti -fno-exceptions -fno-strict-aliasing
-AM_LDFLAGS = -lpthread
-
-libazbox_la_SOURCES = \
-	hardware_caps.c \
-	dmx.cpp \
-	video.cpp \
-	audio.cpp \
-	init.cpp \
-	playback.cpp \
-	record.cpp
-
diff -Nur libstb-hal-ddt.git.orig/libazbox/playback.cpp libstb-hal-ddt.git/libazbox/playback.cpp
--- libstb-hal-ddt.git.orig/libazbox/playback.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/playback.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,521 +0,0 @@
-/*
- * cPlayback implementation for azbox
- * this is actually just a wrapper around rmfp_player which does
- * all the heavy listing
- *
- * based on the original aztrino implementation, but almost
- * completely rewritten since then
- *
- * some of the methods and constants were found by stracing the
- * AZPlay enigma2 plugin...
- *
- * (C) 2012 Stefan Seyfried
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sstream>
-#include <pty.h>
-#include <sys/poll.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-
-#include "hal_debug.h"
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_PLAYBACK, this, args)
-#define hal_info(args...)  _hal_info(HAL_DEBUG_PLAYBACK, this, args)
-#define hal_info_c(args...) _hal_info(HAL_DEBUG_PLAYBACK, NULL, args)
-
-#include <proc_tools.h>
-
-/* the file-based commands work better than the FIFOs... */
-#define CMD_FILE "/tmp/rmfp.cmd2"
-#define IN_FILE  "/tmp/rmfp.in2"
-#define OUT_FILE "/tmp/rmfp.out2"
-
-#include "playback_lib.h"
-
-extern "C"{
-#include "e2mruainclude.h"
-}
-
-#if 0
-/* useful for debugging */
-static time_t monotonic_ms(void)
-{
-	struct timespec t;
-	time_t ret;
-	if (clock_gettime(CLOCK_MONOTONIC, &t))
-	{
-		perror("monotonic_ms clock_gettime");
-		return -1;
-	}
-	ret = ((t.tv_sec + 604800)& 0x01FFFFF) * 1000; /* avoid overflow */
-	ret += t.tv_nsec / 1000000;
-	return ret;
-}
-#endif
-
-/* the mutex makes sure that commands are not interspersed */
-bool cPlayback::rmfp_command(int cmd, int param, bool has_param, char *buf, int buflen)
-{
-	hal_info("%s: %d %d %d %d\n", __func__, cmd, param, has_param, buflen);
-	bool ret = true;
-	int fd;
-	if (cmd == 222)
-	{
-		if (pthread_mutex_trylock(&rmfp_cmd_mutex))
-			return false;
-	}
-	else
-		pthread_mutex_lock(&rmfp_cmd_mutex);
-	unlink(OUT_FILE);
-	if (has_param)
-	{
-		fd = open(IN_FILE, O_WRONLY|O_CREAT|O_TRUNC, 0666);
-		dprintf(fd, "%i", param);
-		close(fd);
-	}
-	fd = open(CMD_FILE, O_WRONLY|O_CREAT|O_TRUNC, 0666);
-	dprintf(fd, "%i", cmd);
-	close(fd);
-	int n = 0, m = 0;
-	if (buflen > 0)
-	{
-		while ((fd = open(OUT_FILE, O_RDONLY)) == -1) {
-			if (++m > 500) { /* don't wait more than 5 seconds */
-				hal_info("%s: timed out waiting for %s (cmd %d par %d buflen %d\n",
-					__func__, OUT_FILE, cmd, param, buflen);
-				ret = false;
-				goto out;
-			}
-			usleep(10000);
-		}
-		unlink(OUT_FILE);
-		n = read(fd, buf, buflen);
-		close(fd);
-		/* some commands (CUSTOM_COMMAND_GET_AUDIO_BY_ID for example) actually
-		 * return the answer in two successive writes, as we are not using the
-		 * FIFO, we need to make sure that the file is deleted immediately, because
-		 * rmfp_player will not overwrite it if it exists */
-		while ((fd = open(OUT_FILE, O_RDONLY)) == -1) {
-			if (++m > 10)
-				break;
-			usleep(1000);
-		}
-		if (fd > -1)
-		{
-			read(fd, buf + n, buflen - n);
-			unlink(OUT_FILE);
-			close(fd);
-		}
-		buf[buflen - 1] = '0';
-	}
- out:
-	pthread_mutex_unlock(&rmfp_cmd_mutex);
-	if (cmd != 222) /* called tooo often :-) */
-		hal_info("%s: reply: '%s' ret: %d m:%d\n", __func__, buf?buf:"(none)", ret, m);
-	return ret;
-}
-
-/*
- * runs the rmfp_player in a terminal
- * just doing popen() or similar does not work because then
- * the output will be buffered after starting up and we will only
- * see "Playback has started..." after the player exits
- */
-void cPlayback::run_rmfp()
-{
-	hal_debug("%s: starting\n", __func__);
-	thread_started = true;
-	//Watch for the space at the end
-	std::string base = "rmfp_player -dram 1 -ve 1 -waitexit ";
-	std::string filename(mfilename);
-	std::string file = '"' + filename + '"';
-	std::string final = base + file;
-
-	if (playMode == PLAYMODE_TS && mduration != 0)
-	{
-		std::stringstream duration;
-		duration << (mduration /** 60000LL*/);
-		final = base + "-duration " + duration.str() + " " + file;
-	}
-
-	pid_t pid = 0;
-	int master;
-	pid = forkpty(&master, NULL, NULL, NULL);
-	if (! pid) {
-		execl("/bin/sh", "sh", "-c", final.c_str(), (char *)0);
-		hal_info("%s: execl returned: %m\n", __func__);
-		exit(0);
-	}
-
-	if (pid > 0) {
-		char *output=NULL;
-		size_t n = 0;
-		ssize_t len;
-		FILE *f = fdopen(master, "r");
-		while ((len = getline(&output, &n, f)) != -1)
-		{
-			while (len > 0)
-			{
-				len--;
-				if (!isspace(output[len]))
-					break;
-				output[len] = '\0';
-			}
-			hal_info("%s out: '%s'\n", __func__, output);
-			if (strstr(output, "Playback has started..."))
-			{
-				playing = 1;
-				hal_info("%s: ===================> playing = true\n", __func__);
-			}
-			else if (strstr(output, "End of file..."))
-			{
-				playing = 1; /* this can happen without "Playback has started..." */
-				eof_reached = true;
-				hal_info("%s: ===================> eof_reached = true\n", __func__);
-			}
-		}
-		fclose(f);
-		int s;
-		while (waitpid(pid, &s, WNOHANG) > 0) {};
-		if (output)
-			free(output);
-	}
-
-	hal_info("%s: terminating\n", __func__);
-	if (playing == 0)	/* playback did not start */
-		playing = 2;
-	else
-		playing = 0;
-	eof_reached = true;
-	pthread_exit(NULL);
-}
-
-/* helper function to call the cpp thread loop */
-void *execute_rua_thread(void *c)
-{
-	cPlayback *obj = (cPlayback *)c;
-	hal_info_c("%s\n", __func__);
-	obj->run_rmfp();
-	/* free(obj); // this is most likely wrong */
-
-	return NULL;
-}
-
-//Used by Fileplay
-bool cPlayback::Open(playmode_t PlayMode)
-{
-	static const char *aPLAYMODE[] = {
-		"PLAYMODE_TS",
-		"PLAYMODE_FILE"
-	};
-	playMode = PlayMode;
-	if (playMode > 1)
-	{
-		hal_info("%s: PlayMode %d out of range!\n", __func__, PlayMode);
-		playMode = PLAYMODE_FILE;
-	}
-
-	hal_info("%s: mode %d (%s)\n", __func__, PlayMode, aPLAYMODE[PlayMode]);
-#if 0
-	while (access("/tmp/continue", R_OK))
-		sleep(1);
-#endif
-
-	char c[2] = "0";
-	int i = 0;
-
-	for(;;)
-	{
-		proc_get("/proc/player", c, 2);
-		if (c[0] != '0')
-			break;
-		i++;
-		if (i > 10)
-		{
-			hal_info("%s: ERROR - player is not idle after 10 seconds!\n", __func__);
-			open_success = false;
-			return false;
-		}
-		sleep(1);
-	}
-
-	proc_put("/proc/player", "2", 2);
-	hal_info("%s: /proc/player switched to '2'\n", __func__);
-
-	unlink(CMD_FILE);
-	unlink(IN_FILE);
-	unlink(OUT_FILE);
-
-	open_success = true;
-	return 0;
-}
-
-//Used by Fileplay
-bool cPlayback::Start(char *filename, unsigned short vpid, int vtype, unsigned short _apid,
-		      int ac3, unsigned int duration)
-{
-	bool ret = true;
-
-	hal_info("%s: filename=%s\n", __func__, filename);
-	hal_info("%s: vpid=%u vtype=%d apid=%u ac3=%d duration=%i open_success=%d\n",
-		__func__, vpid, vtype, _apid, ac3, duration, open_success);
-
-	if (!open_success)
-		return false;
-
-	eof_reached = false;
-	//create playback path
-	apid = 0;
-	subpid = 0;
-	mfilename = filename;
-	mduration = duration;
-	if (pthread_create(&thread, 0, execute_rua_thread, this) != 0)
-	{
-		hal_info("%s: error creating rmfp_player thread! (out of memory?)\n", __func__);
-		ret = false;
-	}
-	while (! playing)
-		sleep(1);
-	if (playing == 2)
-		playing = 0;
-	return ret;
-}
-
-void cPlayback::Close(void)
-{
-	hal_info("%s: playing %d thread_started %d\n", __func__, playing, thread_started);
-
-	if (thread_started)
-	{
-		rmfp_command(KEY_COMMAND_QUIT_ALL, 0, false, NULL, 0);
-
-		if (pthread_join(thread, NULL))
-			hal_info("%s: error joining rmfp thread (%m)\n", __func__);
-		playing = 0;
-		thread_started = false;
-	}
-	else
-		hal_info("%s: Warning: thread_started == false!\n", __func__);
-
-	if (open_success)
-	{
-		proc_put("/proc/player", "1", 2);
-		open_success = false;
-		hal_info("%s: /proc/player switched to '1'\n", __func__);
-		usleep(1000000);
-	}
-}
-
-bool cPlayback::SetAPid(unsigned short pid, int /*ac3*/)
-{
-	hal_info("%s: pid %i\n", __func__, pid);
-	if (pid != apid) {
-		rmfp_command(KEY_COMMAND_SWITCH_AUDIO, pid, true, NULL, 0);
-		apid = pid;
-	}
-	return true;
-}
-
-bool cPlayback::SelectSubtitles(int pid)
-{
-	hal_info("%s: pid %i\n", __func__, pid);
-	if (pid != subpid)
-	{
-		rmfp_command(KEY_COMMAND_SWITCH_SUBS, pid, true, NULL, 0);
-		subpid = pid;
-	}
-	return true;
-}
-
-bool cPlayback::SetSpeed(int speed)
-{
-	hal_info("%s: playing %d speed %d\n", __func__, playing, speed);
-
-	if (!playing)
-		return false;
-
-	playback_speed = speed;
-
-	if (speed > 1 || speed < 0)
-		rmfp_command(CUSTOM_COMMAND_TRICK_SEEK, speed, true, NULL, 0);
-	else if (speed == 0)
-		rmfp_command(KEY_COMMAND_PAUSE, 0, false, NULL, 0);
-	else
-		rmfp_command(KEY_COMMAND_PLAY, 0, false, NULL, 0);
-
-	return true;
-}
-
-bool cPlayback::GetSpeed(int &/*speed*/) const
-{
-#if 0
-	hal_info("%s:\n", __func__);
-	speed = playback_speed;
-#endif
-	return true;
-}
-
-// in milliseconds
-bool cPlayback::GetPosition(int &position, int &duration)
-{
-	hal_debug("%s: playing %d\n", __func__, playing);
-
-	if (eof_reached)
-	{
-		position = mduration;
-		duration = mduration;
-		return true;
-	}
-
-	if (!playing)
-		return false;
-
-	char buf[32];
-	/* custom command 222 returns "12345\n1234\n",
-	 * first line is duration, second line is position */
-	if (! rmfp_command(222, 0, false, buf, 32))
-		return false;
-	duration = atoi(buf);
-	char *p = strchr(buf, '\n');
-	if (!p)
-		return false;
-	position = atoi(++p);
-	/* some mpegs return length 0... which would lead to "eof" after 10 seconds */
-	if (duration == 0)
-		duration = position + 1000;
-
-	if (playMode == PLAYMODE_TS)
-	{
-		if (position > mduration)
-			mduration = position + 1000;
-		duration = mduration;
-		return true;
-	}
-	return true;
-}
-
-bool cPlayback::SetPosition(int position, bool absolute)
-{
-	hal_info("%s: pos %d abs %d playing %d\n", __func__, position, absolute, playing);
-
-	if (!playing)
-		return false;
-
-	int seconds = position / 1000;;
-
-	if (absolute)
-	{
-		rmfp_command(KEY_COMMAND_SEEK_TO_TIME, seconds, true, NULL, 0);
-		return true;
-	}
-
-	if (position > 0)
-		rmfp_command(CUSTOM_COMMAND_SEEK_RELATIVE_FWD, seconds, true, NULL, 0);
-	else if (position < 0)
-		rmfp_command(CUSTOM_COMMAND_SEEK_RELATIVE_BWD, seconds, true, NULL, 0);
-	return true;
-}
-
-void cPlayback::FindAllPids(uint16_t *apids, unsigned short *ac3flags, uint16_t *numpida, std::string *language)
-{
-	hal_info("%s\n", __func__);
-	char buf[32];
-	rmfp_command(CUSTOM_COMMAND_AUDIO_COUNT, 0, false, buf, 3);
-	unsigned int audio_count = atoi(buf);
-
-	*numpida = audio_count;
-	if (audio_count > 0)
-	{
-		for (unsigned int aid = 0; aid < audio_count; aid++)
-		{
-			char streamidstring[11];
-			char audio_lang[21];
-			memset(buf, 0, sizeof(buf));
-			rmfp_command(CUSTOM_COMMAND_GET_AUDIO_BY_ID, aid, true, buf, 32);
-			memcpy(streamidstring, buf, 10);
-			streamidstring[10] = '\0';
-			memcpy(audio_lang, buf + 10, 20);
-			audio_lang[20] = '\0';
-			apids[aid] = atoi(streamidstring);
-			ac3flags[aid] = 0;
-			language[aid] = audio_lang;
-			hal_info("%s: #%d apid:%d lang: %s\n", __func__, aid, apids[aid], audio_lang);
-		}
-	}
-}
-
-void cPlayback::FindAllSubs(uint16_t *spids, unsigned short *supported, uint16_t *numpids, std::string *language)
-{
-	hal_info("%s\n", __func__);
-	char buf[32];
-
-	rmfp_command(CUSTOM_COMMAND_SUBS_COUNT, 0, false, buf, 3);
-	unsigned int spu_count = atoi(buf);
-	*numpids = spu_count;
-
-	if (spu_count > 0)
-	{
-		for (unsigned int sid = 0; sid < spu_count; sid++)
-		{
-			char streamidstring[11];
-			char spu_lang[21];
-			memset(buf, 0, sizeof(buf));
-			rmfp_command(CUSTOM_COMMAND_GET_SUB_BY_ID, sid, true, buf, 32);
-			memcpy(streamidstring, buf, 10);
-			streamidstring[10] = '\0';
-			memcpy(spu_lang, buf + 10, 20);
-			spu_lang[20] = '\0';
-			spids[sid] = atoi(streamidstring);
-			language[sid] = spu_lang;
-			supported[sid] = 1;
-			hal_info("%s: #%d apid:%d lang: %s\n", __func__, sid, spids[sid], spu_lang);
-		}
-	}
-	//Add streamid -1 to be able to disable subtitles
-	*numpids = spu_count + 1;
-	spids[spu_count] = -1;
-	language[spu_count] = "Disable";
-}
-
-/* DVD support is not yet ready... */
-void cPlayback::GetChapters(std::vector<int> &positions, std::vector<std::string> &titles)
-{
-	positions.clear();
-	titles.clear();
-}
-
-cPlayback::cPlayback(int /*num*/)
-{
-	hal_info("%s: constructor\n", __func__);
-	playing = 0;
-	thread_started = false;
-	eof_reached = false;
-	open_success = false;
-	pthread_mutex_init(&rmfp_cmd_mutex, NULL);
-}
-
-cPlayback::~cPlayback()
-{
-	hal_info("%s\n", __func__);
-	pthread_mutex_destroy(&rmfp_cmd_mutex);
-}
diff -Nur libstb-hal-ddt.git.orig/libazbox/playback_lib.h libstb-hal-ddt.git/libazbox/playback_lib.h
--- libstb-hal-ddt.git.orig/libazbox/playback_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/playback_lib.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-#ifndef __PLAYBACK_LIB_H__
-#define __PLAYBACK_LIB_H__
-
-#include <string>
-#include <stdint.h>
-#include <vector>
-
-typedef enum {
-	PLAYMODE_TS = 0,
-	PLAYMODE_FILE,
-} playmode_t;
-
-class cPlayback
-{
-	private:
-		pthread_mutex_t rmfp_cmd_mutex;
-		int playing;
-		bool eof_reached;
-		int playback_speed;
-		playmode_t playMode;
-		bool open_success;
-		uint16_t apid;
-		uint16_t subpid;
-		char *mfilename;
-		int mduration;
-		pthread_t thread;
-		bool thread_started;
-		/* private functions */
-		bool rmfp_command(int cmd, int param, bool has_param, char *buf, int buflen);
-	public:
-		cPlayback(int num = 0);
-		~cPlayback();
-
-		void run_rmfp();
-
-		bool Open(playmode_t PlayMode);
-		void Close(void);
-		bool Start(char *filename, unsigned short vpid, int vtype, unsigned short apid,
-			   int ac3, unsigned int duration);
-		bool SetAPid(unsigned short pid, int ac3);
-		bool SetSpeed(int speed);
-		bool GetSpeed(int &speed) const;
-		bool GetPosition(int &position, int &duration);	/* pos: current time in ms, dur: file length in ms */
-		bool SetPosition(int position, bool absolute = false);	/* position: jump in ms */
-		void FindAllPids(uint16_t *apids, unsigned short *ac3flags, uint16_t *numpida, std::string *language);
-		void FindAllSubs(uint16_t *pids, unsigned short *supported, uint16_t *numpida, std::string *language);
-		bool SelectSubtitles(int pid);
-		void GetChapters(std::vector<int> &positions, std::vector<std::string> &titles);
-#if 0
-		// Functions that are not used by movieplayer.cpp:
-		bool Stop(void);
-		bool GetOffset(off64_t &offset);
-		bool IsPlaying(void) const { return playing; }
-		bool IsEnabled(void) const { return enabled; }
-		void * GetHandle(void);
-		void * GetDmHandle(void);
-		int GetCurrPlaybackSpeed(void) const { return nPlaybackSpeed; }
-		void PlaybackNotify (int  Event, void *pData, void *pTag);
-		void DMNotify(int Event, void *pTsBuf, void *Tag);
-#endif
-};
-#endif // __PLAYBACK_LIB_H__
diff -Nur libstb-hal-ddt.git.orig/libazbox/record.cpp libstb-hal-ddt.git/libazbox/record.cpp
--- libstb-hal-ddt.git.orig/libazbox/record.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/record.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,387 +0,0 @@
-#include <errno.h>
-#include <fcntl.h>
-#include <malloc.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/prctl.h>
-#include <inttypes.h>
-#include <cstdio>
-#include <cstring>
-
-#include <pthread.h>
-#include <aio.h>
-
-#include "record_lib.h"
-#include "hal_debug.h"
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_RECORD, this, args)
-#define hal_info(args...) _hal_info(HAL_DEBUG_RECORD, this, args)
-
-/* helper function to call the cpp thread loop */
-void *execute_record_thread(void *c)
-{
-	cRecord *obj = (cRecord *)c;
-	obj->RecordThread();
-	return NULL;
-}
-
-void *execute_writer_thread(void *c)
-{
-	cRecord *obj = (cRecord *)c;
-	obj->WriterThread();
-	return NULL;
-}
-
-cRecord::cRecord(int num, int bs_dmx, int bs)
-{
-	hal_info("%s %d\n", __func__, num);
-	dmx = NULL;
-	record_thread_running = false;
-	file_fd = -1;
-	exit_flag = RECORD_STOPPED;
-	dmx_num = num;
-	bufsize = bs;
-	bufsize_dmx = bs_dmx;
-	failureCallback = NULL;
-	failureData = NULL;
-}
-
-cRecord::~cRecord()
-{
-	hal_info("%s: calling ::Stop()\n", __func__);
-	Stop();
-	hal_info("%s: end\n", __func__);
-}
-
-bool cRecord::Open(void)
-{
-	hal_info("%s\n", __func__);
-	exit_flag = RECORD_STOPPED;
-	return true;
-}
-
-#if 0
-// unused
-void cRecord::Close(void)
-{
-	hal_info("%s: \n", __func__);
-}
-#endif
-
-bool cRecord::Start(int fd, unsigned short vpid, unsigned short *apids, int numpids, uint64_t)
-{
-	hal_info("%s: fd %d, vpid 0x%03x\n", __func__, fd, vpid);
-	int i;
-
-	if (!dmx)
-		dmx = new cDemux(dmx_num);
-
-	dmx->Open(DMX_TP_CHANNEL, NULL, bufsize_dmx);
-	dmx->pesFilter(vpid);
-
-	for (i = 0; i < numpids; i++)
-		dmx->addPid(apids[i]);
-
-	file_fd = fd;
-	exit_flag = RECORD_RUNNING;
-	if (posix_fadvise(file_fd, 0, 0, POSIX_FADV_DONTNEED))
-		perror("posix_fadvise");
-
-	i = pthread_create(&record_thread, 0, execute_record_thread, this);
-	if (i != 0)
-	{
-		exit_flag = RECORD_FAILED_READ;
-		errno = i;
-		hal_info("%s: error creating thread! (%m)\n", __func__);
-		delete dmx;
-		dmx = NULL;
-		return false;
-	}
-	record_thread_running = true;
-	return true;
-}
-
-bool cRecord::Stop(void)
-{
-	hal_info("%s\n", __func__);
-
-	if (exit_flag != RECORD_RUNNING)
-		hal_info("%s: status not RUNNING? (%d)\n", __func__, exit_flag);
-
-	exit_flag = RECORD_STOPPED;
-	if (record_thread_running)
-		pthread_join(record_thread, NULL);
-	record_thread_running = false;
-
-	/* We should probably do that from the destructor... */
-	if (!dmx)
-		hal_info("%s: dmx == NULL?\n", __func__);
-	else
-		delete dmx;
-	dmx = NULL;
-
-	if (file_fd != -1)
-		close(file_fd);
-	else
-		hal_info("%s: file_fd not open??\n", __func__);
-	file_fd = -1;
-	return true;
-}
-
-bool cRecord::ChangePids(unsigned short /*vpid*/, unsigned short *apids, int numapids)
-{
-	std::vector<pes_pids> pids;
-	int j;
-	bool found;
-	unsigned short pid;
-	hal_info("%s\n", __func__);
-	if (!dmx) {
-		hal_info("%s: DMX = NULL\n", __func__);
-		return false;
-	}
-	pids = dmx->pesfds;
-	/* the first PID is the video pid, so start with the second PID... */
-	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
-		found = false;
-		pid = (*i).pid;
-		for (j = 0; j < numapids; j++) {
-			if (pid == apids[j]) {
-				found = true;
-				break;
-			}
-		}
-		if (!found)
-			dmx->removePid(pid);
-	}
-	for (j = 0; j < numapids; j++) {
-		found = false;
-		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
-			if ((*i).pid == apids[j]) {
-				found = true;
-				break;
-			}
-		}
-		if (!found)
-			dmx->addPid(apids[j]);
-	}
-	return true;
-}
-
-bool cRecord::AddPid(unsigned short pid)
-{
-	std::vector<pes_pids> pids;
-	hal_info("%s: \n", __func__);
-	if (!dmx) {
-		hal_info("%s: DMX = NULL\n", __func__);
-		return false;
-	}
-	pids = dmx->pesfds;
-	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i) {
-		if ((*i).pid == pid)
-			return true; /* or is it an error to try to add the same PID twice? */
-	}
-	return dmx->addPid(pid);
-}
-
-void cRecord::WriterThread()
-{
-	char threadname[17];
-	strncpy(threadname, "WriterThread", sizeof(threadname));
-	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
-	unsigned int chunk = 0;
-	while (!sem_wait(&sem)) {
-		if (!io_len[chunk]) // empty, assume end of recording
-			return;
-		unsigned char *p_buf = io_buf[chunk];
-		size_t p_len = io_len[chunk];
-		while (p_len) {
-			ssize_t written = write(file_fd, p_buf, p_len);
-			if (written < 0)
-				break;
-			p_len -= written;
-			p_buf += written;
-		}
-		if (posix_fadvise(file_fd, 0, 0, POSIX_FADV_DONTNEED))
-			perror("posix_fadvise");
-		chunk++;
-		chunk %= RECORD_WRITER_CHUNKS;
-	}
-}
-
-void cRecord::RecordThread()
-{
-	hal_info("%s: begin\n", __func__);
-	char threadname[17];
-	strncpy(threadname, "RecordThread", sizeof(threadname));
-	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
-	int readsize = bufsize / 16;
-	int buf_pos = 0;
-	int count = 0;
-	int queued = 0;
-	uint8_t *buf;
-	struct aiocb a;
-
-	buf = (uint8_t *)malloc(bufsize);
-	hal_info("BUFSIZE=0x%x READSIZE=0x%x\n", bufsize, readsize);
-	if (!buf)
-	{
-		exit_flag = RECORD_FAILED_MEMORY;
-		hal_info("%s: unable to allocate buffer! (out of memory)\n", __func__);
-		if (failureCallback)
-			failureCallback(failureData);
-		hal_info("%s: end\n", __func__);
-		pthread_exit(NULL);
-	}
-
-	int val = fcntl(file_fd, F_GETFL);
-	if (fcntl(file_fd, F_SETFL, val|O_APPEND))
-		hal_info("%s: O_APPEND? (%m)\n", __func__);
-
-	memset(&a, 0, sizeof(a));
-	a.aio_fildes = file_fd;
-	a.aio_sigevent.sigev_notify = SIGEV_NONE;
-
-	dmx->Start();
-	int overflow_count = 0;
-	bool overflow = false;
-	int r = 0;
-	while (exit_flag == RECORD_RUNNING)
-	{
-		if (buf_pos < bufsize)
-		{
-			if (overflow_count) {
-				hal_info("%s: Overflow cleared after %d iterations\n", __func__, overflow_count);
-				overflow_count = 0;
-			}
-			int toread = bufsize - buf_pos;
-			if (toread > readsize)
-				toread = readsize;
-			ssize_t s = dmx->Read(buf + buf_pos, toread, 50);
-			hal_debug("%s: buf_pos %6d s %6d / %6d\n", __func__,
-				buf_pos, (int)s, bufsize - buf_pos);
-			if (s < 0)
-			{
-				if (errno != EAGAIN && (errno != EOVERFLOW || !overflow))
-				{
-					hal_info("%s: read failed: %m\n", __func__);
-					exit_flag = RECORD_FAILED_READ;
-					state = REC_STATUS_OVERFLOW;
-					break;
-				}
-			}
-			else
-			{
-				overflow = false;
-				buf_pos += s;
-				if (count > 100)
-				{
-					if (buf_pos < bufsize / 2)
-						continue;
-				}
-				else
-				{
-					count += 1;
-				}
-			}
-		}
-		else
-		{
-			if (!overflow)
-				overflow_count = 0;
-			overflow = true;
-			if (!(overflow_count % 10))
-				hal_info("%s: buffer full! Overflow? (%d)\n", __func__, ++overflow_count);
-			state = REC_STATUS_SLOW;
-		}
-		r = aio_error(&a);
-		if (r == EINPROGRESS)
-		{
-			hal_debug("%s: aio in progress, free: %d\n", __func__, bufsize - buf_pos);
-			continue;
-		}
-		// not calling aio_return causes a memory leak  --martii
-		r = aio_return(&a);
-		if (r < 0)
-		{
-			exit_flag = RECORD_FAILED_FILE;
-			hal_debug("%s: aio_return = %d (%m)\n", __func__, r);
-			break;
-		}
-		else
-			hal_debug("%s: aio_return = %d, free: %d\n", __func__, r, bufsize - buf_pos);
-		if (posix_fadvise(file_fd, 0, 0, POSIX_FADV_DONTNEED))
-			perror("posix_fadvise");
-		if (queued)
-		{
-			memmove(buf, buf + queued, buf_pos - queued);
-			buf_pos -= queued;
-		}
-		queued = buf_pos;
-		a.aio_buf = buf;
-		a.aio_nbytes = queued;
-		r = aio_write(&a);
-		if (r)
-		{
-			hal_info("%s: aio_write %d (%m)\n", __func__, r);
-			exit_flag = RECORD_FAILED_FILE;
-			break;
-		}
-	}
-	dmx->Stop();
-	while (true) /* write out the unwritten buffer content */
-	{
-		hal_debug("%s: run-out write, buf_pos %d\n", __func__, buf_pos);
-		r = aio_error(&a);
-		if (r == EINPROGRESS)
-		{
-			usleep(50000);
-			continue;
-		}
-		r = aio_return(&a);
-		if (r < 0)
-		{
-			exit_flag = RECORD_FAILED_FILE;
-			hal_info("%s: aio_result: %d (%m)\n", __func__, r);
-			break;
-		}
-		if (!queued)
-			break;
-		memmove(buf, buf + queued, buf_pos - queued);
-		buf_pos -= queued;
-		queued = buf_pos;
-		a.aio_buf = buf;
-		a.aio_nbytes = queued;
-		r = aio_write(&a);
-	}
-	free(buf);
-
-#if 0
-	// TODO: do we need to notify neutrino about failing recording?
-	CEventServer eventServer;
-	eventServer.registerEvent2(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, "/tmp/neutrino.sock");
-	stream2file_status2_t s;
-	s.status = exit_flag;
-	strncpy(s.filename,basename(myfilename),512);
-	s.filename[511] = '\0';
-	strncpy(s.dir,dirname(myfilename),100);
-	s.dir[99] = '\0';
-	eventServer.sendEvent(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, &s, sizeof(s));
-	printf("[stream2file]: pthreads exit code: %i, dir: '%s', filename: '%s' myfilename: '%s'\n", exit_flag, s.dir, s.filename, myfilename);
-#endif
-
-	if ((exit_flag != RECORD_STOPPED) && failureCallback)
-		failureCallback(failureData);
-	hal_info("%s: end\n", __func__);
-	pthread_exit(NULL);
-}
-
-int cRecord::GetStatus()
-{
-	return (exit_flag == RECORD_STOPPED) ? REC_STATUS_STOPPED : REC_STATUS_OK;
-}
-
-void cRecord::ResetStatus()
-{
-	return;
-}
diff -Nur libstb-hal-ddt.git.orig/libazbox/record_lib.h libstb-hal-ddt.git/libazbox/record_lib.h
--- libstb-hal-ddt.git.orig/libazbox/record_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/record_lib.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-#ifndef __RECORD_LIB_H__
-#define __RECORD_LIB_H__
-
-#include <semaphore.h>
-#include "dmx_hal.h"
-
-#define REC_STATUS_OK 0
-#define REC_STATUS_SLOW 1
-#define REC_STATUS_OVERFLOW 2
-#define REC_STATUS_STOPPED 4
-
-typedef enum {
-	RECORD_RUNNING,
-	RECORD_STOPPED,
-	RECORD_FAILED_READ,	/* failed to read from DMX */
-	RECORD_FAILED_OVERFLOW,	/* cannot write fast enough */
-	RECORD_FAILED_FILE,	/* cannot write to file */
-	RECORD_FAILED_MEMORY	/* out of memory */
-} record_state_t;
-
-class cRecord
-{
-	private:
-		int file_fd;
-		int dmx_num;
-		cDemux *dmx;
-		pthread_t record_thread;
-		bool record_thread_running;
-		record_state_t exit_flag;
-		int state;
-		int bufsize;
-		int bufsize_dmx;
-		void (*failureCallback)(void *);
-		void *failureData;
-
-		sem_t sem;
-#define RECORD_WRITER_CHUNKS 16
-		unsigned char *io_buf[RECORD_WRITER_CHUNKS];
-		size_t io_len[RECORD_WRITER_CHUNKS];
-	public:
-		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024); 
-		void setFailureCallback(void (*f)(void *), void *d) { failureCallback = f; failureData = d; }
-		~cRecord();
-
-		bool Open();
-		bool Start(int fd, unsigned short vpid, unsigned short *apids, int numapids, uint64_t ch = 0);
-		bool Stop(void);
-		bool AddPid(unsigned short pid);
-		int  GetStatus();
-		void ResetStatus();
-		bool ChangePids(unsigned short vpid, unsigned short *apids, int numapids);
-
-		void RecordThread();
-		void WriterThread();
-};
-
-#endif // __RECORD_LIB_H__
diff -Nur libstb-hal-ddt.git.orig/libazbox/video.cpp libstb-hal-ddt.git/libazbox/video.cpp
--- libstb-hal-ddt.git.orig/libazbox/video.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/video.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,637 +0,0 @@
-/*
- * (C) 2002-2003 Andreas Oberritter <obi@tuxbox.org>
- * (C) 2010-2012 Stefan Seyfried
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, 51 Franklin Street, Suite 500 Boston, MA 02110-1335 USA
- */
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <utime.h>
-#include <errno.h>
-#include <ctype.h>
-
-#include <cstring>
-#include <cstdio>
-#include <cstdlib>
-
-#include <pthread.h>
-
-#include <linux/types.h>
-#include <linux/dvb/video.h>
-
-#include <proc_tools.h>
-
-#include "video_lib.h"
-#define VIDEO_DEVICE "/dev/dvb/adapter0/video0"
-#include "hal_debug.h"
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_VIDEO, this, args)
-#define hal_info(args...) _hal_info(HAL_DEBUG_VIDEO, this, args)
-#define hal_debug_c(args...) _hal_debug(HAL_DEBUG_VIDEO, NULL, args)
-#define hal_info_c(args...) _hal_info(HAL_DEBUG_VIDEO, NULL, args)
-
-#define fop(cmd, args...) ({				\
-	int _r;						\
-	if (fd >= 0) { 					\
-		if ((_r = ::cmd(fd, args)) < 0)		\
-			hal_info(#cmd"(fd, "#args")\n");	\
-		else					\
-			hal_debug(#cmd"(fd, "#args")\n");\
-	}						\
-	else { _r = fd; } 				\
-	_r;						\
-})
-
-cVideo * videoDecoder = NULL;
-int system_rev = 0;
-
-static bool stillpicture = false;
-static unsigned char *blank_data;
-static ssize_t blank_size;
-static pthread_mutex_t stillp_mutex = PTHREAD_MUTEX_INITIALIZER;
-/* prototype */
-static void show_iframe(int fd, unsigned char *iframe, size_t st_size);
-
-#define VIDEO_STREAMTYPE_MPEG2 0
-#define VIDEO_STREAMTYPE_MPEG4_H264 1
-#define VIDEO_STREAMTYPE_VC1 3
-#define VIDEO_STREAMTYPE_MPEG4_Part2 4
-#define VIDEO_STREAMTYPE_VC1_SM 5
-#define VIDEO_STREAMTYPE_MPEG1 6
-
-cVideo::cVideo(int, void *, void *, unsigned int)
-{
-	hal_debug("%s\n", __FUNCTION__);
-
-	//croppingMode = VID_DISPMODE_NORM;
-	//outputformat = VID_OUTFMT_RGBC_SVIDEO;
-	scartvoltage = -1;
-	video_standby = 0;
-	fd = -1;
-
-	const char *blankname = "/share/tuxbox/blank_576.mpg";
-	int blankfd;
-	struct stat st;
-
-	blank_data = NULL; /* initialize */
-	blank_size = 0;
-	blankfd = open(blankname, O_RDONLY|O_CLOEXEC);
-	if (blankfd < 0)
-		hal_info("%s cannot open %s: %m", __func__, blankname);
-	else
-	{
-		if (fstat(blankfd, &st) != -1 && st.st_size > 0)
-		{
-			blank_size = st.st_size;
-			blank_data = (unsigned char *)malloc(blank_size);
-			if (! blank_data)
-				hal_info("%s malloc failed (%m)\n", __func__);
-			else if (read(blankfd, blank_data, blank_size) != blank_size)
-			{
-				hal_info("%s short read (%m)\n", __func__);
-				free(blank_data); /* don't leak... */
-				blank_data = NULL;
-			}
-		}
-		close(blankfd);
-	}
-	openDevice();
-	Pig(-1, -1, -1, -1);
-}
-
-cVideo::~cVideo(void)
-{
-	closeDevice();
-	if (blank_data)
-		free(blank_data);
-}
-
-void cVideo::openDevice(void)
-{
-	int n = 0;
-	hal_debug("%s\n", __func__);
-	/* todo: this fd checking is racy, should be protected by a lock */
-	if (fd != -1) /* already open */
-		return;
-retry:
-	if ((fd = open(VIDEO_DEVICE, O_RDWR|O_CLOEXEC)) < 0)
-	{
-		if (errno == EBUSY)
-		{
-			/* sometimes we get busy quickly after close() */
-			usleep(50000);
-			if (++n < 10)
-				goto retry;
-		}
-		hal_info("%s cannot open %s: %m, retries %d\n", __func__, VIDEO_DEVICE, n);
-	}
-	playstate = VIDEO_STOPPED;
-}
-
-void cVideo::closeDevice(void)
-{
-	hal_debug("%s\n", __func__);
-	if (fd >= 0)
-		close(fd);
-	fd = -1;
-	playstate = VIDEO_STOPPED;
-}
-
-int cVideo::setAspectRatio(int aspect, int mode)
-{
-	static const char *a[] = { "n/a", "4:3", "14:9", "16:9" };
-	/*                       { "panscan", "letterbox", "fullscreen", "14:9", "(unset)" } */
-	static const char *m[] = { "1",        "2",        "0",          "1",    "(unset)" };
-	int n;
-
-	int mo = (mode < 0||mode > 3) ? 4 : mode;
-	hal_debug("%s: a:%d m:%d  %s\n", __func__, aspect, mode, m[(mo]);
-
-	if (aspect > 3 || aspect == 0)
-		hal_info("%s: invalid aspect: %d\n", __func__, aspect);
-	else if (aspect > 0) /* -1 == don't set */
-	{
-		hal_debug("%s: /proc/stb/video/aspect -> %s\n", __func__, a[aspect]);
-		n = proc_put("/proc/stb/video/aspect", a[aspect], strlen(a[aspect]));
-		if (n < 0)
-			hal_info("%s: proc_put /proc/stb/video/aspect (%m)\n", __func__);
-	}
-
-	if (mode == -1)
-		return 0;
-
-	hal_debug("%s: /proc/scalingmode -> %s\n", __func__, m[mo]);
-	n = proc_put("/proc/scalingmode", m[mo], strlen(m[mo]));
-	if (n < 0)
-		return 1;
-	return 0;
-}
-
-int cVideo::getAspectRatio(void)
-{
-	video_size_t s;
-	if (fd == -1)
-	{
-		/* in movieplayer mode, fd is not opened -> fall back to procfs */
-		int n = proc_get_hex("/proc/stb/vmpeg/0/aspect");
-		return n * 2 + 1;
-	}
-	if (fop(ioctl, VIDEO_GET_SIZE, &s) < 0)
-	{
-		hal_info("%s: VIDEO_GET_SIZE %m\n", __func__);
-		return -1;
-	}
-	hal_debug("%s: %d\n", __func__, s.aspect_ratio);
-	return s.aspect_ratio * 2 + 1;
-}
-
-int cVideo::setCroppingMode(int /*vidDispMode_t format*/)
-{
-	return 0;
-#if 0
-	croppingMode = format;
-	const char *format_string[] = { "norm", "letterbox", "unknown", "mode_1_2", "mode_1_4", "mode_2x", "scale", "disexp" };
-	const char *f;
-	if (format >= VID_DISPMODE_NORM && format <= VID_DISPMODE_DISEXP)
-		f = format_string[format];
-	else
-		f = "ILLEGAL format!";
-	hal_debug("%s(%d) => %s\n", __FUNCTION__, format, f);
-	return fop(ioctl, MPEG_VID_SET_DISPMODE, format);
-#endif
-}
-
-int cVideo::Start(void * /*PcrChannel*/, unsigned short /*PcrPid*/, unsigned short /*VideoPid*/, void * /*hChannel*/)
-{
-	hal_debug("%s playstate=%d\n", __FUNCTION__, playstate);
-#if 0
-	if (playstate == VIDEO_PLAYING)
-		return 0;
-	if (playstate == VIDEO_FREEZED)  /* in theory better, but not in practice :-) */
-		fop(ioctl, MPEG_VID_CONTINUE);
-#endif
-	playstate = VIDEO_PLAYING;
-	return fop(ioctl, VIDEO_PLAY);
-}
-
-int cVideo::Stop(bool blank)
-{
-	hal_debug("%s(%d)\n", __FUNCTION__, blank);
-	if (stillpicture)
-	{
-		hal_debug("%s: stillpicture == true\n", __func__);
-		return -1;
-	}
-	/* blank parameter seems to not work on VIDEO_STOP */
-	if (blank)
-		setBlank(1);
-	playstate = blank ? VIDEO_STOPPED : VIDEO_FREEZED;
-	return fop(ioctl, VIDEO_STOP, blank ? 1 : 0);
-}
-
-int cVideo::setBlank(int)
-{
-	pthread_mutex_lock(&stillp_mutex);
-	if (blank_data)
-		show_iframe(fd, blank_data, blank_size);
-	pthread_mutex_unlock(&stillp_mutex);
-	return 1;
-}
-
-int cVideo::SetVideoSystem(int video_system, bool remember)
-{
-	hal_debug("%s(%d, %d)\n", __func__, video_system, remember);
-	char current[32];
-	static const char *modes[] = {
-		"480i",		// VIDEO_STD_NTSC
-		"576i",		// VIDEO_STD_SECAM
-		"576i",		// VIDEO_STD_PAL
-		"480p",		// VIDEO_STD_480P
-		"576p",		// VIDEO_STD_576P
-		"720p60",	// VIDEO_STD_720P60
-		"1080i60",	// VIDEO_STD_1080I60
-		"720p50",	// VIDEO_STD_720P50
-		"1080i50",	// VIDEO_STD_1080I50
-		"1080p30",	// VIDEO_STD_1080P30
-		"1080p24",	// VIDEO_STD_1080P24
-		"1080p25",	// VIDEO_STD_1080P25
-		"720p50",	// VIDEO_STD_AUTO -> not implemented
-		"1080p50"	// VIDEO_STD_1080P50 -> SPARK only
-	};
-
-	if (video_system > VIDEO_STD_MAX)
-	{
-		hal_info("%s: video_system (%d) > VIDEO_STD_MAX (%d)\n", __func__, video_system, VIDEO_STD_MAX);
-		return -1;
-	}
-	int ret = proc_get("/proc/stb/video/videomode", current, 32);
-	if (strcmp(current,  modes[video_system]) == 0)
-	{
-		hal_info("%s: video_system %d (%s) already set, skipping\n", __func__, video_system, current);
-		return 0;
-	}
-	hal_info("%s: old: '%s' new: '%s'\n", __func__, current, modes[video_system]);
-	ret = proc_put("/proc/stb/video/videomode", modes[video_system],strlen(modes[video_system]));
-
-	return ret;
-}
-
-int cVideo::getPlayState(void)
-{
-	return playstate;
-}
-
-void cVideo::SetVideoMode(analog_mode_t mode)
-{
-	hal_debug("%s(%d)\n", __func__, mode);
-	if (!(mode & ANALOG_SCART_MASK))
-	{
-		hal_debug("%s: non-SCART mode ignored\n", __func__);
-		return;
-	}
-	const char *m;
-	switch(mode)
-	{
-		case ANALOG_SD_YPRPB_SCART:
-			m = "yuv";
-			break;
-		case ANALOG_SD_RGB_SCART:
-			m = "rgb";
-			break;
-		default:
-			hal_info("%s unknown mode %d\n", __func__, mode);
-			m = "rgb";
-			break; /* default to rgb */
-	}
-	proc_put("/proc/stb/avs/0/colorformat", m, strlen(m));
-}
-
-void cVideo::ShowPicture(const char * fname)
-{
-	hal_debug("%s(%s)\n", __func__, fname);
-	char destname[512];
-	char cmd[512];
-	char *p;
-	int mfd;
-	unsigned char *iframe;
-	struct stat st, st2;
-	if (video_standby)
-	{
-		/* does not work and the driver does not seem to like it */
-		hal_info("%s: video_standby == true\n", __func__);
-		return;
-	}
-	if (fd < 0)
-	{
-		hal_info("%s: decoder not opened?\n", __func__);
-		return;
-	}
-	strcpy(destname, "/var/cache");
-	if (stat(fname, &st2))
-	{
-		hal_info("%s: could not stat %s (%m)\n", __func__, fname);
-		return;
-	}
-	mkdir(destname, 0755);
-	/* the cache filename is (example for /share/tuxbox/neutrino/icons/radiomode.jpg):
-	   /var/cache/share.tuxbox.neutrino.icons.radiomode.jpg.m2v
-	   build that filename first...
-	   TODO: this could cause name clashes, use a hashing function instead... */
-	strcat(destname, fname);
-	p = &destname[strlen("/var/cache/")];
-	while ((p = strchr(p, '/')) != NULL)
-		*p = '.';
-	strcat(destname, ".m2v");
-	/* ...then check if it exists already... */
-	if (stat(destname, &st) || (st.st_mtime != st2.st_mtime) || (st.st_size == 0))
-	{
-		struct utimbuf u;
-		u.actime = time(NULL);
-		u.modtime = st2.st_mtime;
-		/* it does not exist or has a different date, so call ffmpeg... */
-		sprintf(cmd, "ffmpeg -y -f mjpeg -i '%s' -s 1280x720 '%s' </dev/null",
-							fname, destname);
-		system(cmd); /* TODO: use libavcodec to directly convert it */
-		utime(destname, &u);
-	}
-
-	/* the mutex is a workaround: setBlank is apparently called from
-	   a differnt thread and takes slightly longer, so that the decoder
-	   was blanked immediately after displaying the image, which is not
-	   what we want. the mutex ensures proper ordering. */
-	pthread_mutex_lock(&stillp_mutex);
-
-	mfd = open(destname, O_RDONLY|O_CLOEXEC);
-	if (mfd < 0)
-	{
-		hal_info("%s cannot open %s: %m", __func__, destname);
-		goto out;
-	}
-	fstat(mfd, &st);
-
-	stillpicture = true;
-
-	iframe = (unsigned char *)malloc(st.st_size);
-	if (! iframe)
-	{
-		hal_info("%s: malloc failed (%m)\n", __func__);
-		goto out;
-	}
-	read(mfd, iframe, st.st_size);
-	show_iframe(fd, iframe, st.st_size);
-	free(iframe);
- out:
-	close(mfd);
-	pthread_mutex_unlock(&stillp_mutex);
-	return;
-}
-
-void cVideo::StopPicture()
-{
-	hal_debug("%s\n", __func__);
-	stillpicture = false;
-}
-
-void cVideo::Standby(unsigned int bOn)
-{
-	hal_debug("%s(%d)\n", __func__, bOn);
-	if (bOn)
-	{
-		closeDevice();
-		proc_put("/proc/stb/avs/0/input", "aux", 4);
-	}
-	else
-	{
-		proc_put("/proc/stb/avs/0/input", "encoder", 8);
-		openDevice();
-	}
-	video_standby = bOn;
-}
-
-int cVideo::getBlank(void)
-{
-	int ret = proc_get_hex("/proc/stb/vmpeg/0/xres");
-	hal_debug("%s => %d\n", __func__, !ret);
-	return !ret;
-}
-
-/* this function is regularly called, checks if video parameters
-   changed and triggers appropriate actions */
-void cVideo::VideoParamWatchdog(void)
-{
-#if 0
-	static unsigned int _v_info = (unsigned int) -1;
-	unsigned int v_info;
-	if (fd == -1)
-		return;
-	ioctl(fd, MPEG_VID_GET_V_INFO_RAW, &v_info);
-	if (_v_info != v_info)
-	{
-		hal_debug("%s params changed. old: %08x new: %08x\n", __FUNCTION__, _v_info, v_info);
-		setAspectRatio(-1, -1);
-	}
-	_v_info = v_info;
-#endif
-}
-
-void cVideo::Pig(int x, int y, int w, int h, int osd_w, int osd_h)
-{
-	char buffer[64];
-	int _x, _y, _w, _h;
-	/* the target "coordinates" seem to be in a PAL sized plane
-	 * TODO: check this in the driver sources */
-	int xres = 720; /* proc_get_hex("/proc/stb/vmpeg/0/xres") */
-	int yres = 576; /* proc_get_hex("/proc/stb/vmpeg/0/yres") */
-	hal_debug("%s: x:%d y:%d w:%d h:%d ow:%d oh:%d\n", __func__, x, y, w, h, osd_w, osd_h);
-	if (x == -1 && y == -1 && w == -1 && h == -1)
-	{
-		_w = xres;
-		_h = yres;
-		_x = 0;
-		_y = 0;
-	}
-	else
-	{
-		_x = x * xres / osd_w;
-		_w = w * xres / osd_w;
-		_y = y * yres / osd_h;
-		_h = h * yres / osd_h;
-	}
-	hal_debug("%s: x:%d y:%d w:%d h:%d xr:%d yr:%d\n", __func__, _x, _y, _w, _h, xres, yres);
-	sprintf(buffer, "%x", _x);
-	proc_put("/proc/stb/vmpeg/0/dst_left", buffer, strlen(buffer));
-	sprintf(buffer, "%x", _y);
-	proc_put("/proc/stb/vmpeg/0/dst_top", buffer, strlen(buffer));
-	sprintf(buffer, "%x", _w);
-	proc_put("/proc/stb/vmpeg/0/dst_width", buffer, strlen(buffer));
-	sprintf(buffer, "%x", _h);
-	proc_put("/proc/stb/vmpeg/0/dst_height", buffer, strlen(buffer));
-}
-
-static inline int rate2csapi(int rate)
-{
-	switch (rate)
-	{
-		/* no idea how the float values are represented by the driver */
-		case 23976:
-			return 0;
-		case 24:
-			return 1;
-		case 25:
-			return 2;
-		case 29970:
-			return 3;
-		case 30:
-			return 4;
-		case 50:
-			return 5;
-		case 59940:
-			return 6;
-		case 60:
-			return 7;
-		default:
-			break;
-	}
-	return -1;
-}
-
-void cVideo::getPictureInfo(int &width, int &height, int &rate)
-{
-	video_size_t s;
-	int r;
-	if (fd == -1)
-	{
-		/* in movieplayer mode, fd is not opened -> fall back to procfs */
-		r      = proc_get_hex("/proc/stb/vmpeg/0/framerate");
-		width  = proc_get_hex("/proc/stb/vmpeg/0/xres");
-		height = proc_get_hex("/proc/stb/vmpeg/0/yres");
-		rate   = rate2csapi(r);
-		return;
-	}
-	ioctl(fd, VIDEO_GET_SIZE, &s);
-	ioctl(fd, VIDEO_GET_FRAME_RATE, &r);
-	rate = rate2csapi(r);
-	height = s.h;
-	width = s.w;
-	hal_debug("%s: rate: %d, width: %d height: %d\n", __func__, rate, width, height);
-}
-
-void cVideo::SetSyncMode(AVSYNC_TYPE mode)
-{
-	hal_debug("%s %d\n", __func__, mode);
-	/*
-	 * { 0, LOCALE_OPTIONS_OFF },
-	 * { 1, LOCALE_OPTIONS_ON  },
-	 * { 2, LOCALE_AUDIOMENU_AVSYNC_AM }
-	 */
-#if 0
-	switch(Mode)
-	{
-		case 0:
-			ioctl(fd, MPEG_VID_SYNC_OFF);
-			break;
-		case 1:
-			ioctl(fd, MPEG_VID_SYNC_ON, VID_SYNC_VID);
-			break;
-		default:
-			ioctl(fd, MPEG_VID_SYNC_ON, VID_SYNC_AUD);
-			break;
-	}
-#endif
-};
-
-int cVideo::SetStreamType(VIDEO_FORMAT type)
-{
-	static const char *VF[] = {
-		"VIDEO_FORMAT_MPEG2",
-		"VIDEO_FORMAT_MPEG4",
-		"VIDEO_FORMAT_VC1",
-		"VIDEO_FORMAT_JPEG",
-		"VIDEO_FORMAT_GIF",
-		"VIDEO_FORMAT_PNG"
-	};
-	int t;
-	hal_debug("%s type=%s\n", __FUNCTION__, VF[type]);
-
-	switch (type)
-	{
-		case VIDEO_FORMAT_MPEG4:
-			t = VIDEO_STREAMTYPE_MPEG4_H264;
-			break;
-		case VIDEO_FORMAT_VC1:
-			t = VIDEO_STREAMTYPE_VC1;
-			break;
-		case VIDEO_FORMAT_MPEG2:
-		default:
-			t = VIDEO_STREAMTYPE_MPEG2;
-			break;
-	}
-
-	if (ioctl(fd, VIDEO_SET_STREAMTYPE, t) < 0)
-		hal_info("%s VIDEO_SET_STREAMTYPE(%d) failed: %m\n", __func__, t);
-	return 0;
-}
-
-int64_t cVideo::GetPTS(void)
-{
-	int64_t pts = 0;
-	if (ioctl(fd, VIDEO_GET_PTS, &pts) < 0)
-		hal_info("%s: GET_PTS failed (%m)\n", __func__);
-	return pts;
-}
-
-static void show_iframe(int fd, unsigned char *iframe, size_t st_size)
-{
-	static const unsigned char pes_header[] = { 0, 0, 1, 0xE0, 0, 0, 0x80, 0x80, 5, 0x21, 0, 1, 0, 1};
-	static const unsigned char seq_end[] = { 0x00, 0x00, 0x01, 0xB7 };
-	unsigned char stuffing[128];
-	bool seq_end_avail = false;
-	size_t pos = 0;
-	int count = 7;
-	if (ioctl(fd, VIDEO_SET_FORMAT, VIDEO_FORMAT_16_9) < 0)
-		hal_info_c("%s: VIDEO_SET_FORMAT failed (%m)\n", __func__);
-	ioctl(fd, VIDEO_SET_STREAMTYPE, VIDEO_FORMAT_MPEG2);
-	ioctl(fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY);
-	ioctl(fd, VIDEO_PLAY);
-	ioctl(fd, VIDEO_CONTINUE);
-	ioctl(fd, VIDEO_CLEAR_BUFFER);
-	while (pos <= (st_size-4) && !(seq_end_avail = (!iframe[pos] && !iframe[pos+1] && iframe[pos+2] == 1 && iframe[pos+3] == 0xB7)))
-		++pos;
-	while (count--)
-	{
-		if ((iframe[3] >> 4) != 0xE) // no pes header
-			write(fd, pes_header, sizeof(pes_header));
-		else
-			iframe[4] = iframe[5] = 0x00;
-		write(fd, iframe, st_size);
-		usleep(8000);
-	}
-	if (!seq_end_avail)
-		write(fd, seq_end, sizeof(seq_end));
-
-	memset(stuffing, 0, sizeof(stuffing));
-	for (count = 0; count < 8192 / (int)sizeof(stuffing); count++)
-		write(fd, stuffing, sizeof(stuffing));
-	ioctl(fd, VIDEO_STOP, 0);
-	ioctl(fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
-}
-
-void cVideo::SetDemux(cDemux *)
-{
-	hal_debug("%s: not implemented yet\n", __func__);
-}
diff -Nur libstb-hal-ddt.git.orig/libazbox/video_lib.h libstb-hal-ddt.git/libazbox/video_lib.h
--- libstb-hal-ddt.git.orig/libazbox/video_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libazbox/video_lib.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,196 +0,0 @@
-#ifndef __VIDEO_LIB_H__
-#define __VIDEO_LIB_H__
-
-#include <linux/dvb/video.h>
-#include "cs_types.h"
-#include "dmx_hal.h"
-
-typedef enum {
-	ANALOG_SD_RGB_CINCH = 0x00,
-	ANALOG_SD_YPRPB_CINCH,
-	ANALOG_HD_RGB_CINCH,
-	ANALOG_HD_YPRPB_CINCH,
-	ANALOG_SD_RGB_SCART = 0x10,
-	ANALOG_SD_YPRPB_SCART,
-	ANALOG_HD_RGB_SCART,
-	ANALOG_HD_YPRPB_SCART,
-	ANALOG_SCART_MASK = 0x10
-} analog_mode_t;
-
-
-typedef enum {
-	VIDEO_FORMAT_MPEG2 = 0,
-	VIDEO_FORMAT_MPEG4,
-	VIDEO_FORMAT_VC1,
-	VIDEO_FORMAT_JPEG,
-	VIDEO_FORMAT_GIF,
-	VIDEO_FORMAT_PNG
-} VIDEO_FORMAT;
-
-typedef enum {
-	VIDEO_SD = 0,
-	VIDEO_HD,
-	VIDEO_120x60i,
-	VIDEO_320x240i,
-	VIDEO_1440x800i,
-	VIDEO_360x288i
-} VIDEO_DEFINITION;
-
-typedef enum {
-	VIDEO_FRAME_RATE_23_976 = 0,
-	VIDEO_FRAME_RATE_24,
-	VIDEO_FRAME_RATE_25,
-	VIDEO_FRAME_RATE_29_97,
-	VIDEO_FRAME_RATE_30,
-	VIDEO_FRAME_RATE_50,
-	VIDEO_FRAME_RATE_59_94,
-	VIDEO_FRAME_RATE_60
-} VIDEO_FRAME_RATE;
-
-typedef enum {
-	DISPLAY_AR_1_1,
-	DISPLAY_AR_4_3,
-	DISPLAY_AR_14_9,
-	DISPLAY_AR_16_9,
-	DISPLAY_AR_20_9,
-	DISPLAY_AR_RAW,
-} DISPLAY_AR;
-
-typedef enum {
-	DISPLAY_AR_MODE_PANSCAN = 0,
-	DISPLAY_AR_MODE_LETTERBOX,
-	DISPLAY_AR_MODE_NONE,
-	DISPLAY_AR_MODE_PANSCAN2
-} DISPLAY_AR_MODE;
-
-typedef enum {
-	VIDEO_DB_DR_NEITHER = 0,
-	VIDEO_DB_ON,
-	VIDEO_DB_DR_BOTH
-} VIDEO_DB_DR;
-
-typedef enum {
-	VIDEO_PLAY_STILL = 0,
-	VIDEO_PLAY_CLIP,
-	VIDEO_PLAY_TRICK,
-	VIDEO_PLAY_MOTION,
-	VIDEO_PLAY_MOTION_NO_SYNC
-} VIDEO_PLAY_MODE;
-
-typedef enum {
-	VIDEO_STD_NTSC,
-	VIDEO_STD_SECAM,
-	VIDEO_STD_PAL,
-	VIDEO_STD_480P,
-	VIDEO_STD_576P,
-	VIDEO_STD_720P60,
-	VIDEO_STD_1080I60,
-	VIDEO_STD_720P50,
-	VIDEO_STD_1080I50,
-	VIDEO_STD_1080P30,
-	VIDEO_STD_1080P24,
-	VIDEO_STD_1080P25,
-	VIDEO_STD_AUTO,
-	VIDEO_STD_1080P50,	/* SPARK only */
-	VIDEO_STD_MAX
-} VIDEO_STD;
-
-/* not used, for dummy functions */
-typedef enum {
-	VIDEO_HDMI_CEC_MODE_OFF = 0,
-	VIDEO_HDMI_CEC_MODE_TUNER,
-	VIDEO_HDMI_CEC_MODE_RECORDER
-} VIDEO_HDMI_CEC_MODE;
-
-typedef enum
-{
-	VIDEO_CONTROL_BRIGHTNESS = 0,
-	VIDEO_CONTROL_CONTRAST,
-	VIDEO_CONTROL_SATURATION,
-	VIDEO_CONTROL_HUE,
-	VIDEO_CONTROL_SHARPNESS,
-	VIDEO_CONTROL_MAX = VIDEO_CONTROL_SHARPNESS
-} VIDEO_CONTROL;
-
-
-class cVideo
-{
-	friend class cDemux;
-	friend class cPlayback;
-	private:
-		/* video device */
-		int fd;
-		/* apparently we cannot query the driver's state
-		   => remember it */
-		video_play_state_t playstate;
-		int /*vidDispMode_t*/ croppingMode;
-		int /*vidOutFmt_t*/ outputformat;
-		int scartvoltage;
-
-		VIDEO_FORMAT StreamType;
-		VIDEO_DEFINITION VideoDefinition;
-		DISPLAY_AR DisplayAR;
-		VIDEO_PLAY_MODE SyncMode;
-		DISPLAY_AR_MODE ARMode;
-		VIDEO_DB_DR eDbDr;
-		DISPLAY_AR PictureAR;
-		VIDEO_FRAME_RATE FrameRate;
-		int video_standby;
-		int64_t GetPTS(void);
-
-		void openDevice(void);
-		void closeDevice(void);
-	public:
-		/* constructor & destructor */
-		cVideo(int mode, void *, void *, unsigned int unit = 0);
-		~cVideo(void);
-
-		void * GetTVEnc() { return NULL; };
-		void * GetTVEncSD() { return NULL; };
-
-		/* aspect ratio */
-		int getAspectRatio(void);
-		void getPictureInfo(int &width, int &height, int &rate);
-		int setAspectRatio(int aspect, int mode);
-
-		/* cropping mode */
-		int setCroppingMode(int x = 0 /*vidDispMode_t x = VID_DISPMODE_NORM*/);
-
-		/* get play state */
-		int getPlayState(void);
-
-		/* blank on freeze */
-		int getBlank(void);
-		int setBlank(int enable);
-
-		/* change video play state. Parameters are all unused. */
-		int Start(void *PcrChannel = NULL, unsigned short PcrPid = 0, unsigned short VideoPid = 0, void *x = NULL);
-		int Stop(bool blank = true);
-		bool Pause(void);
-
-		/* set video_system */
-		int SetVideoSystem(int video_system, bool remember = true);
-		int SetStreamType(VIDEO_FORMAT type);
-		void SetSyncMode(AVSYNC_TYPE mode);
-		bool SetCECMode(VIDEO_HDMI_CEC_MODE) { return true; };
-		void SetCECAutoView(bool) { return; };
-		void SetCECAutoStandby(bool) { return; };
-		void ShowPicture(const char * fname);
-		void StopPicture();
-		void Standby(unsigned int bOn);
-		void Pig(int x, int y, int w, int h, int osd_w = 1064, int osd_h = 600);
-		void SetControl(int, int) { return; };
-		void VideoParamWatchdog(void);
-		void setContrast(int val);
-		void SetVideoMode(analog_mode_t mode);
-		void SetDBDR(int) { return; };
-		void SetAudioHandle(void *) { return; };
-		void SetAutoModes(int [VIDEO_STD_MAX]) { return; };
-		int  OpenVBI(int) { return 0; };
-		int  CloseVBI(void) { return 0; };
-		int  StartVBI(unsigned short) { return 0; };
-		int  StopVBI(void) { return 0; };
-		void SetDemux(cDemux *dmx);
-};
-
-#endif // __VIDEO_LIB_H__
diff -Nur libstb-hal-ddt.git.orig/libduckbox/audio.cpp libstb-hal-ddt.git/libduckbox/audio.cpp
--- libstb-hal-ddt.git.orig/libduckbox/audio.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libduckbox/audio.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -8,22 +8,45 @@
 
 #include <linux/dvb/audio.h>
 
+#include <hardware_caps.h>
 #include <proc_tools.h>
 
 #include "audio_lib.h"
 #include "audio_mixer.h"
 #include "hal_debug.h"
 
-#define AUDIO_DEVICE	"/dev/dvb/adapter0/audio0"
 #define hal_debug(args...) _hal_debug(HAL_DEBUG_AUDIO, this, args)
 #define hal_info(args...) _hal_info(HAL_DEBUG_AUDIO, this, args)
 
 #include <linux/soundcard.h>
 
-cAudio * audioDecoder = NULL;
+enum
+{
+	ENCODER,
+	AUX
+};
+
+cAudio *audioDecoder = NULL;
+cAudio *pipAudioDecoder[3] = { NULL, NULL, NULL };
+
+static const char *ADEV[] =
+{
+	"/dev/dvb/adapter0/audio0",
+	"/dev/dvb/adapter0/audio1",
+	"/dev/dvb/adapter0/audio2",
+	"/dev/dvb/adapter0/audio3"
+};
 
-cAudio::cAudio(void *, void *, void *)
+cAudio::cAudio(void *, void *, void *, unsigned int unit)
 {
+	hw_caps_t *hwcaps = get_hwcaps();
+	if (unit > (unsigned int) hwcaps->pip_devs)
+	{
+		hal_info("%s: unit %d out of range, setting to 0\n", __func__, unit);
+		devnum = 0;
+	}
+	else
+		devnum = unit;
 	fd = -1;
 	clipfd = -1;
 	mixer_fd = -1;
@@ -48,7 +71,7 @@
 
 	if (fd < 0)
 	{
-		if ((fd = open(AUDIO_DEVICE, O_RDWR)) < 0)
+		if ((fd = open(ADEV[devnum], O_RDWR)) < 0)
 			hal_info("openDevice: open failed (%m)\n");
 		fcntl(fd, F_SETFD, FD_CLOEXEC);
 		do_mute(true, false);
@@ -61,20 +84,28 @@
 {
 	closeMixers();
 
-	if (fd > -1) {
+	if (fd > -1)
+	{
 		close(fd);
 		fd = -1;
 	}
-	if (clipfd > -1) {
+	if (clipfd > -1)
+	{
 		close(clipfd);
 		clipfd = -1;
 	}
-	if (mixer_fd > -1) {
+	if (mixer_fd > -1)
+	{
 		close(mixer_fd);
 		mixer_fd = -1;
 	}
 }
 
+void cAudio::setAVInput(int val)
+{
+	hal_info("%s not implemented yet - switching to: %s\n", __func__, val == AUX ? "AUX" : "ENCODER");
+}
+
 int cAudio::do_mute(bool enable, bool remember)
 {
 	hal_debug("%s(%d, %d)\n", __FUNCTION__, enable, remember);
@@ -114,7 +145,8 @@
 	volume = (left + right) / 2;
 	int v = map_volume(volume);
 #if 0
-	if (clipfd != -1 && mixer_fd != -1) {
+	if (clipfd != -1 && mixer_fd != -1)
+	{
 		int tmp = 0;
 		/* not sure if left / right is correct here, but it is always the same anyways ;-) */
 		if (! Muted)
@@ -157,41 +189,12 @@
 	ioctl(fd, AUDIO_SET_AV_SYNC, Mode);
 }
 
-// E2 streamtype values. These correspond to
-//  player2/linux/drivers/media/dvb/stm/dvb/dvb_audio.c:AudioIoctlSetBypassMode
-#define AUDIO_STREAMTYPE_AC3	0
-#define AUDIO_STREAMTYPE_MPEG	1
-#define AUDIO_STREAMTYPE_DTS	2
-#define AUDIO_STREAMTYPE_AAC	8
-#define AUDIO_STREAMTYPE_AACHE	9
-
-void cAudio::SetStreamType(AUDIO_FORMAT type)
-{
-	int bypass = AUDIO_STREAMTYPE_MPEG;
-	hal_debug("%s %d\n", __FUNCTION__, type);
-	StreamType = type;
+void cAudio::SetStreamType(int bypass)
+{
+	StreamType = bypass;
 
-	switch (type)
-	{
-		case AUDIO_FMT_DD_PLUS:
-		case AUDIO_FMT_DOLBY_DIGITAL:
-			bypass = AUDIO_STREAMTYPE_AC3;
-			break;
-		case AUDIO_FMT_AAC:
-			bypass = AUDIO_STREAMTYPE_AAC;
-			break;
-		case AUDIO_FMT_AAC_PLUS:
-			bypass = AUDIO_STREAMTYPE_AACHE;
-			break;
-		case AUDIO_FMT_DTS:
-			bypass = AUDIO_STREAMTYPE_DTS;
-			break;
-		default:
-			break;
-	}
+	hal_info("%s %d (0x%x)\n", __FUNCTION__, bypass, bypass);
 
-	// Normaly the encoding should be set using AUDIO_SET_ENCODING
-	// But as we implemented the behavior to bypass (cause of e2) this is correct here
 	if (ioctl(fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
 		hal_info("%s: AUDIO_SET_BYPASS_MODE failed (%m)\n", __func__);
 }
@@ -209,7 +212,8 @@
 	const char *dsp_dev = getenv("DSP_DEVICE");
 	const char *mix_dev = getenv("MIX_DEVICE");
 	hal_debug("%s ch %d srate %d bits %d le %d\n", __FUNCTION__, ch, srate, bits, little_endian);
-	if (clipfd > -1) {
+	if (clipfd > -1)
+	{
 		hal_info("%s: clipfd already opened (%d)\n", __FUNCTION__, clipfd);
 		return -1;
 	}
@@ -222,16 +226,18 @@
 	 *   export MIX_DEVICE=/dev/sound/mixer2
 	 *   neutrino
 	 */
-	if ((!dsp_dev) || (access(dsp_dev, W_OK))) {
+	if ((!dsp_dev) || (access(dsp_dev, W_OK)))
+	{
 		if (dsp_dev)
 			hal_info("%s: DSP_DEVICE is set (%s) but cannot be opened,"
-				" fall back to /dev/dsp1\n", __func__, dsp_dev);
+			    " fall back to /dev/dsp1\n", __func__, dsp_dev);
 		dsp_dev = "/dev/dsp1";
 	}
 	hal_info("%s: dsp_dev %s mix_dev %s\n", __func__, dsp_dev, mix_dev); /* NULL mix_dev is ok */
 	/* the tdoss dsp driver seems to work only on the second open(). really. */
 	clipfd = open(dsp_dev, O_WRONLY);
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s open %s: %m\n", dsp_dev, __FUNCTION__);
 		return -1;
 	}
@@ -254,42 +260,50 @@
 		return 0;
 
 	mixer_fd = open(mix_dev, O_RDWR);
-	if (mixer_fd < 0) {
+	if (mixer_fd < 0)
+	{
 		hal_info("%s: open mixer %s failed (%m)\n", __func__, mix_dev);
 		/* not a real error */
 		return 0;
 	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_DEVMASK, &devmask) == -1) {
+	if (ioctl(mixer_fd, SOUND_MIXER_READ_DEVMASK, &devmask) == -1)
+	{
 		hal_info("%s: SOUND_MIXER_READ_DEVMASK %m\n", __func__);
 		devmask = 0;
 	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_STEREODEVS, &stereo) == -1) {
+	if (ioctl(mixer_fd, SOUND_MIXER_READ_STEREODEVS, &stereo) == -1)
+	{
 		hal_info("%s: SOUND_MIXER_READ_STEREODEVS %m\n", __func__);
 		stereo = 0;
 	}
 	usable = devmask & stereo;
-	if (usable == 0) {
+	if (usable == 0)
+	{
 		hal_info("%s: devmask: %08x stereo: %08x, no usable dev :-(\n",
-			__func__, devmask, stereo);
+		    __func__, devmask, stereo);
 		close(mixer_fd);
 		mixer_fd = -1;
 		return 0; /* TODO: should we treat this as error? */
 	}
 	/* __builtin_popcount needs GCC, it counts the set bits... */
-	if (__builtin_popcount (usable) != 1) {
+	if (__builtin_popcount(usable) != 1)
+	{
 		/* TODO: this code is not yet tested as I have only single-mixer devices... */
 		hal_info("%s: more than one mixer control: devmask %08x stereo %08x\n"
-			"%s: querying MIX_NUMBER environment variable...\n",
-			__func__, devmask, stereo, __func__);
+		    "%s: querying MIX_NUMBER environment variable...\n",
+		    __func__, devmask, stereo, __func__);
 		const char *tmp = getenv("MIX_NUMBER");
 		if (tmp)
 			mixer_num = atoi(tmp);
 		hal_info("%s: mixer_num is %d -> device %08x\n",
-			__func__, mixer_num, (mixer_num >= 0) ? (1 << mixer_num) : 0);
+		    __func__, mixer_num, (mixer_num >= 0) ? (1 << mixer_num) : 0);
 		/* no error checking, you'd better know what you are doing... */
-	} else {
+	}
+	else
+	{
 		mixer_num = 0;
-		while (!(usable & 0x01)) {
+		while (!(usable & 0x01))
+		{
 			mixer_num++;
 			usable >>= 1;
 		}
@@ -303,7 +317,8 @@
 {
 	int ret;
 	// hal_debug("cAudio::%s\n", __FUNCTION__);
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
 		return -1;
 	}
@@ -316,13 +331,15 @@
 int cAudio::StopClip()
 {
 	hal_debug("%s\n", __FUNCTION__);
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
 		return -1;
 	}
 	close(clipfd);
 	clipfd = -1;
-	if (mixer_fd > -1) {
+	if (mixer_fd > -1)
+	{
 		close(mixer_fd);
 		mixer_fd = -1;
 	}
@@ -350,24 +367,24 @@
 
 	type = atype;
 #if 0
-/* this does not work, some of the values are negative?? */
+	/* this does not work, some of the values are negative?? */
 	AMPEGStatus A;
 	memcpy(&A, &i.word00, sizeof(i.word00));
 	layer   = A.audio_mpeg_layer;
 	mode    = A.audio_mpeg_mode;
 	bitrate = A.audio_mpeg_bitrate;
-	switch(A.audio_mpeg_frequency)
+	switch (A.audio_mpeg_frequency)
 #endif
-	/* layer and bitrate are not used anyway... */
-	layer   = 0; //(i.word00 >> 17) & 3;
+		/* layer and bitrate are not used anyway... */
+		layer   = 0; //(i.word00 >> 17) & 3;
 	bitrate = 0; //(i.word00 >> 12) & 3;
 	switch (type)
 	{
-		case 0:	/* MPEG */
+		case 0: /* MPEG */
 			mode = (i.word00 >> 6) & 3;
 			freq = freq_mpg[(i.word00 >> 10) & 3];
 			break;
-		case 1:	/* AC3 */
+		case 1: /* AC3 */
 			mode = (i.word00 >> 28) & 7;
 			freq = freq_ac3[(i.word00 >> 16) & 3];
 			break;
@@ -436,17 +453,20 @@
 
 void cAudio::setMixerVolume(const char *name, long value, bool remember)
 {
-	if (!strcmp(name, "Analog")) {
+	if (!strcmp(name, "Analog"))
+	{
 		mixerAnalog->setVolume(value);
 		if (remember)
 			volumeAnalog = value;
 	}
-	if (!strcmp(name, "HDMI")) {
+	if (!strcmp(name, "HDMI"))
+	{
 		mixerHDMI->setVolume(value);
 		if (remember)
 			volumeHDMI = value;
 	}
-	if (!strcmp(name, "SPDIF")) {
+	if (!strcmp(name, "SPDIF"))
+	{
 		mixerSPDIF->setVolume(value);
 		if (remember)
 			volumeSPDIF = value;
@@ -455,12 +475,15 @@
 
 void cAudio::muteMixers(bool m)
 {
-	if (m && !mixersMuted) {
+	if (m && !mixersMuted)
+	{
 		mixersMuted = true;
 		setMixerVolume("Analog", 0, false);
 		setMixerVolume("HDMI", 0, false);
 		setMixerVolume("SPDIF", 0, false);
-	} else if (!m && mixersMuted) {
+	}
+	else if (!m && mixersMuted)
+	{
 		mixersMuted = false;
 		setMixerVolume("Analog", volumeAnalog, false);
 		setMixerVolume("HDMI", volumeHDMI, false);
diff -Nur libstb-hal-ddt.git.orig/libduckbox/audio_lib.h libstb-hal-ddt.git/libduckbox/audio_lib.h
--- libstb-hal-ddt.git.orig/libduckbox/audio_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libduckbox/audio_lib.h	2022-07-23 18:18:31.539772306 +0200
@@ -12,44 +12,28 @@
 	AUDIO_SYNC_AUDIO_MASTER
 } AUDIO_SYNC_MODE;
 
-typedef enum {
+typedef enum
+{
 	HDMI_ENCODED_OFF,
 	HDMI_ENCODED_AUTO,
 	HDMI_ENCODED_FORCED
 } HDMI_ENCODED_MODE;
 
-typedef enum
-{
-	AUDIO_FMT_AUTO = 0,
-	AUDIO_FMT_MPEG,
-	AUDIO_FMT_MP3,
-	AUDIO_FMT_DOLBY_DIGITAL,
-	AUDIO_FMT_BASIC = AUDIO_FMT_DOLBY_DIGITAL,
-	AUDIO_FMT_AAC,
-	AUDIO_FMT_AAC_PLUS,
-	AUDIO_FMT_DD_PLUS,
-	AUDIO_FMT_DTS,
-	AUDIO_FMT_AVS,
-	AUDIO_FMT_MLP,
-	AUDIO_FMT_WMA,
-	AUDIO_FMT_MPG1, // TD only. For Movieplayer / cPlayback
-	AUDIO_FMT_ADVANCED = AUDIO_FMT_MLP
-} AUDIO_FORMAT;
-
 class mixerVolume;
 
 class cAudio
 {
-	friend class cPlayback;
+		friend class cPlayback;
 	private:
 		int fd;
+		unsigned int devnum;
 		bool Muted;
 
 		int clipfd; /* for pcm playback */
 		int mixer_fd;  /* if we are using the OSS mixer */
 		int mixer_num; /* oss mixer to use, if any */
 
-		AUDIO_FORMAT	StreamType;
+		int StreamType;
 		AUDIO_SYNC_MODE    SyncMode;
 		bool started;
 
@@ -67,35 +51,67 @@
 
 	public:
 		/* construct & destruct */
-		cAudio(void *, void *, void *);
+		cAudio(void *, void *, void *, unsigned int unit = 0);
 		~cAudio(void);
 
-		void *GetHandle() { return NULL; };
+		void open_AVInput_Device(void)
+		{
+			return;
+		};
+		void close_AVInput_Device(void)
+		{
+			return;
+		};
+
+		void setAVInput(int val);
+
+		void *GetHandle()
+		{
+			return NULL;
+		};
 		/* shut up */
-		int mute(bool remember = true) { return do_mute(true, remember); };
-		int unmute(bool remember = true) { return do_mute(false, remember); };
+		int mute(bool remember = true)
+		{
+			return do_mute(true, remember);
+		};
+		int unmute(bool remember = true)
+		{
+			return do_mute(false, remember);
+		};
 
 		/* volume, min = 0, max = 255 */
 		int setVolume(unsigned int left, unsigned int right);
-		int getVolume(void) { return volume;}
-		bool getMuteStatus(void) { return Muted; };
+		int getVolume(void)
+		{
+			return volume;
+		}
+		bool getMuteStatus(void)
+		{
+			return Muted;
+		};
 
 		/* start and stop audio */
 		int Start(void);
 		int Stop(void);
 		bool Pause(bool Pcm = true);
-		void SetStreamType(AUDIO_FORMAT type);
-		AUDIO_FORMAT GetStreamType(void) { return StreamType; }
+		void SetStreamType(int bypass);
+		int GetStreamType(void)
+		{
+			return StreamType;
+		}
 		void SetSyncMode(AVSYNC_TYPE Mode);
 
 		/* select channels */
 		int setChannel(int channel);
 		int PrepareClipPlay(int uNoOfChannels, int uSampleRate, int uBitsPerSample, int bLittleEndian);
-		int WriteClip(unsigned char * buffer, int size);
+		int WriteClip(unsigned char *buffer, int size);
 		int StopClip();
-		void getAudioInfo(int &type, int &layer, int& freq, int &bitrate, int &mode);
+		void getAudioInfo(int &type, int &layer, int &freq, int &bitrate, int &mode);
 		void SetSRS(int iq_enable, int nmgr_enable, int iq_mode, int iq_level);
-		bool IsHdmiDDSupported() { return true; };
+		bool IsHdmiDDSupported()
+		{
+			return true;
+		};
 		void SetHdmiDD(bool enable);
 		void SetSpdifDD(bool enable);
 		void ScheduleMute(bool On);
diff -Nur libstb-hal-ddt.git.orig/libduckbox/audio_mixer.cpp libstb-hal-ddt.git/libduckbox/audio_mixer.cpp
--- libstb-hal-ddt.git.orig/libduckbox/audio_mixer.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libduckbox/audio_mixer.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -19,7 +19,8 @@
 
 #include <audio_mixer.h>
 
-mixerVolume::mixerVolume(const char *name, const char *card, long volume) {
+mixerVolume::mixerVolume(const char *name, const char *card, long volume)
+{
 	snd_mixer_selem_id_t *sid = NULL;
 	elem = NULL;
 	handle = NULL;
@@ -49,7 +50,8 @@
 	snd_mixer_selem_id_set_index(sid, 0);
 	snd_mixer_selem_id_set_name(sid, name);
 	elem = snd_mixer_find_selem(handle, sid);
-	if (elem) {
+	if (elem)
+	{
 		snd_mixer_selem_get_playback_volume_range(elem, &min, &max);
 		setVolume(volume);
 	}
@@ -60,9 +62,10 @@
 		snd_mixer_close(handle);
 }
 
-bool mixerVolume::setVolume(long volume) {
+bool mixerVolume::setVolume(long volume)
+{
 	return elem
-		&& (volume > -1)
-		&& (volume < 101)
-		&& !snd_mixer_selem_set_playback_volume_all(elem, min + volume * (max - min)/100);
+	    && (volume > -1)
+	    && (volume < 101)
+	    && !snd_mixer_selem_set_playback_volume_all(elem, min + volume * (max - min) / 100);
 }
diff -Nur libstb-hal-ddt.git.orig/libduckbox/audio_mixer.h libstb-hal-ddt.git/libduckbox/audio_mixer.h
--- libstb-hal-ddt.git.orig/libduckbox/audio_mixer.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libduckbox/audio_mixer.h	2022-07-23 18:18:31.539772306 +0200
@@ -27,7 +27,7 @@
 	private:
 		long min, max;
 		snd_mixer_t *handle;
-		snd_mixer_elem_t* elem;
+		snd_mixer_elem_t *elem;
 	public:
 		mixerVolume(const char *selem_name, const char *Card, long volume = -1);
 		~mixerVolume(void);
diff -Nur libstb-hal-ddt.git.orig/libduckbox/dmx.cpp libstb-hal-ddt.git/libduckbox/dmx.cpp
--- libstb-hal-ddt.git.orig/libduckbox/dmx.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libduckbox/dmx.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -26,19 +26,19 @@
  *
  * the sh4 pti driver, driving the /dev/dvb/adapter0/dmxN devices, can
  * apparently only map one input to on demux device at a time, so e.g.
- * 	DMX_SOURCE_FRONT1 -> demux0
- * 	DMX_SOURCE_FRONT2 -> demux0
- * 	DMX_SOURCE_FRONT1 -> demux1
+ *  DMX_SOURCE_FRONT1 -> demux0
+ *  DMX_SOURCE_FRONT2 -> demux0
+ *  DMX_SOURCE_FRONT1 -> demux1
  * does not work. The driver makes sure that a one-to-one mapping of
  * DMX_SOURCE_FRONTn to demuxM is maintained, and it does by e.g changing
  * the default of
- * 	FRONT0 -> demux0
- * 	FRONT1 -> demux1
- * 	FRONT2 -> demux2
+ *  FRONT0 -> demux0
+ *  FRONT1 -> demux1
+ *  FRONT2 -> demux2
  * to
- * 	FRONT1 -> demux0
- * 	FRONT0 -> demux1
- * 	FRONT2 -> demux2
+ *  FRONT1 -> demux0
+ *  FRONT0 -> demux1
+ *  FRONT2 -> demux2
  * if you do a DMX_SET_SOURCE(FRONT1) ioctl on demux0.
  * This means, it also changes demux1's source on the SET_SOURCE ioctl on
  * demux0, potentially disturbing any operation on demux1 (e.g. recording).
@@ -84,15 +84,16 @@
 #define hal_debug_z(args...) _hal_debug(HAL_DEBUG_DEMUX, thiz, args)
 
 #define dmx_err(_errfmt, _errstr, _revents) do { \
-	hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
-		__func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
+    hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
+        __func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
 } while(0);
 
 cDemux *videoDemux = NULL;
 cDemux *audioDemux = NULL;
 //cDemux *pcrDemux = NULL;
 
-static const char *DMX_T[] = {
+static const char *DMX_T[] =
+{
 	"DMX_INVALID",
 	"DMX_VIDEO",
 	"DMX_AUDIO",
@@ -109,17 +110,21 @@
 /* the current source of each cDemux unit */
 static int dmx_source[NUM_DEMUX] = { 0, 0, 0, 0 };
 
+char dmxdev[32];
+static char *devname(int adapter, int demux)
+{
+	snprintf(dmxdev, sizeof(dmxdev), "/dev/dvb/adapter%d/demux%d", adapter, demux);
+	return dmxdev;
+}
+
 /* map the device numbers. */
 #define NUM_DEMUXDEV 3
-static const char *devname[NUM_DEMUXDEV] = {
-	"/dev/dvb/adapter0/demux0",
-	"/dev/dvb/adapter0/demux1",
-	"/dev/dvb/adapter0/demux2"
-};
+
 /* did we already DMX_SET_SOURCE on that demux device? */
 static bool init[NUM_DEMUXDEV] = { false, false, false };
 
-typedef struct dmx_pdata {
+typedef struct dmx_pdata
+{
 	int last_source;
 	OpenThreads::Mutex *mutex;
 } dmx_pdata;
@@ -167,31 +172,33 @@
 
 static bool _open(cDemux *thiz, int num, int &fd, int &last_source, DMX_CHANNEL_TYPE dmx_type, int buffersize)
 {
-	int flags = O_RDWR|O_CLOEXEC;
+	int flags = O_RDWR | O_CLOEXEC;
 	int devnum = dmx_source[num];
-	if (last_source == devnum) {
+	if (last_source == devnum)
+	{
 		hal_debug_z("%s #%d: source (%d) did not change\n", __func__, num, last_source);
 		if (fd > -1)
 			return true;
 	}
-	if (fd > -1) {
+	if (fd > -1)
+	{
 		/* we changed source -> close and reopen the fd */
 		hal_debug_z("%s #%d: FD ALREADY OPENED fd = %d lastsource %d devnum %d\n",
-				__func__, num, fd, last_source, devnum);
+		    __func__, num, fd, last_source, devnum);
 		close(fd);
 	}
 
 	if (dmx_type != DMX_PSI_CHANNEL)
 		flags |= O_NONBLOCK;
 
-	fd = open(devname[devnum], flags);
+	fd = open(devname(0, devnum), flags);
 	if (fd < 0)
 	{
-		hal_info_z("%s %s: %m\n", __FUNCTION__, devname[devnum]);
+		hal_info_z("%s %s: %m\n", __FUNCTION__, devname(0, devnum));
 		return false;
 	}
 	hal_debug_z("%s #%d pes_type: %s(%d), uBufferSize: %d fd: %d\n", __func__,
-		 num, DMX_T[dmx_type], dmx_type, buffersize, fd);
+	    num, DMX_T[dmx_type], dmx_type, buffersize, fd);
 
 	/* this would actually need locking, but the worst that weill happen is, that
 	 * we'll DMX_SET_SOURCE twice per device, so don't bother... */
@@ -199,7 +206,7 @@
 	{
 		/* this should not change anything... */
 		int n = DMX_SOURCE_FRONT0 + devnum;
-		hal_info_z("%s: setting %s to source %d\n", __func__, devname[devnum], n);
+		hal_info_z("%s: setting %s to source %d\n", __func__, devname(0, devnum), n);
 		if (ioctl(fd, DMX_SET_SOURCE, &n) < 0)
 			hal_info_z("%s DMX_SET_SOURCE failed!\n", __func__);
 		else
@@ -262,7 +269,7 @@
 #if 0
 	if (len != 4095 && timeout != 10)
 		fprintf(stderr, "cDemux::%s #%d fd: %d type: %s len: %d timeout: %d\n",
-			__FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
+		    __FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
 #endif
 	if (fd < 0)
 	{
@@ -275,7 +282,7 @@
 	int to = timeout;
 	struct pollfd ufds;
 	ufds.fd = fd;
-	ufds.events = POLLIN|POLLPRI|POLLERR;
+	ufds.events = POLLIN | POLLPRI | POLLERR;
 	ufds.revents = 0;
 
 	/* hack: if the frontend loses and regains lock, the demuxer often will not
@@ -286,7 +293,7 @@
 
 	if (to > 0)
 	{
- retry:
+retry:
 		rc = ::poll(&ufds, 1, to);
 		if (ufds.fd != fd)
 		{
@@ -331,8 +338,9 @@
 			return 0;
 		}
 	}
-	if (ufds.fd != fd)	/* does this ever happen? and if, is it harmful? */
-	{			/* read(-1,...) will just return EBADF anyway... */
+	if (ufds.fd != fd)  /* does this ever happen? and if, is it harmful? */
+	{
+		/* read(-1,...) will just return EBADF anyway... */
 		hal_info("%s:2 ========== fd has changed, %d->%d ==========\n", __func__, ufds.fd, fd);
 		return -1;
 	}
@@ -345,9 +353,9 @@
 	return rc;
 }
 
-bool cDemux::sectionFilter(unsigned short _pid, const unsigned char * const filter,
-			   const unsigned char * const mask, int len, int timeout,
-			   const unsigned char * const negmask)
+bool cDemux::sectionFilter(unsigned short _pid, const unsigned char *const filter,
+    const unsigned char *const mask, int len, int timeout,
+    const unsigned char *const negmask)
 {
 	struct dmx_sct_filter_params s_flt;
 	memset(&s_flt, 0, sizeof(s_flt));
@@ -368,7 +376,7 @@
 	if (negmask != NULL)
 		memcpy(s_flt.filter.mode, negmask, len);
 
-	s_flt.flags = DMX_IMMEDIATE_START|DMX_CHECK_CRC;
+	s_flt.flags = DMX_IMMEDIATE_START | DMX_CHECK_CRC;
 
 	int to = 0;
 	switch (filter[0])
@@ -453,13 +461,22 @@
 		s_flt.timeout = to;
 
 	hal_debug("%s #%d pid:0x%04hx fd:%d type:%s len:%d to:%d flags:%x flt[0]:%02x\n", __func__, num,
-		pid, fd, DMX_T[dmx_type], len, s_flt.timeout, s_flt.flags, s_flt.filter.filter[0]);
-#if 0
-	fprintf(stderr,"filt: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.filter[i]); fprintf(stderr, "\n");
-	fprintf(stderr,"mask: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mask  [i]); fprintf(stderr, "\n");
-	fprintf(stderr,"mode: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mode  [i]); fprintf(stderr, "\n");
-#endif
-	ioctl (fd, DMX_STOP);
+	    pid, fd, DMX_T[dmx_type], len, s_flt.timeout, s_flt.flags, s_flt.filter.filter[0]);
+
+	if (debuglevel == 2)
+	{
+		fprintf(stderr, "filt: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.filter[i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mask: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mask  [i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mode: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mode  [i]);
+		fprintf(stderr, "\n");
+	}
+
+	ioctl(fd, DMX_STOP);
 	if (ioctl(fd, DMX_SET_FILTER, &s_flt) < 0)
 		return false;
 
@@ -475,7 +492,7 @@
 	 * this check originally is from tuxbox cvs but I'm not sure
 	 * what it is good for...
 	if (pid <= 0x0001 && dmx_type != DMX_PCR_ONLY_CHANNEL)
-		return false;
+	    return false;
 	 */
 	if ((pid >= 0x0002 && pid <= 0x000f) || pid >= 0x1fff)
 		return false;
@@ -486,31 +503,50 @@
 
 	memset(&p_flt, 0, sizeof(p_flt));
 	p_flt.pid    = pid;
-	p_flt.output = DMX_OUT_DECODER;
 	p_flt.input  = DMX_IN_FRONTEND;
+	p_flt.output = DMX_OUT_DECODER;
 	p_flt.flags  = DMX_IMMEDIATE_START;
 
 	switch (dmx_type)
 	{
-		case DMX_PCR_ONLY_CHANNEL:
-			p_flt.pes_type = DMX_PES_PCR;
-			break;
-		case DMX_AUDIO_CHANNEL:
-			p_flt.pes_type = DMX_PES_AUDIO;
-			break;
 		case DMX_VIDEO_CHANNEL:
-			p_flt.pes_type = DMX_PES_VIDEO;
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_VIDEO0; break;
+				case 1: p_flt.pes_type = DMX_PES_VIDEO1; break;
+				case 2: p_flt.pes_type = DMX_PES_VIDEO2; break;
+				case 3: p_flt.pes_type = DMX_PES_VIDEO3; break;
+			}
 			break;
-		case DMX_PIP_CHANNEL: /* PIP is a special version of DMX_VIDEO_CHANNEL */
-			p_flt.pes_type = DMX_PES_VIDEO1;
+		case DMX_AUDIO_CHANNEL:
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_AUDIO0; break;
+				case 1: p_flt.pes_type = DMX_PES_AUDIO1; break;
+				case 2: p_flt.pes_type = DMX_PES_AUDIO2; break;
+				case 3: p_flt.pes_type = DMX_PES_AUDIO3; break;
+			}
 			break;
 		case DMX_PES_CHANNEL:
 			p_flt.pes_type = DMX_PES_OTHER;
-			p_flt.output  = DMX_OUT_TAP;
+			p_flt.output   = DMX_OUT_TAP;
 			break;
+#if 0
+		case DMX_PSI_CHANNEL:
+			break;
+#endif
 		case DMX_TP_CHANNEL:
 			p_flt.pes_type = DMX_PES_OTHER;
-			p_flt.output  = DMX_OUT_TSDEMUX_TAP;
+			p_flt.output   = DMX_OUT_TSDEMUX_TAP;
+			break;
+		case DMX_PCR_ONLY_CHANNEL:
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_PCR0; break;
+				case 1: p_flt.pes_type = DMX_PES_PCR1; break;
+				case 2: p_flt.pes_type = DMX_PES_PCR2; break;
+				case 3: p_flt.pes_type = DMX_PES_PCR3; break;
+			}
 			break;
 		default:
 			hal_info("%s #%d invalid dmx_type %d!\n", __func__, num, dmx_type);
@@ -567,7 +603,8 @@
 	}
 	for (std::vector<pes_pids>::iterator i = pesfds.begin(); i != pesfds.end(); ++i)
 	{
-		if ((*i).pid == Pid) {
+		if ((*i).pid == Pid)
+		{
 			hal_debug("removePid: removing demux fd %d pid 0x%04x\n", fd, Pid);
 			if (ioctl(fd, DMX_REMOVE_PID, Pid) < 0)
 				hal_info("%s: (DMX_REMOVE_PID, 0x%04hx): %m\n", __func__, Pid);
@@ -578,7 +615,7 @@
 	hal_info("%s pid 0x%04x not found\n", __FUNCTION__, Pid);
 }
 
-void cDemux::getSTC(int64_t * STC)
+void cDemux::getSTC(int64_t *STC)
 {
 	/* apparently I can only get the PTS of the video decoder,
 	 * but that's good enough for dvbsub */
@@ -600,7 +637,8 @@
 
 bool cDemux::SetSource(int unit, int source)
 {
-	if (unit >= NUM_DEMUX || unit < 0) {
+	if (unit >= NUM_DEMUX || unit < 0)
+	{
 		hal_info_c("%s: unit (%d) out of range, NUM_DEMUX %d\n", __func__, unit, NUM_DEMUX);
 		return false;
 	}
@@ -614,7 +652,8 @@
 
 int cDemux::GetSource(int unit)
 {
-	if (unit >= NUM_DEMUX || unit < 0) {
+	if (unit >= NUM_DEMUX || unit < 0)
+	{
 		hal_info_c("%s: unit (%d) out of range, NUM_DEMUX %d\n", __func__, unit, NUM_DEMUX);
 		return -1;
 	}
diff -Nur libstb-hal-ddt.git.orig/libduckbox/hardware_caps.c libstb-hal-ddt.git/libduckbox/hardware_caps.c
--- libstb-hal-ddt.git.orig/libduckbox/hardware_caps.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libduckbox/hardware_caps.c	2022-07-23 18:18:31.503773029 +0200
@@ -7,6 +7,7 @@
  * License: GPL v2 or later
  */
 
+#include <config.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
@@ -25,221 +26,267 @@
 
 	memset(&caps, 0, sizeof(hw_caps_t));
 
-	initialized = 1;
-	char buf[64];
-	int len = -1;
-	int fd = open("/proc/stb/info/model", O_RDONLY);
-	caps.display_can_set_brightness = 0;
-	caps.display_can_deepstandby = 0;
-	caps.display_has_statusline = 0;
-	if (fd != -1) {
-		len = read(fd, buf, sizeof(buf) - 1);
-		close(fd);
-	}
-	if (len > 0) {
-		buf[len] = 0;
-		if (!strncmp(buf, "atevio7500", 10)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 1;
-			caps.has_fan = 0;
-			caps.has_CI = 2;
-			caps.display_can_set_brightness = 1;
-			caps.display_type = HW_DISPLAY_LINE_TEXT;
-			caps.display_xres = 12;
-		}
-		else if (!strncmp(buf, "ufs912", 6)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 1;
-			caps.has_fan = 0;
-			caps.has_CI = 2;
-			caps.display_can_set_brightness = 1;
-			caps.display_type = HW_DISPLAY_LINE_TEXT;
-			caps.display_xres = 16;
-		}
-		else if (!strncmp(buf, "ufs913", 6)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 1;
-			caps.has_fan = 0;
-			caps.has_CI = 2;
-			caps.display_can_set_brightness = 1;
-			caps.display_type = HW_DISPLAY_LINE_TEXT;
-			caps.display_xres = 16;
-		}
-		else if (!strncmp(buf, "ufs922", 6)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 1;
-			caps.has_CI = 2;
-			caps.display_can_set_brightness = 1;
-			caps.display_type = HW_DISPLAY_LINE_TEXT;
-			caps.display_xres = 16;
-		}
-		else if (!strncmp(buf, "ufs910", 6)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 0;
-			caps.has_CI = 2;
-			caps.display_can_set_brightness = 1;
-			caps.display_type = HW_DISPLAY_LINE_TEXT;
-			caps.display_xres = 16;
-		}
-		else if (!strncmp(buf, "hdbox", 5)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 0;
-			caps.has_CI = 2;
-			caps.display_can_set_brightness = 1;
-			caps.display_type = HW_DISPLAY_LINE_TEXT;
-			caps.display_xres = 12;
-		}
-		else if (!strncmp(buf, "octagon1008", 11)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 0;
-			caps.has_CI = 2;
-			caps.display_can_set_brightness = 1;
-			caps.display_type = HW_DISPLAY_LINE_TEXT;
-			caps.display_xres = 8;
-		}
-		else if (!strncmp(buf, "cuberevo-mini", 14)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 0;
-			caps.has_CI = 2;
-		}
-		else if (!strncmp(buf, "cuberevo-mini2", 14)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 1;
-			caps.has_CI = 2;
-			caps.display_can_set_brightness = 1;
-			caps.display_type = HW_DISPLAY_LINE_TEXT;
-			caps.display_xres = 14;
-		}
-		else if (!strncmp(buf, "cuberevo-250hd", 4)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 1;
-			caps.has_CI = 0;
-		}
-		else if (!strncmp(buf, "cuberevo-2000hd", 15)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 0;
-			caps.has_CI = 0;
-		}
-		else if (!strncmp(buf, "cuberevo", 8)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 1;
-			caps.has_CI = 2;
-		}
-		else if (!strncmp(buf, "cuberevo-3000hd", 14)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 1;
-			caps.has_CI = 2;
-		}
-		else if (!strncmp(buf, "ipbox9900", 9)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 2;
-			caps.can_cec = 0;
-			caps.has_fan = 1;
-			caps.has_CI = 2;
-		}
-		else if (!strncmp(buf, "ipbox99", 7)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 1;
-			caps.has_CI = 0;
-		}
-		else if (!strncmp(buf, "ipbox55", 7)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 0;
-			caps.has_CI = 0;
-		}
-		else if (!strncmp(buf, "tf7700", 6)) {
-			strcpy(caps.boxvendor, "DUCKBOX");
-			strcpy(caps.boxname, buf);
-			caps.can_shutdown = 1;
-			caps.has_HDMI = 1;
-			caps.has_SCART = 1;
-			caps.can_cec = 0;
-			caps.has_fan = 0;
-			caps.has_CI = 2;
-		}
-		else {
-			strcpy(caps.boxvendor, "unknown");
-			strcpy(caps.boxname, buf);
-		}
-	}
-	else
-		strcpy(caps.boxname, "(unknown model)");
+	if (access("/dev/dvb/adapter0/video1", F_OK) != -1)
+		caps.can_pip = 1;
 
-	strcpy(caps.boxarch,caps.boxname);
+#if BOXMODEL_UFS910
+	initialized = 1;
+	strcpy(caps.boxvendor, "KATHREIN");
+	strcpy(caps.boxname, "UFS910");
+	strcpy(caps.boxarch, "STX7100");
+	caps.can_shutdown = 1;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+//	caps.has_SCART_input = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 2;
+	caps.display_can_set_brightness = 1;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.display_type = HW_DISPLAY_LINE_TEXT;
+	caps.display_xres = 16;
+#endif
+#if BOXMODEL_UFS912
+	initialized = 1;
+	strcpy(caps.boxvendor, "KATHREIN");
+	strcpy(caps.boxname, "UFS912");
+	strcpy(caps.boxarch, "STX7111");
+	caps.can_shutdown = 1;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+//	caps.has_SCART_input = 1;
+	caps.can_cec = 1;
+	caps.has_CI = 2;
+	caps.display_can_set_brightness = 1;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.display_type = HW_DISPLAY_LINE_TEXT;
+	caps.display_xres = 16;
+#endif
+#if BOXMODEL_UFS913
+	initialized = 1;
+	strcpy(caps.boxvendor, "KATHREIN");
+	strcpy(caps.boxname, "UFS913");
+	strcpy(caps.boxarch, "STX7105");
+	caps.can_shutdown = 1;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+//	caps.has_SCART_input = 1;
+	caps.can_cec = 1;
+	caps.has_CI = 2;
+	caps.display_can_set_brightness = 1;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.display_type = HW_DISPLAY_LINE_TEXT;
+	caps.display_xres = 16;
+#endif
+#if BOXMODEL_UFS922
+	initialized = 1;
+	strcpy(caps.boxvendor, "KATHREIN");
+	strcpy(caps.boxname, "UFS922");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 2;
+	caps.display_can_set_brightness = 1;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.display_type = HW_DISPLAY_LINE_TEXT;
+	caps.display_xres = 16;
+#endif
+#if BOXMODEL_ATEVIO7500
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "ATEVIO7500");
+	strcpy(caps.boxarch, "STX7105");
+	caps.can_shutdown = 1;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+//	caps.has_SCART_input = 1;
+	caps.can_cec = 1;
+	caps.has_CI = 2;
+	caps.display_can_set_brightness = 1;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.display_type = HW_DISPLAY_LINE_TEXT;
+	caps.display_xres = 12;
+#endif
+#if BOXMODEL_FORTIS_HDBOX
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "HDBOX");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+//	caps.has_SCART_input = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 2;
+	caps.display_can_set_brightness = 1;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.display_type = HW_DISPLAY_LINE_TEXT;
+	caps.display_xres = 12;
+#endif
+#if BOXMODEL_OCTAGON1008
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "OCTAGON1008");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 2;
+	caps.display_can_set_brightness = 1;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.display_type = HW_DISPLAY_LINE_TEXT;
+	caps.display_xres = 8;
+#endif
+#if BOXMODEL_CUBEREVO
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "CUBEREVO");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.display_can_set_brightness = 0;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 2;
+#endif
+#if BOXMODEL_CUBEREVO_MINI
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "CUBEREVO-MINI");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.display_can_set_brightness = 0;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 2;
+#endif
+#if BOXMODEL_CUBEREVO_MINI2
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "CUBEREVO-MINI2");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 2;
+	caps.display_can_set_brightness = 1;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.display_type = HW_DISPLAY_LINE_TEXT;
+	caps.display_xres = 14;
+#endif
+#if BOXMODEL_CUBEREVO_250HD
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "CUBEREVO-250HD");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.display_can_set_brightness = 0;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 0;
+#endif
+#if BOXMODEL_CUBEREVO_2000HD
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "CUBEREVO-2000HD");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.display_can_set_brightness = 0;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 0;
+#endif
+#if BOXMODEL_CUBEREVO_3000HD
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "CUBEREVO-3000HD");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.display_can_set_brightness = 0;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 2;
+#endif
+#if BOXMODEL_IPBOX9900
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "IPBOX9900");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.display_can_set_brightness = 0;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 2;
+	caps.can_cec = 0;
+	caps.has_CI = 2;
+#endif
+#if BOXMODEL_IPBOX99
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "IPBOX99");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.display_can_set_brightness = 0;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 0;
+#endif
+#if BOXMODEL_IPBOX55
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "IPBOX55");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.display_can_set_brightness = 0;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 0;
+#endif
+#if BOXMODEL_TF7700
+	initialized = 1;
+	strcpy(caps.boxvendor, "DUCKBOX");
+	strcpy(caps.boxname, "TF7700");
+	strcpy(caps.boxarch, "STX7109");
+	caps.can_shutdown = 1;
+	caps.display_can_set_brightness = 0;
+	caps.display_can_deepstandby = 0;
+	caps.display_has_statusline = 0;
+	caps.has_HDMI = 1;
+	caps.has_SCART = 1;
+	caps.can_cec = 0;
+	caps.has_CI = 2;
+#endif
 	return &caps;
 }
diff -Nur libstb-hal-ddt.git.orig/libduckbox/init.cpp libstb-hal-ddt.git/libduckbox/init.cpp
--- libstb-hal-ddt.git.orig/libduckbox/init.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libduckbox/init.cpp	2022-07-23 18:18:31.503773029 +0200
@@ -29,7 +29,7 @@
 		/* this is a strange hack: the drivers seem to only work correctly after
 		 * demux0 has been used once. After that, we can use demux1,2,... */
 		struct dmx_pes_filter_params p;
-		int dmx = open("/dev/dvb/adapter0/demux0", O_RDWR|O_CLOEXEC);
+		int dmx = open("/dev/dvb/adapter0/demux0", O_RDWR | O_CLOEXEC);
 		if (dmx < 0)
 			hal_info("%s: ERROR open /dev/dvb/adapter0/demux0 (%m)\n", __func__);
 		else
diff -Nur libstb-hal-ddt.git.orig/libduckbox/Makefile.am libstb-hal-ddt.git/libduckbox/Makefile.am
--- libstb-hal-ddt.git.orig/libduckbox/Makefile.am	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libduckbox/Makefile.am	2022-07-23 18:18:31.503773029 +0200
@@ -24,4 +24,4 @@
 	playback_libeplayer3.cpp \
 	record.cpp
 
-AM_CPPFLAGS += -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS
+AM_CPPFLAGS += -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS
diff -Nur libstb-hal-ddt.git.orig/libduckbox/playback_libeplayer3.cpp libstb-hal-ddt.git/libduckbox/playback_libeplayer3.cpp
--- libstb-hal-ddt.git.orig/libduckbox/playback_libeplayer3.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libduckbox/playback_libeplayer3.cpp	2022-07-23 18:18:31.543772226 +0200
@@ -54,7 +54,7 @@
 
 bool cPlayback::Start(std::string filename, std::string headers)
 {
-	return Start((char*) filename.c_str(),0,0,0,0,0, headers);
+	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers);
 }
 
 bool cPlayback::Start(char *filename, int vpid, int vtype, int apid, int ac3, int, std::string headers)
@@ -77,40 +77,53 @@
 	if ((file.find(":31339/id=") != std::string::npos) || (file.find(":10000") != std::string::npos) || (file.find(":8001/") != std::string::npos)) // for LocalTV and Entertain-TV streaming
 		no_probe = true;
 
-	if (file.substr(0, 7) == "file://") {
-		if (file.substr(file.length() - 3) ==  ".ts") {
+	if (file.substr(0, 7) == "file://")
+	{
+		if (file.substr(file.length() - 3) ==  ".ts")
+		{
 			fn_ts = file.substr(7);
 			fn_xml = file.substr(7, file.length() - 9);
 			fn_xml += "xml";
 			no_probe = true;
 		}
-	} else
+	}
+	else
 		isHTTP = true;
 
-	if (player->Open(file.c_str(), no_probe, headers)) {
-		if (pm == PLAYMODE_TS) {
+	if (player->Open(file.c_str(), no_probe, headers))
+	{
+		if (pm == PLAYMODE_TS)
+		{
 			struct stat64 s;
 			if (!stat64(file.c_str(), &s))
 				last_size = s.st_size;
 			ret = true;
 			videoDecoder->Stop(false);
 			audioDecoder->Stop();
-		} else {
+		}
+		else
+		{
 			std::vector<std::string> keys, values;
 			int selected_program = 0;
-			if (vpid || apid) {
+			if (vpid || apid)
+			{
 				;
-			} else if (GetPrograms(keys, values) && (keys.size() > 1) && ProgramSelectionCallback) {
+			}
+			else if (GetPrograms(keys, values) && (keys.size() > 1) && ProgramSelectionCallback)
+			{
 				const char *key = ProgramSelectionCallback(ProgramSelectionCallbackData, keys, values);
-				if (!key) {
+				if (!key)
+				{
 					player->Close();
 					return false;
 				}
 				selected_program = atoi(key);
-			} else if (keys.size() > 0)
+			}
+			else if (keys.size() > 0)
 				selected_program = atoi(keys[0].c_str());
 
-			if (!keys.size() || !player->SelectProgram(selected_program)) {
+			if (!keys.size() || !player->SelectProgram(selected_program))
+			{
 				if (apid)
 					SetAPid(apid);
 				if (vpid)
@@ -181,27 +194,35 @@
 
 	nPlaybackSpeed = speed;
 
-	if (speed > 1) {
+	if (speed > 1)
+	{
 		/* direction switch ? */
 		if (player->isBackWard)
 			player->FastBackward(0);
 		res = player->FastForward(speed);
-	} else if (speed < 0) {
+	}
+	else if (speed < 0)
+	{
 		/* direction switch ? */
 		if (player->isForwarding)
 			player->Continue();
 		res = player->FastBackward(speed);
-	} else if (speed == 0) {
+	}
+	else if (speed == 0)
+	{
 		/* konfetti: hmmm accessing the member isn't very proper */
 		if ((player->isForwarding) || (!player->isBackWard))
 			/* res = */ player->Pause();
 		else
 			/* res = */ player->FastForward(0);
-	} else /* speed == 1 */ {
+	}
+	else /* speed == 1 */
+	{
 		res = player->Continue();
 	}
 
-	if (init_jump > -1) {
+	if (init_jump > -1)
+	{
 		SetPosition(init_jump);
 		init_jump = -1;
 	}
@@ -252,7 +273,8 @@
 	if (!playing)
 		return false;
 
-	if (!player->isPlaying) {
+	if (!player->isPlaying)
+	{
 		hal_info("%s !!!!EOF!!!! < -1\n", __func__);
 		position = duration + 1000;
 		// duration = 0;
@@ -263,11 +285,14 @@
 	int64_t vpts = 0;
 	player->GetPts(vpts);
 
-	if(vpts <= 0) {
+	if (vpts <= 0)
+	{
 		//printf("ERROR: vpts==0");
-	} else {
+	}
+	else
+	{
 		/* len is in nanoseconds. we have 90 000 pts per second. */
-		position = vpts/90;
+		position = vpts / 90;
 	}
 
 	if (got_duration)
@@ -277,7 +302,7 @@
 
 	player->GetDuration(length);
 
-	if(length <= 0)
+	if (length <= 0)
 		duration = position + AV_TIME_BASE / 1000;
 	else
 		duration = length * 1000 / AV_TIME_BASE;
@@ -308,9 +333,11 @@
 	hal_info("%s\n", __func__);
 	unsigned int i = 0;
 
-	if (IsPlaying()) {
+	if (IsPlaying())
+	{
 		std::vector<Track> tracks = player->manager.getAudioTracks();
-		for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it) {
+		for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it)
+		{
 			pids[i] = it->pid;
 			ac3flags[i] = it->ac3flags;
 			language[i] = it->title;
@@ -326,7 +353,8 @@
 	unsigned int i = 0;
 
 	std::vector<Track> tracks = player->manager.getSubtitleTracks();
-	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it) {
+	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it)
+	{
 		pids[i] = it->pid;
 		language[i] = it->title;
 		i++;
@@ -341,7 +369,8 @@
 	unsigned int i = 0;
 
 	std::vector<Track> tracks = player->manager.getTeletextTracks();
-	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it) {
+	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it)
+	{
 		if (it->type != 2 && it->type != 5) // return subtitles only
 			continue;
 		pids[i] = it->pid;
@@ -357,7 +386,8 @@
 int cPlayback::GetFirstTeletextPid(void)
 {
 	std::vector<Track> tracks = player->manager.getTeletextTracks();
-	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end(); ++it) {
+	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end(); ++it)
+	{
 		if (it->type == 1)
 			return it->pid;
 	}
@@ -413,17 +443,20 @@
 	delete player;
 }
 
-void cPlayback::RequestAbort() {
+void cPlayback::RequestAbort()
+{
 	player->RequestAbort();
 	while (player->isPlaying)
 		usleep(100000);
 }
 
-bool cPlayback::IsPlaying() {
+bool cPlayback::IsPlaying()
+{
 	return player->isPlaying;
 }
 
-uint64_t cPlayback::GetReadCount() {
+uint64_t cPlayback::GetReadCount()
+{
 	return player->readCount;
 }
 
diff -Nur libstb-hal-ddt.git.orig/libduckbox/playback_libeplayer3.h libstb-hal-ddt.git/libduckbox/playback_libeplayer3.h
--- libstb-hal-ddt.git.orig/libduckbox/playback_libeplayer3.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libduckbox/playback_libeplayer3.h	2022-07-23 18:18:31.543772226 +0200
@@ -4,7 +4,8 @@
 #include <string>
 #include <vector>
 
-typedef enum {
+typedef enum
+{
 	PLAYMODE_TS = 0,
 	PLAYMODE_FILE
 } playmode_t;
@@ -14,7 +15,7 @@
 
 class cPlayback
 {
-	friend class CStreamInfo2;
+		friend class CStreamInfo2;
 
 	private:
 		bool enabled;
@@ -82,10 +83,10 @@
 		bool GetOffset(off64_t &offset);
 		bool IsPlaying(void) const;
 		bool IsEnabled(void) const;
-		void * GetHandle(void);
-		void * GetDmHandle(void);
+		void *GetHandle(void);
+		void *GetDmHandle(void);
 		int GetCurrPlaybackSpeed(void) const;
-		void PlaybackNotify (int  Event, void *pData, void *pTag);
+		void PlaybackNotify(int  Event, void *pData, void *pTag);
 		void DMNotify(int Event, void *pTsBuf, void *Tag);
 #endif
 };
diff -Nur libstb-hal-ddt.git.orig/libduckbox/record.cpp libstb-hal-ddt.git/libduckbox/record.cpp
--- libstb-hal-ddt.git.orig/libduckbox/record.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libduckbox/record.cpp	2022-07-23 18:18:31.543772226 +0200
@@ -134,17 +134,21 @@
 	bool found;
 	unsigned short pid;
 	hal_info("%s\n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
 	/* the first PID is the video pid, so start with the second PID... */
-	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+	{
 		found = false;
 		pid = (*i).pid;
-		for (j = 0; j < numapids; j++) {
-			if (pid == apids[j]) {
+		for (j = 0; j < numapids; j++)
+		{
+			if (pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -152,10 +156,13 @@
 		if (!found)
 			dmx->removePid(pid);
 	}
-	for (j = 0; j < numapids; j++) {
+	for (j = 0; j < numapids; j++)
+	{
 		found = false;
-		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
-			if ((*i).pid == apids[j]) {
+		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+		{
+			if ((*i).pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -170,12 +177,14 @@
 {
 	std::vector<pes_pids> pids;
 	hal_info("%s: \n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
-	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i)
+	{
 		if ((*i).pid == pid)
 			return true; /* or is it an error to try to add the same PID twice? */
 	}
@@ -187,14 +196,16 @@
 	char threadname[17];
 	strncpy(threadname, "WriterThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	unsigned int chunk = 0;
-	while (!sem_wait(&sem)) {
+	while (!sem_wait(&sem))
+	{
 		if (!io_len[chunk]) // empty, assume end of recording
 			return;
 		unsigned char *p_buf = io_buf[chunk];
 		size_t p_len = io_len[chunk];
-		while (p_len) {
+		while (p_len)
+		{
 			ssize_t written = write(file_fd, p_buf, p_len);
 			if (written < 0)
 				break;
@@ -214,7 +225,7 @@
 	char threadname[17];
 	strncpy(threadname, "RecordThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	int readsize = bufsize / 16;
 	int buf_pos = 0;
 	int count = 0;
@@ -235,7 +246,7 @@
 	}
 
 	int val = fcntl(file_fd, F_GETFL);
-	if (fcntl(file_fd, F_SETFL, val|O_APPEND))
+	if (fcntl(file_fd, F_SETFL, val | O_APPEND))
 		hal_info("%s: O_APPEND? (%m)\n", __func__);
 
 	memset(&a, 0, sizeof(a));
@@ -250,7 +261,8 @@
 	{
 		if (buf_pos < bufsize)
 		{
-			if (overflow_count) {
+			if (overflow_count)
+			{
 				hal_info("%s: Overflow cleared after %d iterations\n", __func__, overflow_count);
 				overflow_count = 0;
 			}
@@ -259,7 +271,7 @@
 				toread = readsize;
 			ssize_t s = dmx->Read(buf + buf_pos, toread, 50);
 			hal_debug("%s: buf_pos %6d s %6d / %6d\n", __func__,
-				buf_pos, (int)s, bufsize - buf_pos);
+			    buf_pos, (int)s, bufsize - buf_pos);
 			if (s < 0)
 			{
 				if (errno != EAGAIN && (errno != EOVERFLOW || !overflow))
@@ -362,9 +374,9 @@
 	eventServer.registerEvent2(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, "/tmp/neutrino.sock");
 	stream2file_status2_t s;
 	s.status = exit_flag;
-	strncpy(s.filename,basename(myfilename),512);
+	strncpy(s.filename, basename(myfilename), 512);
 	s.filename[511] = '\0';
-	strncpy(s.dir,dirname(myfilename),100);
+	strncpy(s.dir, dirname(myfilename), 100);
 	s.dir[99] = '\0';
 	eventServer.sendEvent(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, &s, sizeof(s));
 	printf("[stream2file]: pthreads exit code: %i, dir: '%s', filename: '%s' myfilename: '%s'\n", exit_flag, s.dir, s.filename, myfilename);
diff -Nur libstb-hal-ddt.git.orig/libduckbox/record_lib.h libstb-hal-ddt.git/libduckbox/record_lib.h
--- libstb-hal-ddt.git.orig/libduckbox/record_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libduckbox/record_lib.h	2022-07-23 18:18:31.543772226 +0200
@@ -9,13 +9,14 @@
 #define REC_STATUS_OVERFLOW 2
 #define REC_STATUS_STOPPED 4
 
-typedef enum {
+typedef enum
+{
 	RECORD_RUNNING,
 	RECORD_STOPPED,
-	RECORD_FAILED_READ,	/* failed to read from DMX */
-	RECORD_FAILED_OVERFLOW,	/* cannot write fast enough */
-	RECORD_FAILED_FILE,	/* cannot write to file */
-	RECORD_FAILED_MEMORY	/* out of memory */
+	RECORD_FAILED_READ, /* failed to read from DMX */
+	RECORD_FAILED_OVERFLOW, /* cannot write fast enough */
+	RECORD_FAILED_FILE, /* cannot write to file */
+	RECORD_FAILED_MEMORY    /* out of memory */
 } record_state_t;
 
 class cRecord
@@ -38,8 +39,12 @@
 		unsigned char *io_buf[RECORD_WRITER_CHUNKS];
 		size_t io_len[RECORD_WRITER_CHUNKS];
 	public:
-		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024); 
-		void setFailureCallback(void (*f)(void *), void *d) { failureCallback = f; failureData = d; }
+		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024);
+		void setFailureCallback(void (*f)(void *), void *d)
+		{
+			failureCallback = f;
+			failureData = d;
+		}
 		~cRecord();
 
 		bool Open();
diff -Nur libstb-hal-ddt.git.orig/libduckbox/video.cpp libstb-hal-ddt.git/libduckbox/video.cpp
--- libstb-hal-ddt.git.orig/libduckbox/video.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libduckbox/video.cpp	2022-07-23 18:18:31.543772226 +0200
@@ -39,6 +39,7 @@
 #include "video_lib.h"
 #include "hal_debug.h"
 
+#include <hardware_caps.h>
 #include <proc_tools.h>
 
 extern "C"
@@ -53,70 +54,104 @@
 #define hal_debug_c(args...) _hal_debug(HAL_DEBUG_VIDEO, NULL, args)
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_VIDEO, NULL, args)
 
-#define fop(cmd, args...) ({				\
-	int _r;						\
-	if (fd >= 0) { 					\
-		if ((_r = ::cmd(fd, args)) < 0)		\
-			hal_info(#cmd"(fd, "#args")\n");	\
-		else					\
-			hal_debug(#cmd"(fd, "#args")\n");\
-	}						\
-	else { _r = fd; } 				\
-	_r;						\
+#define fop(cmd, args...) ({                \
+    int _r;                     \
+    if (fd >= 0) {                  \
+        if ((_r = ::cmd(fd, args)) < 0)     \
+            hal_info(#cmd"(fd, "#args")\n");    \
+        else                    \
+            hal_debug(#cmd"(fd, "#args")\n");\
+    }                       \
+    else { _r = fd; }               \
+    _r;                     \
 })
 
-cVideo * videoDecoder = NULL;
-cVideo * pipDecoder = NULL;
+enum
+{
+	ENCODER,
+	AUX
+};
+
+cVideo *videoDecoder = NULL;
+cVideo *pipVideoDecoder[3] = { NULL, NULL, NULL };
 
 int system_rev = 0;
 
 static bool hdmi_enabled = true;
 static bool stillpicture = false;
 
-static const char *VDEV[] = {
+static const char *VDEV[] =
+{
 	"/dev/dvb/adapter0/video0",
-	"/dev/dvb/adapter0/video1"
+	"/dev/dvb/adapter0/video1",
+	"/dev/dvb/adapter0/video2",
+	"/dev/dvb/adapter0/video3"
 };
-static const char *VMPEG_aspect[] = {
+static const char *VMPEG_aspect[] =
+{
 	"/proc/stb/vmpeg/0/aspect",
-	"/proc/stb/vmpeg/1/aspect"
+	"/proc/stb/vmpeg/1/aspect",
+	"/proc/stb/vmpeg/2/aspect",
+	"/proc/stb/vmpeg/3/aspect"
 };
 
-static const char *VMPEG_xres[] = {
+static const char *VMPEG_xres[] =
+{
 	"/proc/stb/vmpeg/0/xres",
-	"/proc/stb/vmpeg/1/xres"
+	"/proc/stb/vmpeg/1/xres",
+	"/proc/stb/vmpeg/2/xres",
+	"/proc/stb/vmpeg/3/xres"
 };
 
-static const char *VMPEG_yres[] = {
+static const char *VMPEG_yres[] =
+{
 	"/proc/stb/vmpeg/0/yres",
-	"/proc/stb/vmpeg/1/yres"
+	"/proc/stb/vmpeg/1/yres",
+	"/proc/stb/vmpeg/2/yres",
+	"/proc/stb/vmpeg/3/yres"
 };
 
-static const char *VMPEG_dst_all[] = {
+static const char *VMPEG_dst_all[] =
+{
 	"/proc/stb/vmpeg/0/dst_all",
-	"/proc/stb/vmpeg/1/dst_all"
+	"/proc/stb/vmpeg/1/dst_all",
+	"/proc/stb/vmpeg/2/dst_all",
+	"/proc/stb/vmpeg/3/dst_all"
 };
 
-static const char *VMPEG_framerate[] = {
+static const char *VMPEG_framerate[] =
+{
 	"/proc/stb/vmpeg/0/framerate",
-	"/proc/stb/vmpeg/1/framerate"
+	"/proc/stb/vmpeg/1/framerate",
+	"/proc/stb/vmpeg/2/framerate",
+	"/proc/stb/vmpeg/3/framerate"
 };
 
-static const char *vid_modes[] = {
-	"pal",		// VIDEO_STD_NTSC
-	"pal",		// VIDEO_STD_SECAM
-	"pal",		// VIDEO_STD_PAL
-	"480p",		// VIDEO_STD_480P
-	"576p50",	// VIDEO_STD_576P
-	"720p60",	// VIDEO_STD_720P60
-	"1080i60",	// VIDEO_STD_1080I60
-	"720p50",	// VIDEO_STD_720P50
-	"1080i50",	// VIDEO_STD_1080I50
-	"1080p30",	// VIDEO_STD_1080P30
-	"1080p24",	// VIDEO_STD_1080P24
-	"1080p25",	// VIDEO_STD_1080P25
-	"720p50",	// VIDEO_STD_AUTO -> not implemented
-	"1080p50",	// VIDEO_STD_1080P50 -> SPARK only
+static const char *VMPEG_visible[] =
+{
+	"/proc/stb/vmpeg/0/visible",
+	"/proc/stb/vmpeg/1/visible",
+	"/proc/stb/vmpeg/2/visible",
+	"/proc/stb/vmpeg/3/visible"
+};
+
+
+static const char *vid_modes[] =
+{
+	"pal",      // VIDEO_STD_NTSC
+	"pal",      // VIDEO_STD_SECAM
+	"pal",      // VIDEO_STD_PAL
+	"480p",     // VIDEO_STD_480P
+	"576p50",   // VIDEO_STD_576P
+	"720p60",   // VIDEO_STD_720P60
+	"1080i60",  // VIDEO_STD_1080I60
+	"720p50",   // VIDEO_STD_720P50
+	"1080i50",  // VIDEO_STD_1080I50
+	"1080p30",  // VIDEO_STD_1080P30
+	"1080p24",  // VIDEO_STD_1080P24
+	"1080p25",  // VIDEO_STD_1080P25
+	"720p50",   // VIDEO_STD_AUTO -> not implemented
+	"1080p50",  // VIDEO_STD_1080P50 -> SPARK only
 	NULL
 };
 
@@ -164,49 +199,61 @@
 }
 
 
-void init_parameters(AVFrame* in_frame, AVCodecContext *codec_context)
+void init_parameters(AVFrame *in_frame, AVCodecContext *codec_context)
 {
 	/* put sample parameters */
 	codec_context->bit_rate = 400000;
 	/* resolution must be a multiple of two */
-	codec_context->width = (in_frame->width/2)*2;
-	codec_context->height = (in_frame->height/2)*2;
+	codec_context->width = (in_frame->width / 2) * 2;
+	codec_context->height = (in_frame->height / 2) * 2;
 	/* frames per second */
-	codec_context->time_base = (AVRational ) { 1, 60 };
+	codec_context->time_base = (AVRational)
+	{
+		1, 60
+	};
 	codec_context->gop_size = 10; /* emit one intra frame every ten frames */
 	codec_context->max_b_frames = 1;
 	codec_context->pix_fmt = AV_PIX_FMT_YUV420P;
 }
 
-void write_frame(AVFrame* in_frame, FILE* fp)
+void write_frame(AVFrame *in_frame, FILE *fp)
 {
-	if(in_frame == NULL || fp == NULL)
+	if (in_frame == NULL || fp == NULL)
 		return;
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
 	AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MPEG2VIDEO);
+#else
+	const AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MPEG2VIDEO);
+#endif
 	if (codec)
 	{
 		AVCodecContext *codec_context = avcodec_alloc_context3(codec);
 		if (codec_context)
 		{
 			init_parameters(in_frame, codec_context);
-			if (avcodec_open2(codec_context, codec, 0) != -1) {
+			if (avcodec_open2(codec_context, codec, 0) != -1)
+			{
 				AVPacket pkt;
 				av_init_packet(&pkt);
 				/* encode the image */
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 				int got_output = 0;
 				int ret = avcodec_encode_video2(codec_context, &pkt, in_frame, &got_output);
-				if (ret != -1) {
-					if (got_output) {
+				if (ret != -1)
+				{
+					if (got_output)
+					{
 						fwrite(pkt.data, 1, pkt.size, fp);
 						av_packet_unref(&pkt);
 					}
 					int i = 1;
-					for (got_output = 1; got_output; i++) {
-					/* get the delayed frames */
+					for (got_output = 1; got_output; i++)
+					{
+						/* get the delayed frames */
 						in_frame->pts = i;
 						ret = avcodec_encode_video2(codec_context, &pkt, 0, &got_output);
-						if (ret != -1 && got_output) {
+						if (ret != -1 && got_output)
+						{
 							fwrite(pkt.data, 1, pkt.size, fp);
 							av_packet_unref(&pkt);
 						}
@@ -214,16 +261,19 @@
 				}
 #else
 				int ret = avcodec_send_frame(codec_context, in_frame);
-				if (!ret) {
+				if (!ret)
+				{
 					/* signalling end of stream */
 					ret = avcodec_send_frame(codec_context, NULL);
 				}
-				if (!ret) {
+				if (!ret)
+				{
 					int i = 1;
 					/* get the delayed frames */
 					in_frame->pts = i;
 					ret = avcodec_receive_packet(codec_context, &pkt);
-					if (!ret) {
+					if (!ret)
+					{
 						fwrite(pkt.data, 1, pkt.size, fp);
 						av_packet_unref(&pkt);
 					}
@@ -236,13 +286,15 @@
 	}
 }
 
-int decode_frame(AVCodecContext *codecContext,AVPacket &packet, FILE* fp)
+int decode_frame(AVCodecContext *codecContext, AVPacket &packet, FILE *fp)
 {
 	AVFrame *frame = av_frame_alloc();
-	if(frame){
+	if (frame)
+	{
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 		int decode_ok = 0;
-		if ((avcodec_decode_video2(codecContext, frame, &decode_ok, &packet)) < 0 || !decode_ok){
+		if ((avcodec_decode_video2(codecContext, frame, &decode_ok, &packet)) < 0 || !decode_ok)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
@@ -251,25 +303,29 @@
 		ret = avcodec_send_packet(codecContext, &packet);
 		// In particular, we don't expect AVERROR(EAGAIN), because we read all
 		// decoded frames with avcodec_receive_frame() until done.
-		if (ret < 0) {
+		if (ret < 0)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
 		ret = avcodec_receive_frame(codecContext, frame);
-		if (ret < 0) {
+		if (ret < 0)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
 #endif
 		AVFrame *dest_frame = av_frame_alloc();
-		if(dest_frame){
-			dest_frame->height = (frame->height/2)*2;
-			dest_frame->width = (frame->width/2)*2;
+		if (dest_frame)
+		{
+			dest_frame->height = (frame->height / 2) * 2;
+			dest_frame->width = (frame->width / 2) * 2;
 			dest_frame->format = AV_PIX_FMT_YUV420P;
 			av_frame_get_buffer(dest_frame, 32);
 			struct SwsContext *convert = NULL;
 			convert = sws_getContext(frame->width, frame->height, (AVPixelFormat)frame->format, dest_frame->width, dest_frame->height, AV_PIX_FMT_YUVJ420P, SWS_FAST_BILINEAR, NULL, NULL, NULL);
-			if(convert){
+			if (convert)
+			{
 				sws_scale(convert, frame->data, frame->linesize, 0, frame->height, dest_frame->data, dest_frame->linesize);
 				sws_freeContext(convert);
 			}
@@ -282,19 +338,27 @@
 
 }
 
-AVCodecContext* open_codec(AVMediaType mediaType, AVFormatContext* formatContext)
+AVCodecContext *open_codec(AVMediaType mediaType, AVFormatContext *formatContext)
 {
-	AVCodec * codec = NULL;
-	AVCodecContext * codecContext = NULL;
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
+	AVCodec *codec = NULL;
+#else
+	const AVCodec *codec = NULL;
+#endif
+	AVCodecContext *codecContext = NULL;
 	int stream_index;
-#if (LIBAVFORMAT_VERSION_INT < AV_VERSION_INT( 57,25,101 ))
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(57,25,101)
 	stream_index = av_find_best_stream(formatContext, mediaType, -1, -1, NULL, 0);
-	if (stream_index >=0 ){
+	if (stream_index >= 0)
+	{
 		codecContext = formatContext->streams[stream_index]->codec;
-		if(codecContext){
+		if (codecContext)
+		{
 			codec = avcodec_find_decoder(codecContext->codec_id);
-			if(codec){
-				if ((avcodec_open2(codecContext, codec, NULL)) != 0){
+			if (codec)
+			{
+				if ((avcodec_open2(codecContext, codec, NULL)) != 0)
+				{
 					return NULL;
 				}
 			}
@@ -304,13 +368,17 @@
 	return NULL;
 #else
 	stream_index = av_find_best_stream(formatContext, mediaType, -1, -1, &codec, 0);
-	if (stream_index >= 0) {
+	if (stream_index >= 0)
+	{
 		codec = avcodec_find_decoder(formatContext->streams[stream_index]->codecpar->codec_id);
-		if (codec) {
+		if (codec)
+		{
 			codecContext = avcodec_alloc_context3(codec);
 		}
-		if (codecContext) {
-			if ((avcodec_open2(codecContext, codec, NULL)) != 0) {
+		if (codecContext)
+		{
+			if ((avcodec_open2(codecContext, codec, NULL)) != 0)
+			{
 				return NULL;
 			}
 			return codecContext;
@@ -329,15 +397,20 @@
 #endif
 
 	AVFormatContext *formatContext = avformat_alloc_context();
-	if (formatContext && (ret = avformat_open_input(&formatContext, image_name, NULL, NULL)) == 0){
+	if (formatContext && (ret = avformat_open_input(&formatContext, image_name, NULL, NULL)) == 0)
+	{
 		AVCodecContext *codecContext = open_codec(AVMEDIA_TYPE_VIDEO, formatContext);
-		if(codecContext){
+		if (codecContext)
+		{
 			AVPacket packet;
 			av_init_packet(&packet);
-			if ((ret = av_read_frame(formatContext, &packet)) !=-1){
-				FILE* fp = fopen(encode_name, "wb");
-				if(fp){
-					if(decode_frame(codecContext, packet, fp) != 1){
+			if ((ret = av_read_frame(formatContext, &packet)) != -1)
+			{
+				FILE *fp = fopen(encode_name, "wb");
+				if (fp)
+				{
+					if (decode_frame(codecContext, packet, fp) != 1)
+					{
 						/* add sequence end code to have a real mpeg file */
 						uint8_t endcode[] = { 0, 0, 1, 0xb7 };
 						fwrite(endcode, 1, sizeof(endcode), fp);
@@ -347,7 +420,7 @@
 				av_packet_unref(&packet);
 			}
 			avcodec_close(codecContext);
-#if (LIBAVFORMAT_VERSION_INT > AV_VERSION_INT( 57,25,100 ))
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57,25,100)
 			avcodec_free_context(&codecContext);
 #endif
 		}
@@ -357,6 +430,20 @@
 	return 0;
 }
 
+void cVideo::setAVInput(int val)
+{
+	hal_info("%s not implemented yet - switching to: %s\n", __func__, val == AUX ? "SCART" : "ENCODER");
+#if 0 // not working
+	int input_fd = open("/proc/stb/avs/0/input", O_WRONLY);
+	if (input_fd)
+	{
+		const char *input[] = {"encoder", "scart"};
+		write(input_fd, input[val], strlen(input[val]));
+		close(input_fd);
+	}
+#endif
+}
+
 cVideo::cVideo(int, void *, void *, unsigned int unit)
 {
 	hal_debug("%s unit %u\n", __func__, unit);
@@ -368,10 +455,12 @@
 
 	scartvoltage = -1;
 	video_standby = 0;
-	if (unit > 1) {
+	if (unit > 1)
+	{
 		hal_info("%s: unit %d out of range, setting to 0\n", __func__, unit);
 		devnum = 0;
-	} else
+	}
+	else
 		devnum = unit;
 	fd = -1;
 	openDevice();
@@ -390,7 +479,7 @@
 	if (fd != -1) /* already open */
 		return;
 retry:
-	if ((fd = open(VDEV[devnum], O_RDWR|O_CLOEXEC)) < 0)
+	if ((fd = open(VDEV[devnum], O_RDWR | O_CLOEXEC)) < 0)
 	{
 		if (errno == EBUSY)
 		{
@@ -417,11 +506,11 @@
 
 int cVideo::setAspectRatio(int aspect, int mode)
 {
-	static const char *a[] = { "n/a", "4:3", "14:9", "16:9" };
+	static const char *a[] = { "n/a", "4:3", "16:9" };
 	static const char *m[] = { "panscan", "letterbox", "bestfit", "nonlinear", "(unset)" };
 	int n;
 
-	int mo = (mode < 0||mode > 3) ? 4 : mode;
+	int mo = (mode < 0 || mode > 3) ? 4 : mode;
 	hal_debug("%s: a:%d m:%d  %s\n", __func__, aspect, mode, m[mo]);
 
 	if (aspect > 3 || aspect == 0)
@@ -488,7 +577,8 @@
 		fop(ioctl, MPEG_VID_CONTINUE);
 #endif
 	/* implicitly do StopPicture() on video->Start() */
-	if (stillpicture) {
+	if (stillpicture)
+	{
 		hal_info("%s: stillpicture == true, doing implicit StopPicture()\n", __func__);
 		stillpicture = false;
 		Stop(1);
@@ -496,19 +586,23 @@
 	playstate = VIDEO_PLAYING;
 	fop(ioctl, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
 	int res = fop(ioctl, VIDEO_PLAY);
-	if (brightness > -1) {
+	if (brightness > -1)
+	{
 		SetControl(VIDEO_CONTROL_BRIGHTNESS, brightness);
 		brightness = -1;
 	}
-	if (contrast > -1) {
+	if (contrast > -1)
+	{
 		SetControl(VIDEO_CONTROL_CONTRAST, contrast);
 		contrast = -1;
 	}
-	if (saturation > -1) {
+	if (saturation > -1)
+	{
 		SetControl(VIDEO_CONTROL_SATURATION, saturation);
 		saturation = -1;
 	}
-	if (hue > -1) {
+	if (hue > -1)
+	{
 		SetControl(VIDEO_CONTROL_HUE, hue);
 		hue = -1;
 	}
@@ -561,7 +655,7 @@
 		stopped = true;
 	}
 	hdmi_out(false);
-	ret = proc_put("/proc/stb/video/videomode", vid_modes[video_system],strlen(vid_modes[video_system]));
+	ret = proc_put("/proc/stb/video/videomode", vid_modes[video_system], strlen(vid_modes[video_system]));
 	hdmi_out(true);
 	if (stopped)
 		Start();
@@ -586,10 +680,12 @@
 {
 	if (system == -1)
 		system = GetVideoSystem();
-	if (system < 0 || system > VIDEO_STD_1080P50) {
+	if (system < 0 || system > VIDEO_STD_1080P50)
+	{
 		hal_info("%s: invalid system %d\n", __func__, system);
 		strcpy(format->format, "invalid");
-	} else
+	}
+	else
 		strcpy(format->format, vid_modes[system]);
 }
 
@@ -598,33 +694,9 @@
 	return playstate;
 }
 
-void cVideo::SetVideoMode(analog_mode_t mode)
-{
-	hal_debug("#%d: %s(%d)\n", devnum, __func__, mode);
-	if (!(mode & ANALOG_SCART_MASK))
-	{
-		hal_debug("%s: non-SCART mode ignored\n", __func__);
-		return;
-	}
-	const char *m;
-	switch(mode)
-	{
-		case ANALOG_SD_YPRPB_SCART:
-			m = "yuv";
-			break;
-		case ANALOG_SD_RGB_SCART:
-			m = "rgb";
-			break;
-		default:
-			hal_info("%s unknown mode %d\n", __func__, mode);
-			m = "rgb";
-			break; /* default to rgb */
-	}
-	proc_put("/proc/stb/avs/0/colorformat", m, strlen(m));
-}
-
-void cVideo::ShowPicture(const char * fname, const char *_destname)
+bool cVideo::ShowPicture(const char *fname, const char *_destname)
 {
+	bool ret = false;
 	hal_debug("%s(%s)\n", __func__, fname);
 	//static const unsigned char pes_header[] = { 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x80, 0x00, 0x00 };
 	static const unsigned char pes_header[] = {0x0, 0x0, 0x1, 0xe0, 0x00, 0x00, 0x80, 0x80, 0x5, 0x21, 0x0, 0x1, 0x0, 0x1};
@@ -637,20 +709,29 @@
 	{
 		/* does not work and the driver does not seem to like it */
 		hal_info("%s: video_standby == true\n", __func__);
-		return;
+		return ret;
+	}
+	if (fd == -1)
+	{
+		/* in movieplayer mode, fd is not opened */
+		hal_info("%s: decoder not opened\n", __func__);
+		return ret;
 	}
+
 	const char *lastDot = strrchr(fname, '.');
 	if (lastDot && !strcasecmp(lastDot + 1, "m2v"))
 		strncpy(destname, fname, sizeof(destname));
-	else {
+	else
+	{
 		if (_destname)
 			strncpy(destname, _destname, sizeof(destname));
-		else {
+		else
+		{
 			strcpy(destname, "/tmp/cache");
 			if (stat(fname, &st2))
 			{
 				hal_info("%s: could not stat %s (%m)\n", __func__, fname);
-				return;
+				return ret;
 			}
 			mkdir(destname, 0755);
 			/* the cache filename is (example for /share/tuxbox/neutrino/icons/radiomode.jpg):
@@ -660,7 +741,7 @@
 			strcat(destname, fname);
 			p = &destname[strlen("/tmp/cache/")];
 			while ((p = strchr(p, '/')) != NULL)
-				*p = '.';
+				* p = '.';
 			strcat(destname, ".m2v");
 		}
 		/* ...then check if it exists already... */
@@ -692,7 +773,7 @@
 		if (ioctl(fd, VIDEO_SET_FORMAT, VIDEO_FORMAT_16_9) < 0)
 			hal_info("%s: VIDEO_SET_FORMAT failed (%m)\n", __func__);
 		bool seq_end_avail = false;
-		off_t pos=0;
+		off_t pos = 0;
 		unsigned char *iframe = (unsigned char *)malloc((st.st_size < 8192) ? 8192 : st.st_size);
 		if (! iframe)
 		{
@@ -704,7 +785,7 @@
 		ioctl(fd, VIDEO_PLAY);
 		ioctl(fd, VIDEO_CONTINUE);
 		ioctl(fd, VIDEO_CLEAR_BUFFER);
-		while (pos <= (st.st_size-4) && !(seq_end_avail = (!iframe[pos] && !iframe[pos+1] && iframe[pos+2] == 1 && iframe[pos+3] == 0xB7)))
+		while (pos <= (st.st_size - 4) && !(seq_end_avail = (!iframe[pos] && !iframe[pos + 1] && iframe[pos + 2] == 1 && iframe[pos + 3] == 0xB7)))
 			++pos;
 
 		if ((iframe[3] >> 4) != 0xE) // no pes header
@@ -716,10 +797,11 @@
 		write(fd, iframe, 8192);
 		ioctl(fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
 		free(iframe);
+		ret = true;
 	}
- out:
+out:
 	close(mfd);
-	return;
+	return ret;
 }
 
 void cVideo::StopPicture()
@@ -741,7 +823,7 @@
 	{
 		/* only enable HDMI output when coming from standby, not on
 		 * start. I have no idea why, but enabling it on startup leads
-		 * to strange locking problems of the framebuffer driver :-( */
+		 * to strange locking problems of the framebuffer driver :-(*/
 		if (!hdmi_enabled)
 		{
 			hdmi_out(true);
@@ -804,6 +886,13 @@
 #endif
 }
 
+void cVideo::ShowPig(int _x)
+{
+	char buffer[64];
+	sprintf(buffer, "%d", _x);
+	proc_put(VMPEG_visible[devnum], buffer, strlen(buffer));
+}
+
 void cVideo::Pig(int x, int y, int w, int h, int osd_w, int osd_h, int startx, int starty, int endx, int endy)
 {
 	char buffer[64];
@@ -911,7 +1000,8 @@
 
 int cVideo::SetStreamType(VIDEO_FORMAT type)
 {
-	static const char *VF[] = {
+	static const char *VF[] =
+	{
 		"VIDEO_FORMAT_MPEG2",
 		"VIDEO_FORMAT_MPEG4",
 		"VIDEO_FORMAT_VC1",
@@ -960,27 +1050,30 @@
 	hal_debug("#%d %s not implemented yet\n", devnum, __func__);
 }
 
-void cVideo::SetControl(int control, int value) {
+void cVideo::SetControl(int control, int value)
+{
 	const char *p = NULL;
-	switch (control) {
-	case VIDEO_CONTROL_BRIGHTNESS:
-		brightness = value;
-		p = "/proc/stb/video/plane/psi_brightness";
-		break;
-	case VIDEO_CONTROL_CONTRAST:
-		contrast = value;
-		p = "/proc/stb/video/plane/psi_contrast";
-		break;
-	case VIDEO_CONTROL_SATURATION:
-		saturation = value;
-		p = "/proc/stb/video/plane/psi_saturation";
-		break;
-	case VIDEO_CONTROL_HUE:
-		hue = value;
-		p = "/proc/stb/video/plane/psi_tint";
-		break;
+	switch (control)
+	{
+		case VIDEO_CONTROL_BRIGHTNESS:
+			brightness = value;
+			p = "/proc/stb/video/plane/psi_brightness";
+			break;
+		case VIDEO_CONTROL_CONTRAST:
+			contrast = value;
+			p = "/proc/stb/video/plane/psi_contrast";
+			break;
+		case VIDEO_CONTROL_SATURATION:
+			saturation = value;
+			p = "/proc/stb/video/plane/psi_saturation";
+			break;
+		case VIDEO_CONTROL_HUE:
+			hue = value;
+			p = "/proc/stb/video/plane/psi_tint";
+			break;
 	}
-	if (p) {
+	if (p)
+	{
 		char buf[20];
 		int len = snprintf(buf, sizeof(buf), "%d", value);
 		if (len < (int) sizeof(buf))
@@ -988,30 +1081,32 @@
 	}
 }
 
-void cVideo::SetColorFormat(COLOR_FORMAT color_format) {
+void cVideo::SetColorFormat(COLOR_FORMAT color_format)
+{
 	const char *p = NULL;
-	switch(color_format) {
-	case COLORFORMAT_RGB:
-		p = "rgb";
-		break;
-	case COLORFORMAT_YUV:
-		p = "yuv";
-		break;
-	case COLORFORMAT_CVBS:
-		p = "cvbs";
-		break;
-	case COLORFORMAT_SVIDEO:
-		p = "svideo";
-		break;
-	case COLORFORMAT_HDMI_RGB:
-		p = "hdmi_rgb";
-		break;
-	case COLORFORMAT_HDMI_YCBCR444:
-		p = "hdmi_yuv";
-		break;
-	case COLORFORMAT_HDMI_YCBCR422:
-		p = "hdmi_422";
-		break;
+	switch (color_format)
+	{
+		case COLORFORMAT_RGB:
+			p = "rgb";
+			break;
+		case COLORFORMAT_YUV:
+			p = "yuv";
+			break;
+		case COLORFORMAT_CVBS:
+			p = "cvbs";
+			break;
+		case COLORFORMAT_SVIDEO:
+			p = "svideo";
+			break;
+		case COLORFORMAT_HDMI_RGB:
+			p = "hdmi_rgb";
+			break;
+		case COLORFORMAT_HDMI_YCBCR444:
+			p = "hdmi_yuv";
+			break;
+		case COLORFORMAT_HDMI_YCBCR422:
+			p = "hdmi_422";
+			break;
 	}
 	if (p)
 		proc_put("/proc/stb/avs/0/colorformat", p, strlen(p));
@@ -1023,7 +1118,8 @@
  * and the patches for STi support from
  * https://github.com/Schischu/STLinux.BSP-Duckbox.git */
 /* static lookup tables for faster yuv2rgb conversion */
-static const uint32_t yuv2rgbtable_y[256] = {
+static const uint32_t yuv2rgbtable_y[256] =
+{
 	0xFFED5EA0, 0xFFEE88B6, 0xFFEFB2CC, 0xFFF0DCE2, 0xFFF206F8, 0xFFF3310E, 0xFFF45B24, 0xFFF5853A,
 	0xFFF6AF50, 0xFFF7D966, 0xFFF9037C, 0xFFFA2D92, 0xFFFB57A8, 0xFFFC81BE, 0xFFFDABD4, 0xFFFED5EA,
 	0x00000000, 0x00012A16, 0x0002542C, 0x00037E42, 0x0004A858, 0x0005D26E, 0x0006FC84, 0x0008269A,
@@ -1057,7 +1153,8 @@
 	0x0104D340, 0x0105FD56, 0x0107276C, 0x01085182, 0x01097B98, 0x010AA5AE, 0x010BCFC4, 0x010CF9DA,
 	0x010E23F0, 0x010F4E06, 0x0110781C, 0x0111A232, 0x0112CC48, 0x0113F65E, 0x01152074, 0x01164A8A
 };
-static const uint32_t yuv2rgbtable_ru[256] = {
+static const uint32_t yuv2rgbtable_ru[256] =
+{
 	0xFEFDA500, 0xFEFFA9B6, 0xFF01AE6C, 0xFF03B322, 0xFF05B7D8, 0xFF07BC8E, 0xFF09C144, 0xFF0BC5FA,
 	0xFF0DCAB0, 0xFF0FCF66, 0xFF11D41C, 0xFF13D8D2, 0xFF15DD88, 0xFF17E23E, 0xFF19E6F4, 0xFF1BEBAA,
 	0xFF1DF060, 0xFF1FF516, 0xFF21F9CC, 0xFF23FE82, 0xFF260338, 0xFF2807EE, 0xFF2A0CA4, 0xFF2C115A,
@@ -1091,7 +1188,8 @@
 	0x00E20FA0, 0x00E41456, 0x00E6190C, 0x00E81DC2, 0x00EA2278, 0x00EC272E, 0x00EE2BE4, 0x00F0309A,
 	0x00F23550, 0x00F43A06, 0x00F63EBC, 0x00F84372, 0x00FA4828, 0x00FC4CDE, 0x00FE5194, 0x00100564A
 };
-static const uint32_t yuv2rgbtable_gu[256] = {
+static const uint32_t yuv2rgbtable_gu[256] =
+{
 	0xFFCDD300, 0xFFCE375A, 0xFFCE9BB4, 0xFFCF000E, 0xFFCF6468, 0xFFCFC8C2, 0xFFD02D1C, 0xFFD09176,
 	0xFFD0F5D0, 0xFFD15A2A, 0xFFD1BE84, 0xFFD222DE, 0xFFD28738, 0xFFD2EB92, 0xFFD34FEC, 0xFFD3B446,
 	0xFFD418A0, 0xFFD47CFA, 0xFFD4E154, 0xFFD545AE, 0xFFD5AA08, 0xFFD60E62, 0xFFD672BC, 0xFFD6D716,
@@ -1125,7 +1223,8 @@
 	0x002BE760, 0x002C4BBA, 0x002CB014, 0x002D146E, 0x002D78C8, 0x002DDD22, 0x002E417C, 0x002EA5D6,
 	0x002F0A30, 0x002F6E8A, 0x002FD2E4, 0x0030373E, 0x00309B98, 0x0030FFF2, 0x0031644C, 0x0031C8A6
 };
-static const uint32_t yuv2rgbtable_gv[256] = {
+static const uint32_t yuv2rgbtable_gv[256] =
+{
 	0xFF97E900, 0xFF98B92E, 0xFF99895C, 0xFF9A598A, 0xFF9B29B8, 0xFF9BF9E6, 0xFF9CCA14, 0xFF9D9A42,
 	0xFF9E6A70, 0xFF9F3A9E, 0xFFA00ACC, 0xFFA0DAFA, 0xFFA1AB28, 0xFFA27B56, 0xFFA34B84, 0xFFA41BB2,
 	0xFFA4EBE0, 0xFFA5BC0E, 0xFFA68C3C, 0xFFA75C6A, 0xFFA82C98, 0xFFA8FCC6, 0xFFA9CCF4, 0xFFAA9D22,
@@ -1159,7 +1258,8 @@
 	0x005B1420, 0x005BE44E, 0x005CB47C, 0x005D84AA, 0x005E54D8, 0x005F2506, 0x005FF534, 0x0060C562,
 	0x00619590, 0x006265BE, 0x006335EC, 0x0064061A, 0x0064D648, 0x0065A676, 0x006676A4, 0x006746D2
 };
-static const uint32_t yuv2rgbtable_bv[256] = {
+static const uint32_t yuv2rgbtable_bv[256] =
+{
 	0xFF33A280, 0xFF353B3B, 0xFF36D3F6, 0xFF386CB1, 0xFF3A056C, 0xFF3B9E27, 0xFF3D36E2, 0xFF3ECF9D,
 	0xFF406858, 0xFF420113, 0xFF4399CE, 0xFF453289, 0xFF46CB44, 0xFF4863FF, 0xFF49FCBA, 0xFF4B9575,
 	0xFF4D2E30, 0xFF4EC6EB, 0xFF505FA6, 0xFF51F861, 0xFF53911C, 0xFF5529D7, 0xFF56C292, 0xFF585B4D,
@@ -1195,49 +1295,49 @@
 };
 
 #define OUT(x) \
-	out[OUTITER] = (uint8_t)*(decode_surface + x)&0xFF; \
-	OUTITER += OUTINC;
+    out[OUTITER] = (uint8_t)*(decode_surface + x)&0xFF; \
+    OUTITER += OUTINC;
 
 #define OUT4(x) \
-	OUT(x + 0x03); \
-	OUT(x + 0x02); \
-	OUT(x + 0x01); \
-	OUT(x + 0x00);
+    OUT(x + 0x03); \
+    OUT(x + 0x02); \
+    OUT(x + 0x01); \
+    OUT(x + 0x00);
 
 #define OUT8(x) \
-	OUT4(x + 0x04); \
-	OUT4(x + 0x00);
+    OUT4(x + 0x04); \
+    OUT4(x + 0x00);
 
 #define OUT_LU_16A(x) \
-	OUT8(x); \
-	OUT8(x + 0x40);
+    OUT8(x); \
+    OUT8(x + 0x40);
 
 #define OUT_CH_8A(x) \
-	OUT4(x); \
-	OUT4(x + 0x20);
+    OUT4(x); \
+    OUT4(x + 0x20);
 
 //pppppppppppppppp
 //x: macroblock address
 //l: line 0-15
 #define OUT_LU_16(x,l) \
-	OUT_LU_16A(x + (l/4) * 0x10 + (l%2) * 0x80 + ((l/2)%2?0x00:0x08));
+    OUT_LU_16A(x + (l/4) * 0x10 + (l%2) * 0x80 + ((l/2)%2?0x00:0x08));
 
 //pppppppp
 //x: macroblock address
 //l: line 0-7
 //b: 0=cr 1=cb
 #define OUT_CH_8(x,l,b) \
-	OUT_CH_8A(x + (l/4) * 0x10 + (l%2) * 0x40 + ((l/2)%2?0x00:0x08) + (b?0x04:0x00));
+    OUT_CH_8A(x + (l/4) * 0x10 + (l%2) * 0x40 + ((l/2)%2?0x00:0x08) + (b?0x04:0x00));
 
 //----
-#define CLAMP(x)	((x < 0) ? 0 : ((x > 255) ? 255 : x))
-#define SWAP(x,y)	{ x ^= y; y ^= x; x ^= y; }
+#define CLAMP(x)    ((x < 0) ? 0 : ((x > 255) ? 255 : x))
+#define SWAP(x,y)   { x ^= y; y ^= x; x ^= y; }
 
 /* TODO: aspect ratio correction and PIP */
-bool cVideo::GetScreenImage(unsigned char * &video, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
+bool cVideo::GetScreenImage(unsigned char*&video, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
 {
 	hal_info("%s: get_video: %d get_osd: %d scale_to_video: %d\n",
-		 __func__, get_video, get_osd, scale_to_video);
+	    __func__, get_video, get_osd, scale_to_video);
 
 	int fbfd = -1, bpafd = -1;
 	int vid_x, vid_y, osd_x, osd_y, aspect;
@@ -1251,7 +1351,8 @@
 		hal_info("%s: WARNING, video != NULL?\n", __func__);
 
 	fbfd = open("/dev/fb0", O_RDWR);
-	if (fbfd < 0) {
+	if (fbfd < 0)
+	{
 		hal_info("%s: cannot open open /dev/fb0 (%m)\n", __func__);
 		return false;
 	}
@@ -1261,12 +1362,14 @@
 	if (ioctl(fbfd, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
 		hal_info("%s: FBIOGET_VSCREENINFO (%m)\n", __func__);
 
-	if (var_screeninfo.bits_per_pixel != 32) {
+	if (var_screeninfo.bits_per_pixel != 32)
+	{
 		hal_info("%s: only 32bit framebuffer supported.\n", __func__);
 		close(fbfd);
 		return false;
 	}
-	if (fix_screeninfo.line_length - (var_screeninfo.xres * 4) != 0) {
+	if (fix_screeninfo.line_length - (var_screeninfo.xres * 4) != 0)
+	{
 		hal_info("%s: framebuffer with offset not supported.\n", __func__);
 		close(fbfd);
 		return false;
@@ -1284,10 +1387,13 @@
 
 	if (get_video && get_osd)
 	{
-		if (scale_to_video) {
+		if (scale_to_video)
+		{
 			xres = vid_x;
 			yres = vid_y;
-		} else {
+		}
+		else
+		{
 			xres = osd_x;
 			yres = osd_y;
 		}
@@ -1335,7 +1441,7 @@
 		hal_info("%s: cannot open secondary bpamem device %s: %m\n", __func__, bpa_mem_device);
 		goto error_cleanup;
 	}
-	bpa = (uint8_t *)mmap(0, bpa_data.mem_size, PROT_WRITE|PROT_READ, MAP_SHARED, bpafd, 0);
+	bpa = (uint8_t *)mmap(0, bpa_data.mem_size, PROT_WRITE | PROT_READ, MAP_SHARED, bpafd, 0);
 	if (bpa == MAP_FAILED)
 	{
 		hal_info("%s: cannot map from bpamem: %m\n", __func__);
@@ -1376,19 +1482,22 @@
 			}
 			fclose(pipe);
 		}
-		if (vid_phys_addr == 0) {
+		if (vid_phys_addr == 0)
+		{
 			hal_info("%s: primary display pane not found in /proc/bpa2\n", __func__);
 		}
 
 		mfd = open("/dev/mem", O_RDWR | O_CLOEXEC);
-		if (mfd < 0) {
+		if (mfd < 0)
+		{
 			hal_info("%s: cannot open open /dev/mem (%m)\n", __func__);
 			goto error_cleanup;
 		}
 
 		hal_info("%s: Using bpa2 part LMI_VID - 0x%lx %lu\n", __func__, vid_phys_addr, vid_mem_size);
 		decode_surface = (uint8_t *)mmap(0, vid_mem_size, PROT_READ, MAP_SHARED, mfd, vid_phys_addr);
-		if (decode_surface == MAP_FAILED) {
+		if (decode_surface == MAP_FAILED)
+		{
 			hal_info("%s: cannot mmap /dev/mem for VIDEO (%m)\n", __func__);
 			close(mfd);
 			goto error_cleanup;
@@ -1457,21 +1566,21 @@
 		xblock = stride_half >> 3;/// 8; //no roundin
 
 		//if xblock is not even than we will have to move to the next even value an
-		yblockoffset = (((xblock + 1) >> 1 /* / 2*/) << 1 /* * 2*/ ) << 8 /* * 64=8x8px * 2=2 block rows * 2=cr cb*/;
+		yblockoffset = (((xblock + 1) >> 1 /* / 2*/) << 1 /* * 2*/) << 8 /* * 64=8x8px * 2=2 block rows * 2=cr cb*/;
 
 		OUTITER       = 0;
 		OUTITERoffset = 0;
 		OUTINC        = 2;
 		out           = chroma;
 
-		for(cr = 0; cr < 2; cr++)
+		for (cr = 0; cr < 2; cr++)
 		{
-			for(even = 0; even < 2; even++)
+			for (even = 0; even < 2; even++)
 			{
 				offset        = layer_offset + (even  << 8 /* * 0x100*/);
 				OUTITERoffset = even * (xblock << 7 /* * 128=8x8px * 2*/) + cr;
 
-				for (iyblock = even; iyblock < yblock; iyblock+=2)
+				for (iyblock = even; iyblock < yblock; iyblock += 2)
 				{
 					for (ixblock = 0; ixblock < xblock; ixblock++)
 					{
@@ -1485,7 +1594,7 @@
 						}
 
 						//0x00 0x80 0x200 0x280, ...
-						offset += (offset%0x100?0x180/*80->200*/:0x80/*0->80*/);
+						offset += (offset % 0x100 ? 0x180/*80->200*/ : 0x80/*0->80*/);
 						OUTITERoffset += 16/*OUTINC*8=16*/;
 					}
 					OUTITERoffset += (vid_x << 4) - vid_x /* * 15*/;
@@ -1503,7 +1612,7 @@
 		const int rgbstride = vid_x * 3;
 		const int scans = vid_y / 2;
 		int y;
-		for (y=0; y < scans; ++y)
+		for (y = 0; y < scans; ++y)
 		{
 			int x;
 			int out1 = y * rgbstride * 2;
@@ -1524,16 +1633,16 @@
 				int Y = yuv2rgbtable_y[luma[pos]];
 
 				//p0:0
-				vid[out1  ] = CLAMP((Y + RU)>>16);
-				vid[out1+1] = CLAMP((Y - GV - GU)>>16);
-				vid[out1+2] = CLAMP((Y + BV)>>16);
+				vid[out1  ] = CLAMP((Y + RU) >> 16);
+				vid[out1 + 1] = CLAMP((Y - GV - GU) >> 16);
+				vid[out1 + 2] = CLAMP((Y + BV) >> 16);
 
 				Y = yuv2rgbtable_y[luma[vid_x + pos]];
 
 				//p1:0
-				vid[out1  +rgbstride] = CLAMP((Y + RU)>>16);
-				vid[out1+1+rgbstride] = CLAMP((Y - GV - GU)>>16);
-				vid[out1+2+rgbstride] = CLAMP((Y + BV)>>16);
+				vid[out1  + rgbstride] = CLAMP((Y + RU) >> 16);
+				vid[out1 + 1 + rgbstride] = CLAMP((Y - GV - GU) >> 16);
+				vid[out1 + 2 + rgbstride] = CLAMP((Y + BV) >> 16);
 
 				out1 += 3;
 				pos++;
@@ -1541,16 +1650,16 @@
 				Y = yuv2rgbtable_y[luma[pos]];
 
 				//p0:1
-				vid[out1  ] = CLAMP((Y + RU)>>16);
-				vid[out1+1] = CLAMP((Y - GV - GU)>>16);
-				vid[out1+2] = CLAMP((Y + BV)>>16);
+				vid[out1  ] = CLAMP((Y + RU) >> 16);
+				vid[out1 + 1] = CLAMP((Y - GV - GU) >> 16);
+				vid[out1 + 2] = CLAMP((Y + BV) >> 16);
 
 				Y = yuv2rgbtable_y[luma[vid_x + pos]];
 
 				//p1:1
-				vid[out1  +rgbstride] = CLAMP((Y + RU)>>16);
-				vid[out1+1+rgbstride] = CLAMP((Y - GV - GU)>>16);
-				vid[out1+2+rgbstride] = CLAMP((Y + BV)>>16);
+				vid[out1  + rgbstride] = CLAMP((Y + RU) >> 16);
+				vid[out1 + 1 + rgbstride] = CLAMP((Y - GV - GU) >> 16);
+				vid[out1 + 2 + rgbstride] = CLAMP((Y + BV) >> 16);
 
 				out1 += 3;
 				pos++;
@@ -1563,8 +1672,9 @@
 		uint8_t *lfb = (uint8_t *)mmap(0, fix_screeninfo.smem_len, PROT_READ, MAP_SHARED, fbfd, 0);
 		if (lfb == MAP_FAILED)
 			hal_info("%s: mmap fb memory failed (%m)\n", __func__);
-		else {
-			memcpy(osd, lfb, fix_screeninfo.line_length*var_screeninfo.yres);
+		else
+		{
+			memcpy(osd, lfb, fix_screeninfo.line_length * var_screeninfo.yres);
 			munmap(lfb, fix_screeninfo.smem_len);
 		}
 	}
@@ -1578,7 +1688,8 @@
 		int pip_w = xres;
 		int pip_h = yres;
 		bool scale = false;
-		if (get_osd) {
+		if (get_osd)
+		{
 			pip_x = proc_get_hex("/proc/stb/vmpeg/0/dst_left");
 			pip_y = proc_get_hex("/proc/stb/vmpeg/0/dst_top");
 			pip_w = proc_get_hex("/proc/stb/vmpeg/0/dst_width");
@@ -1591,15 +1702,20 @@
 			pip_h = pip_h * yres / 576;
 			if (scale == false && aspect == 1)
 			{
-				pip_w = xres * 9/16*4/3;
+				pip_w = xres * 9 / 16 * 4 / 3;
 				pip_x = (xres - pip_w) / 2;
 			}
 		}
-		if (scale || aspect == 1) {
+		if (scale || aspect == 1)
+		{
 			/* todo: use the blitter, luke */
 			uint8_t *p = bpa - 1;
-			for (int i = 0; i < outmem; i += 4) {
-				*++p = 0; *++p = 0; *++p = 0; *++p = 0xff;
+			for (int i = 0; i < outmem; i += 4)
+			{
+				*++p = 0;
+				*++p = 0;
+				*++p = 0;
+				*++p = 0xff;
 			}
 		}
 
@@ -1632,7 +1748,7 @@
 		memset(&blt_data, 0, sizeof(STMFBIO_BLT_EXTERN_DATA));
 		blt_data.operation  = BLT_OP_COPY;
 		if (get_video)
-			blt_data.ulFlags    = BLT_OP_FLAGS_BLEND_SRC_ALPHA|BLT_OP_FLAGS_BLEND_DST_MEMORY;
+			blt_data.ulFlags    = BLT_OP_FLAGS_BLEND_SRC_ALPHA | BLT_OP_FLAGS_BLEND_DST_MEMORY;
 		else
 			blt_data.ulFlags    = 0;
 		blt_data.srcOffset  = 0;
@@ -1669,10 +1785,11 @@
 	close(fbfd);
 	return true;
 
- error_cleanup:
+error_cleanup:
 	if (bpa != MAP_FAILED)
 		munmap(bpa, bpa_data.mem_size);
-	if (bpafd > -1) {
+	if (bpafd > -1)
+	{
 		ioctl(bpafd, BPAMEMIO_FREEMEM);
 		close(bpafd);
 	}
diff -Nur libstb-hal-ddt.git.orig/libduckbox/video_lib.h libstb-hal-ddt.git/libduckbox/video_lib.h
--- libstb-hal-ddt.git.orig/libduckbox/video_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libduckbox/video_lib.h	2022-07-23 18:18:31.543772226 +0200
@@ -10,20 +10,9 @@
 	char format[16];
 } cs_vs_format_struct_t;
 
-typedef enum {
-	ANALOG_SD_RGB_CINCH = 0x00,
-	ANALOG_SD_YPRPB_CINCH,
-	ANALOG_HD_RGB_CINCH,
-	ANALOG_HD_YPRPB_CINCH,
-	ANALOG_SD_RGB_SCART = 0x10,
-	ANALOG_SD_YPRPB_SCART,
-	ANALOG_HD_RGB_SCART,
-	ANALOG_HD_YPRPB_SCART,
-	ANALOG_SCART_MASK = 0x10
-} analog_mode_t;
-
-typedef enum {
-	COLORFORMAT_RGB = 0x10, // keep compatible with analog_mode_t
+typedef enum
+{
+	COLORFORMAT_RGB = 0x10,
 	COLORFORMAT_YUV,
 	COLORFORMAT_CVBS,
 	COLORFORMAT_SVIDEO,
@@ -32,7 +21,8 @@
 	COLORFORMAT_HDMI_YCBCR422
 } COLOR_FORMAT;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_FORMAT_MPEG2 = 0,
 	VIDEO_FORMAT_MPEG4_H264,
 	VIDEO_FORMAT_VC1,
@@ -43,16 +33,8 @@
 	VIDEO_FORMAT_AVS = 16
 } VIDEO_FORMAT;
 
-typedef enum {
-	VIDEO_SD = 0,
-	VIDEO_HD,
-	VIDEO_120x60i,
-	VIDEO_320x240i,
-	VIDEO_1440x800i,
-	VIDEO_360x288i
-} VIDEO_DEFINITION;
-
-typedef enum {
+typedef enum
+{
 	VIDEO_FRAME_RATE_23_976 = 0,
 	VIDEO_FRAME_RATE_24,
 	VIDEO_FRAME_RATE_25,
@@ -63,29 +45,24 @@
 	VIDEO_FRAME_RATE_60
 } VIDEO_FRAME_RATE;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_1_1,
 	DISPLAY_AR_4_3,
-	DISPLAY_AR_14_9,
 	DISPLAY_AR_16_9,
 	DISPLAY_AR_20_9,
 	DISPLAY_AR_RAW
 } DISPLAY_AR;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_MODE_PANSCAN = 0,
 	DISPLAY_AR_MODE_LETTERBOX,
-	DISPLAY_AR_MODE_NONE,
-	DISPLAY_AR_MODE_PANSCAN2
+	DISPLAY_AR_MODE_NONE
 } DISPLAY_AR_MODE;
 
-typedef enum {
-	VIDEO_DB_DR_NEITHER = 0,
-	VIDEO_DB_ON,
-	VIDEO_DB_DR_BOTH
-} VIDEO_DB_DR;
-
-typedef enum {
+typedef enum
+{
 	VIDEO_PLAY_STILL = 0,
 	VIDEO_PLAY_CLIP,
 	VIDEO_PLAY_TRICK,
@@ -93,7 +70,8 @@
 	VIDEO_PLAY_MOTION_NO_SYNC
 } VIDEO_PLAY_MODE;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_STD_NTSC,
 	VIDEO_STD_SECAM,
 	VIDEO_STD_PAL,
@@ -107,12 +85,13 @@
 	VIDEO_STD_1080P24,
 	VIDEO_STD_1080P25,
 	VIDEO_STD_AUTO,
-	VIDEO_STD_1080P50,	/* SPARK only */
+	VIDEO_STD_1080P50,  /* SPARK only */
 	VIDEO_STD_MAX
 } VIDEO_STD;
 
 /* not used, for dummy functions */
-typedef enum {
+typedef enum
+{
 	VIDEO_HDMI_CEC_MODE_OFF = 0,
 	VIDEO_HDMI_CEC_MODE_TUNER,
 	VIDEO_HDMI_CEC_MODE_RECORDER
@@ -128,11 +107,10 @@
 	VIDEO_CONTROL_MAX = VIDEO_CONTROL_SHARPNESS
 } VIDEO_CONTROL;
 
-
 class cVideo
 {
-	friend class cPlayback;
-	friend class cDemux;
+		friend class cPlayback;
+		friend class cDemux;
 	private:
 		/* video device */
 		int fd;
@@ -145,11 +123,9 @@
 		int scartvoltage;
 
 		VIDEO_FORMAT StreamType;
-		VIDEO_DEFINITION VideoDefinition;
 		DISPLAY_AR DisplayAR;
 		VIDEO_PLAY_MODE SyncMode;
 		DISPLAY_AR_MODE ARMode;
-		VIDEO_DB_DR eDbDr;
 		DISPLAY_AR PictureAR;
 		VIDEO_FRAME_RATE FrameRate;
 		int video_standby;
@@ -157,6 +133,7 @@
 
 		int brightness, contrast, saturation, hue;
 
+		/* used internally by playback */
 		void openDevice(void);
 		void closeDevice(void);
 	public:
@@ -164,8 +141,25 @@
 		cVideo(int mode, void *, void *, unsigned int unit = 0);
 		~cVideo(void);
 
-		void * GetTVEnc() { return NULL; };
-		void * GetTVEncSD() { return NULL; };
+		void open_AVInput_Device(void)
+		{
+			return;
+		}; // Dummy
+		void close_AVInput_Device(void)
+		{
+			return;
+		};    // Dummy
+
+		void setAVInput(int val);
+
+		void *GetTVEnc()
+		{
+			return NULL;
+		};
+		void *GetTVEncSD()
+		{
+			return NULL;
+		};
 
 		/* aspect ratio */
 		int getAspectRatio(void);
@@ -190,33 +184,56 @@
 		/* get video system infos */
 		int GetVideoSystem(void);
 		/* when system = -1 then use current video system */
-		void GetVideoSystemFormatName(cs_vs_format_t* format, int system = -1);
+		void GetVideoSystemFormatName(cs_vs_format_t *format, int system = -1);
 
 		/* set video_system */
 		int SetVideoSystem(int video_system, bool remember = true);
 		int SetStreamType(VIDEO_FORMAT type);
 		void SetSyncMode(AVSYNC_TYPE mode);
-		bool SetCECMode(VIDEO_HDMI_CEC_MODE) { return true; };
-		void SetCECAutoView(bool) { return; };
-		void SetCECAutoStandby(bool) { return; };
-		void ShowPicture(const char * fname, const char *_destname = NULL);
+		bool SetCECMode(VIDEO_HDMI_CEC_MODE)
+		{
+			return true;
+		};
+		void SetCECAutoView(bool)
+		{
+			return;
+		};
+		void SetCECAutoStandby(bool)
+		{
+			return;
+		};
+		bool ShowPicture(const char *fname, const char *_destname = NULL);
 		void StopPicture();
 		void Standby(unsigned int bOn);
+		void ShowPig(int _x);
 		void Pig(int x, int y, int w, int h, int osd_w = 1064, int osd_h = 600, int startx = 0, int starty = 0, int endx = 1279, int endy = 719);
 		void SetControl(int, int);
 		void VideoParamWatchdog(void);
 		void setContrast(int val);
-		void SetVideoMode(analog_mode_t mode);
-		void SetDBDR(int) { return; };
-		void SetAudioHandle(void *) { return; };
-		void SetAutoModes(int [VIDEO_STD_MAX]) { return; };
-		int  OpenVBI(int) { return 0; };
-		int  CloseVBI(void) { return 0; };
-		int  StartVBI(unsigned short) { return 0; };
-		int  StopVBI(void) { return 0; };
+
+		void SetAudioHandle(void *)
+		{
+			return;
+		};
+		int  OpenVBI(int)
+		{
+			return 0;
+		};
+		int  CloseVBI(void)
+		{
+			return 0;
+		};
+		int  StartVBI(unsigned short)
+		{
+			return 0;
+		};
+		int  StopVBI(void)
+		{
+			return 0;
+		};
 		void SetDemux(cDemux *dmx);
 		void SetColorFormat(COLOR_FORMAT color_format);
-		bool GetScreenImage(unsigned char * &data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
+		bool GetScreenImage(unsigned char*&data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
 };
 
 #endif // __VIDEO_LIB_H__
diff -Nur libstb-hal-ddt.git.orig/libdvbci/aes_xcbc_mac.cpp libstb-hal-ddt.git/libdvbci/aes_xcbc_mac.cpp
--- libstb-hal-ddt.git.orig/libdvbci/aes_xcbc_mac.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/aes_xcbc_mac.cpp	2022-07-23 18:18:31.503773029 +0200
@@ -11,7 +11,8 @@
 
 	AES_set_encrypt_key(key, 128, &aes_key);
 
-	for (y = 0; y < 3; y++) {
+	for (y = 0; y < 3; y++)
+	{
 		for (x = 0; x < 16; x++)
 			ctx->K[y][x] = y + 1;
 		AES_ecb_encrypt(ctx->K[y], ctx->K[y], &aes_key, 1);
@@ -28,8 +29,10 @@
 
 int aes_xcbc_mac_process(struct aes_xcbc_mac_ctx *ctx, const uint8_t *in, unsigned int len)
 {
-	while (len) {
-		if (ctx->buflen == 16) {
+	while (len)
+	{
+		if (ctx->buflen == 16)
+		{
 			AES_ecb_encrypt(ctx->IV, ctx->IV, &ctx->key, 1);
 			ctx->buflen = 0;
 		}
@@ -44,11 +47,14 @@
 {
 	int i;
 
-	if (ctx->buflen == 16) {
+	if (ctx->buflen == 16)
+	{
 		/* K2 */
 		for (i = 0; i < 16; i++)
 			ctx->IV[i] ^= ctx->K[1][i];
-	} else {
+	}
+	else
+	{
 		ctx->IV[ctx->buflen] ^= 0x80;
 		/* K3 */
 		for (i = 0; i < 16; i++)
diff -Nur libstb-hal-ddt.git.orig/libdvbci/aes_xcbc_mac.h libstb-hal-ddt.git/libdvbci/aes_xcbc_mac.h
--- libstb-hal-ddt.git.orig/libdvbci/aes_xcbc_mac.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/aes_xcbc_mac.h	2022-07-23 18:18:31.503773029 +0200
@@ -1,7 +1,8 @@
 #ifndef __AES_XCBC_H_
 #define __AES_XCBC_H_
 
-struct aes_xcbc_mac_ctx {
+struct aes_xcbc_mac_ctx
+{
 	uint8_t K[3][16];
 	uint8_t IV[16];
 	AES_KEY key;
diff -Nur libstb-hal-ddt.git.orig/libdvbci/descrambler.cpp libstb-hal-ddt.git/libdvbci/descrambler.cpp
--- libstb-hal-ddt.git.orig/libdvbci/descrambler.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libdvbci/descrambler.cpp	2022-07-23 18:18:31.503773029 +0200
@@ -13,13 +13,14 @@
 
 #include <config.h>
 
-static const char * FILENAME = "[descrambler]";
+static const char *FILENAME = "[descrambler]";
 
 static int desc_fd = -1;
 static int desc_user_count = 0;
 
 #ifndef CA_SET_PID
-typedef struct ca_pid {
+typedef struct ca_pid
+{
 	unsigned int pid;
 	int index;      /* -1 == disable*/
 } ca_pid_t;
@@ -28,17 +29,20 @@
 #endif
 
 #ifndef CA_SET_DESCR_DATA
-enum ca_descr_data_type {
+enum ca_descr_data_type
+{
 	CA_DATA_IV,
 	CA_DATA_KEY,
 };
 
-enum ca_descr_parity {
+enum ca_descr_parity
+{
 	CA_PARITY_EVEN,
 	CA_PARITY_ODD,
 };
 
-struct ca_descr_data {
+struct ca_descr_data
+{
 	unsigned int index;
 	enum ca_descr_parity parity;
 	enum ca_descr_data_type data_type;
@@ -173,8 +177,9 @@
 {
 	if (desc_fd > 0)
 		return true;
-	desc_fd = open(descrambler_filename, O_RDWR | O_NONBLOCK );
-	if (desc_fd <= 0) {
+	desc_fd = open(descrambler_filename, O_RDWR | O_NONBLOCK);
+	if (desc_fd <= 0)
+	{
 		printf("cannot open %s\n", descrambler_filename);
 		return false;
 	}
diff -Nur libstb-hal-ddt.git.orig/libdvbci/_dh_params.h libstb-hal-ddt.git/libdvbci/_dh_params.h
--- libstb-hal-ddt.git.orig/libdvbci/_dh_params.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/_dh_params.h	2022-07-23 18:18:31.503773029 +0200
@@ -1,6 +1,7 @@
 /* DH */
 
-unsigned char dh_p[256] = {       /* prime */
+unsigned char dh_p[256] =         /* prime */
+{
 	0xd6, 0x27, 0x14, 0x7a, 0x7c, 0x0c, 0x26, 0x63, 0x9d, 0x82, 0xeb, 0x1f, 0x4a, 0x18, 0xff, 0x6c,
 	0x34, 0xad, 0xea, 0xa6, 0xc0, 0x23, 0xe6, 0x65, 0xfc, 0x8e, 0x32, 0xc3, 0x33, 0xf4, 0x91, 0xa7,
 	0xcc, 0x88, 0x58, 0xd7, 0xf3, 0xb3, 0x17, 0x5e, 0xb0, 0xa8, 0xeb, 0x5c, 0xd4, 0xd8, 0x3a, 0xae,
@@ -19,7 +20,8 @@
 	0x15, 0xb8, 0x3c, 0x8d, 0x80, 0x92, 0x1c, 0xa1, 0x03, 0xd0, 0x83, 0x2f, 0x5f, 0xe3, 0x07, 0x69
 };
 
-unsigned char dh_g[256] = {       /* generator */
+unsigned char dh_g[256] =         /* generator */
+{
 	0x95, 0x7d, 0xd1, 0x49, 0x68, 0xc1, 0xa5, 0xf1, 0x48, 0xe6, 0x50, 0x4f, 0xa1, 0x10, 0x72, 0xc4,
 	0xef, 0x12, 0xec, 0x2d, 0x94, 0xbe, 0xc7, 0x20, 0x2c, 0x94, 0xf9, 0x68, 0x67, 0x0e, 0x22, 0x17,
 	0xb5, 0x5c, 0x0b, 0xca, 0xac, 0x9f, 0x25, 0x9c, 0xd2, 0xa6, 0x1a, 0x20, 0x10, 0x16, 0x6a, 0x42,
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dh_rsa_misc.cpp libstb-hal-ddt.git/libdvbci/dh_rsa_misc.cpp
--- libstb-hal-ddt.git.orig/libdvbci/dh_rsa_misc.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libdvbci/dh_rsa_misc.cpp	2022-07-23 18:18:31.507772949 +0200
@@ -20,8 +20,9 @@
 	hLen = 20;      /* SHA1 */
 
 	/* allocate memory */
-	buf = (uint8_t*)malloc(hLen);
-	if (buf == NULL) {
+	buf = (uint8_t *)malloc(hLen);
+	if (buf == NULL)
+	{
 		printf("error mem\n");
 		return -1;
 	}
@@ -29,7 +30,8 @@
 	/* start counter */
 	counter = 0;
 
-	while (masklen > 0) {
+	while (masklen > 0)
+	{
 		/* handle counter */
 		BYTE32(buf, counter);
 		++counter;
@@ -50,8 +52,8 @@
 }
 
 static int pkcs_1_pss_encode(const uint8_t *msghash, unsigned int msghashlen,
-			     unsigned long saltlen, unsigned long modulus_bitlen,
-			     uint8_t *out, unsigned int outlen)
+    unsigned long saltlen, unsigned long modulus_bitlen,
+    uint8_t *out, unsigned int outlen)
 {
 	unsigned char *DB, *mask, *salt, *hash;
 	unsigned long x, y, hLen, modulus_len;
@@ -63,22 +65,25 @@
 	modulus_len = (modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0);
 
 	/* allocate ram for DB/mask/salt/hash of size modulus_len */
-	DB = (unsigned char*)malloc(modulus_len);
-	mask = (unsigned char*)malloc(modulus_len);
-	salt = (unsigned char*)malloc(modulus_len);
-	hash = (unsigned char*)malloc(modulus_len);
+	DB = (unsigned char *)malloc(modulus_len);
+	mask = (unsigned char *)malloc(modulus_len);
+	salt = (unsigned char *)malloc(modulus_len);
+	hash = (unsigned char *)malloc(modulus_len);
 
 	hashbuflen = 8 + msghashlen + saltlen;
-	hashbuf = (unsigned char*)malloc(hashbuflen);
+	hashbuf = (unsigned char *)malloc(hashbuflen);
 
-	if (!(DB && mask && salt && hash && hashbuf)) {
+	if (!(DB && mask && salt && hash && hashbuf))
+	{
 		printf("out of memory\n");
 		goto LBL_ERR;
 	}
 
 	/* generate random salt */
-	if (saltlen > 0) {
-		if (get_random(salt, saltlen) != (long)saltlen) {
+	if (saltlen > 0)
+	{
+		if (get_random(salt, saltlen) != (long)saltlen)
+		{
 			printf("rnd failed\n");
 			goto LBL_ERR;
 		}
@@ -107,7 +112,8 @@
 		DB[y] ^= mask[y];
 
 	/* output is DB || hash || 0xBC */
-	if (outlen < modulus_len) {
+	if (outlen < modulus_len)
+	{
 		err = -1;
 		printf("error overflow\n");
 		goto LBL_ERR;
@@ -168,7 +174,8 @@
 	DH_get0_key(dh, &pub_key, &priv_key);
 	len = BN_num_bytes(priv_key);
 #endif
-	if (len > dest_len) {
+	if (len > dest_len)
+	{
 		printf("len > dest_len\n");
 		return -1;
 	}
@@ -206,7 +213,8 @@
 
 
 	len = BN_num_bytes(bn_dest);
-	if (len > dest_len) {
+	if (len > dest_len)
+	{
 		printf("len > dest_len\n");
 		return -1;
 	}
@@ -251,7 +259,8 @@
 
 	SHA1(dest, 0x12e, hash);
 
-	if (pkcs_1_pss_encode(hash, 20, 20, 0x800, dbuf, sizeof(dbuf))) {
+	if (pkcs_1_pss_encode(hash, 20, 20, 0x800, dbuf, sizeof(dbuf)))
+	{
 		printf("pss encode failed\n");
 		return -1;
 	}
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_appmgr.cpp libstb-hal-ddt.git/libdvbci/dvbci_appmgr.cpp
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_appmgr.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/dvbci_appmgr.cpp	2022-07-23 18:18:31.507772949 +0200
@@ -6,7 +6,7 @@
 
 #include "dvbci_appmgr.h"
 
-/* prevent possibly segfaults: read at end of this file */ 
+/* prevent possibly segfaults: read at end of this file */
 #define yy_debug 0
 
 eDVBCIApplicationManagerSession::eDVBCIApplicationManagerSession(eDVBCISlot *tslot)
@@ -26,7 +26,7 @@
 {
 	printf("[CI AM] SESSION(%d)/APP %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
 	for (int i = 0; i < len; i++)
-		printf("%02x ", ((const unsigned char*)data)[i]);
+		printf("%02x ", ((const unsigned char *)data)[i]);
 	printf("\n");
 
 	if ((tag[0] == 0x9f) && (tag[1] == 0x80))
@@ -38,21 +38,21 @@
 				int dl;
 				printf("[CI AM] application info:\n");
 				printf("[CI AM]   len: %d\n", len);
-				printf("[CI AM]   application_type: %d\n", ((unsigned char*)data)[0]);
-				printf("[CI AM]   application_manufacturer: %02x %02x\n", ((unsigned char*)data)[2], ((unsigned char*)data)[1]);
-				printf("[CI AM]   manufacturer_code: %02x %02x\n", ((unsigned char*)data)[4], ((unsigned char*)data)[3]);
+				printf("[CI AM]   application_type: %d\n", ((unsigned char *)data)[0]);
+				printf("[CI AM]   application_manufacturer: %02x %02x\n", ((unsigned char *)data)[2], ((unsigned char *)data)[1]);
+				printf("[CI AM]   manufacturer_code: %02x %02x\n", ((unsigned char *)data)[4], ((unsigned char *)data)[3]);
 				printf("  menu string: ");
-				dl = ((unsigned char*)data)[5];
+				dl = ((unsigned char *)data)[5];
 				if ((dl + 6) > len)
 				{
 					printf("[CI AM] warning, invalid length (%d vs %d)\n", dl + 6, len);
 					dl = len - 6;
 				}
 				char str[dl + 1];
-				memcpy(str, ((char*)data) + 6, dl);
+				memcpy(str, ((char *)data) + 6, dl);
 				str[dl] = '\0';
 				for (int i = 0; i < dl; ++i)
-					printf("%c", ((unsigned char*)data)[i + 6]);
+					printf("%c", ((unsigned char *)data)[i + 6]);
 				printf("\n");
 
 				strcpy(slot->name, str);
@@ -111,16 +111,16 @@
 bool eDVBCIApplicationManagerSession::readBlist()
 {
 	int rc, i;
-	char cSid[4] = {0,0,0,0};
+	char cSid[4] = {0, 0, 0, 0};
 	u16 Sid;
 	FILE *fd;
 	char blacklist_file[32];
 
-	sprintf(blacklist_file,"/etc/blacklist_slot_%d",slot->slot);
+	sprintf(blacklist_file, "/etc/blacklist_slot_%d", slot->slot);
 
 	if (access(blacklist_file, F_OK) != 0)
 		return false;
-	fd = fopen(blacklist_file,"r");
+	fd = fopen(blacklist_file, "r");
 	if (!fd)
 		return false;
 	else
@@ -139,7 +139,8 @@
 				Sid = (u16)strtol(cSid, NULL, 16);
 				slot->bsids.push_back(Sid);
 			}
-		} while (rc != EOF);
+		}
+		while (rc != EOF);
 fin:
 		fclose(fd);
 	}
@@ -153,7 +154,7 @@
 {
 	if (readBlist())
 	{
-/* out commented: causes sometimes segfault when reboot....don't know why :( */
+		/* out commented: causes sometimes segfault when reboot....don't know why :(*/
 #if yy_debug
 		printf("Blacked sids: %d > ", slot->bsids.size());
 		for (unsigned int i = 0; i < slot->bsids.size(); i++)
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_appmgr.h libstb-hal-ddt.git/libdvbci/dvbci_appmgr.h
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_appmgr.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/dvbci_appmgr.h	2022-07-23 18:18:31.507772949 +0200
@@ -5,22 +5,23 @@
 
 class eDVBCIApplicationManagerSession: public eDVBCISession
 {
-	enum {
-		stateFinal=statePrivate
-	};
+		enum
+		{
+			stateFinal = statePrivate
+		};
 
-	eDVBCISlot *slot;
+		eDVBCISlot *slot;
 
-	int wantmenu;
-	int receivedAPDU(const unsigned char *tag, const void *data, int len);
-	int doAction();
-	bool readBlist();
-	int checkBlist();
-public:
-	eDVBCIApplicationManagerSession(eDVBCISlot *tslot);
-	~eDVBCIApplicationManagerSession();
-	int enterMenu();
-	int startMMI();
+		int wantmenu;
+		int receivedAPDU(const unsigned char *tag, const void *data, int len);
+		int doAction();
+		bool readBlist();
+		int checkBlist();
+	public:
+		eDVBCIApplicationManagerSession(eDVBCISlot *tslot);
+		~eDVBCIApplicationManagerSession();
+		int enterMenu();
+		int startMMI();
 };
 
 #endif
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_camgr.cpp libstb-hal-ddt.git/libdvbci/dvbci_camgr.cpp
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_camgr.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libdvbci/dvbci_camgr.cpp	2022-07-23 18:18:31.507772949 +0200
@@ -20,7 +20,7 @@
 {
 	printf("[CI CA] SESSION(%d)/CA %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
 	for (int i = 0; i < len; i++)
-		printf("%02x ", ((const unsigned char*)data)[i]);
+		printf("%02x ", ((const unsigned char *)data)[i]);
 	printf("\n");
 
 	if ((tag[0] == 0x9f) && (tag[1] == 0x80))
@@ -32,8 +32,8 @@
 				printf("[CI CA] ca info:\n");
 				for (int i = 0; i < len; i += 2)
 				{
-					printf("%04x ", (((const unsigned char*)data)[i] << 8) | (((const unsigned char*)data)[i + 1]));
-					caids.push_back((((const unsigned char*)data)[i] << 8) | (((const unsigned char*)data)[i + 1]));
+					printf("%04x ", (((const unsigned char *)data)[i] << 8) | (((const unsigned char *)data)[i + 1]));
+					caids.push_back((((const unsigned char *)data)[i] << 8) | (((const unsigned char *)data)[i + 1]));
 				}
 				if (!caids.empty())
 				{
@@ -85,7 +85,7 @@
 		}
 		case stateFinal:
 			printf("[CI CA] stateFinal and action should not happen\n");
-			// fall through
+		// fall through
 		default:
 			return 0;
 	}
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_camgr.h libstb-hal-ddt.git/libdvbci/dvbci_camgr.h
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_camgr.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/dvbci_camgr.h	2022-07-23 18:18:31.507772949 +0200
@@ -7,18 +7,22 @@
 
 class eDVBCICAManagerSession: public eDVBCISession
 {
-	enum {
-		stateFinal=statePrivate
-	};
-	std::vector<uint16_t> caids;
-	int receivedAPDU(const unsigned char *tag, const void *data, int len);
-	int doAction();
-public:
-	eDVBCICAManagerSession(eDVBCISlot *tslot);
-	~eDVBCICAManagerSession();
+		enum
+		{
+			stateFinal = statePrivate
+		};
+		std::vector<uint16_t> caids;
+		int receivedAPDU(const unsigned char *tag, const void *data, int len);
+		int doAction();
+	public:
+		eDVBCICAManagerSession(eDVBCISlot *tslot);
+		~eDVBCICAManagerSession();
 
-	const std::vector<uint16_t> &getCAIDs() const { return caids; }
-	int sendCAPMT(unsigned char *pmt, int len);
+		const std::vector<uint16_t> &getCAIDs() const
+		{
+			return caids;
+		}
+		int sendCAPMT(unsigned char *pmt, int len);
 };
 
 #endif
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_ccmgr.cpp libstb-hal-ddt.git/libdvbci/dvbci_ccmgr.cpp
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_ccmgr.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libdvbci/dvbci_ccmgr.cpp	2022-07-23 18:18:31.507772949 +0200
@@ -28,15 +28,16 @@
 #define x_debug 0
 #define y_debug 0
 
-static const char * FILENAME = "[dvbci_ccmgr]";
+static const char *FILENAME = "[dvbci_ccmgr]";
 
 /* storage & load of authenticated data (HostID & DHSK & AKH) */
 
 static void CheckFile(char *file)
 {
-	if (access(file, F_OK) != 0) {
+	if (access(file, F_OK) != 0)
+	{
 		printf("No File: %s\n", file);
-		FILE* fd;
+		FILE *fd;
 		fd = fopen(file, "w");
 		fclose(fd);
 	}
@@ -64,19 +65,23 @@
 	get_authdata_filename(filename, sizeof(filename), slot);
 
 	fd = open(filename, O_RDONLY);
-	if (fd <= 0) {
+	if (fd <= 0)
+	{
 		fprintf(stderr, "cannot open %s\n", filename);
 		return false;
 	}
 
-	for (i = 0; i < 5; i++) {
-		if (read(fd, chunk, sizeof(chunk)) != sizeof(chunk)) {
+	for (i = 0; i < 5; i++)
+	{
+		if (read(fd, chunk, sizeof(chunk)) != sizeof(chunk))
+		{
 			fprintf(stderr, "cannot read auth_data\n");
 			close(fd);
 			return false;
 		}
 
-		if (i == index) {
+		if (i == index)
+		{
 			memcpy(host_id, chunk, 8);
 			memcpy(dhsk, &chunk[8], 256);
 			memcpy(akh, &chunk[8 + 256], 32);
@@ -100,13 +105,15 @@
 	unsigned int i;
 	bool ret = false;
 
-	for (entries = 0; entries < 5; entries++) {
+	for (entries = 0; entries < 5; entries++)
+	{
 		int offset = (8 + 256 + 32) * entries;
 		if (!get_authdata(&buf[offset], &buf[offset + 8], &buf[offset + 8 + 256], slot, entries))
 			break;
 
 		/* check if we got this pair already */
-		if (!memcmp(&buf[offset + 8 + 256], akh, 32)) {
+		if (!memcmp(&buf[offset + 8 + 256], akh, 32))
+		{
 			printf("data already stored\n");
 			return true;
 		}
@@ -117,23 +124,27 @@
 	get_authdata_filename(filename, sizeof(filename), slot);
 
 	fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR);
-	if (fd <= 0) {
+	if (fd <= 0)
+	{
 		printf("cannot open %s for writing - authdata not stored\n", filename);
 		return false;
 	}
 
 	/* store new entry first */
-	if (write(fd, host_id, 8) != 8) {
+	if (write(fd, host_id, 8) != 8)
+	{
 		fprintf(stderr, "error in write\n");
 		goto end;
 	}
 
-	if (write(fd, dhsk, 256) != 256) {
+	if (write(fd, dhsk, 256) != 256)
+	{
 		fprintf(stderr, "error in write\n");
 		goto end;
 	}
 
-	if (write(fd, akh, 32) != 32) {
+	if (write(fd, akh, 32) != 32)
+	{
 		fprintf(stderr, "error in write\n");
 		goto end;
 	}
@@ -142,9 +153,11 @@
 	if (entries > 3)
 		entries = 3;
 
-	for (i = 0; i < entries; i++) {
+	for (i = 0; i < entries; i++)
+	{
 		int offset = (8 + 256 + 32) * i;
-		if (write(fd, &buf[offset], (8 + 256 + 32)) != (8 + 256 + 32)) {
+		if (write(fd, &buf[offset], (8 + 256 + 32)) != (8 + 256 + 32))
+		{
 			fprintf(stderr, "error in write\n");
 			goto end;
 		}
@@ -159,7 +172,8 @@
 
 /* CI+ certificates */
 
-struct cert_ctx {
+struct cert_ctx
+{
 	X509_STORE *store;
 
 	/* Host */
@@ -173,7 +187,8 @@
 
 static int verify_cb(int /*ok*/, X509_STORE_CTX *ctx)
 {
-	if (X509_STORE_CTX_get_error(ctx) == X509_V_ERR_CERT_NOT_YET_VALID) {
+	if (X509_STORE_CTX_get_error(ctx) == X509_V_ERR_CERT_NOT_YET_VALID)
+	{
 		time_t now = time(NULL);
 		struct tm *t = localtime(&now);
 		if (t->tm_year < 2015)
@@ -193,7 +208,8 @@
 	RSA *r = NULL;
 
 	fp = fopen(filename, "r");
-	if (!fp) {
+	if (!fp)
+	{
 		fprintf(stderr, "cannot open %s\n", filename);
 		return NULL;
 	}
@@ -213,7 +229,8 @@
 	X509 *cert;
 
 	fp = fopen(filename, "r");
-	if (!fp) {
+	if (!fp)
+	{
 		fprintf(stderr, "cannot open %s\n", filename);
 		return NULL;
 	}
@@ -256,15 +273,18 @@
 {
 	X509 *cert;
 
-	if (!ctx->store) {
+	if (!ctx->store)
+	{
 		/* we assume this is the first certificate added - so its root-ca */
 		ctx->store = X509_STORE_new();
-		if (!ctx->store) {
+		if (!ctx->store)
+		{
 			fprintf(stderr, "cannot create cert_store\n");
 			exit(-1);
 		}
 
-		if (X509_STORE_load_locations(ctx->store, filename, NULL) != 1) {
+		if (X509_STORE_load_locations(ctx->store, filename, NULL) != 1)
+		{
 			fprintf(stderr, "load of first certificate (root_ca) failed\n");
 			exit(-1);
 		}
@@ -273,19 +293,22 @@
 	}
 
 	cert = certificate_open(filename);
-	if (!cert) {
+	if (!cert)
+	{
 		fprintf(stderr, "cannot open certificate %s\n", filename);
 		return NULL;
 	}
 
-	if (!certificate_validate(ctx, cert)) {
+	if (!certificate_validate(ctx, cert))
+	{
 		fprintf(stderr, "cannot vaildate certificate\n");
 		X509_free(cert);
 		return NULL;
 	}
 
 	/* push into store - create a chain */
-	if (X509_STORE_load_locations(ctx->store, filename, NULL) != 1) {
+	if (X509_STORE_load_locations(ctx->store, filename, NULL) != 1)
+	{
 		fprintf(stderr, "load of certificate failed\n");
 		X509_free(cert);
 		return NULL;
@@ -299,12 +322,14 @@
 	X509 *cert;
 
 	cert = d2i_X509(NULL, &data, len);
-	if (!cert) {
+	if (!cert)
+	{
 		fprintf(stderr, "cannot read certificate\n");
 		return NULL;
 	}
 
-	if (!certificate_validate(ctx, cert)) {
+	if (!certificate_validate(ctx, cert))
+	{
 		fprintf(stderr, "cannot vaildate certificate\n");
 		X509_free(cert);
 		return NULL;
@@ -320,7 +345,8 @@
 
 #define MAX_ELEMENTS    33
 
-uint32_t datatype_sizes[MAX_ELEMENTS] = {
+uint32_t datatype_sizes[MAX_ELEMENTS] =
+{
 	0, 50, 0, 0, 0, 8, 8, 0,
 	0, 0, 0, 0, 32, 256, 256, 0,
 	0, 256, 256, 32, 8, 8, 32, 32,
@@ -328,14 +354,16 @@
 	32
 };
 
-struct element {
+struct element
+{
 	uint8_t *data;
 	uint32_t size;
 	/* buffer valid */
 	bool valid;
 };
 
-struct cc_ctrl_data {
+struct cc_ctrl_data
+{
 	/* parent */
 	//struct ci_session *session;
 	eDVBCISlot *slot;
@@ -370,7 +398,8 @@
 static struct element *element_get(struct cc_ctrl_data *cc_data, unsigned int id)
 {
 	/* array index */
-	if ((id < 1) || (id >= MAX_ELEMENTS)) {
+	if ((id < 1) || (id >= MAX_ELEMENTS))
+	{
 		fprintf(stderr, "element_get: invalid id\n");
 		return NULL;
 	}
@@ -383,7 +412,8 @@
 	struct element *e;
 
 	e = element_get(cc_data, id);
-	if (e) {
+	if (e)
+	{
 		free(e->data);
 		memset(e, 0, sizeof(struct element));
 	}
@@ -406,13 +436,14 @@
 		return false;
 
 	/* check size */
-	if ((datatype_sizes[id] != 0) && (datatype_sizes[id] != size)) {
+	if ((datatype_sizes[id] != 0) && (datatype_sizes[id] != size))
+	{
 		fprintf(stderr, "size %d of datatype_id %d doesn't match\n", size, id);
 		return false;
 	}
 
 	free(e->data);
-	e->data = (uint8_t*)malloc(size);
+	e->data = (uint8_t *)malloc(size);
 	memcpy(e->data, data, size);
 	e->size = size;
 	e->valid = true;
@@ -428,12 +459,14 @@
 	int cert_len;
 
 	cert_len = i2d_X509(cert, &cert_der);
-	if (cert_len <= 0) {
+	if (cert_len <= 0)
+	{
 		printf("cannot get data in DER format\n");
 		return false;
 	}
 
-	if (!element_set(cc_data, id, cert_der, cert_len)) {
+	if (!element_set(cc_data, id, cert_der, cert_len))
+	{
 		printf("cannot store element (%d)\n", id);
 		return false;
 	}
@@ -448,7 +481,8 @@
 	char hostid[20];
 	uint8_t bin_hostid[8];
 
-	if ((id != 5) && (id != 6)) {
+	if ((id != 5) && (id != 6))
+	{
 		printf("wrong datatype_id for hostid\n");
 		return false;
 	}
@@ -456,14 +490,16 @@
 	subject = X509_get_subject_name(cert);
 	X509_NAME_get_text_by_NID(subject, nid_cn, hostid, sizeof(hostid));
 
-	if (strlen(hostid) != 16) {
+	if (strlen(hostid) != 16)
+	{
 		printf("malformed hostid\n");
 		return false;
 	}
 
 	str2bin(bin_hostid, hostid, 16);
 
-	if (!element_set(cc_data, id, bin_hostid, sizeof(bin_hostid))) {
+	if (!element_set(cc_data, id, bin_hostid, sizeof(bin_hostid)))
+	{
 		printf("cannot set hostid\n");
 		return false;
 	}
@@ -488,12 +524,14 @@
 	if (e == NULL)
 		return 0;
 
-	if (!e->valid) {
+	if (!e->valid)
+	{
 		fprintf(stderr, "element_get_buf: datatype %d not valid\n", id);
 		return 0;
 	}
 
-	if (!e->data) {
+	if (!e->data)
+	{
 		fprintf(stderr, "element_get_buf: datatype %d doesn't exist\n", id);
 		return 0;
 	}
@@ -508,7 +546,8 @@
 {
 	unsigned int len = element_get_buf(cc_data, &dest[3], id);
 
-	if (len == 0) {
+	if (len == 0)
+	{
 		fprintf(stderr, "cannot get element %d\n", id);
 		return 0;
 	}
@@ -528,12 +567,14 @@
 	if (e == NULL)
 		return NULL;
 
-	if (!e->valid) {
+	if (!e->valid)
+	{
 		fprintf(stderr, "element_get_ptr: datatype %u not valid\n", id);
 		return NULL;
 	}
 
-	if (!e->data) {
+	if (!e->data)
+	{
 		fprintf(stderr, "element_get_ptr: datatype %u doesn't exist\n", id);
 		return NULL;
 	}
@@ -557,7 +598,8 @@
 	aes_xcbc_mac_process(&ctx, data, len - 16);
 	aes_xcbc_mac_done(&ctx, calced_signature);
 
-	if (memcmp(&data[len - 16], calced_signature, 16)) {
+	if (memcmp(&data[len - 16], calced_signature, 16))
+	{
 		fprintf(stderr, "signature wrong\n");
 		return false;
 	}
@@ -654,7 +696,8 @@
 	len = element_get_buf(cc_data, buf, id);
 
 	cert = certificate_import_and_check(ctx, buf, len);
-	if (!cert) {
+	if (!cert)
+	{
 		printf("cannot read/verify DER cert\n");
 		return NULL;
 	}
@@ -688,19 +731,22 @@
 #endif
 
 	/* import CICAM_BrandCert */
-	if ((ctx->ci_cust_cert = import_ci_certificates(cc_data, 8)) == NULL) {
+	if ((ctx->ci_cust_cert = import_ci_certificates(cc_data, 8)) == NULL)
+	{
 		printf("cannot import cert\n");
 		return -1;
 	}
 
 	/* import CICAM_DevCert */
-	if ((ctx->ci_device_cert = import_ci_certificates(cc_data, 16)) == NULL) {
+	if ((ctx->ci_device_cert = import_ci_certificates(cc_data, 16)) == NULL)
+	{
 		printf("cannot import cert\n");
 		return -1;
 	}
 
 	/* everything seems to be fine here - so extract the CICAM_id from cert */
-	if (!element_set_hostid_from_certificate(cc_data, 6, ctx->ci_device_cert)) {
+	if (!element_set_hostid_from_certificate(cc_data, 6, ctx->ci_device_cert))
+	{
 		printf("cannot set cicam_id in elements\n");
 		return -1;
 	}
@@ -770,10 +816,13 @@
 
 	printf("%s -> %s\n", FILENAME, __FUNCTION__);
 
-	if (!cc_data->cert_ctx) {
-		ctx = (struct cert_ctx*)calloc(1, sizeof(struct cert_ctx));
+	if (!cc_data->cert_ctx)
+	{
+		ctx = (struct cert_ctx *)calloc(1, sizeof(struct cert_ctx));
 		cc_data->cert_ctx = ctx;
-	} else {
+	}
+	else
+	{
 		ctx = cc_data->cert_ctx;
 	}
 
@@ -782,7 +831,8 @@
 	ctx->cust_cert = certificate_load_and_check(ctx, CUSTOMER_CERT);
 	ctx->device_cert = certificate_load_and_check(ctx, DEVICE_CERT);
 
-	if (!ctx->cust_cert || !ctx->device_cert) {
+	if (!ctx->cust_cert || !ctx->device_cert)
+	{
 		fprintf(stderr, "cannot loader certificates\n");
 		return -1;
 	}
@@ -798,7 +848,8 @@
 		fprintf(stderr, "cannot set hostid in elements\n");
 
 	cc_data->rsa_device_key = rsa_privatekey_open(DEVICE_CERT);
-	if (!cc_data->rsa_device_key) {
+	if (!cc_data->rsa_device_key)
+	{
 		fprintf(stderr, "cannot read private key\n");
 		return -1;
 	}
@@ -901,46 +952,47 @@
 
 	/* depends on new received items */
 
-	switch (id) {
-	case 8:         /* CICAM_BrandCert */
-	case 14:        /* DHPM */
-	case 16:        /* CICAM_DevCert */
-	case 18:        /* Signature_B */
-		/* this results in CICAM_ID when cert-chain is verified and ok */
-		if (check_ci_certificates(cc_data))
+	switch (id)
+	{
+		case 8:         /* CICAM_BrandCert */
+		case 14:        /* DHPM */
+		case 16:        /* CICAM_DevCert */
+		case 18:        /* Signature_B */
+			/* this results in CICAM_ID when cert-chain is verified and ok */
+			if (check_ci_certificates(cc_data))
+				break;
+			/* generate DHSK & AKH */
+			check_dh_challenge(cc_data);
+			break;
+
+		case 19:        /* auth_nonce - triggers new dh keychallenge - invalidates DHSK & AKH */
+			/* generate DHPH & Signature_A */
+			restart_dh_challenge(cc_data);
+			break;
+
+		case 21:        /* Ns_module - triggers SAC key calculation */
+			generate_ns_host(cc_data);
+			generate_key_seed(cc_data);
+			generate_SAK_SEK(cc_data->sak, cc_data->sek, cc_data->ks_host);
+			break;
+
+		/* SAC data messages */
+
+		case 6:                 //CICAM_id
+		case 12:                //keyprecursor
+			check_new_key(cc_data);
+			break;
+		case 26:                //programm number
+		case 25:                //uri_message
+			generate_uri_confirm(cc_data, cc_data->sak);
+			break;
+		case 28:                //key register
+			check_new_key(cc_data);
+			break;
+
+		default:
+			printf("%s -> %s unhandled ID (%d)\n", FILENAME, __FUNCTION__, id);
 			break;
-		/* generate DHSK & AKH */
-		check_dh_challenge(cc_data);
-		break;
-
-	case 19:        /* auth_nonce - triggers new dh keychallenge - invalidates DHSK & AKH */
-		/* generate DHPH & Signature_A */
-		restart_dh_challenge(cc_data);
-		break;
-
-	case 21:        /* Ns_module - triggers SAC key calculation */
-		generate_ns_host(cc_data);
-		generate_key_seed(cc_data);
-		generate_SAK_SEK(cc_data->sak, cc_data->sek, cc_data->ks_host);
-		break;
-
-	/* SAC data messages */
-
-	case 6:                 //CICAM_id
-	case 12:                //keyprecursor
-		check_new_key(cc_data);
-		break;
-	case 26:				//programm number
-	case 25:                //uri_message
-		generate_uri_confirm(cc_data, cc_data->sak);
-		break;
-	case 28:                //key register
-		check_new_key(cc_data);
-		break;
-
-	default:
-		printf("%s -> %s unhandled ID (%d)\n", FILENAME, __FUNCTION__, id);
-		break;
 	}
 
 	return 0;
@@ -951,22 +1003,24 @@
 #if x_debug
 	printf("%s -> %s ID = (%d)\n", FILENAME, __FUNCTION__, id);
 #endif
-	switch (id) {
-	case 22:                /* AKH */
+	switch (id)
 	{
-		uint8_t akh[32], host_id[8];
-		memset(akh, 0, sizeof(akh));
-		if (cc_data->akh_index != 5) {
-			if (!get_authdata(host_id, cc_data->dhsk, akh, cc_data->slot->slot, cc_data->akh_index++))
-				cc_data->akh_index = 5;
-			if (!element_set(cc_data, 22, akh, 32))
-				printf("cannot set AKH in elements\n");
-			if (!element_set(cc_data, 5, host_id, 8))
-				printf("cannot set host_id in elements\n");
+		case 22:                /* AKH */
+		{
+			uint8_t akh[32], host_id[8];
+			memset(akh, 0, sizeof(akh));
+			if (cc_data->akh_index != 5)
+			{
+				if (!get_authdata(host_id, cc_data->dhsk, akh, cc_data->slot->slot, cc_data->akh_index++))
+					cc_data->akh_index = 5;
+				if (!element_set(cc_data, 22, akh, 32))
+					printf("cannot set AKH in elements\n");
+				if (!element_set(cc_data, 5, host_id, 8))
+					printf("cannot set host_id in elements\n");
+			}
 		}
-	}
-	default:
-		break;
+		default:
+			break;
 	}
 
 	return 0;
@@ -980,7 +1034,8 @@
 #if x_debug
 	printf("%s -> %s\n", FILENAME, __FUNCTION__);
 #endif
-	for (i = 0; i < items; i++) {
+	for (i = 0; i < items; i++)
+	{
 		if (pos + 3 > datalen)
 			return 0;
 
@@ -1020,14 +1075,16 @@
 	if (items > datalen)
 		return -1;
 
-	for (i = 0; i < items; i++) {
+	for (i = 0; i < items; i++)
+	{
 		dt_id = *data++;
 #if x_debug
 		printf("req element %d\n", dt_id);
 #endif
 		data_req_handle_new(cc_data, dt_id);    /* check if there is any action needed before we answer */
 		len = element_get_req(cc_data, dest, dt_id);
-		if (len == 0) {
+		if (len == 0)
+		{
 			printf("cannot get element %d\n", dt_id);
 			return -1;
 		}
@@ -1054,13 +1111,15 @@
 
 	printf("%s -> %s\n", FILENAME, __FUNCTION__);
 
-	if (tslot->private_data) {
+	if (tslot->private_data)
+	{
 		fprintf(stderr, "strange private_data not null!\n");
 		return false;
 	}
 
-	data = (struct cc_ctrl_data*)calloc(1, sizeof(struct cc_ctrl_data));
-	if (!data) {
+	data = (struct cc_ctrl_data *)calloc(1, sizeof(struct cc_ctrl_data));
+	if (!data)
+	{
 		fprintf(stderr, "out of memory\n");
 		return false;
 	}
@@ -1084,7 +1143,8 @@
 
 	/* load first AKH */
 	data->akh_index = 0;
-	if (!get_authdata(host_id, data->dhsk, buf, tslot->slot, data->akh_index)) {
+	if (!get_authdata(host_id, data->dhsk, buf, tslot->slot, data->akh_index))
+	{
 		/* no AKH available */
 		memset(buf, 0, sizeof(buf));
 		data->akh_index = 5;    /* last one */
@@ -1114,7 +1174,7 @@
 
 bool eDVBCIContentControlManagerSession::ci_ccmgr_cc_data_req(eDVBCISlot *tslot, const uint8_t *data, unsigned int len)
 {
-	struct cc_ctrl_data *cc_data = (struct cc_ctrl_data*)(tslot->private_data);
+	struct cc_ctrl_data *cc_data = (struct cc_ctrl_data *)(tslot->private_data);
 	uint8_t cc_data_cnf_tag[3] = { 0x9f, 0x90, 0x04 };
 	uint8_t dest[2048 * 2];
 	int dt_nr;
@@ -1143,7 +1203,8 @@
 	dest[1] = dt_nr;
 
 	answ_len = data_req_loop(cc_data, &dest[2], &data[rp], len - rp, dt_nr);
-	if (answ_len <= 0) {
+	if (answ_len <= 0)
+	{
 		fprintf(stderr, "cannot req data\n");
 		return false;
 	}
@@ -1157,9 +1218,9 @@
 
 void eDVBCIContentControlManagerSession::ci_ccmgr_cc_sac_sync_req(eDVBCISlot *tslot, const uint8_t *data, unsigned int
 #if y_debug
- len
+    len
 #endif
- )
+)
 {
 	const uint8_t sync_cnf_tag[3] = { 0x9f, 0x90, 0x10 };
 	uint8_t dest[64];
@@ -1193,7 +1254,7 @@
 
 bool eDVBCIContentControlManagerSession::ci_ccmgr_cc_sac_send(eDVBCISlot *tslot, const uint8_t *tag, uint8_t *data, unsigned int pos)
 {
-	struct cc_ctrl_data *cc_data = (struct cc_ctrl_data*)(tslot->private_data);
+	struct cc_ctrl_data *cc_data = (struct cc_ctrl_data *)(tslot->private_data);
 	printf("%s -> %s (%02X%02X%02X) \n", FILENAME, __FUNCTION__, tag[0], tag[1], tag[2]);
 
 	if (pos < 8)
@@ -1217,7 +1278,7 @@
 
 bool eDVBCIContentControlManagerSession::ci_ccmgr_cc_sac_data_req(eDVBCISlot *tslot, const uint8_t *data, unsigned int len)
 {
-	struct cc_ctrl_data *cc_data = (struct cc_ctrl_data*)(tslot->private_data);
+	struct cc_ctrl_data *cc_data = (struct cc_ctrl_data *)(tslot->private_data);
 	const uint8_t data_cnf_tag[3] = { 0x9f, 0x90, 0x08 };
 	uint8_t dest[2048];
 	uint8_t tmp[len];
@@ -1240,7 +1301,8 @@
 		printf("%02x ", data[i]);
 	printf("\n");
 #endif
-	if (!sac_check_auth(data, len, cc_data->sak)) {
+	if (!sac_check_auth(data, len, cc_data->sak))
+	{
 		fprintf(stderr, "check_auth of message failed\n");
 		return false;
 	}
@@ -1269,7 +1331,8 @@
 	dest[pos++] = dt_nr;    /* dt_nbr */
 
 	answ_len = data_req_loop(cc_data, &dest[pos], &data[rp], len - rp, dt_nr);
-	if (answ_len <= 0) {
+	if (answ_len <= 0)
+	{
 		fprintf(stderr, "cannot req data\n");
 		return false;
 	}
@@ -1294,7 +1357,7 @@
 
 void eDVBCIContentControlManagerSession::ci_ccmgr_doClose(eDVBCISlot *tslot)
 {
-	struct cc_ctrl_data *data = (struct cc_ctrl_data*)(tslot->private_data);
+	struct cc_ctrl_data *data = (struct cc_ctrl_data *)(tslot->private_data);
 	printf("%s -> %s\n", FILENAME, __FUNCTION__);
 
 	descrambler_deinit();
@@ -1309,23 +1372,35 @@
 	printf("SESSION(%d)/CC %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
 #if y_debug
 	for (int i = 0; i < len; i++)
-		printf("%02x ", ((const unsigned char*)data)[i]);
+		printf("%02x ", ((const unsigned char *)data)[i]);
 #endif
 	printf("\n");
 
-	if ((tag[0] == 0x9f) && (tag[1] == 0x90)) {
-		switch (tag[2]) {
-		case 0x01: ci_ccmgr_cc_open_cnf(slot); break;
-		case 0x03: ci_ccmgr_cc_data_req(slot, (const uint8_t*)data, len); break;
-		case 0x05: ci_ccmgr_cc_sync_req(); break;
-		case 0x07: ci_ccmgr_cc_sac_data_req(slot, (const uint8_t*)data, len); break;
-		case 0x09: ci_ccmgr_cc_sac_sync_req(slot, (const uint8_t*)data, len); break;
-		default:
-			fprintf(stderr, "unknown apdu tag %02x\n", tag[2]);
-			break;
+	if ((tag[0] == 0x9f) && (tag[1] == 0x90))
+	{
+		switch (tag[2])
+		{
+			case 0x01:
+				ci_ccmgr_cc_open_cnf(slot);
+				break;
+			case 0x03:
+				ci_ccmgr_cc_data_req(slot, (const uint8_t *)data, len);
+				break;
+			case 0x05:
+				ci_ccmgr_cc_sync_req();
+				break;
+			case 0x07:
+				ci_ccmgr_cc_sac_data_req(slot, (const uint8_t *)data, len);
+				break;
+			case 0x09:
+				ci_ccmgr_cc_sac_sync_req(slot, (const uint8_t *)data, len);
+				break;
+			default:
+				fprintf(stderr, "unknown apdu tag %02x\n", tag[2]);
+				break;
 		}
 	}
-	
+
 	return 0;
 }
 
@@ -1342,7 +1417,7 @@
 		}
 		case stateFinal:
 			printf("stateFinal und action! kann doch garnicht sein ;)\n");
-			// fall through
+		// fall through
 		default:
 			return 0;
 	}
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_ccmgr.h libstb-hal-ddt.git/libdvbci/dvbci_ccmgr.h
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_ccmgr.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/dvbci_ccmgr.h	2022-07-23 18:18:31.507772949 +0200
@@ -5,23 +5,24 @@
 
 class eDVBCIContentControlManagerSession: public eDVBCISession
 {
-	bool data_initialize(eDVBCISlot *tslot);
-	bool ci_ccmgr_cc_data_req(eDVBCISlot *tslot, const uint8_t *data, unsigned int len);
-	bool ci_ccmgr_cc_sac_data_req(eDVBCISlot *tslot, const uint8_t *data, unsigned int len);
-	bool ci_ccmgr_cc_sac_send(eDVBCISlot *tslot, const uint8_t *tag, uint8_t *data, unsigned int pos);
-	void ci_ccmgr_cc_sac_sync_req(eDVBCISlot *tslot, const uint8_t *data, unsigned int len);
-	void ci_ccmgr_cc_sync_req();
-	void ci_ccmgr_cc_open_cnf(eDVBCISlot *slot);
+		bool data_initialize(eDVBCISlot *tslot);
+		bool ci_ccmgr_cc_data_req(eDVBCISlot *tslot, const uint8_t *data, unsigned int len);
+		bool ci_ccmgr_cc_sac_data_req(eDVBCISlot *tslot, const uint8_t *data, unsigned int len);
+		bool ci_ccmgr_cc_sac_send(eDVBCISlot *tslot, const uint8_t *tag, uint8_t *data, unsigned int pos);
+		void ci_ccmgr_cc_sac_sync_req(eDVBCISlot *tslot, const uint8_t *data, unsigned int len);
+		void ci_ccmgr_cc_sync_req();
+		void ci_ccmgr_cc_open_cnf(eDVBCISlot *slot);
 
-	enum {
-		stateFinal=statePrivate
-	};
-	int receivedAPDU(const unsigned char *tag, const void *data, int len);
-	int doAction();
-public:
-	eDVBCIContentControlManagerSession(eDVBCISlot *tslot);
-	~eDVBCIContentControlManagerSession();
-	void ci_ccmgr_doClose(eDVBCISlot *tslot);
-	void resendKey(eDVBCISlot *tslot);
+		enum
+		{
+			stateFinal = statePrivate
+		};
+		int receivedAPDU(const unsigned char *tag, const void *data, int len);
+		int doAction();
+	public:
+		eDVBCIContentControlManagerSession(eDVBCISlot *tslot);
+		~eDVBCIContentControlManagerSession();
+		void ci_ccmgr_doClose(eDVBCISlot *tslot);
+		void resendKey(eDVBCISlot *tslot);
 };
 #endif
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_datetimemgr.cpp libstb-hal-ddt.git/libdvbci/dvbci_datetimemgr.cpp
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_datetimemgr.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libdvbci/dvbci_datetimemgr.cpp	2022-07-23 18:18:31.507772949 +0200
@@ -22,7 +22,7 @@
 {
 	printf("[CI DT] SESSION(%d)/DATETIME %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
 	for (int i = 0; i < len; i++)
-		printf("%02x ", ((const unsigned char*)data)[i]);
+		printf("%02x ", ((const unsigned char *)data)[i]);
 	printf("\n");
 
 	if ((tag[0] == 0x9f) && (tag[1] == 0x84))
@@ -52,7 +52,7 @@
 			return 0;
 		case stateFinal:
 			printf("stateFinal und action! kann doch garnicht sein ;)\n");
-			// fall through
+		// fall through
 		default:
 			return 0;
 	}
@@ -66,7 +66,7 @@
 	unsigned char msg[7] = {0, 0, 0, 0, 0, 0, 0};
 	printf("[CI DT] -> %s\n", __FUNCTION__);
 	time_t t = time(NULL);
-	if ( gmtime_r(&t, &tm_gmt) && localtime_r(&t, &tm_loc) )
+	if (gmtime_r(&t, &tm_gmt) && localtime_r(&t, &tm_loc))
 	{
 		int Y = tm_gmt.tm_year;
 		int M = tm_gmt.tm_mon + 1;
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_datetimemgr.h libstb-hal-ddt.git/libdvbci/dvbci_datetimemgr.h
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_datetimemgr.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/dvbci_datetimemgr.h	2022-07-23 18:18:31.507772949 +0200
@@ -5,15 +5,16 @@
 
 class eDVBCIDateTimeSession: public eDVBCISession
 {
-	enum {
-		stateFinal=statePrivate, stateSendDateTime
-	};
-	int receivedAPDU(const unsigned char *tag, const void *data, int len);
-	int doAction();
-public:
-	eDVBCIDateTimeSession(eDVBCISlot *tslot);
-	~eDVBCIDateTimeSession();
-	void sendDateTime();
+		enum
+		{
+			stateFinal = statePrivate, stateSendDateTime
+		};
+		int receivedAPDU(const unsigned char *tag, const void *data, int len);
+		int doAction();
+	public:
+		eDVBCIDateTimeSession(eDVBCISlot *tslot);
+		~eDVBCIDateTimeSession();
+		void sendDateTime();
 };
 
 #endif
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_mmi.cpp libstb-hal-ddt.git/libdvbci/dvbci_mmi.cpp
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_mmi.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/dvbci_mmi.cpp	2022-07-23 18:18:31.507772949 +0200
@@ -17,7 +17,7 @@
 eDVBCIMMISession::~eDVBCIMMISession()
 {
 	/* Send a message to Neutrino cam_menu handler */
-	CA_MESSAGE* pMsg = (CA_MESSAGE*) malloc(sizeof(CA_MESSAGE));
+	CA_MESSAGE *pMsg = (CA_MESSAGE *) malloc(sizeof(CA_MESSAGE));
 	memset(pMsg, 0, sizeof(CA_MESSAGE));
 
 	pMsg->MsgId = CA_MESSAGE_MSG_MMI_CLOSE;
@@ -34,7 +34,7 @@
 {
 	printf("[CI MMI] SESSION(%d)/MMI %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
 	for (int i = 0; i < len; i++)
-		printf("%02x ", ((const unsigned char*)data)[i]);
+		printf("%02x ", ((const unsigned char *)data)[i]);
 	printf("\n");
 
 	if ((tag[0] == 0x9f) && (tag[1] == 0x88))
@@ -45,7 +45,7 @@
 			case 0x00: /* close */
 			{
 				/* Send a message to Neutrino cam_menu handler */
-				CA_MESSAGE* pMsg = (CA_MESSAGE*) malloc(sizeof(CA_MESSAGE));
+				CA_MESSAGE *pMsg = (CA_MESSAGE *) malloc(sizeof(CA_MESSAGE));
 				memset(pMsg, 0, sizeof(CA_MESSAGE));
 
 				pMsg->MsgId = CA_MESSAGE_MSG_MMI_CLOSE;
@@ -61,10 +61,10 @@
 				break;
 			case 0x07: /* menu enq */
 			{
-				MMI_ENQUIRY_INFO* enquiry = (MMI_ENQUIRY_INFO*) malloc(sizeof(MMI_ENQUIRY_INFO));
+				MMI_ENQUIRY_INFO *enquiry = (MMI_ENQUIRY_INFO *) malloc(sizeof(MMI_ENQUIRY_INFO));
 				memset(enquiry, 0, sizeof(MMI_ENQUIRY_INFO));
-				unsigned char *d = (unsigned char*)data;
-				unsigned char *max = ((unsigned char*)d) + len;
+				unsigned char *d = (unsigned char *)data;
+				unsigned char *max = ((unsigned char *)d) + len;
 
 				int textlen = len - 2;
 				if ((d + 2) > max)
@@ -77,7 +77,7 @@
 					break;
 
 				char str[textlen + 1];
-				memcpy(str, ((char*)d), textlen);
+				memcpy(str, ((char *)d), textlen);
 				str[textlen] = '\0';
 				printf("enq-text: %s", str);
 				enquiry->slot = slot->slot;
@@ -86,14 +86,14 @@
 				strcpy(enquiry->enquiryText, str);
 
 				/* Send a message to Neutrino cam_menu handler */
-				CA_MESSAGE* pMsg = (CA_MESSAGE*) malloc(sizeof(CA_MESSAGE));
+				CA_MESSAGE *pMsg = (CA_MESSAGE *) malloc(sizeof(CA_MESSAGE));
 				memset(pMsg, 0, sizeof(CA_MESSAGE));
 
 				pMsg->MsgId = CA_MESSAGE_MSG_MMI_REQ_INPUT;
 				pMsg->SlotType = CA_SLOT_TYPE_CI;
 				pMsg->Slot = slot->slot;
 				pMsg->Flags = CA_MESSAGE_HAS_PARAM1_DATA;
-				pMsg->Msg.Data[0] = (uint8_t*)enquiry;
+				pMsg->Msg.Data[0] = (uint8_t *)enquiry;
 				cCA::GetInstance()->SendMessage(pMsg);
 
 				slot->mmiOpened = true;
@@ -102,14 +102,14 @@
 			case 0x09: /* menu last */
 			case 0x0c: /* list last */
 			{
-				MMI_MENU_LIST_INFO* listInfo = (MMI_MENU_LIST_INFO*) malloc(sizeof(MMI_MENU_LIST_INFO));
+				MMI_MENU_LIST_INFO *listInfo = (MMI_MENU_LIST_INFO *) malloc(sizeof(MMI_MENU_LIST_INFO));
 				memset(listInfo, 0, sizeof(MMI_MENU_LIST_INFO));
 
 				listInfo->slot = slot->slot;
 				listInfo->choice_nb = 0;
 
-				unsigned char *d = (unsigned char*)data;
-				unsigned char *max = ((unsigned char*)d) + len;
+				unsigned char *d = (unsigned char *)data;
+				unsigned char *max = ((unsigned char *)d) + len;
 				int pos = 0;
 
 				if (tag[2] == 0x09)
@@ -142,7 +142,7 @@
 						break;
 
 					char str[textlen + 1];
-					memcpy(str, ((char*)d), textlen);
+					memcpy(str, ((char *)d), textlen);
 					str[textlen] = '\0';
 
 					int type = pos++;
@@ -168,27 +168,27 @@
 				if (tag[2] == 0x09)
 				{
 					/* Send a message to Neutrino cam_menu handler */
-					CA_MESSAGE* pMsg = (CA_MESSAGE*) malloc(sizeof(CA_MESSAGE));
+					CA_MESSAGE *pMsg = (CA_MESSAGE *) malloc(sizeof(CA_MESSAGE));
 					memset(pMsg, 0, sizeof(CA_MESSAGE));
 
 					pMsg->MsgId = CA_MESSAGE_MSG_MMI_MENU;
 					pMsg->SlotType = CA_SLOT_TYPE_CI;
 					pMsg->Slot = slot->slot;
 					pMsg->Flags = CA_MESSAGE_HAS_PARAM1_DATA;
-					pMsg->Msg.Data[0] = (uint8_t*)listInfo;
+					pMsg->Msg.Data[0] = (uint8_t *)listInfo;
 					cCA::GetInstance()->SendMessage(pMsg);
 				}
 				else
 				{
 					/* Send a message to Neutrino cam_menu handler */
-					CA_MESSAGE* pMsg = (CA_MESSAGE*) malloc(sizeof(CA_MESSAGE));
+					CA_MESSAGE *pMsg = (CA_MESSAGE *) malloc(sizeof(CA_MESSAGE));
 					memset(pMsg, 0, sizeof(CA_MESSAGE));
 
 					pMsg->MsgId = CA_MESSAGE_MSG_MMI_LIST;
 					pMsg->SlotType = CA_SLOT_TYPE_CI;
 					pMsg->Slot = slot->slot;
 					pMsg->Flags = CA_MESSAGE_HAS_PARAM1_DATA;
-					pMsg->Msg.Data[0] = (uint8_t*)listInfo;
+					pMsg->Msg.Data[0] = (uint8_t *)listInfo;
 					cCA::GetInstance()->SendMessage(pMsg);
 				}
 			}
@@ -245,7 +245,7 @@
 
 int eDVBCIMMISession::answerText(int answer)
 {
-	printf("[CI MMI] eDVBCIMMISession::answerText(%d)\n",answer);
+	printf("[CI MMI] eDVBCIMMISession::answerText(%d)\n", answer);
 
 	unsigned char tag[] = {0x9f, 0x88, 0x0B};
 	unsigned char data[] = {0x00};
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_mmi.h libstb-hal-ddt.git/libdvbci/dvbci_mmi.h
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_mmi.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/dvbci_mmi.h	2022-07-23 18:18:31.507772949 +0200
@@ -5,20 +5,21 @@
 
 class eDVBCIMMISession: public eDVBCISession
 {
-	enum {
-		stateDisplayReply=statePrivate, stateFakeOK, stateIdle
-	};
+		enum
+		{
+			stateDisplayReply = statePrivate, stateFakeOK, stateIdle
+		};
 
-	int receivedAPDU(const unsigned char *tag, const void *data, int len);
-	int doAction();
-	eDVBCISlot *slot;
-public:
-	eDVBCIMMISession(eDVBCISlot *tslot);
-	~eDVBCIMMISession();
-	int stopMMI();
-	int answerText(int answer);
-	int answerEnq(char *answer, int len);
-	int cancelEnq();
+		int receivedAPDU(const unsigned char *tag, const void *data, int len);
+		int doAction();
+		eDVBCISlot *slot;
+	public:
+		eDVBCIMMISession(eDVBCISlot *tslot);
+		~eDVBCIMMISession();
+		int stopMMI();
+		int answerText(int answer);
+		int answerEnq(char *answer, int len);
+		int cancelEnq();
 };
 
 #endif
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_resmgr.cpp libstb-hal-ddt.git/libdvbci/dvbci_resmgr.cpp
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_resmgr.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libdvbci/dvbci_resmgr.cpp	2022-07-23 18:18:31.507772949 +0200
@@ -9,7 +9,7 @@
 	if (len)
 	{
 		for (int i = 0; i < len; i++)
-			printf("%02x ", ((const unsigned char*)data)[i]);
+			printf("%02x ", ((const unsigned char *)data)[i]);
 		printf("\n");
 	}
 	if ((tag[0] == 0x9f) && (tag[1] == 0x80))
@@ -27,7 +27,7 @@
 					printf("nothing");
 				else
 					for (int i = 0; i < len; i++)
-						printf("%02x ", ((const unsigned char*)data)[i]);
+						printf("%02x ", ((const unsigned char *)data)[i]);
 				printf("\n");
 
 				if (state == stateFirstProfileEnquiry)
@@ -76,16 +76,16 @@
 			{
 				const unsigned char data[][4] =
 				{
-					{0x00, 0x01, 0x00, 0x41},	// resource
-					{0x00, 0x02, 0x00, 0x41},	// application V1
-					{0x00, 0x02, 0x00, 0x43},	// application V3
-					{0x00, 0x03, 0x00, 0x41},	// conditional access
-					{0x00, 0x20, 0x00, 0x41},	// host control (dummy)
-					{0x00, 0x40, 0x00, 0x41},	// mmi
-					{0x00, 0x24, 0x00, 0x41},	// date-time
-					{0x00, 0x8c, 0x10, 0x01},	// content control
-					{0x00, 0x8e, 0x10, 0x01}	// cam upgrade (dummy)
-//					{0x00, 0x10, 0x00, 0x41}	// auth.
+					{0x00, 0x01, 0x00, 0x41},   // resource
+					{0x00, 0x02, 0x00, 0x41},   // application V1
+					{0x00, 0x02, 0x00, 0x43},   // application V3
+					{0x00, 0x03, 0x00, 0x41},   // conditional access
+					{0x00, 0x20, 0x00, 0x41},   // host control (dummy)
+					{0x00, 0x40, 0x00, 0x41},   // mmi
+					{0x00, 0x24, 0x00, 0x41},   // date-time
+					{0x00, 0x8c, 0x10, 0x01},   // content control
+					{0x00, 0x8e, 0x10, 0x01}    // cam upgrade (dummy)
+//					{0x00, 0x10, 0x00, 0x41} // auth.
 				};
 				sendAPDU(tag, data, sizeof(data));
 			}
@@ -93,14 +93,14 @@
 			{
 				const unsigned char data[][4] =
 				{
-					{0x00, 0x01, 0x00, 0x41},	// resource
-					{0x00, 0x02, 0x00, 0x41},	// application V1
-					{0x00, 0x02, 0x00, 0x43},	// application V3
-					{0x00, 0x03, 0x00, 0x41},	// conditional access
-//					{0x00, 0x20, 0x00, 0x41},	// host control
-					{0x00, 0x40, 0x00, 0x41},	// mmi
-					{0x00, 0x24, 0x00, 0x41}	// date-time
-//					{0x00, 0x10, 0x00, 0x41}	// auth.
+					{0x00, 0x01, 0x00, 0x41},   // resource
+					{0x00, 0x02, 0x00, 0x41},   // application V1
+					{0x00, 0x02, 0x00, 0x43},   // application V3
+					{0x00, 0x03, 0x00, 0x41},   // conditional access
+//					{0x00, 0x20, 0x00, 0x41},    // host control
+					{0x00, 0x40, 0x00, 0x41},   // mmi
+					{0x00, 0x24, 0x00, 0x41}    // date-time
+//					{0x00, 0x10, 0x00, 0x41} // auth.
 				};
 				sendAPDU(tag, data, sizeof(data));
 			}
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_resmgr.h libstb-hal-ddt.git/libdvbci/dvbci_resmgr.h
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_resmgr.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/dvbci_resmgr.h	2022-07-23 18:18:31.507772949 +0200
@@ -5,15 +5,16 @@
 
 class eDVBCIResourceManagerSession: public eDVBCISession
 {
-	enum {
-		stateFirstProfileEnquiry=statePrivate,
-		stateProfileChange,
-		stateProfileEnquiry,
-		stateFinal
-	};
-	int receivedAPDU(const unsigned char *tag, const void *data, int len);
-	int doAction();
-public:
+		enum
+		{
+			stateFirstProfileEnquiry = statePrivate,
+			stateProfileChange,
+			stateProfileEnquiry,
+			stateFinal
+		};
+		int receivedAPDU(const unsigned char *tag, const void *data, int len);
+		int doAction();
+	public:
 
 };
 
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_session.cpp libstb-hal-ddt.git/libdvbci/dvbci_session.cpp
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_session.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libdvbci/dvbci_session.cpp	2022-07-23 18:18:31.507772949 +0200
@@ -12,7 +12,7 @@
 #include "dvbci_mmi.h"
 #include "dvbci_ccmgr.h"
 
-eDVBCISession* eDVBCISession::sessions[SLMS];
+eDVBCISession *eDVBCISession::sessions[SLMS];
 
 eDVBCIHostControlSession::eDVBCIHostControlSession(eDVBCISlot *tslot)
 {
@@ -23,11 +23,11 @@
 {
 }
 
-int eDVBCIHostControlSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
+int eDVBCIHostControlSession::receivedAPDU(const unsigned char *tag, const void *data, int len)
 {
 	printf("CI HC SESSION(%d)/TAG %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
-	for (int i=0; i<len; i++)
-		printf("%02x ", ((const unsigned char*)data)[i]);
+	for (int i = 0; i < len; i++)
+		printf("%02x ", ((const unsigned char *)data)[i]);
 	printf("\n");
 	return 0;
 }
@@ -161,7 +161,7 @@
 	}
 }
 
-eDVBCISession* eDVBCISession::createSession(eDVBCISlot *slot, const unsigned char *resource_identifier, unsigned char &status)
+eDVBCISession *eDVBCISession::createSession(eDVBCISlot *slot, const unsigned char *resource_identifier, unsigned char &status)
 {
 	unsigned long tag;
 	unsigned short session_nb;
@@ -207,13 +207,13 @@
 			sessions[session_nb - 1] = new eDVBCIMMISession(slot);
 			printf("[CI SESS] MMI - create session\n");
 			break;
-		if (cCA::GetInstance()->CheckCerts())
-		{
+			if (cCA::GetInstance()->CheckCerts())
+			{
 			case 0x008c1001:
 				printf("[CI SESS] CC MANAGER\n");
 				sessions[session_nb - 1] = new eDVBCIContentControlManagerSession(slot);
 				break;
-		} // fall through
+			} // fall through
 		case 0x00200041:
 			sessions[session_nb - 1] = new eDVBCIHostControlSession(slot);
 			printf("[CI SESS] Host Control\n");
@@ -222,7 +222,7 @@
 //			session=new eDVBCIAuthSession;
 			printf("[CI SESS] AuthSession\n");
 //			break;
-		  // fall through
+		// fall through
 		case 0x008e1001:
 		default:
 			printf("[CI SESS] unknown resource type %02x %02x %02x %02x\n", resource_identifier[0], resource_identifier[1], resource_identifier[2], resource_identifier[3]);
@@ -284,18 +284,18 @@
 
 void eDVBCISession::receiveData(eDVBCISlot *slot, const unsigned char *ptr, size_t len)
 {
-	if ((ptr[0] == 0x90 || ptr[0] == 0x95) && (ptr[3] == 0 ))
+	if ((ptr[0] == 0x90 || ptr[0] == 0x95) && (ptr[3] == 0))
 	{
 		printf("[CI SESS] ****Mist: %02x %02x %02x %02x\n", ptr[0], ptr[1], ptr[2], ptr[3]);
 	}
-	const unsigned char *pkt = (const unsigned char*)ptr;
+	const unsigned char *pkt = (const unsigned char *)ptr;
 	unsigned char tag = *pkt++;
 	int llen, hlen;
 
-	printf("[CI SESS] receiveData slot: %p > ",slot);
+	printf("[CI SESS] receiveData slot: %p > ", slot);
 
 #if 0
-	for(unsigned int i = 0; i < len; i++)
+	for (unsigned int i = 0; i < len; i++)
 		printf("%02x ", ptr[i]);
 #endif
 	printf("\n");
@@ -303,9 +303,9 @@
 	llen = parseLengthField(pkt, hlen);
 	pkt += llen;
 
-	eDVBCISession* session = NULL;
+	eDVBCISession *session = NULL;
 
-	if(tag == 0x91)
+	if (tag == 0x91)
 	{
 		unsigned char status;
 
@@ -357,7 +357,7 @@
 
 	hlen += llen + 1; // lengthfield and tag
 
-	pkt = ((const unsigned char*)ptr) + hlen;
+	pkt = ((const unsigned char *)ptr) + hlen;
 	len -= hlen;
 
 	if (session)
diff -Nur libstb-hal-ddt.git.orig/libdvbci/dvbci_session.h libstb-hal-ddt.git/libdvbci/dvbci_session.h
--- libstb-hal-ddt.git.orig/libdvbci/dvbci_session.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libdvbci/dvbci_session.h	2022-07-23 18:18:31.507772949 +0200
@@ -11,53 +11,68 @@
 
 class eDVBCISession
 {
-	static eDVBCISession* sessions[SLMS];
-	static eDVBCISession* createSession(eDVBCISlot *slot, const unsigned char *resource_identifier, unsigned char &status);
-	static void sendSPDU(eDVBCISlot *slot, unsigned char tag,const void *data, int len, unsigned short session_nb, const void *apdu = 0, int alen = 0);
-	static void sendOpenSessionResponse(eDVBCISlot *slot,unsigned char session_status, const unsigned char *resource_identifier, unsigned short session_nb);
-	void recvCreateSessionResponse(const unsigned char *data);
-	void recvCloseSessionRequest(const unsigned char *data);
-protected:
-	int state;
-	int status;
-	int action;
-	eDVBCISlot *slot;
-	unsigned short session_nb;
-	virtual int receivedAPDU(const unsigned char *tag, const void *data, int len) = 0;
-	void sendAPDU(const unsigned char *tag, const void *data=0,int len=0);
-	virtual int doAction() = 0;
-	void handleClose();
-public:
-	virtual ~eDVBCISession();
-
-	static void deleteSessions(const eDVBCISlot *slot);
-	void sendSPDU(unsigned char tag, const void *data, int len, const void *apdu = 0, int alen = 0);
-
-	int poll() { if (action) { action=doAction(); return 1; } return 0; }
-	enum { stateInCreation, stateBusy, stateInDeletion, stateStarted, statePrivate};
-
-	static int parseLengthField(const unsigned char *pkt, int &len);
-	static int buildLengthField(unsigned char *pkt, int len);
+		static eDVBCISession *sessions[SLMS];
+		static eDVBCISession *createSession(eDVBCISlot *slot, const unsigned char *resource_identifier, unsigned char &status);
+		static void sendSPDU(eDVBCISlot *slot, unsigned char tag, const void *data, int len, unsigned short session_nb, const void *apdu = 0, int alen = 0);
+		static void sendOpenSessionResponse(eDVBCISlot *slot, unsigned char session_status, const unsigned char *resource_identifier, unsigned short session_nb);
+		void recvCreateSessionResponse(const unsigned char *data);
+		void recvCloseSessionRequest(const unsigned char *data);
+	protected:
+		int state;
+		int status;
+		int action;
+		eDVBCISlot *slot;
+		unsigned short session_nb;
+		virtual int receivedAPDU(const unsigned char *tag, const void *data, int len) = 0;
+		void sendAPDU(const unsigned char *tag, const void *data = 0, int len = 0);
+		virtual int doAction() = 0;
+		void handleClose();
+	public:
+		virtual ~eDVBCISession();
+
+		static void deleteSessions(const eDVBCISlot *slot);
+		void sendSPDU(unsigned char tag, const void *data, int len, const void *apdu = 0, int alen = 0);
+
+		int poll()
+		{
+			if (action)
+			{
+				action = doAction();
+				return 1;
+			}
+			return 0;
+		}
+		enum { stateInCreation, stateBusy, stateInDeletion, stateStarted, statePrivate};
+
+		static int parseLengthField(const unsigned char *pkt, int &len);
+		static int buildLengthField(unsigned char *pkt, int len);
+
+		static void receiveData(eDVBCISlot *slot, const unsigned char *ptr, size_t len);
+
+		int getState()
+		{
+			return state;
+		}
+		int getStatus()
+		{
+			return status;
+		}
 
-	static void receiveData(eDVBCISlot *slot, const unsigned char *ptr, size_t len);
-
-	int getState() { return state; }
-	int getStatus() { return status; }
-
-	static int pollAll();
+		static int pollAll();
 };
 
 class eDVBCIHostControlSession: public eDVBCISession
 {
-	enum {
-		stateFinal=statePrivate
-	};
-	eDVBCISlot *slot;
-	int receivedAPDU(const unsigned char *tag,const void *data, int len);
-	int doAction();
-public:
-	eDVBCIHostControlSession(eDVBCISlot *tslot);
-	~eDVBCIHostControlSession();
+		enum
+		{
+			stateFinal = statePrivate
+		};
+		eDVBCISlot *slot;
+		int receivedAPDU(const unsigned char *tag, const void *data, int len);
+		int doAction();
+	public:
+		eDVBCIHostControlSession(eDVBCISlot *tslot);
+		~eDVBCIHostControlSession();
 };
 
 
diff -Nur libstb-hal-ddt.git.orig/libdvbci/misc.cpp libstb-hal-ddt.git/libdvbci/misc.cpp
--- libstb-hal-ddt.git.orig/libdvbci/misc.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libdvbci/misc.cpp	2022-07-23 18:18:31.507772949 +0200
@@ -16,12 +16,14 @@
 	const char *urnd = "/dev/urandom";
 
 	fd = open(urnd, O_RDONLY);
-	if (fd <= 0) {
+	if (fd <= 0)
+	{
 		printf("cannot open %s\n", urnd);
 		return -1;
 	}
 
-	if (read(fd, dest, len) != len) {
+	if (read(fd, dest, len) != len)
+	{
 		printf("cannot read from %s\n", urnd);
 		close(fd);
 		return -2;
@@ -37,11 +39,13 @@
 	int i;
 
 	*len = 0;
-	if (!(*pkt & 0x80)) {
+	if (!(*pkt & 0x80))
+	{
 		*len = *pkt;
 		return 1;
 	}
-	for (i = 0; i < (pkt[0] & 0x7F); ++i) {
+	for (i = 0; i < (pkt[0] & 0x7F); ++i)
+	{
 		*len <<= 8;
 		*len |= pkt[i + 1];
 	}
@@ -53,7 +57,8 @@
 	uint8_t padding = 0x80;
 	int count = 0;
 
-	while (len & (blocklen - 1)) {
+	while (len & (blocklen - 1))
+	{
 		*dest++ = padding;
 		++len;
 		++count;
@@ -84,7 +89,7 @@
 	int i;
 
 	for (i = 0; i < len; i += 2)
-		*dst++ = (get_bin_from_nibble(data[i]) << 4) | get_bin_from_nibble(data[i + 1]);
+		* dst++ = (get_bin_from_nibble(data[i]) << 4) | get_bin_from_nibble(data[i + 1]);
 }
 
 uint32_t UINT32(const unsigned char *in, unsigned int len)
@@ -92,7 +97,8 @@
 	uint32_t val = 0;
 	unsigned int i;
 
-	for (i = 0; i < len; i++) {
+	for (i = 0; i < len; i++)
+	{
 		val <<= 8;
 		val |= *in++;
 	}
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/container/buff_ffmpeg.c libstb-hal-ddt.git/libeplayer3/container/buff_ffmpeg.c
--- libstb-hal-ddt.git.orig/libeplayer3/container/buff_ffmpeg.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/container/buff_ffmpeg.c	2022-07-23 18:18:31.515772788 +0200
@@ -107,7 +107,7 @@
 		 * this is the reason for additional validation when we what to close immediately
 		 */
 		if (!progressive_playback && 0 == ret && currPts >= maxInjectedPts &&
-		        ((currPts - maxInjectedPts) / 90000) < 2)
+		    ((currPts - maxInjectedPts) / 90000) < 2)
 		{
 			/* close immediately
 			 */
@@ -271,7 +271,7 @@
 	}
 
 	while ((flag == 0 && avContextTab[0] != NULL && avContextTab[0]->pb != NULL && rwdiff > FILLBUFDIFF) ||
-	       (flag == 1 && hasfillerThreadStarted[id] == 1 && avContextTab[0] != NULL && avContextTab[0]->pb != NULL && rwdiff > FILLBUFDIFF))
+	    (flag == 1 && hasfillerThreadStarted[id] == 1 && avContextTab[0] != NULL && avContextTab[0]->pb != NULL && rwdiff > FILLBUFDIFF))
 	{
 		if (0 == PlaybackDieNow(0))
 		{
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/container/container_ffmpeg.c libstb-hal-ddt.git/libeplayer3/container/container_ffmpeg.c
--- libstb-hal-ddt.git.orig/libeplayer3/container/container_ffmpeg.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/container/container_ffmpeg.c	2022-07-23 18:18:31.515772788 +0200
@@ -182,9 +182,7 @@
 
 #include "buff_ffmpeg.c"
 #include "wrapped_ffmpeg.c"
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(56, 34, 100)
 #include "mpeg4p2_ffmpeg.c"
-#endif
 
 #ifdef HAVE_FLV2MPEG4_CONVERTER
 #include "flv2mpeg4_ffmpeg.c"
@@ -223,7 +221,7 @@
 /* MISC Functions                */
 /* ***************************** */
 
-static void __attribute__ ((unused)) ffmpeg_silen_callback(void *avcl __attribute__((unused)), int level __attribute__((unused)), const char *fmt __attribute__((unused)), va_list vl __attribute__((unused)))
+static void __attribute__((unused)) ffmpeg_silen_callback(void *avcl __attribute__((unused)), int level __attribute__((unused)), const char *fmt __attribute__((unused)), va_list vl __attribute__((unused)))
 {
 	return;
 }
@@ -565,9 +563,8 @@
 	uint64_t out_channel_layout = AV_CH_LAYOUT_STEREO;
 	uint32_t cAVIdx = 0;
 
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(56, 34, 100)
 	Mpeg4P2Context *mpeg4p2_context = mpeg4p2_context_open();
-#endif
+
 #ifdef HAVE_FLV2MPEG4_CONVERTER
 	Flv2Mpeg4Context flv2mpeg4_context;
 	memset(&flv2mpeg4_context, 0, sizeof(Flv2Mpeg4Context));
@@ -734,9 +731,9 @@
 					break;
 				}
 			}
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(56, 34, 100)
+
 			mpeg4p2_context_reset(mpeg4p2_context);
-#endif
+
 #ifdef HAVE_FLV2MPEG4_CONVERTER
 			flv2mpeg4_context_reset(&flv2mpeg4_context);
 #endif
@@ -823,7 +820,6 @@
 
 			if (videoTrack && (videoTrack->AVIdx == (int)cAVIdx) && (videoTrack->Id == pid))
 			{
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(56, 34, 100)
 				AVCodecContext *codec_context = videoTrack->avCodecCtx;
 				if (codec_context && codec_context->codec_id == AV_CODEC_ID_MPEG4 && NULL != mpeg4p2_context)
 				{
@@ -831,7 +827,6 @@
 					update_max_injected_pts(latestPts);
 				}
 				else
-#endif
 #ifdef HAVE_FLV2MPEG4_CONVERTER
 					if (get_codecpar(avContextTab[cAVIdx]->streams[packet.stream_index])->codec_id == AV_CODEC_ID_FLV1 &&
 					    0 == memcmp(videoTrack->Encoding, "V_MPEG4", 7))
@@ -1124,7 +1119,7 @@
 							if (e < 0)
 							{
 								ffmpeg_err("swr_init: %d (icl=%d ocl=%d isr=%d osr=%d isf=%d osf=%d\n",
-								           -e, (int32_t)c->channel_layout, (int32_t)out_channel_layout, c->sample_rate, out_sample_rate, c->sample_fmt, AV_SAMPLE_FMT_S16);
+								    -e, (int32_t)c->channel_layout, (int32_t)out_channel_layout, c->sample_rate, out_sample_rate, c->sample_fmt, AV_SAMPLE_FMT_S16);
 								swr_free(&swr);
 								swr = NULL;
 							}
@@ -1140,11 +1135,11 @@
 							continue;
 						}
 						int64_t next_in_pts = av_rescale(wrapped_frame_get_best_effort_timestamp(decoded_frame),
-						                                 ((AVStream *) audioTrack->stream)->time_base.num * (int64_t)out_sample_rate * c->sample_rate,
-						                                 ((AVStream *) audioTrack->stream)->time_base.den);
+						        ((AVStream *) audioTrack->stream)->time_base.num * (int64_t)out_sample_rate * c->sample_rate,
+						        ((AVStream *) audioTrack->stream)->time_base.den);
 						int64_t next_out_pts = av_rescale(swr_next_pts(swr, next_in_pts),
-						                                  ((AVStream *) audioTrack->stream)->time_base.den,
-						                                  ((AVStream *) audioTrack->stream)->time_base.num * (int64_t)out_sample_rate * c->sample_rate);
+						        ((AVStream *) audioTrack->stream)->time_base.den,
+						        ((AVStream *) audioTrack->stream)->time_base.num * (int64_t)out_sample_rate * c->sample_rate);
 
 						currentAudioPts = audioTrack->pts = pts = calcPts(cAVIdx, audioTrack->stream, next_out_pts);
 						out_samples = swr_convert(swr, &output[0], out_samples, (const uint8_t **) &decoded_frame->data[0], in_samples);
@@ -1269,7 +1264,7 @@
 				/*
 				if(ffmpegStatus == AVERROR(EAGAIN))
 				{
-					continue;
+				    continue;
 				}
 				*/
 				ffmpegStatus = 0;
@@ -1344,9 +1339,7 @@
 		wrapped_frame_free(&decoded_frame);
 	}
 
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(56, 34, 100)
 	mpeg4p2_context_close(mpeg4p2_context);
-#endif
 
 	hasPlayThreadStarted = 0;
 	context->playback->isPlaying = 0;
@@ -1354,7 +1347,7 @@
 	do_seek_target_seconds = 0;
 	PlaybackDieNow(1);
 
-	if(context && context->playback)
+	if (context && context->playback)
 	{
 		container_ffmpeg_stop(context);
 	}
@@ -1533,7 +1526,7 @@
 	int32_t err = 0;
 	AVInputFormat *fmt = NULL;
 	avContextTab[AVIdx] = avformat_alloc_context();
-	if(avContextTab[AVIdx] != NULL)
+	if (avContextTab[AVIdx] != NULL)
 	{
 		avContextTab[AVIdx]->interrupt_callback.callback = interrupt_cb;
 		avContextTab[AVIdx]->interrupt_callback.opaque = context->playback;
@@ -1555,7 +1548,7 @@
 		avio_ctx = container_ffmpeg_get_avio_context(custom_io_tab[AVIdx], 4096);
 		if (avio_ctx)
 		{
-			if(avContextTab[AVIdx])
+			if (avContextTab[AVIdx])
 			{
 				avContextTab[AVIdx]->pb = avio_ctx;
 				use_custom_io[AVIdx] = 1;
@@ -1774,7 +1767,7 @@
 			{
 				int len = strlen(baseUri) + 2 + 1;
 				filename = malloc(len);
-				snprintf(filename,len,"ff%s",baseUri);
+				snprintf(filename, len, "ff%s", baseUri);
 				free(baseUri);
 				// memory leak, only once, so does not matter
 			}
@@ -1786,7 +1779,7 @@
 		}
 	}
 	else if (0 == strncmp(filename, "http://", 7) ||
-	         0 == strncmp(filename, "https://", 8))
+	    0 == strncmp(filename, "https://", 8))
 	{
 		av_dict_set(&avio_opts, "timeout", "20000000", 0); //20sec
 		av_dict_set(&avio_opts, "reconnect", "1", 0);
@@ -1827,9 +1820,16 @@
 			return cERR_CONTAINER_FFMPEG_OPEN;
 		}
 	}
-	if(avContextTab[AVIdx] != NULL)
+	if (avContextTab[AVIdx] != NULL)
 	{
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
 		avContextTab[AVIdx]->iformat->flags |= AVFMT_SEEK_TO_PTS;
+#else
+		if (!(avContextTab[AVIdx]->iformat->flags & AVFMT_SEEK_TO_PTS)) {
+			printf("[container_ffmpeg.c] - AVFMT_SEEK_TO_PTS not available - FIXME, FFMPEG 4.5 has problems with some VOB/MPG...\n");
+			return false; // FIXME, FFMPEG 4.5 has problems with some VOB/MPG...
+		}
+#endif
 		avContextTab[AVIdx]->flags = AVFMT_FLAG_GENPTS;
 	}
 	printf("minimal Probe: %d\n", context->playback->noprobe);
@@ -1879,7 +1879,7 @@
 		}
 		else if (progressive_playback)
 		{
-			if(avContextTab[AVIdx] != NULL)
+			if (avContextTab[AVIdx] != NULL)
 				avContextTab[AVIdx]->pb->read_packet = ffmpeg_read_wrapper;
 		}
 	}
@@ -1938,7 +1938,7 @@
 
 	context->playback->abortRequested = 0;
 	int32_t res = container_ffmpeg_init_av_context(context, playFilesNames->szFirstFile, playFilesNames->iFirstFileSize, \
-	              playFilesNames->szFirstMoovAtomFile, playFilesNames->iFirstMoovAtomOffset, 0);
+	        playFilesNames->szFirstMoovAtomFile, playFilesNames->iFirstMoovAtomOffset, 0);
 
 	if (0 != res)
 	{
@@ -1948,7 +1948,7 @@
 	if (playFilesNames->szSecondFile && playFilesNames->szSecondFile[0] != '\0')
 	{
 		res = container_ffmpeg_init_av_context(context, playFilesNames->szSecondFile, playFilesNames->iSecondFileSize, \
-		      playFilesNames->szSecondMoovAtomFile, playFilesNames->iSecondMoovAtomOffset, 1);
+		        playFilesNames->szSecondMoovAtomFile, playFilesNames->iSecondMoovAtomOffset, 1);
 	}
 
 	if (0 != res)
@@ -2071,7 +2071,7 @@
 			if (title)
 				snprintf(str, sizeof(str), "%s (%d - %d)", title->value, chstart, chend);
 			else
-				snprintf(str, sizeof(str), "%d (%d - %d)", i+1, chstart, chend);
+				snprintf(str, sizeof(str), "%d (%d - %d)", i + 1, chstart, chend);
 			chstart = (double) 1000 * ch->start * av_q2d(ch->time_base);
 			track.Name      = str;
 			track.Encoding  = "chapter";
@@ -2119,9 +2119,9 @@
 			}
 
 			encoding = Codec2Encoding((int32_t)get_codecpar(stream)->codec_id, (int32_t)get_codecpar(stream)->codec_type, \
-			                          (uint8_t *)get_codecpar(stream)->extradata, \
-			                          (int)get_codecpar(stream)->extradata_size, \
-			                          (int)get_codecpar(stream)->profile, &version);
+			        (uint8_t *)get_codecpar(stream)->extradata, \
+			        (int)get_codecpar(stream)->extradata_size, \
+			        (int)get_codecpar(stream)->profile, &version);
 
 			if (encoding != NULL && !strncmp(encoding, "A_IPCM", 6) && insert_pcm_as_lpcm)
 			{
@@ -2287,7 +2287,11 @@
 							{
 								ffmpeg_printf(10, " Handle inject_as_pcm = %d\n", track.inject_as_pcm);
 
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
 								AVCodec *codec = avcodec_find_decoder(get_codecpar(stream)->codec_id);
+#else
+								const AVCodec *codec = avcodec_find_decoder(get_codecpar(stream)->codec_id);
+#endif
 
 								int errorCode = avcodec_open2(track.avCodecCtx, codec, NULL);
 								if (codec != NULL && !errorCode)
@@ -2408,9 +2412,9 @@
 
 						}
 						else if (get_codecpar(stream)->codec_id == AV_CODEC_ID_WMAV1 ||
-						         get_codecpar(stream)->codec_id == AV_CODEC_ID_WMAV2 ||
-						         get_codecpar(stream)->codec_id == AV_CODEC_ID_WMAPRO ||
-						         get_codecpar(stream)->codec_id == AV_CODEC_ID_WMALOSSLESS) //if (get_codecpar(stream)->extradata_size > 0)
+						    get_codecpar(stream)->codec_id == AV_CODEC_ID_WMAV2 ||
+						    get_codecpar(stream)->codec_id == AV_CODEC_ID_WMAPRO ||
+						    get_codecpar(stream)->codec_id == AV_CODEC_ID_WMALOSSLESS) //if (get_codecpar(stream)->extradata_size > 0)
 						{
 							ffmpeg_printf(10, "Create WMA ExtraData\n");
 							uint16_t channels = get_codecpar(stream)->channels;
@@ -2560,7 +2564,8 @@
 							ffmpeg_printf(1, "cAVIdx[%d]: MANAGER_ADD track AUDIO\n", cAVIdx);
 							if (context->manager->audio->Command(context, MANAGER_ADD, &track) < 0)
 							{
-								if(track.aacbuf){
+								if (track.aacbuf)
+								{
 									free(track.aacbuf);
 									track.aacbuf = NULL;
 								}
@@ -2785,7 +2790,7 @@
 					fclose(io->pFile);
 				if (io->pMoovFile)
 					fclose(io->pMoovFile);
-				if(custom_io_tab[i] != NULL)
+				if (custom_io_tab[i] != NULL)
 				{
 					free(custom_io_tab[i]);
 					custom_io_tab[i] = NULL;
@@ -3287,6 +3292,55 @@
 	*pp++ = NULL;
 	*pp = NULL;
 
+	// find the first attached picture, if available
+	unlink("/tmp/.id3coverart");
+	for (unsigned int i = 0; i < avContextTab[0]->nb_streams; i++)
+	{
+		if (avContextTab[0]->streams[i]->disposition & AV_DISPOSITION_ATTACHED_PIC)
+		{
+			AVPacket *pkt = NULL;
+			pkt = av_packet_clone(&avContextTab[0]->streams[i]->attached_pic);
+			FILE *cover_art = fopen("/tmp/.id3coverart", "wb");
+			if (cover_art)
+			{
+				fwrite(pkt->data, pkt->size, 1, cover_art);
+				fclose(cover_art);
+			}
+			av_packet_free(&pkt);
+			break;
+		}
+	}
+
+	return cERR_CONTAINER_FFMPEG_NO_ERROR;
+}
+
+static int container_ffmpeg_av_context(Context_t *context, AVFormatContext *ext_avContext)
+{
+	if (!context)
+	{
+		fprintf(stderr, "BUG %s:%d\n", __func__, __LINE__);
+		return cERR_CONTAINER_FFMPEG_ERR;
+	}
+	if (avContextTab[0] != NULL)
+	{
+		getMutex(__FILE__, __FUNCTION__, __LINE__);
+		ext_avContext->streams = avContextTab[0]->streams;
+		ext_avContext->nb_streams = avContextTab[0]->nb_streams;
+		releaseMutex(__FILE__, __FUNCTION__, __LINE__);
+	}
+	else if ((avContextTab[0] == NULL) && (avContextTab[1] != NULL))
+	{
+		getMutex(__FILE__, __FUNCTION__, __LINE__);
+		ext_avContext->streams = avContextTab[1]->streams;
+		ext_avContext->nb_streams = avContextTab[1]->nb_streams;
+		releaseMutex(__FILE__, __FUNCTION__, __LINE__);
+	}
+	else
+	{
+		ext_avContext->streams = NULL;
+		ext_avContext->nb_streams = 0;
+	}
+
 	return cERR_CONTAINER_FFMPEG_NO_ERROR;
 }
 
@@ -3383,6 +3437,11 @@
 			ret = container_ffmpeg_get_metadata(context, (char ***)argument);
 			break;
 		}
+		case CONTAINER_GET_AVFCONTEXT:
+		{
+			ret = container_ffmpeg_av_context(context, (AVFormatContext *)argument);
+			break;
+		}
 		default:
 			ffmpeg_err("ContainerCmd %d not supported!\n", command);
 			ret = cERR_CONTAINER_FFMPEG_ERR;
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/container/flv2mpeg4_ffmpeg.c libstb-hal-ddt.git/libeplayer3/container/flv2mpeg4_ffmpeg.c
--- libstb-hal-ddt.git.orig/libeplayer3/container/flv2mpeg4_ffmpeg.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/container/flv2mpeg4_ffmpeg.c	2022-07-23 18:18:31.515772788 +0200
@@ -92,4 +92,3 @@
 
 	return flv2mpeg4_process_flv_packet(mpeg4p2_ctx->ctx, 0, pkt->data, pkt->size, time_ms);
 }
-
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/container/mpeg4p2_ffmpeg.c libstb-hal-ddt.git/libeplayer3/container/mpeg4p2_ffmpeg.c
--- libstb-hal-ddt.git.orig/libeplayer3/container/mpeg4p2_ffmpeg.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/container/mpeg4p2_ffmpeg.c	2022-07-23 18:18:31.515772788 +0200
@@ -3,6 +3,10 @@
 // http://forums.openpli.org/topic/39326-gstreamer10-and-mpeg4-part2/?hl=%2Bmpeg4+%2Bpart2
 //
 
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(59,0,100)
+#include "libavcodec/bsf.h"
+#endif
+
 // mpeg4_unpack_bframes
 typedef struct
 {
@@ -141,4 +145,3 @@
 		return;
 	}
 }
-
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/container/wrapped_ffmpeg.c libstb-hal-ddt.git/libeplayer3/container/wrapped_ffmpeg.c
--- libstb-hal-ddt.git.orig/libeplayer3/container/wrapped_ffmpeg.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/container/wrapped_ffmpeg.c	2022-07-23 18:18:31.515772788 +0200
@@ -3,6 +3,12 @@
  * allows to compile and use exteplayer3
  * with old ffmpeg libs
  */
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(59,0,100)
+//extern "C" {
+#include <libavcodec/avcodec.h>
+//}
+#endif
+
 static void wrapped_frame_free(void *param)
 {
 #if (LIBAVCODEC_VERSION_MAJOR >= 55)
@@ -207,5 +213,3 @@
 	return frame->best_effort_timestamp;
 #endif
 }
-
-
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/external/ffmpeg/get_bits.h libstb-hal-ddt.git/libeplayer3/external/ffmpeg/get_bits.h
--- libstb-hal-ddt.git.orig/libeplayer3/external/ffmpeg/get_bits.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/external/ffmpeg/get_bits.h	2022-07-23 18:18:31.515772788 +0200
@@ -389,7 +389,7 @@
  * @return 0 on success, AVERROR_INVALIDDATA if the buffer_size would overflow.
  */
 static inline int init_get_bits(GetBitContext *s, const uint8_t *buffer,
-                                int bit_size)
+    int bit_size)
 {
 	int buffer_size;
 	int ret = 0;
@@ -421,7 +421,7 @@
  * @return 0 on success, AVERROR_INVALIDDATA if the buffer_size would overflow.
  */
 static inline int init_get_bits8(GetBitContext *s, const uint8_t *buffer,
-                                 int byte_size)
+    int byte_size)
 {
 	if (byte_size > INT_MAX / 8 || byte_size < 0)
 		byte_size = -1;
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/external/ffmpeg/mpeg4audio.h libstb-hal-ddt.git/libeplayer3/external/ffmpeg/mpeg4audio.h
--- libstb-hal-ddt.git.orig/libeplayer3/external/ffmpeg/mpeg4audio.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/external/ffmpeg/mpeg4audio.h	2022-07-23 18:18:31.519772708 +0200
@@ -54,7 +54,7 @@
  * @return On error -1 is returned, on success AudioSpecificConfig bit index in extradata.
  */
 int avpriv_mpeg4audio_get_config(MPEG4AudioConfig *c, const uint8_t *buf,
-                                 int bit_size, int sync_extension);
+    int bit_size, int sync_extension);
 
 enum AudioObjectType
 {
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/external/ffmpeg/put_bits.h libstb-hal-ddt.git/libeplayer3/external/ffmpeg/put_bits.h
--- libstb-hal-ddt.git.orig/libeplayer3/external/ffmpeg/put_bits.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/external/ffmpeg/put_bits.h	2022-07-23 18:18:31.519772708 +0200
@@ -47,7 +47,7 @@
  * @param buffer_size the size in bytes of buffer
  */
 static inline void init_put_bits(PutBitContext *s, uint8_t *buffer,
-                                 int buffer_size)
+    int buffer_size)
 {
 	if (buffer_size < 0)
 	{
@@ -71,7 +71,7 @@
  *                    must be larger than the previous size
  */
 static inline void rebase_put_bits(PutBitContext *s, uint8_t *buffer,
-                                   int buffer_size)
+    int buffer_size)
 {
 	av_assert0(8 * buffer_size > s->size_in_bits);
 
@@ -138,7 +138,7 @@
  * @param terminate_string 0-terminates the written string if value is 1
  */
 void avpriv_put_string(PutBitContext *pb, const char *string,
-                       int terminate_string);
+    int terminate_string);
 
 /**
  * Copy the content of src to the bitstream.
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/external/ffmpeg/src/mpeg4audio.c libstb-hal-ddt.git/libeplayer3/external/ffmpeg/src/mpeg4audio.c
--- libstb-hal-ddt.git.orig/libeplayer3/external/ffmpeg/src/mpeg4audio.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/external/ffmpeg/src/mpeg4audio.c	2022-07-23 18:18:31.519772708 +0200
@@ -80,7 +80,7 @@
 }
 
 int avpriv_mpeg4audio_get_config(MPEG4AudioConfig *c, const uint8_t *buf,
-                                 int bit_size, int sync_extension)
+    int bit_size, int sync_extension)
 {
 	GetBitContext gb;
 	int specific_config_bitindex, ret;
@@ -100,8 +100,8 @@
 	c->sbr = -1;
 	c->ps  = -1;
 	if (c->object_type == AOT_SBR || (c->object_type == AOT_PS &&
-	    // check for W6132 Annex YYYY draft MP3onMP4
-	    !(show_bits(&gb, 3) & 0x03 && !(show_bits(&gb, 9) & 0x3F))))
+	        // check for W6132 Annex YYYY draft MP3onMP4
+	        !(show_bits(&gb, 3) & 0x03 && !(show_bits(&gb, 9) & 0x3F))))
 	{
 		if (c->object_type == AOT_PS)
 			c->ps = 1;
@@ -165,8 +165,8 @@
 }
 
 static av_always_inline unsigned int copy_bits(PutBitContext *pb,
-        GetBitContext *gb,
-        int bits)
+    GetBitContext *gb,
+    int bits)
 {
 	unsigned int el = get_bits(gb, bits);
 	put_bits(pb, bits, el);
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/external/flv2mpeg4/src/flv2mpeg4.c libstb-hal-ddt.git/libeplayer3/external/flv2mpeg4/src/flv2mpeg4.c
--- libstb-hal-ddt.git.orig/libeplayer3/external/flv2mpeg4/src/flv2mpeg4.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/external/flv2mpeg4/src/flv2mpeg4.c	2022-07-23 18:18:31.519772708 +0200
@@ -139,10 +139,10 @@
 
 		// write frame
 		if (pub_ctx->write_packet_cb(pub_ctx->usr_data,
-		                             0,
-		                             0,//c->frame,
-		                             bw->buf,
-		                             bw->pos) < 0)
+		        0,
+		        0,//c->frame,
+		        bw->buf,
+		        bw->pos) < 0)
 		{
 			return -1;
 		}
@@ -203,10 +203,10 @@
 
 	// write frame
 	if (pub_ctx->write_packet_cb(pub_ctx->usr_data,
-	                             vop.picture_type == M4V_I_TYPE,
-	                             0,//c->frame,
-	                             bw->buf,
-	                             bw->pos) < 0)
+	        vop.picture_type == M4V_I_TYPE,
+	        0,//c->frame,
+	        bw->buf,
+	        bw->pos) < 0)
 	{
 		return -1;
 	}
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/external/flv2mpeg4/src/m4vencode.c libstb-hal-ddt.git/libeplayer3/external/flv2mpeg4/src/m4vencode.c
--- libstb-hal-ddt.git.orig/libeplayer3/external/flv2mpeg4/src/m4vencode.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/external/flv2mpeg4/src/m4vencode.c	2022-07-23 18:18:31.519772708 +0200
@@ -115,8 +115,8 @@
 {
 #if 0
 	put_bits(p,
-	         7 + 2 + 1 + 6 + 1 + 12 + 1, //30bit
-	         (3 << 23) + (3 << 21) + (last << 20) + (run << 14) + (1 << 13) + (((level - 64) & 0xfff) << 1) + 1);
+	    7 + 2 + 1 + 6 + 1 + 12 + 1, //30bit
+	    (3 << 23) + (3 << 21) + (last << 20) + (run << 14) + (1 << 13) + (((level - 64) & 0xfff) << 1) + 1);
 #else
 	put_bits(p, 7, 3); // escape
 	put_bits(p, 2, 3); // escape3
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/include/bcm_ioctls.h libstb-hal-ddt.git/libeplayer3/include/bcm_ioctls.h
--- libstb-hal-ddt.git.orig/libeplayer3/include/bcm_ioctls.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/include/bcm_ioctls.h	2022-07-23 18:18:31.523772628 +0200
@@ -35,7 +35,6 @@
 	CT_VP9
 } video_codec_type_t;
 
-
 typedef enum
 {
 	STREAMTYPE_UNKNOWN = -1,
@@ -55,11 +54,9 @@
 	STREAMTYPE_DIVX5 = 15,
 	STREAMTYPE_VB6 = 18,
 	STREAMTYPE_SPARK = 21,
-	STREAMTYPE_MJPEG = 30,
+	STREAMTYPE_MJPEG = 30
 } video_stream_type_t;
 
-
-
 typedef enum
 {
 	AUDIOTYPE_UNKNOWN = -1,
@@ -79,8 +76,4 @@
 	AUDIOTYPE_RAW = 0x30
 } audio_stream_type_t;
 
-
-
-
 #endif /* H_DVB_BCM_H */
-
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/include/container.h libstb-hal-ddt.git/libeplayer3/include/container.h
--- libstb-hal-ddt.git.orig/libeplayer3/include/container.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/include/container.h	2022-07-23 18:18:31.523772628 +0200
@@ -25,7 +25,8 @@
 	CONTAINER_GET_BUFFER_SIZE,
 	CONTAINER_GET_BUFFER_STATUS,
 	CONTAINER_STOP_BUFFER,
-	CONTAINER_GET_METADATA
+	CONTAINER_GET_METADATA,
+	CONTAINER_GET_AVFCONTEXT
 } ContainerCmd_t;
 
 struct Context_s;
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/include/debug.h libstb-hal-ddt.git/libeplayer3/include/debug.h
--- libstb-hal-ddt.git.orig/libeplayer3/include/debug.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/include/debug.h	2022-07-23 18:18:31.523772628 +0200
@@ -6,7 +6,6 @@
 #define log_error(fmt, x...) do { printf("[%s:%s] " fmt, __FILENAME__, __FUNCTION__, ## x); } while (0)
 #define log_printf(maxlevel, level, fmt, x...) do { if (maxlevel >= level) printf("[%s:%s] " fmt, __FILENAME__, __FUNCTION__, ## x); } while (0)
 
-
 /*******************************************
  * ffmpeg
  *******************************************/
@@ -545,4 +544,4 @@
 #define mjpeg_err(...) log_error(__VA_ARGS__)
 #else
 #define mjpeg_err(...)
-#endif
\ No newline at end of file
+#endif
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/include/manager.h libstb-hal-ddt.git/libeplayer3/include/manager.h
--- libstb-hal-ddt.git.orig/libeplayer3/include/manager.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/include/manager.h	2022-07-23 18:18:31.523772628 +0200
@@ -25,7 +25,7 @@
 	MANAGER_UPDATED_TRACK_INFO,
 	MANAGER_REGISTER_UPDATED_TRACK_INFO,
 	MANAGER_REF_LIST,
-	MANAGER_REF_LIST_SIZE,
+	MANAGER_REF_LIST_SIZE
 } ManagerCmd_t;
 
 typedef enum
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/include/misc.h libstb-hal-ddt.git/libeplayer3/include/misc.h
--- libstb-hal-ddt.git.orig/libeplayer3/include/misc.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/include/misc.h	2022-07-23 18:18:31.523772628 +0200
@@ -26,7 +26,7 @@
 	STB_DREAMBOX,
 	STB_VUPLUS,
 	STB_HISILICON,
-	STB_OTHER = 999,
+	STB_OTHER = 999
 } stb_type_t;
 
 /* ***************************** */
@@ -64,16 +64,16 @@
 static inline uint32_t ReadUint32(uint8_t *buffer)
 {
 	uint32_t num = (uint32_t)buffer[0] << 24 |
-	               (uint32_t)buffer[1] << 16 |
-	               (uint32_t)buffer[2] << 8  |
-	               (uint32_t)buffer[3];
+	    (uint32_t)buffer[1] << 16 |
+	    (uint32_t)buffer[2] << 8  |
+	    (uint32_t)buffer[3];
 	return num;
 }
 
 static inline uint16_t ReadUInt16(uint8_t *buffer)
 {
 	uint16_t num = (uint16_t)buffer[0] << 8 |
-	               (uint16_t)buffer[1];
+	    (uint16_t)buffer[1];
 	return num;
 }
 
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/include/output.h libstb-hal-ddt.git/libeplayer3/include/output.h
--- libstb-hal-ddt.git.orig/libeplayer3/include/output.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/include/output.h	2022-07-23 18:18:31.523772628 +0200
@@ -29,7 +29,7 @@
 	OUTPUT_GET_FRAME_COUNT,
 	OUTPUT_GET_PROGRESSIVE,
 	OUTPUT_SET_BUFFER_SIZE,
-	OUTPUT_GET_BUFFER_SIZE,
+	OUTPUT_GET_BUFFER_SIZE
 } OutputCmd_t;
 
 typedef struct
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/include/pes.h libstb-hal-ddt.git/libeplayer3/include/pes.h
--- libstb-hal-ddt.git.orig/libeplayer3/include/pes.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/include/pes.h	2022-07-23 18:18:31.523772628 +0200
@@ -1,8 +1,8 @@
 #ifndef pes_123
 #define pes_123
 
-#define PES_HEADER_SIZE                         9							///< size of pes header
-#define PES_MAX_HEADER_SIZE                     (PES_HEADER_SIZE + 256)	///< maximal header size
+#define PES_HEADER_SIZE                         9                           ///< size of pes header
+#define PES_MAX_HEADER_SIZE                     (PES_HEADER_SIZE + 256) ///< maximal header size
 #define PES_PRIVATE_DATA_FLAG                   0x80
 #define PES_PRIVATE_DATA_LENGTH                 8
 #define PES_LENGTH_BYTE_0                       5
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/include/playback.h libstb-hal-ddt.git/libeplayer3/include/playback.h
--- libstb-hal-ddt.git.orig/libeplayer3/include/playback.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/include/playback.h	2022-07-23 18:18:31.523772628 +0200
@@ -7,7 +7,8 @@
 typedef void(* PlaybackDieNowCallback)();
 bool PlaybackDieNowRegisterCallback(PlaybackDieNowCallback callback);
 
-typedef enum {
+typedef enum
+{
 	PLAYBACK_OPEN,
 	PLAYBACK_CLOSE,
 	PLAYBACK_PLAY,
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/include/stm_ioctls.h libstb-hal-ddt.git/libeplayer3/include/stm_ioctls.h
--- libstb-hal-ddt.git.orig/libeplayer3/include/stm_ioctls.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/include/stm_ioctls.h	2022-07-23 18:18:31.523772628 +0200
@@ -129,7 +129,7 @@
 {
 	AUDIO_SPDIF_SOURCE_PP,  /*<! normal decoder output */
 	AUDIO_SPDIF_SOURCE_DEC, /*<! decoder output w/o post-proc */
-	AUDIO_SPDIF_SOURCE_ES,  /*<! raw elementary stream data */
+	AUDIO_SPDIF_SOURCE_ES   /*<! raw elementary stream data */
 } audio_spdif_source_t;
 
 typedef struct
@@ -154,7 +154,7 @@
 {
 	AUDIO_DISCONTINUITY_SKIP                = DVB_DISCONTINUITY_SKIP,
 	AUDIO_DISCONTINUITY_CONTINUOUS_REVERSE  = DVB_DISCONTINUITY_CONTINUOUS_REVERSE,
-	AUDIO_DISCONTINUITY_SURPLUS_DATA        = DVB_DISCONTINUITY_SURPLUS_DATA,
+	AUDIO_DISCONTINUITY_SURPLUS_DATA        = DVB_DISCONTINUITY_SURPLUS_DATA
 } audio_discontinuity_t;
 
 /*
@@ -164,7 +164,7 @@
 {
 	VIDEO_DISCONTINUITY_SKIP                = DVB_DISCONTINUITY_SKIP,
 	VIDEO_DISCONTINUITY_CONTINUOUS_REVERSE  = DVB_DISCONTINUITY_CONTINUOUS_REVERSE,
-	VIDEO_DISCONTINUITY_SURPLUS_DATA        = DVB_DISCONTINUITY_SURPLUS_DATA,
+	VIDEO_DISCONTINUITY_SURPLUS_DATA        = DVB_DISCONTINUITY_SURPLUS_DATA
 } video_discontinuity_t;
 
 #define DVB_TIME_NOT_BOUNDED            0xfedcba9876543210ULL
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/main/exteplayer.c libstb-hal-ddt.git/libeplayer3/main/exteplayer.c
--- libstb-hal-ddt.git.orig/libeplayer3/main/exteplayer.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/main/exteplayer.c	2022-07-23 18:18:31.527772547 +0200
@@ -261,16 +261,18 @@
 			{
 				int i = 0;
 				int Id = -1;
-				char * pch;
+				char *pch;
 				char Name[] = "          ";
 				fprintf(stderr, "{\"%c_%c\": [", argvBuff[0], argvBuff[1]);
 				for (i = 0; TrackList[i] != NULL; i += 2)
 				{
 					pch = strtok(TrackList[i], " ");
-					if (pch != NULL) {
+					if (pch != NULL)
+					{
 						Id = atoi(pch);
 						pch = strtok(NULL, " ");
-						if (pch != NULL) {
+						if (pch != NULL)
+						{
 							snprintf(Name, sizeof(Name), "%s", pch);
 						}
 					}
@@ -278,7 +280,7 @@
 					{
 						fprintf(stderr, ", ");
 					}
-					fprintf(stderr, "{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\"}", Id, TrackList[i+1], Name);
+					fprintf(stderr, "{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\"}", Id, TrackList[i + 1], Name);
 					free(TrackList[i]);
 					free(TrackList[i + 1]);
 				}
@@ -305,7 +307,7 @@
 				else // video
 				{
 					fprintf(stderr, "{\"%c_%c\":{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\",\"w\":%d,\"h\":%d,\"f\":%u,\"p\":%d,\"an\":%d,\"ad\":%d}}\n", \
-					        argvBuff[0], argvBuff[1], track->Id, track->Encoding, track->Name, track->width, track->height, track->frame_rate, track->progressive, track->aspect_ratio_num, track->aspect_ratio_den);
+					    argvBuff[0], argvBuff[1], track->Id, track->Encoding, track->Name, track->width, track->height, track->frame_rate, track->progressive, track->aspect_ratio_num, track->aspect_ratio_den);
 				}
 				free(track->Encoding);
 				free(track->Name);
@@ -343,7 +345,7 @@
 						if (NULL != TrackList)
 						{
 							int i = 0;
-							char * pch;
+							char *pch;
 							for (i = 0; TrackList[i] != NULL; i += 2)
 							{
 								if (idx == i)
@@ -433,7 +435,7 @@
 				else // video
 				{
 					fprintf(stderr, "{\"%c_%c\":{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\",\"w\":%d,\"h\":%d,\"f\":%u,\"p\":%d,\"an\":%d,\"ad\":%d}}\n", \
-					        argvBuff[0], argvBuff[1], track->Id, track->Encoding, track->Name, track->width, track->height, track->frame_rate, track->progressive, track->aspect_ratio_num, track->aspect_ratio_den);
+					    argvBuff[0], argvBuff[1], track->Id, track->Encoding, track->Name, track->width, track->height, track->frame_rate, track->progressive, track->aspect_ratio_num, track->aspect_ratio_den);
 				}
 				free(track->Encoding);
 				free(track->Name);
@@ -671,7 +673,7 @@
 			strcpy(playbackFiles->szFirstFile, "file://");
 		}
 		strcat(playbackFiles->szFirstFile, argv[optind]);
-		playbackFiles->szFirstFile[IPTV_MAX_FILE_PATH-1] = '\0';
+		playbackFiles->szFirstFile[IPTV_MAX_FILE_PATH - 1] = '\0';
 		map_inter_file_path(playbackFiles->szFirstFile);
 		printf("file: [%s]\n", playbackFiles->szFirstFile);
 		++optind;
@@ -1032,7 +1034,7 @@
 
 						if (g_player->container && g_player->container->selectedContainer)
 						{
-							commandRetVal = g_player->container->selectedContainer->Command((Context_t*)g_player->container, CONTAINER_LAST_PTS, &lastPts);
+							commandRetVal = g_player->container->selectedContainer->Command((Context_t *)g_player->container, CONTAINER_LAST_PTS, &lastPts);
 						}
 
 						if (0 == commandRetVal && lastPts != INVALID_PTS_VALUE)
@@ -1052,10 +1054,10 @@
 					if (ptrP)
 					{
 						fprintf(stderr, "{\"PLAYBACK_INFO\":{ \"isPlaying\":%s, \"isPaused\":%s, \"isForwarding\":%s, \"isSeeking\":%s, \"isCreationPhase\":%s,", \
-						        DUMP_BOOL(ptrP->isPlaying), DUMP_BOOL(ptrP->isPaused), DUMP_BOOL(ptrP->isForwarding), DUMP_BOOL(ptrP->isSeeking), DUMP_BOOL(ptrP->isCreationPhase));
+						    DUMP_BOOL(ptrP->isPlaying), DUMP_BOOL(ptrP->isPaused), DUMP_BOOL(ptrP->isForwarding), DUMP_BOOL(ptrP->isSeeking), DUMP_BOOL(ptrP->isCreationPhase));
 						fprintf(stderr, "\"BackWard\":%d, \"SlowMotion\":%d, \"Speed\":%d, \"AVSync\":%d,", ptrP->BackWard, ptrP->SlowMotion, ptrP->Speed, ptrP->AVSync);
 						fprintf(stderr, " \"isVideo\":%s, \"isAudio\":%s, \"isSubtitle\":%s, \"isDvbSubtitle\":%s, \"isTeletext\":%s, \"mayWriteToFramebuffer\":%s, \"abortRequested\":%s }}\n", \
-						        DUMP_BOOL(ptrP->isVideo), DUMP_BOOL(ptrP->isAudio), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(ptrP->abortRequested));
+						    DUMP_BOOL(ptrP->isVideo), DUMP_BOOL(ptrP->isAudio), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(ptrP->abortRequested));
 					}
 
 					break;
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/manager/audio.c libstb-hal-ddt.git/libeplayer3/manager/audio.c
--- libstb-hal-ddt.git.orig/libeplayer3/manager/audio.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/manager/audio.c	2022-07-23 18:18:31.527772547 +0200
@@ -85,7 +85,8 @@
 		if (Tracks[i].Id == track.Id)
 		{
 			Tracks[i].pending = 0;
-			if(track.aacbuf){
+			if (track.aacbuf)
+			{
 				free(track.aacbuf);
 				track.aacbuf = NULL;
 			}
@@ -153,7 +154,7 @@
 }
 
 #if 0
-static TrackDescription_t *ManagerList(Context_t  *context __attribute__((unused)))
+static TrackDescription_t *ManagerList(Context_t *context __attribute__((unused)))
 {
 	int i = 0;
 	TrackDescription_t *tracklist = NULL;
@@ -303,7 +304,7 @@
 		}
 		case MANAGER_GETENCODING:
 		{
-			if ((TrackCount > 0) && (CurrentTrack >= 0) && (Tracks[CurrentTrack].Encoding != NULL ))
+			if ((TrackCount > 0) && (CurrentTrack >= 0) && (Tracks[CurrentTrack].Encoding != NULL))
 			{
 				*((char **)argument) = (char *)strdup(Tracks[CurrentTrack].Encoding);
 			}
@@ -315,7 +316,7 @@
 		}
 		case MANAGER_GETNAME:
 		{
-			if ((TrackCount > 0) && (CurrentTrack >= 0))
+			if ((TrackCount > 0) && (CurrentTrack >= 0) && (Tracks[CurrentTrack].Name != NULL))
 			{
 				*((char **)argument) = (char *)strdup(Tracks[CurrentTrack].Name);
 			}
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/manager/chapter.c libstb-hal-ddt.git/libeplayer3/manager/chapter.c
--- libstb-hal-ddt.git.orig/libeplayer3/manager/chapter.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/manager/chapter.c	2022-07-23 18:18:31.527772547 +0200
@@ -152,7 +152,7 @@
 	}
 
 	chapter_mgr_printf(10, "%s::%s return %p (%d - %d)\n", FILENAME,
-	                   __FUNCTION__, tracklist, j, TrackCount);
+	    __FUNCTION__, tracklist, j, TrackCount);
 
 	return tracklist;
 }
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/manager/video.c libstb-hal-ddt.git/libeplayer3/manager/video.c
--- libstb-hal-ddt.git.orig/libeplayer3/manager/video.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/manager/video.c	2022-07-23 18:18:31.527772547 +0200
@@ -251,7 +251,7 @@
 		}
 		case MANAGER_GETENCODING:
 		{
-			if ((TrackCount > 0) && (CurrentTrack >= 0))
+			if ((TrackCount > 0) && (CurrentTrack >= 0) && (Tracks[CurrentTrack].Encoding != NULL))
 			{
 				*((char **)argument) = (char *)strdup(Tracks[CurrentTrack].Encoding);
 			}
@@ -263,7 +263,7 @@
 		}
 		case MANAGER_GETNAME:
 		{
-			if ((TrackCount > 0) && (CurrentTrack >= 0))
+			if ((TrackCount > 0) && (CurrentTrack >= 0) && (Tracks[CurrentTrack].Name != NULL))
 			{
 				*((char **)argument) = (char *)strdup(Tracks[CurrentTrack].Name);
 			}
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/linuxdvb_fake.c libstb-hal-ddt.git/libeplayer3/output/linuxdvb_fake.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/linuxdvb_fake.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/linuxdvb_fake.c	2022-07-23 18:18:31.527772547 +0200
@@ -231,7 +231,7 @@
 	audio = !strcmp("audio", out->type);
 
 	linuxdvb_printf(20, "DataLength=%u PrivateLength=%u Pts=%"PRIu64" FrameRate=%d\n",
-	                out->len, out->extralen, out->pts, out->frameRate);
+	    out->len, out->extralen, out->pts, out->frameRate);
 	linuxdvb_printf(20, "v%d a%d\n", video, audio);
 
 	if (video)
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/linuxdvb_mipsel.c libstb-hal-ddt.git/libeplayer3/output/linuxdvb_mipsel.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/linuxdvb_mipsel.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/linuxdvb_mipsel.c	2022-07-23 18:18:31.527772547 +0200
@@ -821,7 +821,7 @@
 	audio = !strcmp("audio", out->type);
 
 	linuxdvb_printf(20, "DataLength=%u PrivateLength=%u Pts=%" PRIu64 " FrameRate=%d\n",
-	                out->len, out->extralen, out->pts, out->frameRate);
+	    out->len, out->extralen, out->pts, out->frameRate);
 	linuxdvb_printf(20, "v%d a%d\n", video, audio);
 
 	if (video)
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/linuxdvb_sh4.c libstb-hal-ddt.git/libeplayer3/output/linuxdvb_sh4.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/linuxdvb_sh4.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/linuxdvb_sh4.c	2022-07-23 18:18:31.527772547 +0200
@@ -944,7 +944,7 @@
 
 static int Write(void *_context, void *_out)
 {
-	Context_t          *context  = (Context_t *) _context;
+	Context_t *context  = (Context_t *) _context;
 	AudioVideoOut_t    *out      = (AudioVideoOut_t *) _out;
 	int                ret       = cERR_LINUXDVB_NO_ERROR;
 	int                res       = 0;
@@ -963,7 +963,7 @@
 	audio = !strcmp("audio", out->type);
 
 	linuxdvb_printf(20, "DataLength=%u PrivateLength=%u Pts=%llu FrameRate=%f\n",
-	                out->len, out->extralen, out->pts, out->frameRate);
+	    out->len, out->extralen, out->pts, out->frameRate);
 	linuxdvb_printf(20, "v%d a%d\n", video, audio);
 
 	if (video)
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/common/misc.c libstb-hal-ddt.git/libeplayer3/output/writer/common/misc.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/common/misc.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/common/misc.c	2022-07-23 18:18:31.527772547 +0200
@@ -138,7 +138,7 @@
 			type = STB_DREAMBOX;
 		}
 		else if (access("/proc/stb/info/vumodel", F_OK) != -1 &&
-		         access("/proc/stb/info/boxtype", F_OK) == -1)
+		    access("/proc/stb/info/boxtype", F_OK) == -1)
 		{
 			// some STB like Octagon SF4008 has also /proc/stb/info/vumodel
 			// but VU PLUS does not have /proc/stb/info/boxtype
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/mipsel/aac.c libstb-hal-ddt.git/libeplayer3/output/writer/mipsel/aac.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/mipsel/aac.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/mipsel/aac.c	2022-07-23 18:18:31.527772547 +0200
@@ -169,7 +169,7 @@
 	else // check LOAS header
 	{
 		if (!(call->len > 2 && call->data[0] == 0x56 && (call->data[1] >> 4) == 0xe &&
-		     ((uint32_t)(AV_RB16(call->data + 1) & 0x1FFF) + 3) == call->len))
+		        ((uint32_t)(AV_RB16(call->data + 1) & 0x1FFF) + 3) == call->len))
 		{
 			aac_err("parsing Data with wrong latm header. ignoring...\n");
 			return 0;
@@ -213,7 +213,7 @@
 	}
 
 	if ((call->private_data && 0 == strncmp("ADTS", (const char *)call->private_data, call->private_size)) ||
-		HasADTSHeader(call->data, call->len))
+	    HasADTSHeader(call->data, call->len))
 	{
 		//printf("%hhx %hhx %hhx %hhx %hhx %hhx %hhx %hhx\n", call->data[0], call->data[1], call->data[2], call->data[3], call->data[4], call->data[5], call->data[6], call->data[7]);
 		return _writeData(call, 0);
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/mipsel/divx3.c libstb-hal-ddt.git/libeplayer3/output/writer/mipsel/divx3.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/mipsel/divx3.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/mipsel/divx3.c	2022-07-23 18:18:31.531772467 +0200
@@ -132,11 +132,11 @@
 		data += 38;
 		data[0] = B_GET_BITS(width, 11, 4);
 		data[1] = B_SET_BITS("width [3..0]", B_GET_BITS(width, 3, 0), 7, 4) |
-		          B_SET_BITS("'10'", 0x02, 3, 2) |
-		          B_SET_BITS("height [11..10]", B_GET_BITS(height, 11, 10), 1, 0);
+		    B_SET_BITS("'10'", 0x02, 3, 2) |
+		    B_SET_BITS("height [11..10]", B_GET_BITS(height, 11, 10), 1, 0);
 		data[2] = B_GET_BITS(height, 9, 2);
 		data[3] = B_SET_BITS("height [1.0]", B_GET_BITS(height, 1, 0), 7, 6) |
-		          B_SET_BITS("'100000'", 0x20, 5, 0);
+		    B_SET_BITS("'100000'", 0x20, 5, 0);
 
 		iov[ic].iov_base = brcm_divx311_sequence_header;
 		iov[ic++].iov_len = sizeof(brcm_divx311_sequence_header);
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/mipsel/h264.c libstb-hal-ddt.git/libeplayer3/output/writer/mipsel/h264.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/mipsel/h264.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/mipsel/h264.c	2022-07-23 18:18:31.531772467 +0200
@@ -335,8 +335,8 @@
 
 	/* AnnexA */
 	if (!avc3 && ((1 < call->private_size && 0 == call->private_data[0]) ||
-	             ((call->len > 3) && ((call->data[0] == 0x00 && call->data[1] == 0x00 && call->data[2] == 0x00 && call->data[3] == 0x01) ||
-	             (call->data[0] == 0xff && call->data[1] == 0xff && call->data[2] == 0xff && call->data[3] == 0xff)))))
+	        ((call->len > 3) && ((call->data[0] == 0x00 && call->data[1] == 0x00 && call->data[2] == 0x00 && call->data[3] == 0x01) ||
+	                (call->data[0] == 0xff && call->data[1] == 0xff && call->data[2] == 0xff && call->data[3] == 0xff)))))
 	{
 		uint32_t i = 0;
 		uint8_t InsertPrivData = !sps_pps_in_stream;
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/mipsel/pcm.c libstb-hal-ddt.git/libeplayer3/output/writer/mipsel/pcm.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/mipsel/pcm.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/mipsel/pcm.c	2022-07-23 18:18:31.531772467 +0200
@@ -137,7 +137,7 @@
 			case AV_CODEC_ID_PCM_S16LE:
 			case AV_CODEC_ID_PCM_U16LE:
 				LE = 1;
-				// fall through
+			// fall through
 			case AV_CODEC_ID_PCM_S16BE:
 			case AV_CODEC_ID_PCM_U16BE:
 				width = depth = 16;
@@ -145,7 +145,7 @@
 			case AV_CODEC_ID_PCM_S24LE:
 			case AV_CODEC_ID_PCM_U24LE:
 				LE = 1;
-				// fall through
+			// fall through
 			case AV_CODEC_ID_PCM_S24BE:
 			case AV_CODEC_ID_PCM_U24BE:
 				width = depth = 24;
@@ -153,7 +153,7 @@
 			case AV_CODEC_ID_PCM_S32LE:
 			case AV_CODEC_ID_PCM_U32LE:
 				LE = 1;
-				// fall through
+			// fall through
 			case AV_CODEC_ID_PCM_S32BE:
 			case AV_CODEC_ID_PCM_U32BE:
 				width = depth = 32;
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/mipsel/writer.c libstb-hal-ddt.git/libeplayer3/output/writer/mipsel/writer.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/mipsel/writer.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/mipsel/writer.c	2022-07-23 18:18:31.531772467 +0200
@@ -144,8 +144,8 @@
 
 		//if (retval == 0)
 		//{
-		//	//printf("RETURN FROM SELECT DUE TO TIMEOUT\n");
-		//	continue;
+		//  //printf("RETURN FROM SELECT DUE TO TIMEOUT\n");
+		//  continue;
 		//}
 
 		if (FD_ISSET(pipefd, &rfds))
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/aac.c libstb-hal-ddt.git/libeplayer3/output/writer/sh4/aac.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/aac.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/sh4/aac.c	2022-07-23 18:18:31.531772467 +0200
@@ -168,7 +168,7 @@
 	else // check LOAS header
 	{
 		if (!(call->len > 2 && call->data[0] == 0x56 && (call->data[1] >> 4) == 0xe &&
-		     (AV_RB16(call->data + 1) & 0x1FFF) + 3 == call->len))
+		        (AV_RB16(call->data + 1) & 0x1FFF) + 3 == call->len))
 		{
 			aac_err("parsing Data with wrong latm header. ignoring...\n");
 			return 0;
@@ -214,7 +214,7 @@
 	}
 
 	if ((call->private_data && 0 == strncmp("ADTS", call->private_data, call->private_size)) ||
-	     HasADTSHeader(call->data, call->len))
+	    HasADTSHeader(call->data, call->len))
 	{
 		return _writeData(_call, 0);
 	}
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/h264.c libstb-hal-ddt.git/libeplayer3/output/writer/sh4/h264.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/h264.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/sh4/h264.c	2022-07-23 18:18:31.531772467 +0200
@@ -237,8 +237,8 @@
 
 	/* AnnexA */
 	if (!avc3 && ((1 < call->private_size && 0 == call->private_data[0]) ||
-	             (call->len > 3) && ((call->data[0] == 0x00 && call->data[1] == 0x00 && call->data[2] == 0x00 && call->data[3] == 0x01) ||
-	             (call->data[0] == 0xff && call->data[1] == 0xff && call->data[2] == 0xff && call->data[3] == 0xff))))
+	        (call->len > 3) && ((call->data[0] == 0x00 && call->data[1] == 0x00 && call->data[2] == 0x00 && call->data[3] == 0x01) ||
+	            (call->data[0] == 0xff && call->data[1] == 0xff && call->data[2] == 0xff && call->data[3] == 0xff))))
 	{
 		uint32_t PacketLength = 0;
 		uint32_t FakeStartCode = /*(call->Version << 8) | */PES_VERSION_FAKE_START_CODE;
@@ -440,7 +440,7 @@
 		if (NalStart + NalLength > SampleSize)
 		{
 			h264_printf(20, "nal length past end of buffer - size %u frame offset %u left %u\n",
-			            NalLength, NalStart, SampleSize - NalStart);
+			    NalLength, NalStart, SampleSize - NalStart);
 
 			NalStart = SampleSize;
 		}
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/mpeg2.c libstb-hal-ddt.git/libeplayer3/output/writer/sh4/mpeg2.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/mpeg2.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/sh4/mpeg2.c	2022-07-23 18:18:31.531772467 +0200
@@ -106,7 +106,7 @@
 	while (Position < call->len)
 	{
 		int32_t PacketLength = (call->len - Position) <= MAX_PES_PACKET_SIZE ?
-		                       (call->len - Position) : MAX_PES_PACKET_SIZE;
+		    (call->len - Position) : MAX_PES_PACKET_SIZE;
 
 		int32_t Remaining = call->len - Position - PacketLength;
 
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/pcm.c libstb-hal-ddt.git/libeplayer3/output/writer/sh4/pcm.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/pcm.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/sh4/pcm.c	2022-07-23 18:18:31.531772467 +0200
@@ -97,11 +97,11 @@
 static int32_t prepareClipPlay(int32_t uNoOfChannels, int32_t uSampleRate, int32_t uBitsPerSample, uint8_t bLittleEndian __attribute__((unused)))
 {
 	printf("rate: %d ch: %d bits: %d (%d bps)\n",
-	       uSampleRate/*Format->dwSamplesPerSec*/,
-	       uNoOfChannels/*Format->wChannels*/,
-	       uBitsPerSample/*Format->wBitsPerSample*/,
-	       (uBitsPerSample/*Format->wBitsPerSample*/ / 8)
-	     );
+	    uSampleRate/*Format->dwSamplesPerSec*/,
+	    uNoOfChannels/*Format->wChannels*/,
+	    uBitsPerSample/*Format->wBitsPerSample*/,
+	    (uBitsPerSample/*Format->wBitsPerSample*/ / 8)
+	);
 
 	SubFrameLen = 0;
 	SubFramesPerPES = 0;
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/vc1.c libstb-hal-ddt.git/libeplayer3/output/writer/sh4/vc1.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/vc1.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/sh4/vc1.c	2022-07-23 18:18:31.531772467 +0200
@@ -197,7 +197,7 @@
 		while (Position < call->len)
 		{
 			int32_t PacketLength = (call->len - Position) <= MAX_PES_PACKET_SIZE ?
-			                       (call->len - Position) : MAX_PES_PACKET_SIZE;
+			    (call->len - Position) : MAX_PES_PACKET_SIZE;
 
 			int32_t Remaining = call->len - Position - PacketLength;
 
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/wmv.c libstb-hal-ddt.git/libeplayer3/output/writer/sh4/wmv.c
--- libstb-hal-ddt.git.orig/libeplayer3/output/writer/sh4/wmv.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/output/writer/sh4/wmv.c	2022-07-23 18:18:31.531772467 +0200
@@ -134,7 +134,7 @@
 	wmv_printf(10, "Got Private Size %d\n", call->private_size);
 
 	memcpy(private_data.privateData, call->private_data,
-	       call->private_size > WMV3_PRIVATE_DATA_LENGTH ? WMV3_PRIVATE_DATA_LENGTH : call->private_size);
+	    call->private_size > WMV3_PRIVATE_DATA_LENGTH ? WMV3_PRIVATE_DATA_LENGTH : call->private_size);
 
 	private_data.width = call->Width;
 	private_data.height = call->Height;
@@ -196,7 +196,7 @@
 		while (Position < call->len)
 		{
 			int PacketLength = (call->len - Position) <= MAX_PES_PACKET_SIZE ?
-			                   (call->len - Position) : MAX_PES_PACKET_SIZE;
+			    (call->len - Position) : MAX_PES_PACKET_SIZE;
 
 			int Remaining = call->len - Position - PacketLength;
 
@@ -214,7 +214,7 @@
 				PrivateHeaderLength     = InsertVideoPrivateDataHeader(&PesHeader[HeaderLength], call->len);
 				/* Update PesLength */
 				PesLength               = PesHeader[PES_LENGTH_BYTE_0] +
-				                         (PesHeader[PES_LENGTH_BYTE_1] << 8) + PrivateHeaderLength;
+				    (PesHeader[PES_LENGTH_BYTE_1] << 8) + PrivateHeaderLength;
 				PesHeader[PES_LENGTH_BYTE_0]            = PesLength & 0xff;
 				PesHeader[PES_LENGTH_BYTE_1]            = (PesLength >> 8) & 0xff;
 				PesHeader[PES_HEADER_DATA_LENGTH_BYTE] += PrivateHeaderLength;
diff -Nur libstb-hal-ddt.git.orig/libeplayer3/playback/playback.c libstb-hal-ddt.git/libeplayer3/playback/playback.c
--- libstb-hal-ddt.git.orig/libeplayer3/playback/playback.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3/playback/playback.c	2022-07-23 18:18:31.535772387 +0200
@@ -195,7 +195,7 @@
 			// mms is in reality called rtsp, and ffmpeg expects this
 			int len = strlen(uri) + 2;
 			char *tUri = (char *)malloc(strlen(uri) + 2);
-			snprintf(tUri,len,"rtsp%s",uri+3);
+			snprintf(tUri, len, "rtsp%s", uri + 3);
 			free(context->playback->uri);
 			context->playback->uri = tUri;
 		}
@@ -219,7 +219,7 @@
 	    (context->container->selectedContainer->Command(context, CONTAINER_INIT, pFiles) < 0))
 	{
 		playback_err("CONTAINER_ADD failed\n");
-		if(context->playback->uri)
+		if (context->playback->uri)
 		{
 			free(context->playback->uri);
 			context->playback->uri = NULL;
@@ -242,9 +242,9 @@
 	{
 		playback_err("container delete failed\n");
 	}
-	if(context->manager->audio)
+	if (context->manager->audio)
 		context->manager->audio->Command(context, MANAGER_DEL, NULL);
-	if(context->manager->video)
+	if (context->manager->video)
 		context->manager->video->Command(context, MANAGER_DEL, NULL);
 	if (context->manager->chapter)
 		context->manager->chapter->Command(context, MANAGER_DEL, NULL);
@@ -385,8 +385,8 @@
 	playback_printf(10, "\n");
 
 	if (context->playback->isPlaying &&
-	   (context->playback->isPaused || context->playback->isForwarding ||
-	    context->playback->BackWard || context->playback->SlowMotion))
+	    (context->playback->isPaused || context->playback->isForwarding ||
+	        context->playback->BackWard || context->playback->SlowMotion))
 	{
 		if (context->playback->SlowMotion || context->playback->isForwarding || context->playback->BackWard)
 			context->output->Command(context, OUTPUT_CLEAR, NULL);
@@ -478,7 +478,7 @@
 		}
 
 		ret = context->container->selectedContainer->Command(context, CONTAINER_STOP, NULL);
-		if(context && context->playback)
+		if (context && context->playback)
 		{
 			context->playback->isPaused     = 0;
 			context->playback->isPlaying    = 0;
@@ -487,7 +487,7 @@
 			context->playback->SlowMotion   = 0;
 			context->playback->Speed        = 0;
 		}
-		if(context && context->output)
+		if (context && context->output)
 			context->output->Command(context, OUTPUT_STOP, NULL);
 	}
 	else
@@ -557,7 +557,7 @@
 
 	/* Audio only reverse play not supported */
 	if (context->playback->isVideo && !context->playback->isForwarding &&
-	   (!context->playback->isPaused || context->playback->isPlaying))
+	    (!context->playback->isPaused || context->playback->isPlaying))
 	{
 		if ((*speed > 0) || (*speed < cMaxSpeed_fr))
 		{
@@ -1014,5 +1014,5 @@
 	0,          //size
 	0,          //noprobe
 	0,          //isLoopMode
-	0,          //isTSLiveMode
+	0           //isTSLiveMode
 };
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/include/input.h libstb-hal-ddt.git/libeplayer3-sh4/include/input.h
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/include/input.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3-sh4/include/input.h	2022-07-23 18:18:31.507772949 +0200
@@ -36,9 +36,12 @@
 #include <libavformat/avformat.h>
 #include <libswresample/swresample.h>
 #include <libavutil/opt.h>
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(59,0,100)
+#include <libavcodec/avcodec.h>
+#endif
 }
 
-#if (LIBAVFORMAT_VERSION_INT > AV_VERSION_INT( 57,25,100 ))
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57,25,100)
 #define EPLAYER_MAX_CODECS 16
 struct CodecList
 {
@@ -51,9 +54,9 @@
 
 class Input
 {
-	friend class Player;
-	friend class WriterPCM; // needs calcPts()
-	friend int interrupt_cb(void *arg);
+		friend class Player;
+		friend class WriterPCM; // needs calcPts()
+		friend int interrupt_cb(void *arg);
 
 	private:
 		OpenThreads::Mutex mutex;
@@ -71,11 +74,11 @@
 
 		Player *player;
 		AVFormatContext *avfc;
-#if (LIBAVFORMAT_VERSION_INT > AV_VERSION_INT( 57,25,100 ))
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57,25,100)
 		CodecList codecs[EPLAYER_MAX_CODECS];
 #endif
 		uint64_t readCount;
-		int64_t calcPts(AVStream * stream, int64_t pts);
+		int64_t calcPts(AVStream *stream, int64_t pts);
 
 	public:
 		Input();
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/include/manager.h libstb-hal-ddt.git/libeplayer3-sh4/include/manager.h
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/include/manager.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/include/manager.h	2022-07-23 18:18:31.507772949 +0200
@@ -62,16 +62,16 @@
 
 class Manager
 {
-	friend class Player;
+		friend class Player;
 
 	private:
 		Player *player;
 		OpenThreads::Mutex mutex;
-		std::map<int,Track*> videoTracks, audioTracks, subtitleTracks, teletextTracks;
-		std::map<int,Program> Programs;
-		void addTrack(std::map<int,Track*> &tracks, Track &track);
-		Track *getTrack(std::map<int,Track*> &tracks, int pid);
-		std::vector<Track> getTracks(std::map<int,Track*> &tracks);
+		std::map<int, Track *> videoTracks, audioTracks, subtitleTracks, teletextTracks;
+		std::map<int, Program> Programs;
+		void addTrack(std::map<int, Track *> &tracks, Track &track);
+		Track *getTrack(std::map<int, Track *> &tracks, int pid);
+		std::vector<Track> getTracks(std::map<int, Track *> &tracks);
 	public:
 		void addVideoTrack(Track &track);
 		void addAudioTrack(Track &track);
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/include/misc.h libstb-hal-ddt.git/libeplayer3-sh4/include/misc.h
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/include/misc.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/include/misc.h	2022-07-23 18:18:31.507772949 +0200
@@ -5,16 +5,16 @@
 
 #include <stdint.h>
 
-#define INVALID_PTS_VALUE	0x200000000ll
+#define INVALID_PTS_VALUE   0x200000000ll
 
 struct BitPacker_t
 {
-	uint8_t *Ptr;		/* write pointer */
-	unsigned int BitBuffer;	/* bitreader shifter */
-	int Remaining;		/* number of remaining in the shifter */
+	uint8_t *Ptr;       /* write pointer */
+	unsigned int BitBuffer; /* bitreader shifter */
+	int Remaining;      /* number of remaining in the shifter */
 };
 
-void PutBits(BitPacker_t * ld, unsigned int code, unsigned int length);
-void FlushBits(BitPacker_t * ld);
+void PutBits(BitPacker_t *ld, unsigned int code, unsigned int length);
+void FlushBits(BitPacker_t *ld);
 
 #endif
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/include/output.h libstb-hal-ddt.git/libeplayer3-sh4/include/output.h
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/include/output.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/include/output.h	2022-07-23 18:18:31.507772949 +0200
@@ -44,7 +44,7 @@
 
 class Output
 {
-	friend class Player;
+		friend class Player;
 
 	private:
 		int videofd;
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/include/pes.h libstb-hal-ddt.git/libeplayer3-sh4/include/pes.h
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/include/pes.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/include/pes.h	2022-07-23 18:18:31.507772949 +0200
@@ -3,30 +3,30 @@
 
 #include <stdint.h>
 
-#define PES_MAX_HEADER_SIZE			64
-#define PES_PRIVATE_DATA_FLAG			0x80
-#define PES_PRIVATE_DATA_LENGTH			8
-#define PES_LENGTH_BYTE_0			5
-#define PES_LENGTH_BYTE_1			4
-#define PES_FLAGS_BYTE				7
-#define PES_EXTENSION_DATA_PRESENT		0x01
-#define PES_HEADER_DATA_LENGTH_BYTE		8
-#define PES_START_CODE_RESERVED_4		0xfd
-#define PES_VERSION_FAKE_START_CODE		0x31
+#define PES_MAX_HEADER_SIZE         64
+#define PES_PRIVATE_DATA_FLAG           0x80
+#define PES_PRIVATE_DATA_LENGTH         8
+#define PES_LENGTH_BYTE_0           5
+#define PES_LENGTH_BYTE_1           4
+#define PES_FLAGS_BYTE              7
+#define PES_EXTENSION_DATA_PRESENT      0x01
+#define PES_HEADER_DATA_LENGTH_BYTE     8
+#define PES_START_CODE_RESERVED_4       0xfd
+#define PES_VERSION_FAKE_START_CODE     0x31
 
 
-#define MAX_PES_PACKET_SIZE			65535
+#define MAX_PES_PACKET_SIZE         65535
 
 
 /* start codes */
-#define PCM_PES_START_CODE			0xbd
-#define PRIVATE_STREAM_1_PES_START_CODE		0xbd
-#define H263_VIDEO_PES_START_CODE		0xfe
-#define H264_VIDEO_PES_START_CODE		0xe2
-#define MPEG_VIDEO_PES_START_CODE		0xe0
-#define MPEG_AUDIO_PES_START_CODE		0xc0
-#define VC1_VIDEO_PES_START_CODE		0xfd
-#define AAC_AUDIO_PES_START_CODE		0xcf
+#define PCM_PES_START_CODE          0xbd
+#define PRIVATE_STREAM_1_PES_START_CODE     0xbd
+#define H263_VIDEO_PES_START_CODE       0xfe
+#define H264_VIDEO_PES_START_CODE       0xe2
+#define MPEG_VIDEO_PES_START_CODE       0xe0
+#define MPEG_AUDIO_PES_START_CODE       0xc0
+#define VC1_VIDEO_PES_START_CODE        0xfd
+#define AAC_AUDIO_PES_START_CODE        0xcf
 
 int InsertPesHeader(uint8_t *data, int size, uint8_t stream_id, int64_t pts, int pic_start_code);
 int InsertVideoPrivateDataHeader(uint8_t *data, int payload_size);
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/include/player.h libstb-hal-ddt.git/libeplayer3-sh4/include/player.h
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/include/player.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/include/player.h	2022-07-23 18:18:31.507772949 +0200
@@ -51,13 +51,14 @@
 	int64_t end;
 };
 
-class Player {
-	friend class Input;
-	friend class Output;
-	friend class Manager;
-	friend class cPlayback;
-	friend class WriterPCM;
-	friend int interrupt_cb(void *arg);
+class Player
+{
+		friend class Input;
+		friend class Output;
+		friend class Manager;
+		friend class cPlayback;
+		friend class WriterPCM;
+		friend int interrupt_cb(void *arg);
 
 	private:
 		Input input;
@@ -81,10 +82,10 @@
 		uint64_t readCount;
 
 		std::string url;
-		bool noprobe;	/* hack: only minimal probing in av_find_stream_info */
+		bool noprobe;   /* hack: only minimal probing in av_find_stream_info */
 
 		void SetChapters(std::vector<Chapter> &Chapters);
-		static void* playthread(void*);
+		static void *playthread(void *);
 	public:
 		bool SwitchAudio(int pid);
 		bool SwitchVideo(int pid);
@@ -115,8 +116,14 @@
 		void RequestAbort();
 		bool GetChapters(std::vector<int> &positions, std::vector<std::string> &titles);
 
-		AVFormatContext *GetAVFormatContext() { return input.GetAVFormatContext(); }
-		void ReleaseAVFormatContext() { input.ReleaseAVFormatContext(); }
+		AVFormatContext *GetAVFormatContext()
+		{
+			return input.GetAVFormatContext();
+		}
+		void ReleaseAVFormatContext()
+		{
+			input.ReleaseAVFormatContext();
+		}
 
 		bool GetPrograms(std::vector<std::string> &keys, std::vector<std::string> &values);
 		bool SelectProgram(int key);
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/include/writer.h libstb-hal-ddt.git/libeplayer3-sh4/include/writer.h
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/include/writer.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3-sh4/include/writer.h	2022-07-23 18:18:31.511772868 +0200
@@ -38,22 +38,22 @@
 #define AV_CODEC_ID_INJECTPCM AV_CODEC_ID_PCM_S16LE
 
 /* wrapper */
-#if (LIBAVFORMAT_VERSION_INT > AV_VERSION_INT( 57,25,100 ))
-static AVCodecParameters __attribute__ ((unused)) *get_codecpar(AVStream *stream)
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57,25,100)
+static AVCodecParameters __attribute__((unused)) *get_codecpar(AVStream *stream)
 {
 	return stream->codecpar;
 }
 #else
-static AVCodecContext __attribute__ ((unused)) *get_codecpar(AVStream *stream)
+static AVCodecContext __attribute__((unused)) *get_codecpar(AVStream *stream)
 {
 	return stream->codec;
 }
 #endif
 
 #if (LIBAVCODEC_VERSION_MAJOR > 55)
-#define	av_free_packet av_packet_unref
+#define av_free_packet av_packet_unref
 #else
-#define av_packet_unref	av_free_packet
+#define av_packet_unref av_free_packet
 #endif
 /* end wrapper */
 
@@ -71,7 +71,11 @@
 		static audio_encoding_t GetAudioEncoding(enum AVCodecID id);
 		static Writer *GetWriter(enum AVCodecID id, enum AVMediaType codec_type, int track_type);
 
-		virtual void Init(int _fd, AVStream * /*stream*/, Player *_player ) { fd = _fd; player = _player; }
+		virtual void Init(int _fd, AVStream * /*stream*/, Player *_player)
+		{
+			fd = _fd;
+			player = _player;
+		}
 		virtual bool Write(AVPacket *packet, int64_t pts);
 };
 #endif
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/input.cpp libstb-hal-ddt.git/libeplayer3-sh4/input.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/input.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3-sh4/input.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -34,13 +34,13 @@
 
 static const char *FILENAME = "eplayer/input.cpp";
 
-#define averror(_err,_fun) ({										\
-	if (_err < 0) {											\
-		char _error[512];									\
-		av_strerror(_err, _error, sizeof(_error));						\
-		fprintf(stderr, "%s %d: %s: %d (%s)\n", FILENAME, __LINE__, #_fun, _err, _error);	\
-	}												\
-	_err;												\
+#define averror(_err,_fun) ({                                       \
+    if (_err < 0) {                                         \
+        char _error[512];                                   \
+        av_strerror(_err, _error, sizeof(_error));                      \
+        fprintf(stderr, "%s %d: %s: %d (%s)\n", FILENAME, __LINE__, #_fun, _err, _error);   \
+    }                                               \
+    _err;                                               \
 })
 
 Input::Input()
@@ -54,8 +54,8 @@
 	seek_avts_abs = INT64_MIN;
 	seek_avts_rel = 0;
 	abortPlayback = false;
-#if (LIBAVFORMAT_VERSION_INT > AV_VERSION_INT( 57,25,100 ))
-	for (int n = 0;n < EPLAYER_MAX_CODECS;n++)
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57,25,100)
+	for (int n = 0; n < EPLAYER_MAX_CODECS; n++)
 		codecs[n].codec = NULL;
 #endif
 }
@@ -64,7 +64,7 @@
 {
 }
 
-int64_t Input::calcPts(AVStream * stream, int64_t pts)
+int64_t Input::calcPts(AVStream *stream, int64_t pts)
 {
 	if (pts == AV_NOPTS_VALUE)
 		return INVALID_PTS_VALUE;
@@ -89,17 +89,20 @@
 static std::string lastlog_message;
 static unsigned int lastlog_repeats;
 
-static void log_callback(void *ptr __attribute__ ((unused)), int lvl __attribute__ ((unused)), const char *format, va_list ap)
+static void log_callback(void *ptr __attribute__((unused)), int lvl __attribute__((unused)), const char *format, va_list ap)
 {
 	char m[1024];
-	if (sizeof(m) - 1 > (unsigned int) vsnprintf(m, sizeof(m), format, ap)) {
-		if (lastlog_message.compare(m) || lastlog_repeats > 999) {
+	if (sizeof(m) - 1 > (unsigned int) vsnprintf(m, sizeof(m), format, ap))
+	{
+		if (lastlog_message.compare(m) || lastlog_repeats > 999)
+		{
 			if (lastlog_repeats)
 				fprintf(stderr, "last message repeated %u times\n", lastlog_repeats);
 			lastlog_message = m;
 			lastlog_repeats = 0;
 			fprintf(stderr, "%s", m);
-		} else
+		}
+		else
 			lastlog_repeats++;
 	}
 }
@@ -114,22 +117,30 @@
 
 AVCodecContext *Input::GetCodecContext(unsigned int index)
 {
-#if (LIBAVFORMAT_VERSION_INT > AV_VERSION_INT( 57,25,100 ))
-	if (codecs[index].codec) {
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57,25,100)
+	if (codecs[index].codec)
+	{
 		return codecs[index].codec;
 	}
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
 	AVCodec *codec = avcodec_find_decoder(avfc->streams[index]->codecpar->codec_id);
+#else
+	const AVCodec *codec = avcodec_find_decoder(avfc->streams[index]->codecpar->codec_id);
+#endif
 	codecs[index].codec = avcodec_alloc_context3(codec);
-	if (!codecs[index].codec) {
+	if (!codecs[index].codec)
+	{
 		fprintf(stderr, "context3 alloc for stream %d failed\n", (int)index);
 		return NULL;
 	}
-	if (avcodec_parameters_to_context(codecs[index].codec, avfc->streams[index]->codecpar) < 0) {
+	if (avcodec_parameters_to_context(codecs[index].codec, avfc->streams[index]->codecpar) < 0)
+	{
 		fprintf(stderr, "copy parameters to codec context for stream %d failed\n", (int)index);
 		avcodec_free_context(&codecs[index].codec);
 		return NULL;
 	}
-	if (!codec) {
+	if (!codec)
+	{
 		fprintf(stderr, "decoder for codec_id:(0x%X) stream:(%d) not found\n", avfc->streams[index]->codecpar->codec_id, (int)index);;
 		return codecs[index].codec;
 	}
@@ -138,7 +149,8 @@
 		fprintf(stderr, "decoder for codec_id:(0x%X) stream:(%d) found\n", avfc->streams[index]->codecpar->codec_id, (int)index);;
 	}
 	int err = avcodec_open2(codecs[index].codec, codec, NULL);
-	if (averror(err, avcodec_open2)) {
+	if (averror(err, avcodec_open2))
+	{
 		fprintf(stderr, "open codec context for stream:(%d) failed}n", (int)index);
 		avcodec_free_context(&codecs[index].codec);
 		return NULL;
@@ -161,10 +173,12 @@
 	//       Oddly, this seems to be necessary for network streaming only ...
 	bool audioSeen = !audioTrack || !player->isHttp;
 
-	while (player->isPlaying && !player->abortRequested) {
+	while (player->isPlaying && !player->abortRequested)
+	{
 
 		//IF MOVIE IS PAUSED, WAIT
-		if (player->isPaused) {
+		if (player->isPaused)
+		{
 			fprintf(stderr, "paused\n");
 			usleep(100000);
 			continue;
@@ -173,44 +187,61 @@
 		int seek_target_flag = 0;
 		int64_t seek_target = INT64_MIN; // in AV_TIME_BASE units
 
-		if (seek_avts_rel) {
-			if (avfc->iformat->flags & AVFMT_TS_DISCONT) {
-				if (avfc->bit_rate) {
+		if (seek_avts_rel)
+		{
+			if (avfc->iformat->flags & AVFMT_TS_DISCONT)
+			{
+				if (avfc->bit_rate)
+				{
 					seek_target_flag = AVSEEK_FLAG_BYTE;
 					seek_target = avio_tell(avfc->pb) + av_rescale(seek_avts_rel, avfc->bit_rate, 8 * AV_TIME_BASE);
 				}
-			} else {
+			}
+			else
+			{
 				int64_t pts;
-				if(player->output.GetPts(pts))
+				if (player->output.GetPts(pts))
 					seek_target = av_rescale(pts, AV_TIME_BASE, 90000ll) + seek_avts_rel;
 			}
 			seek_avts_rel = 0;
-		} else if (seek_avts_abs != INT64_MIN) {
-			if (avfc->iformat->flags & AVFMT_TS_DISCONT) {
-				if (avfc->bit_rate) {
+		}
+		else if (seek_avts_abs != INT64_MIN)
+		{
+			if (avfc->iformat->flags & AVFMT_TS_DISCONT)
+			{
+				if (avfc->bit_rate)
+				{
 					seek_target_flag = AVSEEK_FLAG_BYTE;
 					seek_target = av_rescale(seek_avts_abs, avfc->bit_rate, 8 * AV_TIME_BASE);
 				}
-			} else {
+			}
+			else
+			{
 				seek_target = seek_avts_abs;
 			}
 			seek_avts_abs = INT64_MIN;
-		} else if (player->isBackWard && av_gettime_relative() >= showtime) {
+		}
+		else if (player->isBackWard && av_gettime_relative() >= showtime)
+		{
 			player->output.ClearVideo();
 
-			if (bof) {
+			if (bof)
+			{
 				showtime = av_gettime_relative();
 				usleep(100000);
 				continue;
 			}
 			seek_avts_rel = player->Speed * AV_TIME_BASE;
-			showtime = av_gettime_relative() + 300000;	//jump back every 300ms
+			showtime = av_gettime_relative() + 300000;  //jump back every 300ms
 			continue;
-		} else {
+		}
+		else
+		{
 			bof = false;
 		}
 
-		if (seek_target > INT64_MIN) {
+		if (seek_target > INT64_MIN)
+		{
 			int res;
 			if (seek_target < 0)
 				seek_target = 0;
@@ -223,7 +254,8 @@
 			restart_audio_resampling = true;
 
 			// clear streams
-			for (unsigned int i = 0; i < avfc->nb_streams; i++) {
+			for (unsigned int i = 0; i < avfc->nb_streams; i++)
+			{
 				AVCodecContext *avcctx = GetCodecContext(i);
 				if (avcctx && avcctx->codec)
 					avcodec_flush_buffers(avcctx);
@@ -236,13 +268,15 @@
 		av_init_packet(&packet);
 
 		int err = av_read_frame(avfc, &packet);
-		if (err == AVERROR(EAGAIN)) {
+		if (err == AVERROR(EAGAIN))
+		{
 			av_packet_unref(&packet);
 			continue;
 		}
-		if (averror(err, av_read_frame)) { // EOF?
+		if (averror(err, av_read_frame))   // EOF?
+		{
 			av_packet_unref(&packet);
-			break;		// while
+			break;      // while
 		}
 
 		player->readCount += packet.size;
@@ -254,24 +288,32 @@
 		Track *_subtitleTrack = subtitleTrack;
 		Track *_teletextTrack = teletextTrack;
 
-		if (_videoTrack && (_videoTrack->stream == stream)) {
+		if (_videoTrack && (_videoTrack->stream == stream))
+		{
 			int64_t pts = calcPts(stream, packet.pts);
 			if (audioSeen && !player->output.Write(stream, &packet, pts))
 				logprintf("writing data to video device failed\n");
-		} else if (_audioTrack && (_audioTrack->stream == stream)) {
-			if (restart_audio_resampling) {
+		}
+		else if (_audioTrack && (_audioTrack->stream == stream))
+		{
+			if (restart_audio_resampling)
+			{
 				restart_audio_resampling = false;
 				player->output.Write(stream, NULL, 0);
 			}
-			if (!player->isBackWard) {
+			if (!player->isBackWard)
+			{
 				int64_t pts = calcPts(stream, packet.pts);
-				//if (!player->output.Write(stream, &packet, _videoTrack ? pts : 0))	// DBO: why pts only at video tracks ?
+				//if (!player->output.Write(stream, &packet, _videoTrack ? pts : 0))    // DBO: why pts only at video tracks ?
 				if (!player->output.Write(stream, &packet, pts))
 					logprintf("writing data to audio device failed\n");
 			}
 			audioSeen = true;
-		} else if (_subtitleTrack && (_subtitleTrack->stream == stream)) {
-			if (avcctx->codec) {
+		}
+		else if (_subtitleTrack && (_subtitleTrack->stream == stream))
+		{
+			if (avcctx->codec)
+			{
 				AVSubtitle sub;
 				memset(&sub, 0, sizeof(sub));
 				int got_sub_ptr = 0;
@@ -279,13 +321,16 @@
 				err = avcodec_decode_subtitle2(avcctx, &sub, &got_sub_ptr, &packet);
 				averror(err, avcodec_decode_subtitle2);
 
-				if (got_sub_ptr && sub.num_rects > 0) {
-					switch (sub.rects[0]->type) {
+				if (got_sub_ptr && sub.num_rects > 0)
+				{
+					switch (sub.rects[0]->type)
+					{
 						case SUBTITLE_TEXT: // FIXME?
 						case SUBTITLE_ASS:
 							dvbsub_ass_write(avcctx, &sub, _subtitleTrack->pid);
 							break;
-						case SUBTITLE_BITMAP: {
+						case SUBTITLE_BITMAP:
+						{
 							int64_t pts = calcPts(stream, packet.pts);
 							dvbsub_write(&sub, pts);
 							// avsubtitle_free() will be called by handler
@@ -296,7 +341,9 @@
 					}
 				}
 			}
-		} else if (_teletextTrack && (_teletextTrack->stream == stream)) {
+		}
+		else if (_teletextTrack && (_teletextTrack->stream == stream))
+		{
 			if (packet.data && packet.size > 1)
 				teletext_write(_teletextTrack->pid, packet.data + 1, packet.size - 1);
 		}
@@ -329,7 +376,8 @@
 #if LIBAVCODEC_VERSION_MAJOR < 58
 static int lock_callback(void **mutex, enum AVLockOp op)
 {
-	switch (op) {
+	switch (op)
+	{
 		case AV_LOCK_CREATE:
 			*mutex = (void *) new OpenThreads::Mutex;
 			return !*mutex;
@@ -363,24 +411,31 @@
 
 	AVFormatContext *subavfc = avformat_alloc_context();
 	int err = avformat_open_input(&subavfc, subfile, av_find_input_format(format), 0);
-	if (averror(err, avformat_open_input)) {
+	if (averror(err, avformat_open_input))
+	{
 		avformat_free_context(subavfc);
 		return false;
 	}
 
 	avformat_find_stream_info(subavfc, NULL);
-	if (subavfc->nb_streams != 1) {
+	if (subavfc->nb_streams != 1)
+	{
 		avformat_free_context(subavfc);
 		return false;
 	}
 
 	AVCodecContext *c = NULL;
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
 	AVCodec *codec = NULL;
-#if (LIBAVFORMAT_VERSION_INT < AV_VERSION_INT( 57,25,101 ))
+#else
+	const AVCodec *codec = NULL;
+#endif
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(57,25,101)
 	c = subavfc->streams[0]->codec;
 #else
 	c = avcodec_alloc_context3(codec);
-	if (avcodec_parameters_to_context(c, subavfc->streams[0]->codecpar) < 0) {
+	if (avcodec_parameters_to_context(c, subavfc->streams[0]->codecpar) < 0)
+	{
 		avcodec_free_context(&c);
 		avformat_close_input(&subavfc);
 		avformat_free_context(subavfc);
@@ -388,13 +443,15 @@
 	}
 #endif
 	codec = avcodec_find_decoder(c->codec_id);
-	if (!codec) {
+	if (!codec)
+	{
 		avformat_free_context(subavfc);
 		return false;
 	}
 
 	err = avcodec_open2(c, codec, NULL);
-	if (averror(err, avcodec_open2)) {
+	if (averror(err, avcodec_open2))
+	{
 		avformat_free_context(subavfc);
 		return false;
 	}
@@ -402,7 +459,8 @@
 	AVPacket packet;
 	av_init_packet(&packet);
 
-	while (av_read_frame(subavfc, &packet) > -1) {
+	while (av_read_frame(subavfc, &packet) > -1)
+	{
 		AVSubtitle sub;
 		memset(&sub, 0, sizeof(sub));
 		int got_sub = 0;
@@ -412,7 +470,7 @@
 		av_packet_unref(&packet);
 	}
 	avcodec_close(c);
-#if (LIBAVFORMAT_VERSION_INT > AV_VERSION_INT( 57,25,100 ))
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57,25,100)
 	avcodec_free_context(&c);
 #endif
 	avformat_close_input(&subavfc);
@@ -426,7 +484,8 @@
 	return true;
 }
 
-bool Input::ReadSubtitles(const char *filename) {
+bool Input::ReadSubtitles(const char *filename)
+{
 	if (strncmp(filename, "file://", 7))
 		return false;
 	filename += 7;
@@ -454,7 +513,8 @@
 	av_log_set_level(AV_LOG_PANIC);
 #endif
 
-	if (!filename) {
+	if (!filename)
+	{
 		fprintf(stderr, "filename NULL\n");
 		return false;
 	}
@@ -501,16 +561,25 @@
 	av_log_set_level(AV_LOG_INFO);
 #endif
 	av_dict_free(&options);
-	if (averror(err, avformat_open_input)) {
+	if (averror(err, avformat_open_input))
+	{
 		avformat_free_context(avfc);
 		return false;
 	}
 
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
 	avfc->iformat->flags |= AVFMT_SEEK_TO_PTS;
+#else
+	if (!(avfc->iformat->flags & AVFMT_SEEK_TO_PTS)) {
+		printf("[input.cpp] - AVFMT_SEEK_TO_PTS not available - FIXME, FFMPEG 4.5 has problems with some VOB/MPG...\n");
+		return false; // FIXME, FFMPEG 4.5 has problems with some VOB/MPG...
+	}
+#endif
 	avfc->flags = AVFMT_FLAG_GENPTS;
-	if (player->noprobe) {
-#if (LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(55, 43, 100)) || \
-	(LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57, 25, 0))
+	if (player->noprobe)
+	{
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(55, 43, 100) || \
+    LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57, 25, 0)
 		avfc->max_analyze_duration = 1;
 #else
 		avfc->max_analyze_duration2 = 1;
@@ -520,7 +589,8 @@
 #if 0
 	if (!player->isHttp)
 	{
-		for (unsigned int i = 0; i < avfc->nb_streams; i++) {
+		for (unsigned int i = 0; i < avfc->nb_streams; i++)
+		{
 			if (avfc->streams[i]->codec->codec_id == AV_CODEC_ID_AAC)
 				find_info = false;
 		}
@@ -530,9 +600,11 @@
 		err = avformat_find_stream_info(avfc, NULL);
 
 #if 0
-	if (averror(err, avformat_find_stream_info)) {
+	if (averror(err, avformat_find_stream_info))
+	{
 		avformat_close_input(&avfc);
-		if (player->noprobe) {
+		if (player->noprobe)
+		{
 			player->noprobe = false;
 			goto again;
 		}
@@ -542,7 +614,8 @@
 
 	bool res = UpdateTracks();
 
-	if (!videoTrack && !audioTrack) {
+	if (!videoTrack && !audioTrack)
+	{
 		avformat_close_input(&avfc);
 		return false;
 	}
@@ -563,9 +636,10 @@
 		return true;
 
 	std::vector<Chapter> chapters;
-	for (unsigned int i = 0; i < avfc->nb_chapters; i++) {
+	for (unsigned int i = 0; i < avfc->nb_chapters; i++)
+	{
 		AVChapter *ch = avfc->chapters[i];
-		AVDictionaryEntry* title = av_dict_get(ch->metadata, "title", NULL, 0);
+		AVDictionaryEntry *title = av_dict_get(ch->metadata, "title", NULL, 0);
 		Chapter chapter;
 		chapter.title = title ? title->value : "";
 		chapter.start = av_rescale(ch->time_base.num * AV_TIME_BASE, ch->start, ch->time_base.den);
@@ -579,7 +653,8 @@
 	av_dump_format(avfc, 0, player->url.c_str(), 0);
 
 	bool use_index_as_pid = false;
-	for (unsigned int n = 0; n < avfc->nb_streams; n++) {
+	for (unsigned int n = 0; n < avfc->nb_streams; n++)
+	{
 		AVStream *stream = avfc->streams[n];
 
 		AVCodecContext *avcctx = GetCodecContext(n);
@@ -590,7 +665,8 @@
 		track.title = lang ? lang->value : "";
 
 		if (!use_index_as_pid)
-			switch (avcctx->codec_type) {
+			switch (avcctx->codec_type)
+			{
 				case AVMEDIA_TYPE_VIDEO:
 				case AVMEDIA_TYPE_AUDIO:
 				case AVMEDIA_TYPE_SUBTITLE:
@@ -600,17 +676,19 @@
 					break;
 			}
 
-		track.pid = use_index_as_pid ? n + 1: stream->id;
+		track.pid = use_index_as_pid ? n + 1 : stream->id;
 		track.ac3flags = 0;
 
-		switch (avcctx->codec_type) {
+		switch (avcctx->codec_type)
+		{
 			case AVMEDIA_TYPE_VIDEO:
 				player->manager.addVideoTrack(track);
 				if (!videoTrack)
 					videoTrack = player->manager.getVideoTrack(track.pid);
 				break;
 			case AVMEDIA_TYPE_AUDIO:
-				switch(avcctx->codec_id) {
+				switch (avcctx->codec_id)
+				{
 					case AV_CODEC_ID_MP2:
 						track.ac3flags = 1;
 						break;
@@ -623,12 +701,14 @@
 					case AV_CODEC_ID_DTS:
 						track.ac3flags = 4;
 						break;
-					case AV_CODEC_ID_AAC: {
+					case AV_CODEC_ID_AAC:
+					{
 						unsigned int extradata_size = avcctx->extradata_size;
 						unsigned int object_type = 2;
-						if(extradata_size >= 2)
+						if (extradata_size >= 2)
 							object_type = avcctx->extradata[0] >> 3;
-						if (extradata_size <= 1 || object_type == 1 || object_type == 5) {
+						if (extradata_size <= 1 || object_type == 1 || object_type == 5)
+						{
 							fprintf(stderr, "use resampling for AAC\n");
 							track.ac3flags = 6;
 						}
@@ -654,24 +734,30 @@
 					audioTrack = player->manager.getAudioTrack(track.pid);
 				break;
 			case AVMEDIA_TYPE_SUBTITLE:
-				if (avcctx->codec_id == AV_CODEC_ID_DVB_TELETEXT) {
+				if (avcctx->codec_id == AV_CODEC_ID_DVB_TELETEXT)
+				{
 					std::string l = lang ? lang->value : "";
 					uint8_t *data = avcctx->extradata;
 					int size = avcctx->extradata_size;
 					if (size > 0 && 2 * size - 1 == (int) l.length())
-						for (int i = 0; i < size; i += 2) {
+						for (int i = 0; i < size; i += 2)
+						{
 							track.title = l.substr(i * 2, 3);
 							track.type = data[i] >> 3;
 							track.mag = data[i] & 7;
 							track.page = data[i + 1];
 							player->manager.addTeletextTrack(track);
 						}
-				} else {
-					if (!avcctx->codec) {
+				}
+				else
+				{
+					if (!avcctx->codec)
+					{
 						avcctx->codec = avcodec_find_decoder(avcctx->codec_id);
 						if (!avcctx->codec)
 							fprintf(stderr, "avcodec_find_decoder failed for subtitle track %d\n", n);
-						else {
+						else
+						{
 							int err = avcodec_open2(avcctx, avcctx->codec, NULL);
 							if (averror(err, avcodec_open2))
 								avcctx->codec = NULL;
@@ -687,9 +773,11 @@
 		}
 	}
 
-	for (unsigned int n = 0; n < avfc->nb_programs; n++) {
+	for (unsigned int n = 0; n < avfc->nb_programs; n++)
+	{
 		AVProgram *p = avfc->programs[n];
-		if (p->nb_stream_indexes) {
+		if (p->nb_stream_indexes)
+		{
 			AVDictionaryEntry *name = av_dict_get(p->metadata, "name", NULL, 0);
 			Program program;
 			program.title = name ? name->value : "";
@@ -712,10 +800,12 @@
 
 	av_log(NULL, AV_LOG_QUIET, "%s", "");
 
-	if (avfc) {
+	if (avfc)
+	{
 		OpenThreads::ScopedLock<OpenThreads::Mutex> lock(mutex);
-		for (unsigned int i = 0; i < avfc->nb_streams; i++) {
-#if (LIBAVFORMAT_VERSION_INT > AV_VERSION_INT( 57,25,100 ))
+		for (unsigned int i = 0; i < avfc->nb_streams; i++)
+		{
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57,25,100)
 			if (codecs[i].codec)
 				avcodec_free_context(&codecs[i].codec);
 #else
@@ -756,7 +846,8 @@
 
 bool Input::GetDuration(int64_t &duration)
 {
-	if (avfc) {
+	if (avfc)
+	{
 		duration = avfc->duration;
 		return true;
 	}
@@ -796,38 +887,45 @@
 	keys.clear();
 	values.clear();
 
-	if (avfc) {
+	if (avfc)
+	{
 		AVDictionaryEntry *tag = NULL;
 
 		if (avfc->metadata)
-			while ((tag = av_dict_get(avfc->metadata, "", tag, AV_DICT_IGNORE_SUFFIX))) {
+			while ((tag = av_dict_get(avfc->metadata, "", tag, AV_DICT_IGNORE_SUFFIX)))
+			{
 				keys.push_back(tag->key);
 				values.push_back(tag->value);
 			}
 
 		if (videoTrack)
-			while ((tag = av_dict_get(videoTrack->stream->metadata, "", tag, AV_DICT_IGNORE_SUFFIX))) {
+			while ((tag = av_dict_get(videoTrack->stream->metadata, "", tag, AV_DICT_IGNORE_SUFFIX)))
+			{
 				keys.push_back(tag->key);
 				values.push_back(tag->value);
 			}
 
 		if (audioTrack)
-			while ((tag = av_dict_get(audioTrack->stream->metadata, "", tag, AV_DICT_IGNORE_SUFFIX))) {
+			while ((tag = av_dict_get(audioTrack->stream->metadata, "", tag, AV_DICT_IGNORE_SUFFIX)))
+			{
 				keys.push_back(tag->key);
 				values.push_back(tag->value);
 			}
 
 		// find the first attached picture, if available
-		for(unsigned int i = 0; i < avfc->nb_streams; i++) {
-			if (avfc->streams[i]->disposition & AV_DISPOSITION_ATTACHED_PIC) {
-			AVPacket *pkt = &avfc->streams[i]->attached_pic;
-			FILE *cover_art = fopen("/tmp/.id3coverart", "wb");
-			if (cover_art) {
-				fwrite(pkt->data, pkt->size, 1, cover_art);
-				fclose(cover_art);
-			}
-			av_packet_unref(pkt);
-			break;
+		for (unsigned int i = 0; i < avfc->nb_streams; i++)
+		{
+			if (avfc->streams[i]->disposition & AV_DISPOSITION_ATTACHED_PIC)
+			{
+				AVPacket *pkt = &avfc->streams[i]->attached_pic;
+				FILE *cover_art = fopen("/tmp/.id3coverart", "wb");
+				if (cover_art)
+				{
+					fwrite(pkt->data, pkt->size, 1, cover_art);
+					fclose(cover_art);
+				}
+				av_packet_unref(pkt);
+				break;
 			}
 		}
 	}
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/manager.cpp libstb-hal-ddt.git/libeplayer3-sh4/manager.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/manager.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/manager.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -23,15 +23,17 @@
 #include "manager.h"
 #include "player.h"
 
-void Manager::addTrack(std::map<int,Track*> &tracks, Track &track)
+void Manager::addTrack(std::map<int, Track *> &tracks, Track &track)
 {
 	OpenThreads::ScopedLock<OpenThreads::Mutex> m_lock(mutex);
-	std::map<int,Track*>::iterator it = tracks.find(track.pid);
-	if (it == tracks.end()) {
+	std::map<int, Track *>::iterator it = tracks.find(track.pid);
+	if (it == tracks.end())
+	{
 		Track *t = new Track;
 		*t = track;
 		tracks[track.pid] = t;
-	} else
+	}
+	else
 		*it->second = track;
 }
 
@@ -55,12 +57,12 @@
 	addTrack(teletextTracks, track);
 }
 
-std::vector<Track> Manager::getTracks(std::map<int,Track*> &tracks)
+std::vector<Track> Manager::getTracks(std::map<int, Track *> &tracks)
 {
 	player->input.UpdateTracks();
 	std::vector<Track> res;
 	OpenThreads::ScopedLock<OpenThreads::Mutex> m_lock(mutex);
-	for(std::map<int,Track*>::iterator it = tracks.begin(); it != tracks.end(); ++it)
+	for (std::map<int, Track *>::iterator it = tracks.begin(); it != tracks.end(); ++it)
 		if (!it->second->inactive && !it->second->hidden)
 			res.push_back(*it->second);
 	return res;
@@ -86,10 +88,10 @@
 	return getTracks(teletextTracks);
 }
 
-Track *Manager::getTrack(std::map<int,Track*> &tracks, int pid)
+Track *Manager::getTrack(std::map<int, Track *> &tracks, int pid)
 {
 	OpenThreads::ScopedLock<OpenThreads::Mutex> m_lock(mutex);
-	std::map<int,Track*>::iterator it = tracks.find(pid);
+	std::map<int, Track *>::iterator it = tracks.find(pid);
 	if (it != tracks.end() && !it->second->inactive)
 		return it->second;
 	return NULL;
@@ -118,16 +120,16 @@
 {
 	OpenThreads::ScopedLock<OpenThreads::Mutex> m_lock(mutex);
 
-	for (std::map<int,Track*>::iterator it = audioTracks.begin(); it != audioTracks.end(); ++it)
+	for (std::map<int, Track *>::iterator it = audioTracks.begin(); it != audioTracks.end(); ++it)
 		it->second->inactive = !it->second->is_static;
 
-	for (std::map<int, Track*>::iterator it = videoTracks.begin(); it != videoTracks.end(); ++it)
+	for (std::map<int, Track *>::iterator it = videoTracks.begin(); it != videoTracks.end(); ++it)
 		it->second->inactive = !it->second->is_static;
 
-	for (std::map<int,Track*>::iterator it = subtitleTracks.begin(); it != subtitleTracks.end(); ++it)
+	for (std::map<int, Track *>::iterator it = subtitleTracks.begin(); it != subtitleTracks.end(); ++it)
 		it->second->inactive = !it->second->is_static;
 
-	for (std::map<int,Track*>::iterator it = teletextTracks.begin(); it != teletextTracks.end(); ++it)
+	for (std::map<int, Track *>::iterator it = teletextTracks.begin(); it != teletextTracks.end(); ++it)
 		it->second->inactive = !it->second->is_static;
 
 	return true;
@@ -142,7 +144,7 @@
 {
 	OpenThreads::ScopedLock<OpenThreads::Mutex> m_lock(mutex);
 	std::vector<Program> res;
-	for (std::map<int,Program>::iterator it = Programs.begin(); it != Programs.end(); ++it)
+	for (std::map<int, Program>::iterator it = Programs.begin(); it != Programs.end(); ++it)
 		res.push_back(it->second);
 	return res;
 }
@@ -150,81 +152,95 @@
 bool Manager::selectProgram(const int id)
 {
 	OpenThreads::ScopedLock<OpenThreads::Mutex> m_lock(mutex);
-	std::map<int,Program>::iterator i = Programs.find(id);
-	if (i != Programs.end()) {
+	std::map<int, Program>::iterator i = Programs.find(id);
+	if (i != Programs.end())
+	{
 
 		// mark all tracks as hidden
-		for (std::map<int,Track*>::iterator it = audioTracks.begin(); it != audioTracks.end(); ++it)
+		for (std::map<int, Track *>::iterator it = audioTracks.begin(); it != audioTracks.end(); ++it)
 			it->second->hidden = true;
 
-		for (std::map<int, Track*>::iterator it = videoTracks.begin(); it != videoTracks.end(); ++it)
+		for (std::map<int, Track *>::iterator it = videoTracks.begin(); it != videoTracks.end(); ++it)
 			it->second->hidden = true;
 
-		for (std::map<int,Track*>::iterator it = subtitleTracks.begin(); it != subtitleTracks.end(); ++it)
+		for (std::map<int, Track *>::iterator it = subtitleTracks.begin(); it != subtitleTracks.end(); ++it)
 			it->second->hidden = true;
 
-		for (std::map<int,Track*>::iterator it = teletextTracks.begin(); it != teletextTracks.end(); ++it)
+		for (std::map<int, Track *>::iterator it = teletextTracks.begin(); it != teletextTracks.end(); ++it)
 			it->second->hidden = true;
 
 		// unhide tracks that are part of the selected program
-		for (unsigned int j = 0; j < i->second.streams.size(); j++) {
+		for (unsigned int j = 0; j < i->second.streams.size(); j++)
+		{
 			AVStream *stream = i->second.streams[j];
 			bool h = true;
-			for (std::map<int,Track*>::iterator it = audioTracks.begin(); h && (it != audioTracks.end()); ++it)
+			for (std::map<int, Track *>::iterator it = audioTracks.begin(); h && (it != audioTracks.end()); ++it)
 				if (stream == it->second->stream)
 					h = it->second->hidden = false;
 
 			if (!h)
 				continue;
 
-			for (std::map<int, Track*>::iterator it = videoTracks.begin(); h && (it != videoTracks.end()); ++it)
+			for (std::map<int, Track *>::iterator it = videoTracks.begin(); h && (it != videoTracks.end()); ++it)
 				if (stream == it->second->stream)
 					h = it->second->hidden = false;
 
 			if (!h)
 				continue;
 
-			for (std::map<int,Track*>::iterator it = subtitleTracks.begin(); h && (it != subtitleTracks.end()); ++it)
+			for (std::map<int, Track *>::iterator it = subtitleTracks.begin(); h && (it != subtitleTracks.end()); ++it)
 				if (stream == it->second->stream)
 					h = it->second->hidden = false;
 
 			if (!h)
 				continue;
 
-			for (std::map<int,Track*>::iterator it = teletextTracks.begin(); h && (it != teletextTracks.end()); ++it)
+			for (std::map<int, Track *>::iterator it = teletextTracks.begin(); h && (it != teletextTracks.end()); ++it)
 				if (stream == it->second->stream)
 					h = it->second->hidden = false;
 		}
 
 		// tell ffmpeg what we're interested in
-		for (std::map<int,Track*>::iterator it = audioTracks.begin(); it != audioTracks.end(); ++it)
-			if (it->second->hidden || it->second->inactive) {
+		for (std::map<int, Track *>::iterator it = audioTracks.begin(); it != audioTracks.end(); ++it)
+			if (it->second->hidden || it->second->inactive)
+			{
 				it->second->stream->discard = AVDISCARD_ALL;
-			} else {
+			}
+			else
+			{
 				it->second->stream->discard = AVDISCARD_NONE;
 				player->input.SwitchAudio(it->second);
 			}
 
-		for (std::map<int, Track*>::iterator it = videoTracks.begin(); it != videoTracks.end(); ++it)
-			if (it->second->hidden || it->second->inactive) {
+		for (std::map<int, Track *>::iterator it = videoTracks.begin(); it != videoTracks.end(); ++it)
+			if (it->second->hidden || it->second->inactive)
+			{
 				it->second->stream->discard = AVDISCARD_ALL;
-			} else {
+			}
+			else
+			{
 				it->second->stream->discard = AVDISCARD_NONE;
 				player->input.SwitchVideo(it->second);
 			}
 
-		for (std::map<int,Track*>::iterator it = subtitleTracks.begin(); it != subtitleTracks.end(); ++it)
-			if (it->second->hidden || it->second->inactive) {
+		for (std::map<int, Track *>::iterator it = subtitleTracks.begin(); it != subtitleTracks.end(); ++it)
+			if (it->second->hidden || it->second->inactive)
+			{
 				it->second->stream->discard = AVDISCARD_ALL;
-			} else {
+			}
+			else
+			{
 				it->second->stream->discard = AVDISCARD_NONE;
 				player->input.SwitchSubtitle(it->second);
 			}
 
-		for (std::map<int,Track*>::iterator it = teletextTracks.begin(); it != teletextTracks.end(); ++it)
-			if (it->second->hidden || it->second->inactive) {
+		for (std::map<int, Track *>::iterator it = teletextTracks.begin(); it != teletextTracks.end(); ++it)
+			if (it->second->hidden || it->second->inactive)
+			{
 				it->second->stream->discard = AVDISCARD_ALL;
-			} else {
+			}
+			else
+			{
 				it->second->stream->discard = AVDISCARD_NONE;
 				player->input.SwitchTeletext(it->second);
 			}
@@ -238,19 +254,19 @@
 {
 	OpenThreads::ScopedLock<OpenThreads::Mutex> m_lock(mutex);
 
-	for (std::map<int,Track*>::iterator it = audioTracks.begin(); it != audioTracks.end(); ++it)
+	for (std::map<int, Track *>::iterator it = audioTracks.begin(); it != audioTracks.end(); ++it)
 		delete it->second;
 	audioTracks.clear();
 
-	for (std::map<int, Track*>::iterator it = videoTracks.begin(); it != videoTracks.end(); ++it)
+	for (std::map<int, Track *>::iterator it = videoTracks.begin(); it != videoTracks.end(); ++it)
 		delete it->second;
 	videoTracks.clear();
 
-	for (std::map<int,Track*>::iterator it = subtitleTracks.begin(); it != subtitleTracks.end(); ++it)
+	for (std::map<int, Track *>::iterator it = subtitleTracks.begin(); it != subtitleTracks.end(); ++it)
 		delete it->second;
 	subtitleTracks.clear();
 
-	for (std::map<int,Track*>::iterator it = teletextTracks.begin(); it != teletextTracks.end(); ++it)
+	for (std::map<int, Track *>::iterator it = teletextTracks.begin(); it != teletextTracks.end(); ++it)
 		delete it->second;
 	teletextTracks.clear();
 
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/output.cpp libstb-hal-ddt.git/libeplayer3-sh4/output.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/output.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3-sh4/output.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -44,11 +44,11 @@
 
 static const char *FILENAME = "eplayer/output.cpp";
 
-#define dioctl(fd,req,arg) ({		\
-	int _r = ioctl(fd,req,arg); \
-	if (_r)				\
-		fprintf(stderr, "%s %d: ioctl '%s' failed: %d (%s)\n", FILENAME, __LINE__, #req, errno, strerror(errno)); \
-	_r; \
+#define dioctl(fd,req,arg) ({       \
+    int _r = ioctl(fd,req,arg); \
+    if (_r)             \
+        fprintf(stderr, "%s %d: ioctl '%s' failed: %d (%s)\n", FILENAME, __LINE__, #req, errno, strerror(errno)); \
+    _r; \
 })
 
 #define VIDEODEV "/dev/dvb/adapter0/video0"
@@ -70,7 +70,7 @@
 {
 	OpenThreads::ScopedLock<OpenThreads::Mutex> v_lock(videoMutex);
 	OpenThreads::ScopedLock<OpenThreads::Mutex> a_lock(audioMutex);
-	
+
 	if (videofd < 0)
 		videofd = open(VIDEODEV, O_RDWR);
 
@@ -85,7 +85,8 @@
 	if (audiofd < 0)
 		audiofd = open(AUDIODEV, O_RDWR);
 
-	if (audiofd < 0) {
+	if (audiofd < 0)
+	{
 		close(videofd);
 		videofd = -1;
 		return false;
@@ -105,11 +106,13 @@
 	OpenThreads::ScopedLock<OpenThreads::Mutex> v_lock(videoMutex);
 	OpenThreads::ScopedLock<OpenThreads::Mutex> a_lock(audioMutex);
 
-	if (videofd > -1) {
+	if (videofd > -1)
+	{
 		close(videofd);
 		videofd = -1;
 	}
-	if (audiofd > -1) {
+	if (audiofd > -1)
+	{
 		close(audiofd);
 		audiofd = -1;
 	}
@@ -127,22 +130,24 @@
 	OpenThreads::ScopedLock<OpenThreads::Mutex> v_lock(videoMutex);
 	OpenThreads::ScopedLock<OpenThreads::Mutex> a_lock(audioMutex);
 
-	if (videoTrack && videoTrack->stream && videofd > -1 && get_codecpar(videoTrack->stream)) {
+	if (videoTrack && videoTrack->stream && videofd > -1 && get_codecpar(videoTrack->stream))
+	{
 		videoWriter = Writer::GetWriter(get_codecpar(videoTrack->stream)->codec_id, get_codecpar(videoTrack->stream)->codec_type, videoTrack->ac3flags);
 		videoWriter->Init(videofd, videoTrack->stream, player);
 		if (dioctl(videofd, VIDEO_SET_ENCODING, videoWriter->GetVideoEncoding(get_codecpar(videoTrack->stream)->codec_id))
-		||  dioctl(videofd, VIDEO_PLAY, NULL))
+		    ||  dioctl(videofd, VIDEO_PLAY, NULL))
 			ret = false;
 	}
 
-	if (audioTrack && audioTrack->stream && audiofd > -1 && get_codecpar(audioTrack->stream)) {
+	if (audioTrack && audioTrack->stream && audiofd > -1 && get_codecpar(audioTrack->stream))
+	{
 		audioWriter = Writer::GetWriter(get_codecpar(audioTrack->stream)->codec_id, get_codecpar(audioTrack->stream)->codec_type, audioTrack->ac3flags);
 		audioWriter->Init(audiofd, audioTrack->stream, player);
 		audio_encoding_t audioEncoding = AUDIO_ENCODING_LPCMA;
 		if (audioTrack->ac3flags != 6)
 			audioEncoding = audioWriter->GetAudioEncoding(get_codecpar(audioTrack->stream)->codec_id);
 		if (dioctl(audiofd, AUDIO_SET_ENCODING, audioEncoding)
-		||  dioctl(audiofd, AUDIO_PLAY, NULL))
+		    ||  dioctl(audiofd, AUDIO_PLAY, NULL))
 			ret = false;
 	}
 	return ret;
@@ -155,7 +160,8 @@
 	OpenThreads::ScopedLock<OpenThreads::Mutex> v_lock(videoMutex);
 	OpenThreads::ScopedLock<OpenThreads::Mutex> a_lock(audioMutex);
 
-	if (videofd > -1) {
+	if (videofd > -1)
+	{
 		ioctl(videofd, VIDEO_CLEAR_BUFFER, NULL);
 		/* set back to normal speed (end trickmodes) */
 		dioctl(videofd, VIDEO_SET_SPEED, DVB_SPEED_NORMAL_PLAY);
@@ -163,7 +169,8 @@
 			ret = false;
 	}
 
-	if (audiofd > -1) {
+	if (audiofd > -1)
+	{
 		ioctl(audiofd, AUDIO_CLEAR_BUFFER, NULL);
 		/* set back to normal speed (end trickmodes) */
 		dioctl(audiofd, AUDIO_SET_SPEED, DVB_SPEED_NORMAL_PLAY);
@@ -181,12 +188,14 @@
 	OpenThreads::ScopedLock<OpenThreads::Mutex> v_lock(videoMutex);
 	OpenThreads::ScopedLock<OpenThreads::Mutex> a_lock(audioMutex);
 
-	if (videofd > -1) {
+	if (videofd > -1)
+	{
 		if (dioctl(videofd, VIDEO_FREEZE, NULL))
 			ret = false;
 	}
 
-	if (audiofd > -1) {
+	if (audiofd > -1)
+	{
 		if (dioctl(audiofd, AUDIO_PAUSE, NULL))
 			ret = false;
 	}
@@ -228,7 +237,8 @@
 	if (videofd > -1 && ioctl(videofd, VIDEO_FLUSH, NULL))
 		ret = false;
 
-	if (audiofd > -1 && audioWriter) {
+	if (audiofd > -1 && audioWriter)
+	{
 		// flush audio decoder
 		AVPacket packet;
 		packet.data = NULL;
@@ -283,7 +293,7 @@
 {
 	pts = 0;
 	return ((videofd > -1 && !ioctl(videofd, VIDEO_GET_PTS, (void *) &pts)) ||
-		(audiofd > -1 && !ioctl(audiofd, AUDIO_GET_PTS, (void *) &pts)));
+	        (audiofd > -1 && !ioctl(audiofd, AUDIO_GET_PTS, (void *) &pts)));
 }
 
 bool Output::GetFrameCount(int64_t &framecount)
@@ -291,7 +301,8 @@
 	dvb_play_info_t playInfo;
 
 	if ((videofd > -1 && !dioctl(videofd, VIDEO_GET_PLAY_INFO, (void *) &playInfo)) ||
-	    (audiofd > -1 && !dioctl(audiofd, AUDIO_GET_PLAY_INFO, (void *) &playInfo))) {
+	    (audiofd > -1 && !dioctl(audiofd, AUDIO_GET_PLAY_INFO, (void *) &playInfo)))
+	{
 		framecount = playInfo.frame_count;
 		return true;
 	}
@@ -303,20 +314,23 @@
 	OpenThreads::ScopedLock<OpenThreads::Mutex> a_lock(audioMutex);
 	if (audioTrack && track->stream == audioTrack->stream)
 		return true;
-	if (audiofd > -1) {
+	if (audiofd > -1)
+	{
 		dioctl(audiofd, AUDIO_STOP, NULL);
 		ioctl(audiofd, AUDIO_CLEAR_BUFFER, NULL);
 	}
 	audioTrack = track;
-	if (track->stream) {
+	if (track->stream)
+	{
 		if (!get_codecpar(audioTrack->stream))
 			return false;
-			audioWriter = Writer::GetWriter(get_codecpar(audioTrack->stream)->codec_id, get_codecpar(audioTrack->stream)->codec_type, audioTrack->ac3flags);
-			audioWriter->Init(audiofd, audioTrack->stream, player);
-		if (audiofd > -1) {
+		audioWriter = Writer::GetWriter(get_codecpar(audioTrack->stream)->codec_id, get_codecpar(audioTrack->stream)->codec_type, audioTrack->ac3flags);
+		audioWriter->Init(audiofd, audioTrack->stream, player);
+		if (audiofd > -1)
+		{
 			audio_encoding_t audioEncoding = AUDIO_ENCODING_LPCMA;
-		if (audioTrack->ac3flags != 6)
-			audioEncoding = Writer::GetAudioEncoding(get_codecpar(audioTrack->stream)->codec_id);
+			if (audioTrack->ac3flags != 6)
+				audioEncoding = Writer::GetAudioEncoding(get_codecpar(audioTrack->stream)->codec_id);
 			dioctl(audiofd, AUDIO_SET_ENCODING, audioEncoding);
 			dioctl(audiofd, AUDIO_PLAY, NULL);
 		}
@@ -329,17 +343,20 @@
 	OpenThreads::ScopedLock<OpenThreads::Mutex> v_lock(videoMutex);
 	if (videoTrack && track->stream == videoTrack->stream)
 		return true;
-	if (videofd > -1) {
+	if (videofd > -1)
+	{
 		dioctl(videofd, VIDEO_STOP, NULL);
 		ioctl(videofd, VIDEO_CLEAR_BUFFER, NULL);
 	}
 	videoTrack = track;
-	if (track->stream) {
+	if (track->stream)
+	{
 		if (!get_codecpar(videoTrack->stream))
 			return false;
 		videoWriter = Writer::GetWriter(get_codecpar(videoTrack->stream)->codec_id, get_codecpar(videoTrack->stream)->codec_type, videoTrack->type);
 		videoWriter->Init(videofd, videoTrack->stream, player);
-		if (videofd > -1) {
+		if (videofd > -1)
+		{
 			dioctl(videofd, VIDEO_SET_ENCODING, Writer::GetVideoEncoding(get_codecpar(videoTrack->stream)->codec_id));
 			dioctl(videofd, VIDEO_PLAY, NULL);
 		}
@@ -349,12 +366,15 @@
 
 bool Output::Write(AVStream *stream, AVPacket *packet, int64_t pts)
 {
-	switch (get_codecpar(stream)->codec_type) {
-		case AVMEDIA_TYPE_VIDEO: {
+	switch (get_codecpar(stream)->codec_type)
+	{
+		case AVMEDIA_TYPE_VIDEO:
+		{
 			OpenThreads::ScopedLock<OpenThreads::Mutex> v_lock(videoMutex);
 			return videofd > -1 && videoWriter && videoWriter->Write(packet, pts);
 		}
-		case AVMEDIA_TYPE_AUDIO: {
+		case AVMEDIA_TYPE_AUDIO:
+		{
 			OpenThreads::ScopedLock<OpenThreads::Mutex> a_lock(audioMutex);
 			return audiofd > -1 && audioWriter && audioWriter->Write(packet, pts);
 		}
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/player.cpp libstb-hal-ddt.git/libeplayer3-sh4/player.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/player.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3-sh4/player.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -32,8 +32,8 @@
 
 static const char *FILENAME = "eplayer/player.cpp";
 
-#define cMaxSpeed_ff   128	/* fixme: revise */
-#define cMaxSpeed_fr   -320	/* fixme: revise */
+#define cMaxSpeed_ff   128  /* fixme: revise */
+#define cMaxSpeed_fr   -320 /* fixme: revise */
 
 Player::Player()
 {
@@ -75,16 +75,23 @@
 
 	manager.clearTracks();
 
-	if (!strncmp("mms://", Url, 6)) {
+	if (!strncmp("mms://", Url, 6))
+	{
 		url = "mmst";
 		url += Url + 3;
 		isHttp = true;
-	} else if (strstr(Url, "://")) {
+	}
+	else if (strstr(Url, "://"))
+	{
 		url = Url;
 		isHttp = strncmp("file://", Url, 7);
-	} else if (!strncmp(Url, "bluray:/", 8)) {
+	}
+	else if (!strncmp(Url, "bluray:/", 8))
+	{
 		url = Url;
-	} else {
+	}
+	else
+	{
 		fprintf(stderr, "%s %s %d: Unknown stream (%s)\n", FILENAME, __func__, __LINE__, Url);
 		return false;
 	}
@@ -109,37 +116,46 @@
 {
 	bool ret = true;
 
-	if (!isPlaying) {
+	if (!isPlaying)
+	{
 		output.AVSync(true);
 
 		ret = output.Play();
 
-		if (ret) {
+		if (ret)
+		{
 			isPlaying = true;
 			isPaused = false;
 			isForwarding = false;
-			if (isBackWard) {
+			if (isBackWard)
+			{
 				isBackWard = false;
 				output.Mute(false);
 			}
 			isSlowMotion = false;
 			Speed = 1;
 
-			if (!hasThreadStarted) {
+			if (!hasThreadStarted)
+			{
 				int err = pthread_create(&playThread, NULL, playthread, this);
 
-				if (err) {
+				if (err)
+				{
 					fprintf(stderr, "%s %s %d: pthread_create: %d (%s)\n", FILENAME, __func__, __LINE__, err, strerror(err));
 					ret = false;
 					isPlaying = false;
-				} else {
+				}
+				else
+				{
 					pthread_detach(playThread);
 				}
 			}
 		}
 
-	} else {
-		fprintf(stderr,"playback already running\n");
+	}
+	else
+	{
+		fprintf(stderr, "playback already running\n");
 		ret = false;
 	}
 	return ret;
@@ -149,7 +165,8 @@
 {
 	bool ret = true;
 
-	if (isPlaying && !isPaused) {
+	if (isPlaying && !isPaused)
+	{
 
 		if (isSlowMotion)
 			output.Clear();
@@ -159,14 +176,17 @@
 		isPaused = true;
 		//isPlaying  = 1;
 		isForwarding = false;
-		if (isBackWard) {
+		if (isBackWard)
+		{
 			isBackWard = false;
 			output.Mute(false);
 		}
 		isSlowMotion = false;
 		Speed = 1;
-	} else {
-		fprintf(stderr,"playback not playing or already in pause mode\n");
+	}
+	else
+	{
+		fprintf(stderr, "playback not playing or already in pause mode\n");
 		ret = false;
 	}
 	return ret;
@@ -176,7 +196,8 @@
 {
 	int ret = true;
 
-	if (isPlaying && (isPaused || isForwarding || isBackWard || isSlowMotion)) {
+	if (isPlaying && (isPaused || isForwarding || isBackWard || isSlowMotion))
+	{
 
 		if (isSlowMotion)
 			output.Clear();
@@ -186,14 +207,17 @@
 		isPaused = false;
 		//isPlaying  = 1;
 		isForwarding = false;
-		if (isBackWard) {
+		if (isBackWard)
+		{
 			isBackWard = false;
 			output.Mute(false);
 		}
 		isSlowMotion = false;
 		Speed = 1;
-	} else {
-		fprintf(stderr,"continue not possible\n");
+	}
+	else
+	{
+		fprintf(stderr, "continue not possible\n");
 		ret = false;
 	}
 
@@ -204,11 +228,13 @@
 {
 	bool ret = true;
 
-	if (isPlaying) {
+	if (isPlaying)
+	{
 		isPaused = false;
 		isPlaying = false;
 		isForwarding = false;
-		if (isBackWard) {
+		if (isBackWard)
+		{
 			isBackWard = false;
 			output.Mute(false);
 		}
@@ -218,8 +244,10 @@
 		output.Stop();
 		input.Stop();
 
-	} else {
-		fprintf(stderr,"stop not possible\n");
+	}
+	else
+	{
+		fprintf(stderr, "stop not possible\n");
 		ret = false;
 	}
 
@@ -234,9 +262,11 @@
 	int ret = true;
 
 	/* Audio only forwarding not supported */
-	if (input.videoTrack && !isHttp && !isBackWard && (!isPaused ||  isPlaying)) {
+	if (input.videoTrack && !isHttp && !isBackWard && (!isPaused ||  isPlaying))
+	{
 
-		if ((speed <= 0) || (speed > cMaxSpeed_ff)) {
+		if ((speed <= 0) || (speed > cMaxSpeed_ff))
+		{
 			fprintf(stderr, "speed %d out of range (1 - %d) \n", speed, cMaxSpeed_ff);
 			return false;
 		}
@@ -244,8 +274,10 @@
 		isForwarding = 1;
 		Speed = speed;
 		output.FastForward(speed);
-	} else {
-		fprintf(stderr,"fast forward not possible\n");
+	}
+	else
+	{
+		fprintf(stderr, "fast forward not possible\n");
 		ret = false;
 	}
 
@@ -257,32 +289,40 @@
 	bool ret = true;
 
 	/* Audio only reverse play not supported */
-	if (input.videoTrack && !isForwarding && (!isPaused || isPlaying)) {
+	if (input.videoTrack && !isForwarding && (!isPaused || isPlaying))
+	{
 
-		if ((speed > 0) || (speed < cMaxSpeed_fr)) {
+		if ((speed > 0) || (speed < cMaxSpeed_fr))
+		{
 			fprintf(stderr, "speed %d out of range (0 - %d) \n", speed, cMaxSpeed_fr);
 			return false;
 		}
 
-		if (speed == 0) {
+		if (speed == 0)
+		{
 			isBackWard = false;
-			Speed = 0;	/* reverse end */
-		} else {
+			Speed = 0;  /* reverse end */
+		}
+		else
+		{
 			Speed = speed;
 			isBackWard = true;
 		}
 
 		output.Clear();
 #if 0
-		if (output->Command(player, OUTPUT_REVERSE, NULL) < 0) {
-			fprintf(stderr,"OUTPUT_REVERSE failed\n");
+		if (output->Command(player, OUTPUT_REVERSE, NULL) < 0)
+		{
+			fprintf(stderr, "OUTPUT_REVERSE failed\n");
 			isBackWard = false;
 			Speed = 1;
 			ret = false;
 		}
 #endif
-	} else {
-		fprintf(stderr,"fast backward not possible\n");
+	}
+	else
+	{
+		fprintf(stderr, "fast backward not possible\n");
 		ret = false;
 	}
 
@@ -294,11 +334,13 @@
 
 bool Player::SlowMotion(int repeats)
 {
-	if (input.videoTrack && !isHttp && isPlaying) {
+	if (input.videoTrack && !isHttp && isPlaying)
+	{
 		if (isPaused)
 			Continue();
 
-		switch (repeats) {
+		switch (repeats)
+		{
 			case 2:
 			case 4:
 			case 8:
@@ -318,7 +360,7 @@
 bool Player::Seek(int64_t pos, bool absolute)
 {
 	if (GetVideoPid())
-	/* Don't Clear if no video track */
+		/* Don't Clear if no video track */
 		output.Clear();
 	return input.Seek(pos, absolute);
 }
@@ -375,8 +417,9 @@
 	titles.clear();
 	input.UpdateTracks();
 	OpenThreads::ScopedLock<OpenThreads::Mutex> m_lock(chapterMutex);
-	for (std::vector<Chapter>::iterator it = chapters.begin(); it != chapters.end(); ++it) {
-		positions.push_back(it->start/1000);
+	for (std::vector<Chapter>::iterator it = chapters.begin(); it != chapters.end(); ++it)
+	{
+		positions.push_back(it->start / 1000);
 		titles.push_back(it->title);
 	}
 	return true;
@@ -427,7 +470,8 @@
 	if (p.empty())
 		return false;
 
-	for (std::vector<Program>::iterator it = p.begin(); it != p.end(); ++it) {
+	for (std::vector<Program>::iterator it = p.begin(); it != p.end(); ++it)
+	{
 		std::stringstream s;
 		s << it->id;
 		keys.push_back(s.str());
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/aac.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/aac.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/aac.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/aac.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -41,7 +41,8 @@
 static inline void Hexdump(unsigned char *Data, int length)
 {
 	int k;
-	for (k = 0; k < length; k++) {
+	for (k = 0; k < length; k++)
+	{
 		printf("%02x ", Data[k]);
 		if (((k + 1) & 31) == 0)
 			printf("\n");
@@ -84,7 +85,7 @@
 }
 
 #if 0
-static unsigned char DefaultAACHeader[] = {0xff,0xf1,0x50,0x80,0x00,0x1f,0xfc};
+static unsigned char DefaultAACHeader[] = {0xff, 0xf1, 0x50, 0x80, 0x00, 0x1f, 0xfc};
 #endif
 
 class WriterAAC : public Writer
@@ -109,7 +110,7 @@
 	printf("stream->codec->extradata_size %d\n", stream->codec->extradata_size);
 	Hexdump(stream->codec->extradata, stream->codec->extradata_size);
 #endif
-	unsigned int object_type = 2;	// LC
+	unsigned int object_type = 2;   // LC
 	unsigned int sample_index = aac_get_sample_rate_index(stream->codec->sample_rate);
 	unsigned int chan_config = stream->codec->channels;
 	if (stream->codec->extradata_size >= 2)
@@ -123,7 +124,7 @@
 	printf("aac sample_index %d\n", sample_index);
 	printf("aac chan_config %d\n", chan_config);
 #endif
-	object_type -= 1;	// Cause of ADTS
+	object_type -= 1;   // Cause of ADTS
 	aacbuflen = AAC_HEADER_LENGTH;
 	aacbuf[0] = 0xFF;
 	aacbuf[1] = 0xF1;
@@ -147,7 +148,7 @@
 	uint8_t PesHeader[PES_MAX_HEADER_SIZE];
 	uint8_t ExtraData[AAC_HEADER_LENGTH];
 
-	for (int pos = 0; pos < packet->size + AAC_HEADER_LENGTH; )
+	for (int pos = 0; pos < packet->size + AAC_HEADER_LENGTH;)
 	{
 		int PacketLength = std::min(packet->size - pos + AAC_HEADER_LENGTH, MAX_PES_PACKET_SIZE);
 
@@ -182,4 +183,4 @@
 	Register(this, AV_CODEC_ID_AAC, AUDIO_ENCODING_AAC);
 }
 
-static WriterAAC writer_aac __attribute__ ((init_priority (300)));
+static WriterAAC writer_aac __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/ac3.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/ac3.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/ac3.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/ac3.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -46,7 +46,8 @@
 
 	uint8_t PesHeader[PES_MAX_HEADER_SIZE];
 
-	for (int pos = 0; pos < packet->size; ) {
+	for (int pos = 0; pos < packet->size;)
+	{
 		int PacketLength = std::min(packet->size - pos, MAX_PES_PACKET_SIZE);
 		struct iovec iov[2];
 		iov[0].iov_base = PesHeader;
@@ -69,4 +70,4 @@
 	Register(this, AV_CODEC_ID_EAC3, AUDIO_ENCODING_AC3);
 }
 
-static WriterAC3 writer_ac3 __attribute__ ((init_priority (300)));
+static WriterAC3 writer_ac3 __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/divx.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/divx.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/divx.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/divx.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -58,7 +58,7 @@
 		return false;
 
 	uint8_t PesHeader[PES_MAX_HEADER_SIZE];
-	uint8_t FakeHeaders[64] = { 0 };	// 64bytes should be enough to make the fake headers
+	uint8_t FakeHeaders[64] = { 0 };    // 64bytes should be enough to make the fake headers
 	unsigned int FakeHeaderLength;
 	uint8_t Version = 5;
 	unsigned int FakeStartCode = (Version << 8) | PES_VERSION_FAKE_START_CODE;
@@ -72,10 +72,10 @@
 	   PutBits(&ld, 0x0, 8);
 	   PutBits(&ld, 0x0, 8);
 	 */
-	PutBits(&ld, 0x1b0, 32);	// startcode
-	PutBits(&ld, 0, 8);		// profile = reserved
-	PutBits(&ld, 0x1b2, 32);	// startcode (user data)
-	PutBits(&ld, 0x53545443, 32);	// STTC - an embedded ST timecode from an avi file
+	PutBits(&ld, 0x1b0, 32);    // startcode
+	PutBits(&ld, 0, 8);     // profile = reserved
+	PutBits(&ld, 0x1b2, 32);    // startcode (user data)
+	PutBits(&ld, 0x53545443, 32);   // STTC - an embedded ST timecode from an avi file
 	PutBits(&ld, usecPerFrame, 32); // microseconds per frame
 	FlushBits(&ld);
 
@@ -88,7 +88,8 @@
 	iov[ic].iov_base = FakeHeaders;
 	iov[ic++].iov_len = FakeHeaderLength;
 
-	if (initialHeader) {
+	if (initialHeader)
+	{
 		iov[ic].iov_base = get_codecpar(stream)->extradata;
 		iov[ic++].iov_len = get_codecpar(stream)->extradata_size;
 		initialHeader = false;
@@ -107,4 +108,4 @@
 	Register(this, AV_CODEC_ID_MSMPEG4V3, VIDEO_ENCODING_MPEG4P2);
 }
 
-static WriterDIVX writer_divx __attribute__ ((init_priority (300)));
+static WriterDIVX writer_divx __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/dts.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/dts.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/dts.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/dts.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -30,8 +30,8 @@
 #include "pes.h"
 #include "writer.h"
 
-#define PES_AUDIO_PRIVATE_HEADER_SIZE   16	// consider maximum private header size.
-#define PES_AUDIO_HEADER_SIZE		(32 + PES_AUDIO_PRIVATE_HEADER_SIZE)
+#define PES_AUDIO_PRIVATE_HEADER_SIZE   16  // consider maximum private header size.
+#define PES_AUDIO_HEADER_SIZE       (32 + PES_AUDIO_PRIVATE_HEADER_SIZE)
 
 class WriterDTS : public Writer
 {
@@ -53,7 +53,8 @@
 	memcpy(Data, packet->data, packet->size);
 
 	/* 16-bit byte swap all data before injecting it */
-	for (i = 0; i < packet->size; i += 2) {
+	for (i = 0; i < packet->size; i += 2)
+	{
 		uint8_t Tmp = Data[i];
 		Data[i] = Data[i + 1];
 		Data[i + 1] = Tmp;
@@ -63,7 +64,7 @@
 	struct iovec iov[2];
 
 	iov[0].iov_base = PesHeader;
-	iov[0].iov_len = InsertPesHeader(PesHeader, packet->size, MPEG_AUDIO_PES_START_CODE /*PRIVATE_STREAM_1_PES_START_CODE */ , pts, 0);
+	iov[0].iov_len = InsertPesHeader(PesHeader, packet->size, MPEG_AUDIO_PES_START_CODE /*PRIVATE_STREAM_1_PES_START_CODE */, pts, 0);
 #ifdef DO_BYTESPWAP
 	iov[1].iov_base = Data;
 #else
@@ -79,4 +80,4 @@
 	Register(this, AV_CODEC_ID_DTS, AUDIO_ENCODING_DTS);
 }
 
-static WriterDTS writer_dts __attribute__ ((init_priority (300)));
+static WriterDTS writer_dts __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/h263.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/h263.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/h263.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/h263.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -71,4 +71,4 @@
 	Register(this, AV_CODEC_ID_FLV1, VIDEO_ENCODING_FLV1);
 }
 
-static WriterH263 writer_h263 __attribute__ ((init_priority (300)));
+static WriterH263 writer_h263 __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/h264.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/h264.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/h264.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/h264.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -30,17 +30,18 @@
 #include "pes.h"
 #include "writer.h"
 
-#define NALU_TYPE_PLAYER2_CONTAINER_PARAMETERS		24	// Reference: player/standards/h264.h
-#define CONTAINER_PARAMETERS_VERSION			0x00
+#define NALU_TYPE_PLAYER2_CONTAINER_PARAMETERS      24  // Reference: player/standards/h264.h
+#define CONTAINER_PARAMETERS_VERSION            0x00
 
-typedef struct avcC_s {
-	uint8_t Version;		// configurationVersion
-	uint8_t Profile;		// AVCProfileIndication
-	uint8_t Compatibility;		// profile_compatibility
-	uint8_t Level;			// AVCLevelIndication
-	uint8_t NalLengthMinusOne;	// held in bottom two bits
-	uint8_t NumParamSets;		// held in bottom 5 bits
-	uint8_t Params[1];		// {length,params}{length,params}...sequence then picture
+typedef struct avcC_s
+{
+	uint8_t Version;        // configurationVersion
+	uint8_t Profile;        // AVCProfileIndication
+	uint8_t Compatibility;      // profile_compatibility
+	uint8_t Level;          // AVCLevelIndication
+	uint8_t NalLengthMinusOne;  // held in bottom two bits
+	uint8_t NumParamSets;       // held in bottom 5 bits
+	uint8_t Params[1];      // {length,params}{length,params}...sequence then picture
 } avcC_t;
 
 class WriterH264 : public Writer
@@ -74,14 +75,16 @@
 	uint8_t *d = packet->data;
 
 	// byte-stream format
-	if ((packet->size > 3) && (   (d[0] == 0x00 && d[1] == 0x00 && d[2] == 0x00 && d[3] == 0x01) // first NAL unit
-			           || (d[0] == 0xff && d[1] == 0xff && d[2] == 0xff && d[3] == 0xff) // FIXME, needed???
-	)) {
+	if ((packet->size > 3) && ((d[0] == 0x00 && d[1] == 0x00 && d[2] == 0x00 && d[3] == 0x01)    // first NAL unit
+	        || (d[0] == 0xff && d[1] == 0xff && d[2] == 0xff && d[3] == 0xff) // FIXME, needed???
+	   ))
+	{
 		unsigned int FakeStartCode = /* (call->Version << 8) | */ PES_VERSION_FAKE_START_CODE;
 		int ic = 0;
 		iov[ic++].iov_base = PesHeader;
 		unsigned int len = 0;
-		if (initialHeader) {
+		if (initialHeader)
+		{
 			initialHeader = false;
 			iov[ic].iov_base = get_codecpar(stream)->extradata;
 			iov[ic++].iov_len = get_codecpar(stream)->extradata_size;
@@ -103,10 +106,12 @@
 	}
 
 	// convert NAL units without sync byte sequence to byte-stream format
-	if (initialHeader) {
+	if (initialHeader)
+	{
 		avcC_t *avcCHeader = (avcC_t *) get_codecpar(stream)->extradata;
 
-		if (!avcCHeader) {
+		if (!avcCHeader)
+		{
 			fprintf(stderr, "stream->codec->extradata == NULL\n");
 			return false;
 		}
@@ -122,35 +127,35 @@
 
 		uint8_t Header[20];
 		unsigned int len = 0;
-		Header[len++] = 0x00;	// Start code, 00 00 00 01 for first NAL unit
+		Header[len++] = 0x00;   // Start code, 00 00 00 01 for first NAL unit
 		Header[len++] = 0x00;
 		Header[len++] = 0x00;
 		Header[len++] = 0x01;
 		Header[len++] = NALU_TYPE_PLAYER2_CONTAINER_PARAMETERS; // NAL unit header
 		// Container message version - changes when/if we vary the format of the message
 		Header[len++] = CONTAINER_PARAMETERS_VERSION;
-		Header[len++] = 0xff;	// marker bits
+		Header[len++] = 0xff;   // marker bits
 
-		#if 0
+#if 0
 		if (FrameRate == 0xffffffff)
 			FrameRate = (TimeScale > 1000) ? 1001 : 1;
-		#endif
+#endif
 
-		Header[len++] = (TimeScale >> 24) & 0xff;	// Output the timescale
+		Header[len++] = (TimeScale >> 24) & 0xff;   // Output the timescale
 		Header[len++] = (TimeScale >> 16) & 0xff;
-		Header[len++] = 0xff;	// marker bits
+		Header[len++] = 0xff;   // marker bits
 		Header[len++] = (TimeScale >>  8) & 0xff;
-		Header[len++] = (TimeScale      ) & 0xff;
-		Header[len++] = 0xff;	// marker bits
+		Header[len++] = (TimeScale) & 0xff;
+		Header[len++] = 0xff;   // marker bits
 
-		Header[len++] = (FrameRate >> 24) & 0xff;	// Output frame period (should be: time delta)
+		Header[len++] = (FrameRate >> 24) & 0xff;   // Output frame period (should be: time delta)
 		Header[len++] = (FrameRate >> 16) & 0xff;
-		Header[len++] = 0xff;	// marker bits
+		Header[len++] = 0xff;   // marker bits
 		Header[len++] = (FrameRate >>  8) & 0xff;
-		Header[len++] = (FrameRate      ) & 0xff;
-		Header[len++] = 0xff;	// marker bits
+		Header[len++] = (FrameRate) & 0xff;
+		Header[len++] = 0xff;   // marker bits
 
-		Header[len++] = 0x80;	// Rsbp trailing bits
+		Header[len++] = 0x80;   // Rsbp trailing bits
 
 		int ic = 0;
 		iov[ic].iov_base = PesHeader;
@@ -169,7 +174,8 @@
 
 		// sequence parameter set
 		unsigned int ParamSets = avcCHeader->NumParamSets & 0x1f;
-		for (unsigned int i = 0; i < ParamSets; i++) {
+		for (unsigned int i = 0; i < ParamSets; i++)
+		{
 			unsigned int PsLength = (avcCHeader->Params[ParamOffset] << 8) | avcCHeader->Params[ParamOffset + 1];
 
 			iov[ic].iov_base = (uint8_t *) "\0\0\0\1";
@@ -184,7 +190,8 @@
 		// picture parameter set
 		ParamSets = avcCHeader->Params[ParamOffset++];
 
-		for (unsigned int i = 0; i < ParamSets; i++) {
+		for (unsigned int i = 0; i < ParamSets; i++)
+		{
 			unsigned int PsLength = (avcCHeader->Params[ParamOffset] << 8) | avcCHeader->Params[ParamOffset + 1];
 
 			iov[ic].iov_base = (uint8_t *) "\0\0\0\1";
@@ -205,9 +212,11 @@
 	}
 
 	uint8_t *de = d + packet->size;
-	do {
+	do
+	{
 		unsigned int len = 0;
-		switch (NalLengthBytes) {
+		switch (NalLengthBytes)
+		{
 			case 4:
 				len = *d;
 				d++;
@@ -225,8 +234,9 @@
 				d++;
 		}
 
-		if (d + len > de) {
-			fprintf(stderr, "NAL length past end of buffer - size %u frame offset %d left %d\n", len, (int) (d - packet->data), (int) (de - d));
+		if (d + len > de)
+		{
+			fprintf(stderr, "NAL length past end of buffer - size %u frame offset %d left %d\n", len, (int)(d - packet->data), (int)(de - d));
 			break;
 		}
 
@@ -245,7 +255,8 @@
 		d += len;
 		pts = INVALID_PTS_VALUE;
 
-	} while (d < de);
+	}
+	while (d < de);
 
 	return true;
 }
@@ -255,4 +266,4 @@
 	Register(this, AV_CODEC_ID_H264, VIDEO_ENCODING_H264);
 }
 
-static WriterH264 writerh264 __attribute__ ((init_priority (300)));
+static WriterH264 writerh264 __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/misc.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/misc.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/misc.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/misc.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -28,7 +28,7 @@
 
 #include "misc.h"
 
-void PutBits(BitPacker_t * ld, unsigned int code, unsigned int length)
+void PutBits(BitPacker_t *ld, unsigned int code, unsigned int length)
 {
 	unsigned int bit_buf;
 	unsigned int bit_left;
@@ -39,20 +39,23 @@
 #ifdef DEBUG_PUTBITS
 	if (ld->debug)
 		dprintf("code = %d, length = %d, bit_buf = 0x%x, bit_left = %d\n",
-			code, length, bit_buf, bit_left);
+		    code, length, bit_buf, bit_left);
 #endif
 
-	if (length < bit_left) {
+	if (length < bit_left)
+	{
 		/* fits into current buffer */
 		bit_buf = (bit_buf << length) | code;
 		bit_left -= length;
-	} else {
+	}
+	else
+	{
 		/* doesn't fit */
 		bit_buf <<= bit_left;
 		bit_buf |= code >> (length - bit_left);
-		ld->Ptr[0] = (uint8_t) (bit_buf >> 24);
-		ld->Ptr[1] = (uint8_t) (bit_buf >> 16);
-		ld->Ptr[2] = (uint8_t) (bit_buf >> 8);
+		ld->Ptr[0] = (uint8_t)(bit_buf >> 24);
+		ld->Ptr[1] = (uint8_t)(bit_buf >> 16);
+		ld->Ptr[2] = (uint8_t)(bit_buf >> 8);
 		ld->Ptr[3] = (uint8_t) bit_buf;
 		ld->Ptr += 4;
 		length -= bit_left;
@@ -71,10 +74,11 @@
 	ld->Remaining = bit_left;
 }
 
-void FlushBits(BitPacker_t * ld)
+void FlushBits(BitPacker_t *ld)
 {
 	ld->BitBuffer <<= ld->Remaining;
-	while (ld->Remaining < 32) {
+	while (ld->Remaining < 32)
+	{
 #ifdef DEBUG_PUTBITS
 		if (ld->debug)
 			dprintf("flushing 0x%2.2x\n", ld->BitBuffer >> 24);
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/mp3.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/mp3.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/mp3.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/mp3.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -46,7 +46,8 @@
 
 	uint8_t PesHeader[PES_MAX_HEADER_SIZE];
 
-	for (int pos = 0; pos < packet->size; ) {
+	for (int pos = 0; pos < packet->size;)
+	{
 		int PacketLength = std::min(packet->size - pos, MAX_PES_PACKET_SIZE);
 		struct iovec iov[2];
 		iov[0].iov_base = PesHeader;
@@ -71,4 +72,4 @@
 	Register(this, AV_CODEC_ID_FLAC, AUDIO_ENCODING_LPCM);
 }
 
-static WriterMP3 writer_mp3 __attribute__ ((init_priority (300)));
+static WriterMP3 writer_mp3 __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/mpeg2.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/mpeg2.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/mpeg2.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/mpeg2.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -46,7 +46,8 @@
 
 	uint8_t PesHeader[PES_MAX_HEADER_SIZE];
 
-	for (int pos = 0; pos < packet->size; ) {
+	for (int pos = 0; pos < packet->size;)
+	{
 		int PacketLength = std::min(packet->size - pos, MAX_PES_PACKET_SIZE);
 		struct iovec iov[2];
 		iov[0].iov_base = PesHeader;
@@ -68,4 +69,4 @@
 	Register(this, AV_CODEC_ID_MPEG2TS, VIDEO_ENCODING_AUTO);
 }
 
-static WriterMPEG2 writer_mpeg2 __attribute__ ((init_priority (300)));
+static WriterMPEG2 writer_mpeg2 __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/pcm.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/pcm.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/pcm.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/pcm.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -43,18 +43,19 @@
 }
 
 // reference: search for TypeLpcmDVDAudio in player/frame_parser/frame_parser_audio_lpcm.cpp
-static const uint8_t clpcm_prv[14] = {
-	0xA0,	//sub_stream_id
-	0, 0,	//resvd and UPC_EAN_ISRC stuff, unused
-	0x0A,	//private header length
-	0, 9,	//first_access_unit_pointer
-	0x00,	//emph,rsvd,stereo,downmix
-	0x0F,	//quantisation word length 1,2
-	0x0F,	//audio sampling freqency 1,2
-	0,	//resvd, multi channel type
-	0,	//bit shift on channel GR2, assignment
-	0x80,	//dynamic range control
-	0, 0	//resvd for copyright management
+static const uint8_t clpcm_prv[14] =
+{
+	0xA0,   //sub_stream_id
+	0, 0,   //resvd and UPC_EAN_ISRC stuff, unused
+	0x0A,   //private header length
+	0, 9,   //first_access_unit_pointer
+	0x00,   //emph,rsvd,stereo,downmix
+	0x0F,   //quantisation word length 1,2
+	0x0F,   //audio sampling freqency 1,2
+	0,  //resvd, multi channel type
+	0,  //bit shift on channel GR2, assignment
+	0x80,   //dynamic range control
+	0, 0    //resvd for copyright management
 };
 
 class WriterPCM : public Writer
@@ -98,7 +99,8 @@
 	memcpy(lpcm_prv, clpcm_prv, sizeof(lpcm_prv));
 
 	// figure out size of subframe and set up sample rate
-	switch (uSampleRate) {
+	switch (uSampleRate)
+	{
 		case 48000:
 			SubFrameLen = 40;
 			break;
@@ -136,7 +138,8 @@
 	//set number of channels
 	lpcm_prv[10] = uNoOfChannels - 1;
 
-	switch (uBitsPerSample) {
+	switch (uBitsPerSample)
+	{
 		case 24:
 			lpcm_prv[7] |= 0x20;
 		case 16:
@@ -154,7 +157,8 @@
 	bool res = true;
 	uint8_t PesHeader[PES_MAX_HEADER_SIZE];
 
-	if (initialHeader) {
+	if (initialHeader)
+	{
 		initialHeader = false;
 		prepareClipPlay();
 		ioctl(fd, AUDIO_CLEAR_BUFFER, NULL);
@@ -162,7 +166,8 @@
 
 	size += breakBufferFillSize;
 
-	while (size >= SubFrameLen) {
+	while (size >= SubFrameLen)
+	{
 		if (breakBufferFillSize)
 			memcpy(injectBuffer, breakBuffer, breakBufferFillSize);
 		memcpy(injectBuffer + breakBufferFillSize, data, SubFrameLen - breakBufferFillSize);
@@ -171,17 +176,22 @@
 		breakBufferFillSize = 0;
 
 		//write the PCM data
-		if (uBitsPerSample == 16) {
-			for (unsigned int n = 0; n < SubFrameLen; n += 2) {
+		if (uBitsPerSample == 16)
+		{
+			for (unsigned int n = 0; n < SubFrameLen; n += 2)
+			{
 				uint8_t tmp = injectBuffer[n];
 				injectBuffer[n] = injectBuffer[n + 1];
 				injectBuffer[n + 1] = tmp;
 			}
-		} else {
+		}
+		else
+		{
 			//      0   1   2   3   4   5   6   7   8   9  10  11
 			//    A1c A1b A1a B1c B1b B1a A2c A2b A2a B2c B2b B2a
 			// to A1a A1b B1a B1b A2a A2b B2a B2b A1c B1c A2c B2c
-			for (unsigned int n = 0; n < SubFrameLen; n += 12) {
+			for (unsigned int n = 0; n < SubFrameLen; n += 12)
+			{
 				uint8_t t, *p = injectBuffer + n;
 				t = p[0];
 				p[0] = p[2];
@@ -207,12 +217,14 @@
 		iov[2].iov_len = SubFrameLen;
 		iov[0].iov_len = InsertPesHeader(PesHeader, iov[1].iov_len + iov[2].iov_len, PCM_PES_START_CODE, Pts, 0);
 		int len = writev(fd, iov, 3);
-		if (len < 0) {
+		if (len < 0)
+		{
 			res = false;
 			break;
 		}
 	}
-	if (size && res) {
+	if (size && res)
+	{
 		breakBufferFillSize = size;
 		memcpy(breakBuffer, data, size);
 	}
@@ -231,58 +243,71 @@
 
 bool WriterPCM::Write(AVPacket *packet, int64_t pts)
 {
-	if (!packet) {
+	if (!packet)
+	{
 		restart_audio_resampling = true;
 		return true;
 	}
 
 	AVCodecContext *c = player->input.GetCodecContext((unsigned int)stream->index);
 
-	if (restart_audio_resampling) {
+	if (restart_audio_resampling)
+	{
 		restart_audio_resampling = false;
 		initialHeader = true;
 
-		if (swr) {
+		if (swr)
+		{
 			swr_free(&swr);
 			swr = NULL;
 		}
-		if (decoded_frame) {
+		if (decoded_frame)
+		{
 			av_frame_free(&decoded_frame);
 			decoded_frame = NULL;
 		}
 
-#if (LIBAVFORMAT_VERSION_INT < AV_VERSION_INT( 57,25,101 ))
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(57,25,101)
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
 		AVCodec *codec = avcodec_find_decoder(c->codec_id);
-		if (!codec) {
+#else
+		const AVCodec *codec = avcodec_find_decoder(c->codec_id);
+#endif
+		if (!codec)
+		{
 			fprintf(stderr, "%s %d: avcodec_find_decoder(%llx)\n", __func__, __LINE__, (unsigned long long) c->codec_id);
 			return false;
 		}
 		avcodec_close(c);
-		if (avcodec_open2(c, codec, NULL)) {
+		if (avcodec_open2(c, codec, NULL))
+		{
 			fprintf(stderr, "%s %d: avcodec_open2 failed\n", __func__, __LINE__);
 			return false;
 		}
 #endif
 	}
 
-	if (!swr) {
+	if (!swr)
+	{
 		int in_rate = c->sample_rate;
 		// rates in descending order
 		int rates[] = {192000, 176400, 96000, 88200, 48000, 44100, 0};
 		int i = 0;
 		// find the next equal or smallest rate
 		while (rates[i] && in_rate < rates[i])
-		i++;
+			i++;
 		out_sample_rate = rates[i] ? rates[i] : 44100;
 		out_channels = c->channels;
-		if (c->channel_layout == 0) {
+		if (c->channel_layout == 0)
+		{
 			// FIXME -- need to guess, looks pretty much like a bug in the FFMPEG WMA decoder
 			c->channel_layout = AV_CH_LAYOUT_STEREO;
 		}
 
 		out_channel_layout = c->channel_layout;
 		// player2 won't play mono
-		if (out_channel_layout == AV_CH_LAYOUT_MONO) {
+		if (out_channel_layout == AV_CH_LAYOUT_MONO)
+		{
 			out_channel_layout = AV_CH_LAYOUT_STEREO;
 			out_channels = 2;
 		}
@@ -292,7 +317,8 @@
 		uBitsPerSample = 16;
 
 		swr = swr_alloc();
-		if (!swr) {
+		if (!swr)
+		{
 			fprintf(stderr, "%s %d: swr_alloc failed\n", __func__, __LINE__);
 			return false;
 		}
@@ -304,31 +330,37 @@
 		av_opt_set_sample_fmt(swr, "out_sample_fmt", AV_SAMPLE_FMT_S16, 0);
 
 		int e = swr_init(swr);
-		if (e < 0) {
+		if (e < 0)
+		{
 			fprintf(stderr, "swr_init: %d (icl=%d ocl=%d isr=%d osr=%d isf=%d osf=%d)\n",
-				-e, (int) c->channel_layout,
-				(int) out_channel_layout, c->sample_rate, out_sample_rate, c->sample_fmt, AV_SAMPLE_FMT_S16);
+			    -e, (int) c->channel_layout,
+			    (int) out_channel_layout, c->sample_rate, out_sample_rate, c->sample_fmt, AV_SAMPLE_FMT_S16);
 			restart_audio_resampling = true;
 			return false;
 		}
 	}
 
 	unsigned int packet_size = packet->size;
-	while (packet_size > 0 || (!packet_size && !packet->data)) {
+	while (packet_size > 0 || (!packet_size && !packet->data))
+	{
 
-		if (!decoded_frame) {
-			if (!(decoded_frame = av_frame_alloc())) {
+		if (!decoded_frame)
+		{
+			if (!(decoded_frame = av_frame_alloc()))
+			{
 				fprintf(stderr, "out of memory\n");
 				exit(1);
 			}
-		} else
+		}
+		else
 			av_frame_unref(decoded_frame);
 
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 		int got_frame = 0;
 
 		int len = avcodec_decode_audio4(c, decoded_frame, &got_frame, packet);
-		if (len < 0) {
+		if (len < 0)
+		{
 			restart_audio_resampling = true;
 			break;
 		}
@@ -336,35 +368,43 @@
 		if (packet->data)
 			packet_size -= len;
 
-		if (!got_frame) {
+		if (!got_frame)
+		{
 			if (!packet->data || !packet_size)
 				break;
 			continue;
 		}
 #else
-			int ret = avcodec_send_packet(c, packet);
-			if (ret < 0) {
-				if (ret != AVERROR(EAGAIN) && ret != AVERROR_EOF) {
-					restart_audio_resampling = true;
-					break;
-				}
+		int ret = avcodec_send_packet(c, packet);
+		if (ret < 0)
+		{
+			if (ret != AVERROR(EAGAIN) && ret != AVERROR_EOF)
+			{
+				restart_audio_resampling = true;
+				break;
 			}
-			if (ret >= 0) {
-				packet_size = 0;
+		}
+		if (ret >= 0)
+		{
+			packet_size = 0;
+		}
+		ret = avcodec_receive_frame(c, decoded_frame);
+		if (ret < 0)
+		{
+			if (ret == AVERROR_EOF)
+			{
+				restart_audio_resampling = true;
+				break;
 			}
-			ret = avcodec_receive_frame(c, decoded_frame);
-			if (ret < 0) {
-				if (ret == AVERROR_EOF) {
-					restart_audio_resampling = true;
-					break;
-				}
-				if (ret != AVERROR(EAGAIN)) {
-					break;
-				}
-				else {
-					continue;
-				}
+			if (ret != AVERROR(EAGAIN))
+			{
+				break;
 			}
+			else
+			{
+				continue;
+			}
+		}
 #endif
 
 #if (LIBAVUTIL_VERSION_MAJOR < 54)
@@ -375,11 +415,13 @@
 
 		int in_samples = decoded_frame->nb_samples;
 		int out_samples = av_rescale_rnd(swr_get_delay(swr, c->sample_rate) + in_samples, out_sample_rate, c->sample_rate, AV_ROUND_UP);
-		if (out_samples > out_samples_max) {
+		if (out_samples > out_samples_max)
+		{
 			if (output)
 				av_freep(&output);
 			int e = av_samples_alloc(&output, NULL, out_channels, out_samples, AV_SAMPLE_FMT_S16, 1);
-			if (e < 0) {
+			if (e < 0)
+			{
 				fprintf(stderr, "av_samples_alloc: %d\n", -e);
 				break;
 			}
@@ -388,7 +430,8 @@
 
 		out_samples = swr_convert(swr, &output, out_samples, (const uint8_t **) &decoded_frame->data[0], in_samples);
 
-		if (!writePCM(pts, output, out_samples * sizeof(short) * out_channels)) {
+		if (!writePCM(pts, output, out_samples * sizeof(short) * out_channels))
+		{
 			restart_audio_resampling = true;
 			break;
 		}
@@ -409,4 +452,4 @@
 	Register(this, AV_CODEC_ID_INJECTPCM, AUDIO_ENCODING_LPCMA);
 }
 
-static WriterPCM writer_pcm __attribute__ ((init_priority (300)));
+static WriterPCM writer_pcm __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/pes.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/pes.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/pes.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/pes.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -53,44 +53,45 @@
 {
 	BitPacker_t ld2 = { data, 0, 32 };
 
-    /* if (size > MAX_PES_PACKET_SIZE)
-        size = 0;		// unbounded */
+	/* if (size > MAX_PES_PACKET_SIZE)
+	    size = 0;       // unbounded */
 
 	PutBits(&ld2, 0x0, 8);
 	PutBits(&ld2, 0x0, 8);
-	PutBits(&ld2, 0x1, 8);	// Start Code
-	PutBits(&ld2, stream_id, 8);	// Stream_id = Audio Stream
+	PutBits(&ld2, 0x1, 8);  // Start Code
+	PutBits(&ld2, stream_id, 8);    // Stream_id = Audio Stream
 	//4
-	PutBits(&ld2, size + 3 + (pts != INVALID_PTS_VALUE ? 5 : 0) + (pic_start_code ? (5) : 0), 16);	// PES_packet_length
+	PutBits(&ld2, size + 3 + (pts != INVALID_PTS_VALUE ? 5 : 0) + (pic_start_code ? (5) : 0), 16);  // PES_packet_length
 	//6 = 4+2
-	PutBits(&ld2, 0x2, 2);	// 10
-	PutBits(&ld2, 0x0, 2);	// PES_Scrambling_control
-	PutBits(&ld2, 0x0, 1);	// PES_Priority
-	PutBits(&ld2, 0x0, 1);	// data_alignment_indicator
-	PutBits(&ld2, 0x0, 1);	// Copyright
-	PutBits(&ld2, 0x0, 1);	// Original or Copy
+	PutBits(&ld2, 0x2, 2);  // 10
+	PutBits(&ld2, 0x0, 2);  // PES_Scrambling_control
+	PutBits(&ld2, 0x0, 1);  // PES_Priority
+	PutBits(&ld2, 0x0, 1);  // data_alignment_indicator
+	PutBits(&ld2, 0x0, 1);  // Copyright
+	PutBits(&ld2, 0x0, 1);  // Original or Copy
 	//7 = 6+1
 
 	if (pts != INVALID_PTS_VALUE)
 		PutBits(&ld2, 0x2, 2);
 	else
-		PutBits(&ld2, 0x0, 2);	// PTS_DTS flag
+		PutBits(&ld2, 0x0, 2);  // PTS_DTS flag
 
-	PutBits(&ld2, 0x0, 1);	// ESCR_flag
-	PutBits(&ld2, 0x0, 1);	// ES_rate_flag
-	PutBits(&ld2, 0x0, 1);	// DSM_trick_mode_flag
-	PutBits(&ld2, 0x0, 1);	// additional_copy_ingo_flag
-	PutBits(&ld2, 0x0, 1);	// PES_CRC_flag
-	PutBits(&ld2, 0x0, 1);	// PES_extension_flag
+	PutBits(&ld2, 0x0, 1);  // ESCR_flag
+	PutBits(&ld2, 0x0, 1);  // ES_rate_flag
+	PutBits(&ld2, 0x0, 1);  // DSM_trick_mode_flag
+	PutBits(&ld2, 0x0, 1);  // additional_copy_ingo_flag
+	PutBits(&ld2, 0x0, 1);  // PES_CRC_flag
+	PutBits(&ld2, 0x0, 1);  // PES_extension_flag
 	//8 = 7+1
 
 	if (pts != INVALID_PTS_VALUE)
 		PutBits(&ld2, 0x5, 8);
 	else
-		PutBits(&ld2, 0x0, 8);	// PES_header_data_length
+		PutBits(&ld2, 0x0, 8);  // PES_header_data_length
 	//9 = 8+1
 
-	if (pts != INVALID_PTS_VALUE) {
+	if (pts != INVALID_PTS_VALUE)
+	{
 		PutBits(&ld2, 0x2, 4);
 		PutBits(&ld2, (pts >> 30) & 0x7, 3);
 		PutBits(&ld2, 0x1, 1);
@@ -101,12 +102,13 @@
 	}
 	//14 = 9+5
 
-	if (pic_start_code) {
+	if (pic_start_code)
+	{
 		PutBits(&ld2, 0x0, 8);
 		PutBits(&ld2, 0x0, 8);
-		PutBits(&ld2, 0x1, 8);	// Start Code
-		PutBits(&ld2, pic_start_code & 0xff, 8);	// 00, for picture start
-		PutBits(&ld2, (pic_start_code >> 8) & 0xff, 8);	// For any extra information (like in mpeg4p2, the pic_start_code)
+		PutBits(&ld2, 0x1, 8);  // Start Code
+		PutBits(&ld2, pic_start_code & 0xff, 8);    // 00, for picture start
+		PutBits(&ld2, (pic_start_code >> 8) & 0xff, 8); // For any extra information (like in mpeg4p2, the pic_start_code)
 		//14 + 5 = 19
 	}
 
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/vc1.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/vc1.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/vc1.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/vc1.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -32,16 +32,16 @@
 #include "pes.h"
 #include "writer.h"
 
-#define WMV3_PRIVATE_DATA_LENGTH		 4
+#define WMV3_PRIVATE_DATA_LENGTH         4
 
-#define METADATA_STRUCT_A_START			12
-#define METADATA_STRUCT_B_START			24
-#define METADATA_STRUCT_B_FRAMERATE_START	32
-#define METADATA_STRUCT_C_START			 8
+#define METADATA_STRUCT_A_START         12
+#define METADATA_STRUCT_B_START         24
+#define METADATA_STRUCT_B_FRAMERATE_START   32
+#define METADATA_STRUCT_C_START          8
 
 
-#define VC1_SEQUENCE_LAYER_METADATA_START_CODE	0x80
-#define VC1_FRAME_START_CODE			0x0d
+#define VC1_SEQUENCE_LAYER_METADATA_START_CODE  0x80
+#define VC1_FRAME_START_CODE            0x0d
 
 class WriterVC1 : public Writer
 {
@@ -68,22 +68,24 @@
 	if (!packet || !packet->data)
 		return false;
 
-	if (initialHeader) {
+	if (initialHeader)
+	{
 		initialHeader = false;
 		FrameHeaderSeen = false;
 
 		const uint8_t SequenceLayerStartCode[] =
-			{ 0x00, 0x00, 0x01, VC1_SEQUENCE_LAYER_METADATA_START_CODE };
+		{ 0x00, 0x00, 0x01, VC1_SEQUENCE_LAYER_METADATA_START_CODE };
 
 
-		const uint8_t Metadata[] = {
+		const uint8_t Metadata[] =
+		{
 			0x00, 0x00, 0x00, 0xc5,
 			0x04, 0x00, 0x00, 0x00,
-			0xc0, 0x00, 0x00, 0x00,	/* Struct C set for for advanced profile */
-			0x00, 0x00, 0x00, 0x00,	/* Struct A */
+			0xc0, 0x00, 0x00, 0x00, /* Struct C set for for advanced profile */
+			0x00, 0x00, 0x00, 0x00, /* Struct A */
 			0x00, 0x00, 0x00, 0x00,
 			0x0c, 0x00, 0x00, 0x00,
-			0x60, 0x00, 0x00, 0x00,	/* Struct B */
+			0x60, 0x00, 0x00, 0x00, /* Struct B */
 			0x00, 0x00, 0x00, 0x00,
 			0x00, 0x00, 0x00, 0x00
 		};
@@ -116,7 +118,7 @@
 		*PesPtr++ = (get_codecpar(stream)->width >> 16) & 0xff;
 		*PesPtr++ = get_codecpar(stream)->width >> 24;
 
-		PesPtr += 12;		/* Skip flag word and Struct B first 8 bytes */
+		PesPtr += 12;       /* Skip flag word and Struct B first 8 bytes */
 
 		*PesPtr++ = (usecPerFrame >> 0) & 0xff;
 		*PesPtr++ = (usecPerFrame >> 8) & 0xff;
@@ -141,21 +143,25 @@
 		initialHeader = false;
 	}
 
-	if (packet->size > 0) {
+	if (packet->size > 0)
+	{
 		int Position = 0;
 		bool insertSampleHeader = true;
 
-		while (Position < packet->size) {
+		while (Position < packet->size)
+		{
 			int PacketLength = std::min(packet->size - Position, MAX_PES_PACKET_SIZE);
 			uint8_t PesHeader[PES_MAX_HEADER_SIZE];
 			int HeaderLength = InsertPesHeader(PesHeader, PacketLength, VC1_VIDEO_PES_START_CODE, pts, 0);
 
-			if (insertSampleHeader) {
+			if (insertSampleHeader)
+			{
 				const uint8_t Vc1FrameStartCode[] = { 0, 0, 1, VC1_FRAME_START_CODE };
 
 				if (!FrameHeaderSeen && (packet->size > 3) && (memcmp(packet->data, Vc1FrameStartCode, 4) == 0))
 					FrameHeaderSeen = true;
-				if (!FrameHeaderSeen) {
+				if (!FrameHeaderSeen)
+				{
 					memcpy(&PesHeader[HeaderLength], Vc1FrameStartCode, sizeof(Vc1FrameStartCode));
 					HeaderLength += sizeof(Vc1FrameStartCode);
 				}
@@ -185,4 +191,4 @@
 	Register(this, AV_CODEC_ID_VC1, VIDEO_ENCODING_VC1);
 }
 
-static WriterVC1 writer_vc1 __attribute__ ((init_priority (300)));
+static WriterVC1 writer_vc1 __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/wmv.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/wmv.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/wmv.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/wmv.cpp	2022-07-23 18:18:31.511772868 +0200
@@ -33,21 +33,22 @@
 
 #include <algorithm>
 
-#define WMV3_PRIVATE_DATA_LENGTH	4
+#define WMV3_PRIVATE_DATA_LENGTH    4
 
-static const uint8_t Metadata[] = {
+static const uint8_t Metadata[] =
+{
 	0x00, 0x00, 0x00, 0xc5,
 	0x04, 0x00, 0x00, 0x00,
-#define METADATA_STRUCT_C_START			8
-	0xc0, 0x00, 0x00, 0x00,	/* Struct C set for for advanced profile */
-#define METADATA_STRUCT_A_START			12
-	0x00, 0x00, 0x00, 0x00,	/* Struct A */
+#define METADATA_STRUCT_C_START         8
+	0xc0, 0x00, 0x00, 0x00, /* Struct C set for for advanced profile */
+#define METADATA_STRUCT_A_START         12
+	0x00, 0x00, 0x00, 0x00, /* Struct A */
 	0x00, 0x00, 0x00, 0x00,
 	0x0c, 0x00, 0x00, 0x00,
-#define METADATA_STRUCT_B_START			24
-	0x60, 0x00, 0x00, 0x00,	/* Struct B */
+#define METADATA_STRUCT_B_START         24
+	0x60, 0x00, 0x00, 0x00, /* Struct B */
 	0x00, 0x00, 0x00, 0x00,
-#define METADATA_STRUCT_B_FRAMERATE_START	32
+#define METADATA_STRUCT_B_FRAMERATE_START   32
 	0x00, 0x00, 0x00, 0x00
 };
 
@@ -75,7 +76,8 @@
 	if (!packet || !packet->data)
 		return false;
 
-	if (initialHeader) {
+	if (initialHeader)
+	{
 #define PES_MIN_HEADER_SIZE 9
 		uint8_t PesPacket[PES_MIN_HEADER_SIZE + 128];
 		uint8_t *PesPtr;
@@ -103,7 +105,7 @@
 		*PesPtr++ = (get_codecpar(stream)->width >> 16) & 0xff;
 		*PesPtr++ = get_codecpar(stream)->width >> 24;
 
-		PesPtr += 12;		/* Skip flag word and Struct B first 8 bytes */
+		PesPtr += 12;       /* Skip flag word and Struct B first 8 bytes */
 
 		*PesPtr++ = (usecPerFrame >> 0) & 0xff;
 		*PesPtr++ = (usecPerFrame >> 8) & 0xff;
@@ -120,18 +122,21 @@
 		initialHeader = false;
 	}
 
-	if (packet->size > 0 && packet->data) {
+	if (packet->size > 0 && packet->data)
+	{
 		int Position = 0;
 		bool insertSampleHeader = true;
 
-		while (Position < packet->size) {
+		while (Position < packet->size)
+		{
 
 			int PacketLength = std::min(packet->size - Position, MAX_PES_PACKET_SIZE);
 
 			uint8_t PesHeader[PES_MAX_HEADER_SIZE] = { 0 };
 			int HeaderLength = InsertPesHeader(PesHeader, PacketLength, VC1_VIDEO_PES_START_CODE, pts, 0);
 
-			if (insertSampleHeader) {
+			if (insertSampleHeader)
+			{
 				unsigned int PesLength;
 				unsigned int PrivateHeaderLength;
 
@@ -168,4 +173,4 @@
 	Register(this, AV_CODEC_ID_WMV3, VIDEO_ENCODING_WMV);
 }
 
-static WriterWMV writer_wmv __attribute__ ((init_priority (300)));
+static WriterWMV writer_wmv __attribute__((init_priority(300)));
diff -Nur libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/writer.cpp libstb-hal-ddt.git/libeplayer3-sh4/writer/writer.cpp
--- libstb-hal-ddt.git.orig/libeplayer3-sh4/writer/writer.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libeplayer3-sh4/writer/writer.cpp	2022-07-23 18:18:31.515772788 +0200
@@ -43,9 +43,9 @@
 #include "wmv.cpp"
 //#include "aac.cpp"
 
-static std::map<enum AVCodecID,Writer *>writers __attribute__ ((init_priority (200)));
-static std::map<enum AVCodecID,video_encoding_t>vencoding __attribute__ ((init_priority (200)));
-static std::map<enum AVCodecID,audio_encoding_t>aencoding __attribute__ ((init_priority (200)));
+static std::map<enum AVCodecID, Writer *>writers __attribute__((init_priority(200)));
+static std::map<enum AVCodecID, video_encoding_t>vencoding __attribute__((init_priority(200)));
+static std::map<enum AVCodecID, audio_encoding_t>aencoding __attribute__((init_priority(200)));
 
 void Writer::Register(Writer *w, enum AVCodecID id, video_encoding_t encoding)
 {
@@ -64,17 +64,19 @@
 	return false;
 }
 
-static Writer writer __attribute__ ((init_priority (300)));
+static Writer writer __attribute__((init_priority(300)));
 
 Writer *Writer::GetWriter(enum AVCodecID id, enum AVMediaType codec_type, int track_type)
 {
 	fprintf(stderr, "GETWRITER %d %d %d", id, codec_type, track_type);
-	if (track_type != 6) { // hack for ACC resampling
-		std::map<enum AVCodecID,Writer*>::iterator it = writers.find(id);
+	if (track_type != 6)   // hack for ACC resampling
+	{
+		std::map<enum AVCodecID, Writer *>::iterator it = writers.find(id);
 		if (it != writers.end())
 			return it->second;
 	}
-	switch (codec_type) {
+	switch (codec_type)
+	{
 		case AVMEDIA_TYPE_AUDIO:
 			if (id == AV_CODEC_ID_INJECTPCM) // should not happen
 				break;
@@ -91,7 +93,7 @@
 
 video_encoding_t Writer::GetVideoEncoding(enum AVCodecID id)
 {
-	std::map<enum AVCodecID,video_encoding_t>::iterator it = vencoding.find(id);
+	std::map<enum AVCodecID, video_encoding_t>::iterator it = vencoding.find(id);
 	if (it != vencoding.end())
 		return it->second;
 	return VIDEO_ENCODING_AUTO;
@@ -99,7 +101,7 @@
 
 audio_encoding_t Writer::GetAudioEncoding(enum AVCodecID id)
 {
-	std::map<enum AVCodecID,audio_encoding_t>::iterator it = aencoding.find(id);
+	std::map<enum AVCodecID, audio_encoding_t>::iterator it = aencoding.find(id);
 	if (it != aencoding.end())
 		return it->second;
 	return AUDIO_ENCODING_LPCMA;
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/audio.cpp libstb-hal-ddt.git/libgeneric-pc/audio.cpp
--- libstb-hal-ddt.git.orig/libgeneric-pc/audio.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libgeneric-pc/audio.cpp	2022-07-23 18:18:31.535772387 +0200
@@ -43,7 +43,7 @@
 /* my own buf 16k */
 #define DMX_BUF_SZ 0x4000
 
-cAudio * audioDecoder = NULL;
+cAudio *audioDecoder = NULL;
 extern cDemux *audioDemux;
 static uint8_t *dmxbuf = NULL;
 static int bufpos;
@@ -132,9 +132,11 @@
 	hal_debug("%s %d\n", __func__, Mode);
 };
 
-void cAudio::SetStreamType(AUDIO_FORMAT type)
+void cAudio::SetStreamType(int bypass)
 {
-	hal_debug("%s %d\n", __func__, type);
+	StreamType = bypass;
+
+	hal_debug("%s %d (0x%x)\n", __FUNCTION__, bypass, bypass);
 };
 
 int cAudio::setChannel(int /*channel*/)
@@ -161,9 +163,9 @@
 		adevice = ao_open_live(driver, &sformat, NULL);
 		ao_info *ai = ao_driver_info(driver);
 		hal_info("%s: changed params ch %d srate %d bits %d le %d adevice %p\n",
-			__func__, ch, srate, bits, le, adevice);;
+		    __func__, ch, srate, bits, le, adevice);;
 		hal_info("libao driver: %d name '%s' short '%s' author '%s'\n",
-				driver, ai->name, ai->short_name, ai->author);
+		    driver, ai->name, ai->short_name, ai->author);
 	}
 	return 0;
 };
@@ -171,7 +173,8 @@
 int cAudio::WriteClip(unsigned char *buffer, int size)
 {
 	hal_debug("cAudio::%s buf 0x%p size %d\n", __func__, buffer, size);
-	if (!adevice) {
+	if (!adevice)
+	{
 		hal_info("%s: adevice not opened?\n", __func__);
 		return 0;
 	}
@@ -185,7 +188,8 @@
 #if 0
 	/* don't do anything - closing / reopening ao all the time makes for long delays
 	 * reinit on-demand (e.g. for changed parameters) instead */
-	if (!adevice) {
+	if (!adevice)
+	{
 		hal_info("%s: adevice not opened?\n", __func__);
 		return 0;
 	}
@@ -198,13 +202,15 @@
 void cAudio::getAudioInfo(int &type, int &layer, int &freq, int &bitrate, int &mode)
 {
 	type = 0;
-	layer = 0;	/* not used */
+	layer = 0;  /* not used */
 	freq = 0;
-	bitrate = 0;	/* not used, but easy to get :-) */
-	mode = 0;	/* default: stereo */
+	bitrate = 0;    /* not used, but easy to get :-) */
+	mode = 0;   /* default: stereo */
 	printf("cAudio::getAudioInfo c %p\n", c);
-	if (c) {
-		switch (c->codec_id) {
+	if (c)
+	{
+		switch (c->codec_id)
+		{
 			case AV_CODEC_ID_MP2:
 				type = AUDIO_FMT_MPEG;
 				break;
@@ -234,40 +240,42 @@
 		bitrate = c->bit_rate;
 		if (c->channels == 1)
 			mode = 3; /* for AV_CODEC_ID_MP2, only stereo / mono is detected for now */
-		if (c->codec_id != AV_CODEC_ID_MP2) {
-			switch (c->channel_layout) {
+		if (c->codec_id != AV_CODEC_ID_MP2)
+		{
+			switch (c->channel_layout)
+			{
 				case AV_CH_LAYOUT_MONO:
-					mode = 1;	// "C"
+					mode = 1;   // "C"
 					break;
 				case AV_CH_LAYOUT_STEREO:
-					mode = 2;	// "L/R"
+					mode = 2;   // "L/R"
 					break;
 				case AV_CH_LAYOUT_2_1:
 				case AV_CH_LAYOUT_SURROUND:
-					mode = 3;	// "L/C/R"
+					mode = 3;   // "L/C/R"
 					break;
 				case AV_CH_LAYOUT_2POINT1:
-					mode = 4;	// "L/R/S"
+					mode = 4;   // "L/R/S"
 					break;
 				case AV_CH_LAYOUT_3POINT1:
-					mode = 5;	// "L/C/R/S"
+					mode = 5;   // "L/C/R/S"
 					break;
 				case AV_CH_LAYOUT_2_2:
 				case AV_CH_LAYOUT_QUAD:
-					mode = 6;	// "L/R/SL/SR"
+					mode = 6;   // "L/R/SL/SR"
 					break;
 				case AV_CH_LAYOUT_5POINT0:
 				case AV_CH_LAYOUT_5POINT1:
-					mode = 7;	// "L/C/R/SL/SR"
+					mode = 7;   // "L/C/R/SL/SR"
 					break;
 				default:
 					hal_info("%s: unknown ch_layout 0x%" PRIx64 "\n",
-						 __func__, c->channel_layout);
+					    __func__, c->channel_layout);
 			}
 		}
 	}
 	hal_debug("%s t: %d l: %d f: %d b: %d m: %d codec_id: %x\n",
-		  __func__, type, layer, freq, bitrate, mode, c?c->codec_id:-1);
+	    __func__, type, layer, freq, bitrate, mode, c ? c->codec_id : -1);
 };
 
 void cAudio::SetSRS(int /*iq_enable*/, int /*nmgr_enable*/, int /*iq_mode*/, int /*iq_level*/)
@@ -308,8 +316,10 @@
 int cAudio::my_read(uint8_t *buf, int buf_size)
 {
 	int tmp = 0;
-	if (audioDecoder && bufpos < DMX_BUF_SZ - 4096) {
-		while (bufpos < buf_size && ++tmp < 20) { /* retry max 20 times */
+	if (audioDecoder && bufpos < DMX_BUF_SZ - 4096)
+	{
+		while (bufpos < buf_size && ++tmp < 20)   /* retry max 20 times */
+		{
 			int ret = audioDemux->Read(dmxbuf + bufpos, DMX_BUF_SZ - bufpos, 10);
 			if (ret > 0)
 				bufpos += ret;
@@ -320,7 +330,8 @@
 	if (bufpos == 0)
 		return 0;
 	//hal_info("%s buf_size %d bufpos %d th %d tmp %d\n", __func__, buf_size, bufpos, thread_started, tmp);
-	if (bufpos > buf_size) {
+	if (bufpos > buf_size)
+	{
 		memcpy(buf, dmxbuf, buf_size);
 		memmove(dmxbuf, dmxbuf + buf_size, bufpos - buf_size);
 		bufpos -= buf_size;
@@ -365,18 +376,19 @@
 	av_init_packet(&avpkt);
 	inp = av_find_input_format("mpegts");
 	AVIOContext *pIOCtx = avio_alloc_context(inbuf, INBUF_SIZE, // internal Buffer and its size
-			0,		// bWriteable (1=true,0=false)
-			NULL,		// user data; will be passed to our callback functions
-			_my_read,	// read callback
-			NULL,		// write callback
-			NULL);		// seek callback
+	        0,      // bWriteable (1=true,0=false)
+	        NULL,       // user data; will be passed to our callback functions
+	        _my_read,   // read callback
+	        NULL,       // write callback
+	        NULL);      // seek callback
 	avfc = avformat_alloc_context();
 	avfc->pb = pIOCtx;
 	avfc->iformat = inp;
-	avfc->probesize = 188*5;
+	avfc->probesize = 188 * 5;
 	thread_started = true;
 
-	if (avformat_open_input(&avfc, NULL, inp, NULL) < 0) {
+	if (avformat_open_input(&avfc, NULL, inp, NULL) < 0)
+	{
 		hal_info("%s: avformat_open_input() failed.\n", __func__);
 		goto out;
 	}
@@ -392,31 +404,35 @@
 		hal_info("%s: stream 0 no audio codec? 0x%x\n", __func__, p->codec_type);
 
 	codec = avcodec_find_decoder(p->codec_id);
-	if (!codec) {
+	if (!codec)
+	{
 		hal_info("%s: Codec for %s not found\n", __func__, avcodec_get_name(p->codec_id));
 		goto out;
 	}
 	if (c)
 		av_free(c);
 	c = avcodec_alloc_context3(codec);
-	if (avcodec_open2(c, codec, NULL) < 0) {
+	if (avcodec_open2(c, codec, NULL) < 0)
+	{
 		hal_info("%s: avcodec_open2() failed\n", __func__);
 		goto out;
 	}
-	if(p->sample_rate == 0 || p->channels == 0){
+	if (p->sample_rate == 0 || p->channels == 0)
+	{
 		av_get_sample_fmt_string(tmp, sizeof(tmp), c->sample_fmt);
-		hal_info("Header missing %s, sample_fmt %d (%s) sample_rate %d channels %d\n",avcodec_get_name(p->codec_id), c->sample_fmt, tmp, p->sample_rate, p->channels);
+		hal_info("Header missing %s, sample_fmt %d (%s) sample_rate %d channels %d\n", avcodec_get_name(p->codec_id), c->sample_fmt, tmp, p->sample_rate, p->channels);
 		goto out2;
 	}
 	frame = av_frame_alloc();
-	if (!frame) {
+	if (!frame)
+	{
 		hal_info("%s: av_frame_alloc failed\n", __func__);
 		goto out2;
 	}
 	/* output sample rate, channels, layout could be set here if necessary */
-	o_ch = p->channels;		/* 2 */
-	o_sr = p->sample_rate;		/* 48000 */
-	o_layout = p->channel_layout;	/* AV_CH_LAYOUT_STEREO */
+	o_ch = p->channels;     /* 2 */
+	o_sr = p->sample_rate;      /* 48000 */
+	o_layout = p->channel_layout;   /* AV_CH_LAYOUT_STEREO */
 	if (sformat.channels != o_ch || sformat.rate != o_sr ||
 	    sformat.byte_format != AO_FMT_NATIVE || sformat.bits != 16 || adevice == NULL)
 	{
@@ -431,10 +447,10 @@
 		adevice = ao_open_live(driver, &sformat, NULL);
 		ai = ao_driver_info(driver);
 		hal_info("%s: changed params ch %d srate %d bits %d adevice %p\n",
-			__func__, o_ch, o_sr, 16, adevice);
-		if(ai)
+		    __func__, o_ch, o_sr, 16, adevice);
+		if (ai)
 			hal_info("libao driver: %d name '%s' short '%s' author '%s'\n",
-				driver, ai->name, ai->short_name, ai->author);
+			    driver, ai->name, ai->short_name, ai->author);
 	}
 #if 0
 	hal_info(" driver options:");
@@ -444,17 +460,19 @@
 #endif
 	av_get_sample_fmt_string(tmp, sizeof(tmp), c->sample_fmt);
 	hal_info("decoding %s, sample_fmt %d (%s) sample_rate %d channels %d\n",
-		 avcodec_get_name(p->codec_id), c->sample_fmt, tmp, p->sample_rate, p->channels);
+	    avcodec_get_name(p->codec_id), c->sample_fmt, tmp, p->sample_rate, p->channels);
 	swr = swr_alloc_set_opts(swr,
-				 o_layout, AV_SAMPLE_FMT_S16, o_sr,			/* output */
-				 p->channel_layout, c->sample_fmt, p->sample_rate,	/* input */
-				 0, NULL);
-	if (! swr) {
+	        o_layout, AV_SAMPLE_FMT_S16, o_sr,         /* output */
+	        p->channel_layout, c->sample_fmt, p->sample_rate,  /* input */
+	        0, NULL);
+	if (! swr)
+	{
 		hal_info("could not alloc resample context\n");
 		goto out3;
 	}
 	swr_init(swr);
-	while (thread_started) {
+	while (thread_started)
+	{
 		int gotframe = 0;
 		if (av_read_frame(avfc, &avpkt) < 0)
 			break;
@@ -462,26 +480,35 @@
 		avcodec_decode_audio4(c, frame, &gotframe, &avpkt);
 #else
 		av_ret = avcodec_send_packet(c, &avpkt);
-		if (av_ret != 0 && av_ret != AVERROR(EAGAIN)) {
+		if (av_ret != 0 && av_ret != AVERROR(EAGAIN))
+		{
 			hal_info("%s: avcodec_send_packet %d\n", __func__, av_ret);
-		}else {
+		}
+		else
+		{
 			av_ret = avcodec_receive_frame(c, frame);
-			if (av_ret != 0 && av_ret != AVERROR(EAGAIN)) {
+			if (av_ret != 0 && av_ret != AVERROR(EAGAIN))
+			{
 				hal_info("%s: avcodec_send_packet %d\n", __func__, av_ret);
-			}else {
+			}
+			else
+			{
 				gotframe = 1;
 			}
 		}
 #endif
 
-		if (gotframe && thread_started) {
+		if (gotframe && thread_started)
+		{
 			int out_linesize;
 			obuf_sz = av_rescale_rnd(swr_get_delay(swr, p->sample_rate) + frame->nb_samples, o_sr, p->sample_rate, AV_ROUND_UP);
-			if (obuf_sz > obuf_sz_max) {
+			if (obuf_sz > obuf_sz_max)
+			{
 				hal_info("obuf_sz: %d old: %d\n", obuf_sz, obuf_sz_max);
 				av_free(obuf);
 				if (av_samples_alloc(&obuf, &out_linesize, o_ch,
-							frame->nb_samples, AV_SAMPLE_FMT_S16, 1) < 0) {
+				        frame->nb_samples, AV_SAMPLE_FMT_S16, 1) < 0)
+				{
 					hal_info("av_samples_alloc failed\n");
 					av_packet_unref(&avpkt);
 					break; /* while (thread_started) */
@@ -489,29 +516,29 @@
 				obuf_sz_max = obuf_sz;
 			}
 			obuf_sz = swr_convert(swr, &obuf, obuf_sz,
-					      (const uint8_t **)frame->extended_data, frame->nb_samples);
+			        (const uint8_t **)frame->extended_data, frame->nb_samples);
 #if (LIBAVUTIL_VERSION_MAJOR < 54)
 			curr_pts = av_frame_get_best_effort_timestamp(frame);
 #else
 			curr_pts = frame->best_effort_timestamp;
 #endif
-			hal_debug("%s: pts 0x%" PRIx64 " %3f\n", __func__, curr_pts, curr_pts/90000.0);
+			hal_debug("%s: pts 0x%" PRIx64 " %3f\n", __func__, curr_pts, curr_pts / 90000.0);
 			int o_buf_sz = av_samples_get_buffer_size(&out_linesize, o_ch, obuf_sz, AV_SAMPLE_FMT_S16, 1);
 			if (o_buf_sz > 0)
 				ao_play(adevice, (char *)obuf, o_buf_sz);
 		}
 		av_packet_unref(&avpkt);
 	}
-	// ao_close(adevice); /* can take long :-( */
+	// ao_close(adevice); /* can take long :-(*/
 	av_free(obuf);
 	swr_free(&swr);
- out3:
+out3:
 	av_frame_free(&frame);
- out2:
+out2:
 	avcodec_close(c);
 	av_free(c);
 	c = NULL;
- out:
+out:
 	avformat_close_input(&avfc);
 	av_free(pIOCtx->buffer);
 	av_free(pIOCtx);
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/audio_lib.h libstb-hal-ddt.git/libgeneric-pc/audio_lib.h
--- libstb-hal-ddt.git.orig/libgeneric-pc/audio_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/audio_lib.h	2022-07-23 18:18:31.535772387 +0200
@@ -14,7 +14,8 @@
 	AUDIO_SYNC_AUDIO_MASTER
 } AUDIO_SYNC_MODE;
 
-typedef enum {
+typedef enum
+{
 	HDMI_ENCODED_OFF,
 	HDMI_ENCODED_AUTO,
 	HDMI_ENCODED_FORCED
@@ -40,7 +41,7 @@
 
 class cAudio : public OpenThreads::Thread
 {
-	friend class cPlayback;
+		friend class cPlayback;
 	private:
 		int fd;
 		bool Muted;
@@ -49,7 +50,7 @@
 		int mixer_fd;  /* if we are using the OSS mixer */
 		int mixer_num; /* oss mixer to use, if any */
 
-		AUDIO_FORMAT	StreamType;
+		int	StreamType;
 		AUDIO_SYNC_MODE    SyncMode;
 		bool started;
 		bool thread_started;
@@ -68,31 +69,51 @@
 		/* construct & destruct */
 		cAudio(void *, void *, void *);
 		~cAudio(void);
-		int64_t getPts() { return curr_pts; }
-
-		void *GetHandle() { return NULL; };
+		int64_t getPts()
+		{
+			return curr_pts;
+		}
+
+		void setAVInput(int val) { return; };
+		void *GetHandle()
+		{
+			return NULL;
+		};
 		/* shut up */
-		int mute(bool remember = true) { return do_mute(true, remember); };
-		int unmute(bool remember = true) { return do_mute(false, remember); };
+		int mute(bool remember = true)
+		{
+			return do_mute(true, remember);
+		};
+		int unmute(bool remember = true)
+		{
+			return do_mute(false, remember);
+		};
 
 		/* volume, min = 0, max = 255 */
 		int setVolume(unsigned int left, unsigned int right);
-		int getVolume(void) { return volume;}
-		bool getMuteStatus(void) { return Muted; };
+		int getVolume(void)
+		{
+			return volume;
+		}
+		bool getMuteStatus(void)
+		{
+			return Muted;
+		};
 
 		/* start and stop audio */
 		int Start(void);
 		int Stop(void);
 		bool Pause(bool Pcm = true);
-		void SetStreamType(AUDIO_FORMAT type);
+		void SetStreamType(int bypass);
+		int GetStreamType(void) { return StreamType; }
 		void SetSyncMode(AVSYNC_TYPE Mode);
 
 		/* select channels */
 		int setChannel(int channel);
 		int PrepareClipPlay(int uNoOfChannels, int uSampleRate, int uBitsPerSample, int bLittleEndian);
-		int WriteClip(unsigned char * buffer, int size);
+		int WriteClip(unsigned char *buffer, int size);
 		int StopClip();
-		void getAudioInfo(int &type, int &layer, int& freq, int &bitrate, int &mode);
+		void getAudioInfo(int &type, int &layer, int &freq, int &bitrate, int &mode);
 		void SetSRS(int iq_enable, int nmgr_enable, int iq_mode, int iq_level);
 		bool IsHdmiDDSupported();
 		void SetHdmiDD(bool enable);
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/clutterfb.cpp libstb-hal-ddt.git/libgeneric-pc/clutterfb.cpp
--- libstb-hal-ddt.git.orig/libgeneric-pc/clutterfb.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libgeneric-pc/clutterfb.cpp	2022-07-23 18:18:31.535772387 +0200
@@ -1,25 +1,25 @@
 /*
-	Framebuffer implementation using clutter https://developer.gnome.org/clutter/
-	Copyright (C) 2016 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
+    Framebuffer implementation using clutter https://developer.gnome.org/clutter/
+    Copyright (C) 2016 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
 
-	based on the openGL framebuffer implementation
-	Copyright 2010 Carsten Juttner <carjay@gmx.net>
-	Copyright 2012,2013 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-	GNU General Public License for more details.
+    based on the openGL framebuffer implementation
+    Copyright 2010 Carsten Juttner <carjay@gmx.net>
+    Copyright 2012,2013 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+    GNU General Public License for more details.
 
-	You should have received a copy of the GNU General Public License
-	along with this program. If not, see <http://www.gnu.org/licenses/>.
+    You should have received a copy of the GNU General Public License
+    along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-	TODO:	AV-Sync code is "experimental" at best
+    TODO:   AV-Sync code is "experimental" at best
 */
 
 #include "config.h"
@@ -92,8 +92,8 @@
 	*mX = x;
 	*mY = y;
 	av_reduce(&mOA.num, &mOA.den, x, y, INT_MAX);
-	mVA = mOA;	/* initial aspect ratios are from the FB resolution, those */
-	_mVA = mVA;	/* will be updated by the videoDecoder functions anyway */
+	mVA = mOA;  /* initial aspect ratios are from the FB resolution, those */
+	_mVA = mVA; /* will be updated by the videoDecoder functions anyway */
 	mVAchanged = true;
 	mCrop = DISPLAY_AR_MODE_PANSCAN;
 	zoom = 1.0;
@@ -121,7 +121,7 @@
 
 	unlink("/tmp/neutrino.input");
 	mkfifo("/tmp/neutrino.input", 0600);
-	input_fd = open("/tmp/neutrino.input", O_RDWR|O_CLOEXEC|O_NONBLOCK);
+	input_fd = open("/tmp/neutrino.input", O_RDWR | O_CLOEXEC | O_NONBLOCK);
 	if (input_fd < 0)
 		hal_info("%s: could not open /tmp/neutrino.input FIFO: %m\n", __func__);
 	initKeys();
@@ -214,7 +214,8 @@
 	argv[0] = a;
 	argv[1] = NULL;
 	hal_info("GLFB: GL thread starting x %d y %d\n", x, y);
-	if (clutter_init(&argc, &argv) != CLUTTER_INIT_SUCCESS) {
+	if (clutter_init(&argc, &argv) != CLUTTER_INIT_SUCCESS)
+	{
 		hal_info("GLFB: error initializing clutter\n");
 		free(argv);
 		return;
@@ -228,7 +229,7 @@
 	//g_signal_connect(stage, "destroy", G_CALLBACK(clutter_main_quit), NULL);
 	g_signal_connect(stage, "key-press-event", G_CALLBACK(GLFbPC::keyboardcb), (void *)1);
 	g_signal_connect(stage, "key-release-event", G_CALLBACK(GLFbPC::keyboardcb), NULL);
-	clutter_stage_set_user_resizable(CLUTTER_STAGE (stage), TRUE);
+	clutter_stage_set_user_resizable(CLUTTER_STAGE(stage), TRUE);
 	clutter_actor_grab_key_focus(stage);
 	clutter_actor_show(stage);
 
@@ -241,7 +242,8 @@
 	vid_actor = clutter_actor_new();
 	ClutterContent *fb = clutter_image_new();
 	/* osd_buf, because it starts up black */
-	if (!clutter_image_set_data(CLUTTER_IMAGE(fb), osd_buf.data(), COGL_PIXEL_FORMAT_BGR_888, x, y, x*3, NULL)) {
+	if (!clutter_image_set_data(CLUTTER_IMAGE(fb), osd_buf.data(), COGL_PIXEL_FORMAT_BGR_888, x, y, x * 3, NULL))
+	{
 		hal_info("GLFB::%s clutter_image_set_data failed? (vid)\n", __func__);
 		_exit(1); /* life is hard */
 	}
@@ -260,7 +262,8 @@
 
 	fb_actor = clutter_actor_new();
 	fb = clutter_image_new();
-	if (!clutter_image_set_data(CLUTTER_IMAGE(fb), osd_buf.data(), COGL_PIXEL_FORMAT_BGRA_8888, x, y, x*4, NULL)) {
+	if (!clutter_image_set_data(CLUTTER_IMAGE(fb), osd_buf.data(), COGL_PIXEL_FORMAT_BGRA_8888, x, y, x * 4, NULL))
+	{
 		hal_info("GLFB::%s clutter_image_set_data failed? (osd)\n", __func__);
 		_exit(1); /* life is hard */
 	}
@@ -293,14 +296,14 @@
 
 /* static */ bool GLFbPC::keyboardcb(ClutterActor * /*actor*/, ClutterEvent *event, gpointer user_data)
 {
-	guint key = clutter_event_get_key_symbol (event);
+	guint key = clutter_event_get_key_symbol(event);
 	int keystate = user_data ? 1 : 0;
 	hal_info_c("GLFB::%s: 0x%x, %d\n", __func__, key, keystate);
 
 	struct input_event ev;
 	if (key == 'f' && keystate)
 	{
-		hal_info_c("GLFB::%s: toggle fullscreen %s\n", __func__, glfb_priv->mFullscreen?"off":"on");
+		hal_info_c("GLFB::%s: toggle fullscreen %s\n", __func__, glfb_priv->mFullscreen ? "off" : "on");
 		glfb_priv->mFullscreen = !(glfb_priv->mFullscreen);
 		glfb_priv->mReInit = true;
 		return true;
@@ -314,7 +317,7 @@
 	gettimeofday(&ev.time, NULL);
 	hal_debug_c("GLFB::%s: pushing 0x%x\n", __func__, ev.code);
 	ssize_t w = write(glfb_priv->input_fd, &ev, sizeof(ev));
-	if(w < 0)
+	if (w < 0)
 		return false;
 	return true;
 }
@@ -323,7 +326,7 @@
 
 void GLFbPC::render()
 {
-	if(mShutDown)
+	if (mShutDown)
 		clutter_main_quit();
 
 	mReInitLock.lock();
@@ -338,22 +341,26 @@
 		mY = &_mY[mFullscreen];
 #endif
 		*mX = *mY * mOA.num / mOA.den;
-		if (mFullscreen) {
+		if (mFullscreen)
+		{
 			clutter_stage_set_fullscreen(CLUTTER_STAGE(stage), TRUE);
 			clutter_actor_show(stage);
 			clutter_stage_ensure_redraw(CLUTTER_STAGE(stage));
-		} else {
+		}
+		else
+		{
 			clutter_stage_set_fullscreen(CLUTTER_STAGE(stage), FALSE);
 //			*mX = *mY * mOA.num / mOA.den;
 			clutter_actor_set_size(stage, *mX, *mY);
 		}
 		hal_info("%s: reinit mX:%d mY:%d xoff:%d yoff:%d fs %d\n",
-			__func__, *mX, *mY, xoff, yoff, mFullscreen);
+		    __func__, *mX, *mY, xoff, yoff, mFullscreen);
 	}
 	mReInitLock.unlock();
 
 	bltDisplayBuffer(); /* decoded video stream */
-	if (mState.blit) {
+	if (mState.blit)
+	{
 		/* only blit manually after fb->blit(), this helps to find missed blit() calls */
 		mState.blit = false;
 		hal_debug("GLFB::%s blit!\n", __func__);
@@ -368,23 +375,22 @@
 		//xscale = 1.0;
 		int cmp = av_cmp_q(mVA, mOA);
 		const AVRational a149 = { 14, 9 };
-		switch (cmp) {
+		switch (cmp)
+		{
 			default:
-			case INT_MIN:	/* invalid */
-			case 0:		/* identical */
+			case INT_MIN:   /* invalid */
+			case 0:     /* identical */
 				hal_debug("%s: mVA == mOA (or fullscreen mode :-)\n", __func__);
 				break;
-			case 1:		/* mVA > mOA -- video is wider than display */
+			case 1:     /* mVA > mOA -- video is wider than display */
 				hal_debug("%s: mVA > mOA\n", __func__);
-				switch (mCrop) {
+				switch (mCrop)
+				{
 					case DISPLAY_AR_MODE_PANSCAN:
 						zoom = av_q2d(mVA) / av_q2d(mOA);
 						break;
 					case DISPLAY_AR_MODE_LETTERBOX:
 						break;
-					case DISPLAY_AR_MODE_PANSCAN2:
-						zoom = av_q2d(a149) / av_q2d(mOA);
-						break;
 					case DISPLAY_AR_MODE_NONE:
 						xzoom = av_q2d(mOA) / av_q2d(mVA);
 						zoom = av_q2d(mVA) / av_q2d(mOA);
@@ -393,18 +399,12 @@
 						break;
 				}
 				break;
-			case -1:	/* mVA < mOA -- video is taller than display */
+			case -1:    /* mVA < mOA -- video is taller than display */
 				hal_debug("%s: mVA < mOA\n", __func__);
-				switch (mCrop) {
+				switch (mCrop)
+				{
 					case DISPLAY_AR_MODE_LETTERBOX:
 						break;
-					case DISPLAY_AR_MODE_PANSCAN2:
-						if (av_cmp_q(a149, mOA) < 0) {
-							zoom = av_q2d(mVA) * av_q2d(a149) / av_q2d(mOA);
-							break;
-						}
-						// fall through
-						/* fallthrough for output format 14:9 */
 					case DISPLAY_AR_MODE_PANSCAN:
 						zoom = av_q2d(mOA) / av_q2d(mVA);
 						break;
@@ -416,11 +416,11 @@
 				}
 				break;
 		}
-		hal_debug("zoom: %f xscale: %f xzoom: %f\n", zoom, xscale,xzoom);
-		clutter_actor_set_scale(vid_actor, xscale*zoom*xzoom, zoom);
+		hal_debug("zoom: %f xscale: %f xzoom: %f\n", zoom, xscale, xzoom);
+		clutter_actor_set_scale(vid_actor, xscale * zoom * xzoom, zoom);
 	}
 	clutter_timeline_stop(tl);
-	clutter_timeline_set_delay(tl, sleep_us/1000);
+	clutter_timeline_set_delay(tl, sleep_us / 1000);
 	clutter_timeline_start(tl);
 }
 
@@ -430,7 +430,8 @@
 	int x = glfb_priv->mState.width;
 	int y = glfb_priv->mState.height;
 	ClutterContent *fb = clutter_image_new();
-	if (!clutter_image_set_data(CLUTTER_IMAGE(fb), osd_buf->data(), COGL_PIXEL_FORMAT_BGRA_8888, x, y, x*4, NULL)) {
+	if (!clutter_image_set_data(CLUTTER_IMAGE(fb), osd_buf->data(), COGL_PIXEL_FORMAT_BGRA_8888, x, y, x * 4, NULL))
+	{
 		hal_info("GLFB::%s clutter_image_set_data failed?\n", __func__);
 		_exit(1); /* life is hard */
 	}
@@ -446,7 +447,8 @@
 		return;
 	static bool warn = true;
 	cVideo::SWFramebuffer *buf = videoDecoder->getDecBuf();
-	if (!buf) {
+	if (!buf)
+	{
 		if (warn)
 			hal_info("GLFB::%s did not get a buffer...\n", __func__);
 		warn = false;
@@ -458,18 +460,20 @@
 		return;
 
 	AVRational a = buf->AR();
-	if (a.den != 0 && a.num != 0 && av_cmp_q(a, _mVA)) {
+	if (a.den != 0 && a.num != 0 && av_cmp_q(a, _mVA))
+	{
 		_mVA = a;
 		/* _mVA is the raw buffer's aspect, mVA is the real scaled output aspect */
 		av_reduce(&mVA.num, &mVA.den, w * a.num, h * a.den, INT_MAX);
 		// mVA.num: 16 mVA.den: 9 w: 720 h: 576
 		// 16*576/720/9 = 1.42222
-		xscale = (double)mVA.num*h/(double)mVA.den/w;
+		xscale = (double)mVA.num * h / (double)mVA.den / w;
 		mVAchanged = true;
 	}
 
 	ClutterContent *fb = clutter_image_new();
-	if (!clutter_image_set_data(CLUTTER_IMAGE(fb), &(*buf)[0], COGL_PIXEL_FORMAT_BGR_888, w, h, w*3, NULL)) {
+	if (!clutter_image_set_data(CLUTTER_IMAGE(fb), &(*buf)[0], COGL_PIXEL_FORMAT_BGR_888, w, h, w * 3, NULL))
+	{
 		hal_info("GLFB::%s clutter_image_set_data failed?\n", __func__);
 		_exit(1); /* life is hard */
 	}
@@ -484,10 +488,11 @@
 	int64_t vpts = buf->pts();
 	if (audioDecoder)
 		apts = audioDecoder->getPts();
-	if (apts != last_apts) {
+	if (apts != last_apts)
+	{
 		int rate, dummy1, dummy2;
 		if (apts < vpts)
-			sleep_us = (sleep_us * 2 + (vpts - apts)*10/9) / 3;
+			sleep_us = (sleep_us * 2 + (vpts - apts) * 10 / 9) / 3;
 		else if (sleep_us > 1000)
 			sleep_us -= 1000;
 		last_apts = apts;
@@ -502,5 +507,5 @@
 			sleep_us = 1;
 	}
 	hal_debug("vpts: 0x%" PRIx64 " apts: 0x%" PRIx64 " diff: %6.3f sleep_us %d buf %d\n",
-			buf->pts(), apts, (buf->pts() - apts)/90000.0, sleep_us, videoDecoder->buf_num);
+	    buf->pts(), apts, (buf->pts() - apts) / 90000.0, sleep_us, videoDecoder->buf_num);
 }
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/dmx.cpp libstb-hal-ddt.git/libgeneric-pc/dmx.cpp
--- libstb-hal-ddt.git.orig/libgeneric-pc/dmx.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/dmx.cpp	2022-07-23 18:18:31.535772387 +0200
@@ -44,15 +44,16 @@
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_DEMUX, NULL, args)
 
 #define dmx_err(_errfmt, _errstr, _revents) do { \
-	hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
-		__func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
+    hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
+        __func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
 } while(0);
 
 cDemux *videoDemux = NULL;
 cDemux *audioDemux = NULL;
 //cDemux *pcrDemux = NULL;
 
-static const char *DMX_T[] = {
+static const char *DMX_T[] =
+{
 	"DMX_INVALID",
 	"DMX_VIDEO",
 	"DMX_AUDIO",
@@ -64,7 +65,8 @@
 };
 
 /* map the device numbers. for now only demux0 is used */
-static const char *devname[] = {
+static const char *devname[] =
+{
 	"/dev/dvb/adapter0/demux0",
 	"/dev/dvb/adapter0/demux0",
 	"/dev/dvb/adapter0/demux0"
@@ -97,7 +99,7 @@
 bool cDemux::Open(DMX_CHANNEL_TYPE pes_type, void * /*hVideoBuffer*/, int uBufferSize)
 {
 	int devnum = num;
-	int flags = O_RDWR|O_CLOEXEC;
+	int flags = O_RDWR | O_CLOEXEC;
 	if (fd > -1)
 		hal_info("%s FD ALREADY OPENED? fd = %d\n", __FUNCTION__, fd);
 
@@ -112,12 +114,12 @@
 		return false;
 	}
 	hal_debug("%s #%d pes_type: %s(%d), uBufferSize: %d fd: %d\n", __func__,
-		 num, DMX_T[pes_type], pes_type, uBufferSize, fd);
+	    num, DMX_T[pes_type], pes_type, uBufferSize, fd);
 
 	if (dmx_type == DMX_VIDEO_CHANNEL)
-		uBufferSize = 0x100000;		/* 1MB */
+		uBufferSize = 0x100000;     /* 1MB */
 	if (dmx_type == DMX_AUDIO_CHANNEL)
-		uBufferSize = 0x10000;		/* 64k */
+		uBufferSize = 0x10000;      /* 64k */
 #if 0
 	if (!pesfds.empty())
 	{
@@ -191,17 +193,17 @@
 #if 0
 	if (len != 4095 && timeout != 100)
 		fprintf(stderr, "cDemux::%s #%d fd: %d type: %s len: %d timeout: %d\n",
-			__FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
+		    __FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
 #endif
 	int rc;
 	struct pollfd ufds;
 	ufds.fd = fd;
-	ufds.events = POLLIN|POLLPRI|POLLERR;
+	ufds.events = POLLIN | POLLPRI | POLLERR;
 	ufds.revents = 0;
 
 	if (timeout > 0)
 	{
- retry:
+retry:
 		rc = ::poll(&ufds, 1, timeout);
 		if (!rc)
 			return 0; // timeout
@@ -242,9 +244,9 @@
 	return rc;
 }
 
-bool cDemux::sectionFilter(unsigned short _pid, const unsigned char * const filter,
-			   const unsigned char * const mask, int len, int timeout,
-			   const unsigned char * const negmask)
+bool cDemux::sectionFilter(unsigned short _pid, const unsigned char *const filter,
+    const unsigned char *const mask, int len, int timeout,
+    const unsigned char *const negmask)
 {
 	struct dmx_sct_filter_params s_flt;
 	memset(&s_flt, 0, sizeof(s_flt));
@@ -263,79 +265,80 @@
 	if (negmask != NULL)
 		memcpy(s_flt.filter.mode, negmask, len);
 
-	s_flt.flags = DMX_IMMEDIATE_START|DMX_CHECK_CRC;
+	s_flt.flags = DMX_IMMEDIATE_START | DMX_CHECK_CRC;
 
 	int to = 0;
-	switch (filter[0]) {
-	case 0x00: /* program_association_section */
-		to = 2000;
-		break;
-	case 0x01: /* conditional_access_section */
-		to = 6000;
-		break;
-	case 0x02: /* program_map_section */
-		to = 1500;
-		break;
-	case 0x03: /* transport_stream_description_section */
-		to = 10000;
-		break;
-	/* 0x04 - 0x3F: reserved */
-	case 0x40: /* network_information_section - actual_network */
-		to = 10000;
-		break;
-	case 0x41: /* network_information_section - other_network */
-		to = 15000;
-		break;
-	case 0x42: /* service_description_section - actual_transport_stream */
-		to = 10000;
-		break;
-	/* 0x43 - 0x45: reserved for future use */
-	case 0x46: /* service_description_section - other_transport_stream */
-		to = 10000;
-		break;
-	/* 0x47 - 0x49: reserved for future use */
-	case 0x4A: /* bouquet_association_section */
-		to = 11000;
-		break;
-	/* 0x4B - 0x4D: reserved for future use */
-	case 0x4E: /* event_information_section - actual_transport_stream, present/following */
-		to = 2000;
-		break;
-	case 0x4F: /* event_information_section - other_transport_stream, present/following */
-		to = 10000;
-		break;
-	/* 0x50 - 0x5F: event_information_section - actual_transport_stream, schedule */
-	/* 0x60 - 0x6F: event_information_section - other_transport_stream, schedule */
-	case 0x70: /* time_date_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		//s_flt.pid     = 0x0014;
-		to = 30000;
-		break;
-	case 0x71: /* running_status_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		to = 0;
-		break;
-	case 0x72: /* stuffing_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		to = 0;
-		break;
-	case 0x73: /* time_offset_section */
-		//s_flt.pid     = 0x0014;
-		to = 30000;
-		break;
-	/* 0x74 - 0x7D: reserved for future use */
-	case 0x7E: /* discontinuity_information_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		to = 0;
-		break;
-	case 0x7F: /* selection_information_section */
-		to = 0;
-		break;
-	/* 0x80 - 0x8F: ca_message_section */
-	/* 0x90 - 0xFE: user defined */
-	/*        0xFF: reserved */
-	default:
-		break;
+	switch (filter[0])
+	{
+		case 0x00: /* program_association_section */
+			to = 2000;
+			break;
+		case 0x01: /* conditional_access_section */
+			to = 6000;
+			break;
+		case 0x02: /* program_map_section */
+			to = 1500;
+			break;
+		case 0x03: /* transport_stream_description_section */
+			to = 10000;
+			break;
+		/* 0x04 - 0x3F: reserved */
+		case 0x40: /* network_information_section - actual_network */
+			to = 10000;
+			break;
+		case 0x41: /* network_information_section - other_network */
+			to = 15000;
+			break;
+		case 0x42: /* service_description_section - actual_transport_stream */
+			to = 10000;
+			break;
+		/* 0x43 - 0x45: reserved for future use */
+		case 0x46: /* service_description_section - other_transport_stream */
+			to = 10000;
+			break;
+		/* 0x47 - 0x49: reserved for future use */
+		case 0x4A: /* bouquet_association_section */
+			to = 11000;
+			break;
+		/* 0x4B - 0x4D: reserved for future use */
+		case 0x4E: /* event_information_section - actual_transport_stream, present/following */
+			to = 2000;
+			break;
+		case 0x4F: /* event_information_section - other_transport_stream, present/following */
+			to = 10000;
+			break;
+		/* 0x50 - 0x5F: event_information_section - actual_transport_stream, schedule */
+		/* 0x60 - 0x6F: event_information_section - other_transport_stream, schedule */
+		case 0x70: /* time_date_section */
+			s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
+			//s_flt.pid     = 0x0014;
+			to = 30000;
+			break;
+		case 0x71: /* running_status_section */
+			s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
+			to = 0;
+			break;
+		case 0x72: /* stuffing_section */
+			s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
+			to = 0;
+			break;
+		case 0x73: /* time_offset_section */
+			//s_flt.pid     = 0x0014;
+			to = 30000;
+			break;
+		/* 0x74 - 0x7D: reserved for future use */
+		case 0x7E: /* discontinuity_information_section */
+			s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
+			to = 0;
+			break;
+		case 0x7F: /* selection_information_section */
+			to = 0;
+			break;
+		/* 0x80 - 0x8F: ca_message_section */
+		/* 0x90 - 0xFE: user defined */
+		/*        0xFF: reserved */
+		default:
+			break;
 //		return -1;
 	}
 	/* the negmask == NULL is a hack: the users of negmask are PMT-update
@@ -345,13 +348,22 @@
 		s_flt.timeout = to;
 
 	hal_debug("%s #%d pid:0x%04hx fd:%d type:%s len:%d to:%d flags:%x flt[0]:%02x\n", __func__, num,
-		pid, fd, DMX_T[dmx_type], len, s_flt.timeout,s_flt.flags, s_flt.filter.filter[0]);
-#if 0
-	fprintf(stderr,"filt: ");for(int i=0;i<DMX_FILTER_SIZE;i++)fprintf(stderr,"%02hhx ",s_flt.filter.filter[i]);fprintf(stderr,"\n");
-	fprintf(stderr,"mask: ");for(int i=0;i<DMX_FILTER_SIZE;i++)fprintf(stderr,"%02hhx ",s_flt.filter.mask  [i]);fprintf(stderr,"\n");
-	fprintf(stderr,"mode: ");for(int i=0;i<DMX_FILTER_SIZE;i++)fprintf(stderr,"%02hhx ",s_flt.filter.mode  [i]);fprintf(stderr,"\n");
-#endif
-	ioctl (fd, DMX_STOP);
+	    pid, fd, DMX_T[dmx_type], len, s_flt.timeout, s_flt.flags, s_flt.filter.filter[0]);
+
+	if (debuglevel == 2)
+	{
+		fprintf(stderr, "filt: ");
+		for (int i = 0; i < DMX_FILTER_SIZE; i++)fprintf(stderr, "%02hhx ", s_flt.filter.filter[i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mask: ");
+		for (int i = 0; i < DMX_FILTER_SIZE; i++)fprintf(stderr, "%02hhx ", s_flt.filter.mask  [i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mode: ");
+		for (int i = 0; i < DMX_FILTER_SIZE; i++)fprintf(stderr, "%02hhx ", s_flt.filter.mode  [i]);
+		fprintf(stderr, "\n");
+	}
+
+	ioctl(fd, DMX_STOP);
 	if (ioctl(fd, DMX_SET_FILTER, &s_flt) < 0)
 		return false;
 
@@ -367,7 +379,7 @@
 	 * this check originally is from tuxbox cvs but I'm not sure
 	 * what it is good for...
 	if (pid <= 0x0001 && dmx_type != DMX_PCR_ONLY_CHANNEL)
-		return false;
+	    return false;
 	 */
 	if ((pid >= 0x0002 && pid <= 0x000f) || pid >= 0x1fff)
 		return false;
@@ -379,35 +391,36 @@
 	p_flt.output = DMX_OUT_DECODER;
 	p_flt.input  = DMX_IN_FRONTEND;
 
-	switch (dmx_type) {
-	case DMX_PCR_ONLY_CHANNEL:
-		p_flt.pes_type = DMX_PES_PCR;
-		if (HAL_nodec)
-			return true;
-		break;
-	case DMX_AUDIO_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TSDEMUX_TAP;
-		if (HAL_nodec)	/* no need to demux if we don't decode... */
-			return true;
-		break;
-	case DMX_VIDEO_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TSDEMUX_TAP;
-		if (HAL_nodec)
-			return true;
-		break;
-	case DMX_PES_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TAP;
-		break;
-	case DMX_TP_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TSDEMUX_TAP;
-		break;
-	default:
-		hal_info("%s #%d invalid dmx_type %d!\n", __func__, num, dmx_type);
-		return false;
+	switch (dmx_type)
+	{
+		case DMX_PCR_ONLY_CHANNEL:
+			p_flt.pes_type = DMX_PES_PCR;
+			if (HAL_nodec)
+				return true;
+			break;
+		case DMX_AUDIO_CHANNEL:
+			p_flt.pes_type = DMX_PES_OTHER;
+			p_flt.output  = DMX_OUT_TSDEMUX_TAP;
+			if (HAL_nodec)  /* no need to demux if we don't decode... */
+				return true;
+			break;
+		case DMX_VIDEO_CHANNEL:
+			p_flt.pes_type = DMX_PES_OTHER;
+			p_flt.output  = DMX_OUT_TSDEMUX_TAP;
+			if (HAL_nodec)
+				return true;
+			break;
+		case DMX_PES_CHANNEL:
+			p_flt.pes_type = DMX_PES_OTHER;
+			p_flt.output  = DMX_OUT_TAP;
+			break;
+		case DMX_TP_CHANNEL:
+			p_flt.pes_type = DMX_PES_OTHER;
+			p_flt.output  = DMX_OUT_TSDEMUX_TAP;
+			break;
+		default:
+			hal_info("%s #%d invalid dmx_type %d!\n", __func__, num, dmx_type);
+			return false;
 	}
 	return (ioctl(fd, DMX_SET_PES_FILTER, &p_flt) >= 0);
 }
@@ -459,7 +472,8 @@
 	}
 	for (std::vector<pes_pids>::iterator i = pesfds.begin(); i != pesfds.end(); ++i)
 	{
-		if ((*i).pid == Pid) {
+		if ((*i).pid == Pid)
+		{
 			hal_debug("removePid: removing demux fd %d pid 0x%04x\n", fd, Pid);
 			if (ioctl(fd, DMX_REMOVE_PID, Pid) < 0)
 				hal_info("%s: (DMX_REMOVE_PID, 0x%04hx): %m\n", __func__, Pid);
@@ -470,7 +484,7 @@
 	hal_info("%s pid 0x%04x not found\n", __FUNCTION__, Pid);
 }
 
-void cDemux::getSTC(int64_t * STC)
+void cDemux::getSTC(int64_t *STC)
 {
 	int64_t pts = 0;
 	if (videoDecoder)
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/glfb.cpp libstb-hal-ddt.git/libgeneric-pc/glfb.cpp
--- libstb-hal-ddt.git.orig/libgeneric-pc/glfb.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/glfb.cpp	2022-07-23 18:18:31.535772387 +0200
@@ -1,25 +1,25 @@
 /*
-	Copyright 2010 Carsten Juttner <carjay@gmx.net>
-	Copyright 2012,2013 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
+    Copyright 2010 Carsten Juttner <carjay@gmx.net>
+    Copyright 2012,2013 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
 
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program. If not, see <http://www.gnu.org/licenses/>.
-
-	openGL based framebuffer implementation
-	based on Carjay's neutrino-hd-dvbapi work, see
-		http://gitorious.org/neutrino-hd/neutrino-hd-dvbapi
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+    openGL based framebuffer implementation
+    based on Carjay's neutrino-hd-dvbapi work, see
+        http://gitorious.org/neutrino-hd/neutrino-hd-dvbapi
 
-	TODO:	AV-Sync code is "experimental" at best
+    TODO:   AV-Sync code is "experimental" at best
 */
 
 #include "config.h"
@@ -90,8 +90,8 @@
 	*mX = x;
 	*mY = y;
 	av_reduce(&mOA.num, &mOA.den, x, y, INT_MAX);
-	mVA = mOA;	/* initial aspect ratios are from the FB resolution, those */
-	_mVA = mVA;	/* will be updated by the videoDecoder functions anyway */
+	mVA = mOA;  /* initial aspect ratios are from the FB resolution, those */
+	_mVA = mVA; /* will be updated by the videoDecoder functions anyway */
 	mVAchanged = true;
 	mCrop = DISPLAY_AR_MODE_PANSCAN;
 	zoom = 1.0;
@@ -119,7 +119,7 @@
 
 	unlink("/tmp/neutrino.input");
 	mkfifo("/tmp/neutrino.input", 0600);
-	input_fd = open("/tmp/neutrino.input", O_RDWR|O_CLOEXEC|O_NONBLOCK);
+	input_fd = open("/tmp/neutrino.input", O_RDWR | O_CLOEXEC | O_NONBLOCK);
 	if (input_fd < 0)
 		hal_info("%s: could not open /tmp/neutrino.input FIFO: %m\n", __func__);
 	initKeys();
@@ -221,12 +221,12 @@
 
 	/* init the good stuff */
 	GLenum err = glewInit();
-	if(err == GLEW_OK)
+	if (err == GLEW_OK)
 	{
-		if((!GLEW_VERSION_1_5)||(!GLEW_EXT_pixel_buffer_object)||(!GLEW_ARB_texture_non_power_of_two))
+		if ((!GLEW_VERSION_1_5) || (!GLEW_EXT_pixel_buffer_object) || (!GLEW_ARB_texture_non_power_of_two))
 		{
 			hal_info("GLFB: Sorry, your graphics card is not supported. "
-				"Needs at least OpenGL 1.5, pixel buffer objects and NPOT textures.\n");
+			    "Needs at least OpenGL 1.5, pixel buffer objects and NPOT textures.\n");
 			hal_info("incompatible graphics card: %m");
 			_exit(1); /* Life is hard */
 		}
@@ -262,7 +262,8 @@
 }
 
 void GLFbPC::setupOSDBuffer()
-{	/* the OSD buffer size can be decoupled from the actual
+{
+	/* the OSD buffer size can be decoupled from the actual
 	   window size since the GL can blit-stretch with no
 	   trouble at all, ah, the luxury of ignorance... */
 	// mMutex.lock();
@@ -325,7 +326,7 @@
 	struct input_event ev;
 	if (key == 'f')
 	{
-		hal_info_c("GLFB::%s: toggle fullscreen %s\n", __func__, glfb_priv->mFullscreen?"off":"on");
+		hal_info_c("GLFB::%s: toggle fullscreen %s\n", __func__, glfb_priv->mFullscreen ? "off" : "on");
 		glfb_priv->mFullscreen = !(glfb_priv->mFullscreen);
 		glfb_priv->mReInit = true;
 		return;
@@ -364,7 +365,7 @@
 
 void GLFbPC::render()
 {
-	if(mShutDown)
+	if (mShutDown)
 		glutLeaveMainLoop();
 
 	mReInitLock.lock();
@@ -376,7 +377,8 @@
 		mReInit = false;
 		mX = &_mX[mFullscreen];
 		mY = &_mY[mFullscreen];
-		if (mFullscreen) {
+		if (mFullscreen)
+		{
 			int x = glutGet(GLUT_SCREEN_WIDTH);
 			int y = glutGet(GLUT_SCREEN_HEIGHT);
 			*mX = x;
@@ -389,17 +391,18 @@
 			xoff = (x - *mX) / 2;
 			yoff = (y - *mY) / 2;
 			glutFullScreen();
-		} else
+		}
+		else
 			*mX = *mY * mOA.num / mOA.den;
 		hal_info("%s: reinit mX:%d mY:%d xoff:%d yoff:%d fs %d\n",
-			__func__, *mX, *mY, xoff, yoff, mFullscreen);
+		    __func__, *mX, *mY, xoff, yoff, mFullscreen);
 		glViewport(xoff, yoff, *mX, *mY);
 		glMatrixMode(GL_PROJECTION);
 		glLoadIdentity();
-		float aspect = static_cast<float>(*mX)/ *mY;
+		float aspect = static_cast<float>(*mX) / *mY;
 		float osdaspect = static_cast<float>(mOA.den) / mOA.num;
 
-		glOrtho(aspect*-osdaspect, aspect*osdaspect, -1.0, 1.0, -1.0, 1.0 );
+		glOrtho(aspect * -osdaspect, aspect * osdaspect, -1.0, 1.0, -1.0, 1.0);
 		glClearColor(0.0, 0.0, 0.0, 1.0);
 
 		glMatrixMode(GL_MODELVIEW);
@@ -414,7 +417,8 @@
 		glutReshapeWindow(*mX, *mY);
 
 	bltDisplayBuffer(); /* decoded video stream */
-	if (mState.blit) {
+	if (mState.blit)
+	{
 		/* only blit manually after fb->blit(), this helps to find missed blit() calls */
 		mState.blit = false;
 		hal_debug("GLFB::%s blit!\n", __func__);
@@ -431,40 +435,34 @@
 		xscale = 1.0;
 		int cmp = (mCrop == DISPLAY_AR_MODE_NONE) ? 0 : av_cmp_q(mVA, mOA);
 		const AVRational a149 = { 14, 9 };
-		switch (cmp) {
+		switch (cmp)
+		{
 			default:
-			case INT_MIN:	/* invalid */
-			case 0:		/* identical */
+			case INT_MIN:   /* invalid */
+			case 0:     /* identical */
 				hal_debug("%s: mVA == mOA (or fullscreen mode :-)\n", __func__);
 				break;
-			case 1:		/* mVA > mOA -- video is wider than display */
+			case 1:     /* mVA > mOA -- video is wider than display */
 				hal_debug("%s: mVA > mOA\n", __func__);
 				xscale = av_q2d(mVA) / av_q2d(mOA);
-				switch (mCrop) {
+				switch (mCrop)
+				{
 					case DISPLAY_AR_MODE_PANSCAN:
 						break;
 					case DISPLAY_AR_MODE_LETTERBOX:
 						zoom = av_q2d(mOA) / av_q2d(mVA);
 						break;
-					case DISPLAY_AR_MODE_PANSCAN2:
-						zoom = av_q2d(mOA) / av_q2d(a149);
-						break;
 					default:
 						break;
 				}
 				break;
-			case -1:	/* mVA < mOA -- video is taller than display */
+			case -1:    /* mVA < mOA -- video is taller than display */
 				hal_debug("%s: mVA < mOA\n", __func__);
 				xscale = av_q2d(mVA) / av_q2d(mOA);
-				switch (mCrop) {
+				switch (mCrop)
+				{
 					case DISPLAY_AR_MODE_LETTERBOX:
 						break;
-					case DISPLAY_AR_MODE_PANSCAN2:
-						if (av_cmp_q(a149, mOA) < 0) {
-							zoom = av_q2d(mVA) * av_q2d(a149) / av_q2d(mOA);
-							break;
-						}
-						/* fallthrough for output format 14:9 */
 					case DISPLAY_AR_MODE_PANSCAN:
 						zoom = av_q2d(mOA) / av_q2d(mVA);
 						break;
@@ -500,11 +498,15 @@
 	static int last_x = 0, last_y = 0;
 
 	mReInitLock.lock();
-	if (!mFullscreen && !mReInit && (x != *mX || y != *mY)) {
-		if (x != *mX && abs(x - last_x) > 2) {
+	if (!mFullscreen && !mReInit && (x != *mX || y != *mY))
+	{
+		if (x != *mX && abs(x - last_x) > 2)
+		{
 			*mX = x;
 			*mY = *mX * mOA.den / mOA.num;
-		} else if (y != *mY && abs(y - last_y) > 2) {
+		}
+		else if (y != *mY && abs(y - last_y) > 2)
+		{
 			*mY = y;
 			*mX = *mY * mOA.num / mOA.den;
 		}
@@ -517,25 +519,29 @@
 
 void GLFbPC::drawSquare(float size, float x_factor)
 {
-	GLfloat vertices[] = {
-		 1.0f,  1.0f,
+	GLfloat vertices[] =
+	{
+		1.0f,  1.0f,
 		-1.0f,  1.0f,
 		-1.0f, -1.0f,
-		 1.0f, -1.0f,
+		1.0f, -1.0f,
 	};
 
 	GLubyte indices[] = { 0, 1, 2, 3 };
 
-	GLfloat texcoords[] = {
-		 1.0, 0.0,
-		 0.0, 0.0,
-		 0.0, 1.0,
-		 1.0, 1.0,
+	GLfloat texcoords[] =
+	{
+		1.0, 0.0,
+		0.0, 0.0,
+		0.0, 1.0,
+		1.0, 1.0,
 	};
-	if (x_factor > -99.0) { /* x_factor == -100 => OSD */
+	if (x_factor > -99.0)   /* x_factor == -100 => OSD */
+	{
 		if (videoDecoder &&
 		    videoDecoder->pig_x > 0 && videoDecoder->pig_y > 0 &&
-		    videoDecoder->pig_w > 0 && videoDecoder->pig_h > 0) {
+		    videoDecoder->pig_w > 0 && videoDecoder->pig_h > 0)
+		{
 			/* these calculations even consider cropping and panscan mode
 			 * maybe this could be done with some clever opengl tricks? */
 			double w2 = (double)mState.width * 0.5l;
@@ -546,16 +552,17 @@
 			double h = (double)videoDecoder->pig_h / h2;
 			x += ((1.0l - x_factor * size) / 2.0l) * w / x_factor / size;
 			y += ((size - 1.0l) / 2.0l) * h / size;
-			vertices[0] = x + w;		/* top right x */
-			vertices[1] = y;		/* top right y */
-			vertices[2] = x;		/* top left x */
-			vertices[3] = y;		/* top left y */
-			vertices[4] = x;		/* bottom left x */
-			vertices[5] = y - h;		/* bottom left y */
-			vertices[6] = vertices[0];	/* bottom right x */
-			vertices[7] = vertices[5];	/* bottom right y */
+			vertices[0] = x + w;        /* top right x */
+			vertices[1] = y;        /* top right y */
+			vertices[2] = x;        /* top left x */
+			vertices[3] = y;        /* top left y */
+			vertices[4] = x;        /* bottom left x */
+			vertices[5] = y - h;        /* bottom left y */
+			vertices[6] = vertices[0];  /* bottom right x */
+			vertices[7] = vertices[5];  /* bottom right y */
 		}
-	} else
+	}
+	else
 		x_factor = 1.0; /* OSD */
 
 	glPushMatrix();
@@ -589,7 +596,8 @@
 		return;
 	static bool warn = true;
 	cVideo::SWFramebuffer *buf = videoDecoder->getDecBuf();
-	if (!buf) {
+	if (!buf)
+	{
 		if (warn)
 			hal_info("GLFB::%s did not get a buffer...\n", __func__);
 		warn = false;
@@ -601,7 +609,8 @@
 		return;
 
 	AVRational a = buf->AR();
-	if (a.den != 0 && a.num != 0 && av_cmp_q(a, _mVA)) {
+	if (a.den != 0 && a.num != 0 && av_cmp_q(a, _mVA))
+	{
 		_mVA = a;
 		/* _mVA is the raw buffer's aspect, mVA is the real scaled output aspect */
 		av_reduce(&mVA.num, &mVA.den, w * a.num, h * a.den, INT_MAX);
@@ -624,10 +633,11 @@
 	int64_t vpts = buf->pts() + 18000;
 	if (audioDecoder)
 		apts = audioDecoder->getPts();
-	if (apts != last_apts) {
+	if (apts != last_apts)
+	{
 		int rate, dummy1, dummy2;
 		if (apts < vpts)
-			sleep_us = (sleep_us * 2 + (vpts - apts)*10/9) / 3;
+			sleep_us = (sleep_us * 2 + (vpts - apts) * 10 / 9) / 3;
 		else if (sleep_us > 1000)
 			sleep_us -= 1000;
 		last_apts = apts;
@@ -642,5 +652,5 @@
 			sleep_us = 1;
 	}
 	hal_debug("vpts: 0x%" PRIx64 " apts: 0x%" PRIx64 " diff: %6.3f sleep_us %d buf %d\n",
-			buf->pts(), apts, (buf->pts() - apts)/90000.0, sleep_us, videoDecoder->buf_num);
+	    buf->pts(), apts, (buf->pts() - apts) / 90000.0, sleep_us, videoDecoder->buf_num);
 }
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/glfb_priv.h libstb-hal-ddt.git/libgeneric-pc/glfb_priv.h
--- libstb-hal-ddt.git.orig/libgeneric-pc/glfb_priv.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/glfb_priv.h	2022-07-23 18:18:31.535772387 +0200
@@ -1,23 +1,23 @@
 /*
-	Copyright 2010 Carsten Juttner <carjay@gmx.net>
-	Copyright 2012,2013,2016 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
+    Copyright 2010 Carsten Juttner <carjay@gmx.net>
+    Copyright 2012,2013,2016 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
 
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program. If not, see <http://www.gnu.org/licenses/>.
-
-	********************************************************************
-	private stuff of the GLFB thread that is only used inside libstb-hal
-	and not exposed to the application.
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program. If not, see <http://www.gnu.org/licenses/>.
+
+    ********************************************************************
+    private stuff of the GLFB thread that is only used inside libstb-hal
+    and not exposed to the application.
 */
 
 #ifndef __glfb_priv__
@@ -41,86 +41,108 @@
 
 class GLFbPC
 {
-public:
-	GLFbPC(int x, int y, std::vector<unsigned char> &buf);
-	~GLFbPC();
-	std::vector<unsigned char> *getOSDBuffer() { return osd_buf; } /* pointer to OSD bounce buffer */
-	int getOSDWidth() { return mState.width; }
-	int getOSDHeight() { return mState.height; }
-	void blit() { mState.blit = true; };
-	fb_var_screeninfo getScreenInfo() { return si; }
-	void setOutputFormat(AVRational a, int h, int c) { mOA = a; *mY = h; mCrop = c; mReInit = true; }
-/* just make everything public for simplicity - this is only used inside libstb-hal anyway
-private:
-*/
-	fb_var_screeninfo si;
-	int *mX;
-	int *mY;
-	int _mX[2];			/* output window size */
-	int _mY[2];			/* [0] = normal, [1] = fullscreen */
-	AVRational mOA;			/* output window aspect ratio */
-	AVRational mVA;			/* video aspect ratio */
-	AVRational _mVA;		/* for detecting changes in mVA */
-	bool mVAchanged;
-	float zoom;			/* for cropping */
-	float xscale;			/* and aspect ratio */
-	int mCrop;			/* DISPLAY_AR_MODE */
-
-	bool mFullscreen;		/* fullscreen? */
-	bool mReInit;			/* setup things for GL */
-	OpenThreads::Mutex mReInitLock;
-	bool mShutDown;			/* if set main loop is left */
-	bool mInitDone;			/* condition predicate */
-	// OpenThreads::Condition mInitCond;	/* condition variable for init */
-	// mutable OpenThreads::Mutex mMutex;	/* lock our data */
+	public:
+		GLFbPC(int x, int y, std::vector<unsigned char> &buf);
+		~GLFbPC();
+		std::vector<unsigned char> *getOSDBuffer()
+		{
+			return osd_buf;    /* pointer to OSD bounce buffer */
+		}
+		int getOSDWidth()
+		{
+			return mState.width;
+		}
+		int getOSDHeight()
+		{
+			return mState.height;
+		}
+		void blit()
+		{
+			mState.blit = true;
+		};
+		fb_var_screeninfo getScreenInfo()
+		{
+			return si;
+		}
+		void setOutputFormat(AVRational a, int h, int c)
+		{
+			mOA = a;
+			*mY = h;
+			mCrop = c;
+			mReInit = true;
+		}
+		/* just make everything public for simplicity - this is only used inside libstb-hal anyway
+		private:
+		*/
+		fb_var_screeninfo si;
+		int *mX;
+		int *mY;
+		int _mX[2];         /* output window size */
+		int _mY[2];         /* [0] = normal, [1] = fullscreen */
+		AVRational mOA;         /* output window aspect ratio */
+		AVRational mVA;         /* video aspect ratio */
+		AVRational _mVA;        /* for detecting changes in mVA */
+		bool mVAchanged;
+		float zoom;         /* for cropping */
+		float xscale;           /* and aspect ratio */
+		int mCrop;          /* DISPLAY_AR_MODE */
+
+		bool mFullscreen;       /* fullscreen? */
+		bool mReInit;           /* setup things for GL */
+		OpenThreads::Mutex mReInitLock;
+		bool mShutDown;         /* if set main loop is left */
+		bool mInitDone;         /* condition predicate */
+		// OpenThreads::Condition mInitCond;    /* condition variable for init */
+		// mutable OpenThreads::Mutex mMutex;   /* lock our data */
 
-	std::vector<unsigned char> *osd_buf; /* silly bounce buffer */
+		std::vector<unsigned char> *osd_buf; /* silly bounce buffer */
 
 #if USE_OPENGL
-	std::map<unsigned char, int> mKeyMap;
-	std::map<int, int> mSpecialMap;
+		std::map<unsigned char, int> mKeyMap;
+		std::map<int, int> mSpecialMap;
 #endif
 #if USE_CLUTTER
-	std::map<int, int> mKeyMap;
+		std::map<int, int> mKeyMap;
 #endif
-	int input_fd;
-	int64_t last_apts;
-	void run();
+		int input_fd;
+		int64_t last_apts;
+		void run();
 
-	static void rendercb();		/* callback for GLUT */
-	void render();			/* actual render function */
+		static void rendercb();     /* callback for GLUT */
+		void render();          /* actual render function */
 #if USE_OPENGL
-	static void keyboardcb(unsigned char key, int x, int y);
-	static void specialcb(int key, int x, int y);
-	static void resizecb(int w, int h);
-	void checkReinit(int w, int h);	/* e.g. in case window was resized */
-	void setupGLObjects();		/* PBOs, textures and stuff */
-	void releaseGLObjects();
-	void drawSquare(float size, float x_factor = 1);	/* do not be square */
+		static void keyboardcb(unsigned char key, int x, int y);
+		static void specialcb(int key, int x, int y);
+		static void resizecb(int w, int h);
+		void checkReinit(int w, int h); /* e.g. in case window was resized */
+		void setupGLObjects();      /* PBOs, textures and stuff */
+		void releaseGLObjects();
+		void drawSquare(float size, float x_factor = 1);    /* do not be square */
 #endif
 #if USE_CLUTTER
-	static bool keyboardcb(ClutterActor *actor, ClutterEvent *event, gpointer user_data);
+		static bool keyboardcb(ClutterActor *actor, ClutterEvent *event, gpointer user_data);
 #endif
 
-	void initKeys();		/* setup key bindings for window */
+		void initKeys();        /* setup key bindings for window */
 #if 0
-	void setupCtx();		/* create the window and make the context current */
-	void setupOSDBuffer();		/* create the OSD buffer */
+		void setupCtx();        /* create the window and make the context current */
+		void setupOSDBuffer();      /* create the OSD buffer */
 #endif
 
-	struct {
-		int width;		/* width and height, fixed for a framebuffer instance */
-		int height;
-		bool blit;
+		struct
+		{
+			int width;      /* width and height, fixed for a framebuffer instance */
+			int height;
+			bool blit;
 #if USE_OPENGL
-		GLuint osdtex;		/* holds the OSD texture */
-		GLuint pbo;		/* PBO we use for transfer to texture */
-		GLuint displaytex;	/* holds the display texture */
-		GLuint displaypbo;
+			GLuint osdtex;      /* holds the OSD texture */
+			GLuint pbo;     /* PBO we use for transfer to texture */
+			GLuint displaytex;  /* holds the display texture */
+			GLuint displaypbo;
 #endif
-	} mState;
+		} mState;
 
-	void bltOSDBuffer();
-	void bltDisplayBuffer();
+		void bltOSDBuffer();
+		void bltDisplayBuffer();
 };
 #endif
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/hardware_caps.c libstb-hal-ddt.git/libgeneric-pc/hardware_caps.c
--- libstb-hal-ddt.git.orig/libgeneric-pc/hardware_caps.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libgeneric-pc/hardware_caps.c	2022-07-23 18:18:31.535772387 +0200
@@ -27,8 +27,11 @@
 
 	memset(&caps, 0, sizeof(hw_caps_t));
 
+	if (access("/dev/dvb/adapter0/video1", F_OK) != -1)
+		caps.can_pip = 1;
+
 	initialized = 1;
-	caps.can_shutdown = 1;	/* for testing */
+	caps.can_shutdown = 1;  /* for testing */
 	caps.display_type = HW_DISPLAY_LINE_TEXT;
 	caps.has_HDMI = 1;
 	caps.display_xres = 8;
@@ -36,9 +39,10 @@
 	caps.display_has_statusline = 0;
 	strcpy(caps.boxvendor, "Generic");
 	strcpy(caps.boxname, "PC");
-	if (! uname(&u)){
+	if (! uname(&u))
+	{
 		strncpy(caps.boxarch, u.machine, sizeof(caps.boxarch));
-		caps.boxarch[sizeof(caps.boxarch)-1] = '\0';
+		caps.boxarch[sizeof(caps.boxarch) - 1] = '\0';
 	}
 	else
 		fprintf(stderr, "%s: uname() failed: %m\n", __func__);
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/init.cpp libstb-hal-ddt.git/libgeneric-pc/init.cpp
--- libstb-hal-ddt.git.orig/libgeneric-pc/init.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/init.cpp	2022-07-23 18:18:31.535772387 +0200
@@ -18,7 +18,8 @@
 	if (!initialized)
 		hal_debug_init();
 	hal_info("%s begin, initialized=%d, debug=0x%02x\n", __func__, (int)initialized, debuglevel);
-	if (! glfb) {
+	if (! glfb)
+	{
 		int x = 1280, y = 720; /* default OSD FB resolution */
 		/*
 		 * export GLFB_RESOLUTION=720,576
@@ -28,7 +29,8 @@
 		const char *p = NULL;
 		if (tmp)
 			p = strchr(tmp, ',');
-		if (p) {
+		if (p)
+		{
 			x = atoi(tmp);
 			y = atoi(p + 1);
 		}
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/Makefile.am libstb-hal-ddt.git/libgeneric-pc/Makefile.am
--- libstb-hal-ddt.git.orig/libgeneric-pc/Makefile.am	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/Makefile.am	2022-07-23 18:18:31.535772387 +0200
@@ -11,6 +11,7 @@
 AM_CXXFLAGS = -fno-rtti -fno-exceptions -fno-strict-aliasing
 
 AM_LDFLAGS = \
+	-lrt \
 	-lao \
 	-lOpenThreads \
 	@AVFORMAT_LIBS@ \
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/playback.cpp libstb-hal-ddt.git/libgeneric-pc/playback.cpp
--- libstb-hal-ddt.git.orig/libgeneric-pc/playback.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/playback.cpp	2022-07-23 18:18:31.535772387 +0200
@@ -2,7 +2,7 @@
 
 #include "playback_lib.h"
 
-static const char * FILENAME = "playback-dummy";
+static const char *FILENAME = "playback-dummy";
 
 bool cPlayback::Open(playmode_t)
 {
@@ -15,13 +15,13 @@
 
 bool cPlayback::Start(std::string filename, std::string headers)
 {
-	return Start((char*) filename.c_str(),0,0,0,0,0, headers);
+	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers);
 }
 
 bool cPlayback::Start(char *filename, int vpid, int vtype, int apid, int ac3, int duration, std::string /*headers*/)
 {
 	printf("%s:%s - filename=%s vpid=%u vtype=%d apid=%u ac3=%d duration=%i\n",
-		FILENAME, __func__, filename, vpid, vtype, apid, ac3, duration);
+	    FILENAME, __func__, filename, vpid, vtype, apid, ac3, duration);
 	return true;
 }
 
@@ -58,7 +58,7 @@
 
 bool cPlayback::SetPosition(int position, bool)
 {
-	printf("%s:%s %d\n", FILENAME, __func__,position);
+	printf("%s:%s %d\n", FILENAME, __func__, position);
 	return true;
 }
 
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/playback_gst_01.cpp libstb-hal-ddt.git/libgeneric-pc/playback_gst_01.cpp
--- libstb-hal-ddt.git.orig/libgeneric-pc/playback_gst_01.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/playback_gst_01.cpp	2022-07-23 18:18:31.535772387 +0200
@@ -43,7 +43,7 @@
 #define hal_debug_c(args...) _hal_debug(HAL_DEBUG_PLAYBACK, NULL, args)
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_PLAYBACK, NULL, args)
 
-static const char * FILENAME = "[playback.cpp]";
+static const char *FILENAME = "[playback.cpp]";
 
 #include <gst/gst.h>
 #include <gst/pbutils/missing-plugins.h>
@@ -63,86 +63,86 @@
 } GstPlayFlags;
 
 
-GstElement * m_gst_playbin = NULL;
-GstElement * audioSink = NULL;
-GstElement * videoSink = NULL;
-gchar * uri = NULL;
-GstTagList * m_stream_tags = 0;
+GstElement *m_gst_playbin = NULL;
+GstElement *audioSink = NULL;
+GstElement *videoSink = NULL;
+gchar *uri = NULL;
+GstTagList *m_stream_tags = 0;
 static int end_eof = 0;
 
 extern GLFramebuffer *glfb;
 
 gint match_sinktype(GstElement *element, gpointer type)
 {
-	return strcmp(g_type_name(G_OBJECT_TYPE(element)), (const char*)type);
+	return strcmp(g_type_name(G_OBJECT_TYPE(element)), (const char *)type);
 }
-GstBusSyncReply Gst_bus_call(GstBus * bus, GstMessage *msg, gpointer user_data)
+GstBusSyncReply Gst_bus_call(GstBus *bus, GstMessage *msg, gpointer user_data)
 {
-	gchar * sourceName;
-	
+	gchar *sourceName;
+
 	// source
-	GstObject * source;
+	GstObject *source;
 	source = GST_MESSAGE_SRC(msg);
-	
+
 	if (!GST_IS_OBJECT(source))
 		return GST_BUS_DROP;
-	
+
 	sourceName = gst_object_get_name(source);
 
-	switch (GST_MESSAGE_TYPE(msg)) 
+	switch (GST_MESSAGE_TYPE(msg))
 	{
-		case GST_MESSAGE_EOS: 
+		case GST_MESSAGE_EOS:
 		{
 			g_message("End-of-stream");
 			end_eof = 1;
 			break;
 		}
-		
-		case GST_MESSAGE_ERROR: 
+
+		case GST_MESSAGE_ERROR:
 		{
-			gchar * debug;
+			gchar *debug;
 			GError *err;
 			gst_message_parse_error(msg, &err, &debug);
-			g_free (debug);
-			hal_info_c( "%s:%s - GST_MESSAGE_ERROR: %s (%i) from %s\n", FILENAME, __FUNCTION__, err->message, err->code, sourceName );
-			if ( err->domain == GST_STREAM_ERROR )
+			g_free(debug);
+			hal_info_c("%s:%s - GST_MESSAGE_ERROR: %s (%i) from %s\n", FILENAME, __FUNCTION__, err->message, err->code, sourceName);
+			if (err->domain == GST_STREAM_ERROR)
 			{
-				if ( err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND )
+				if (err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND)
 				{
-					if ( g_strrstr(sourceName, "videosink") )
-						hal_info_c( "%s:%s - GST_MESSAGE_ERROR: videosink\n", FILENAME, __FUNCTION__ ); //FIXME: how shall playback handle this event???
-					else if ( g_strrstr(sourceName, "audiosink") )
-						hal_info_c( "%s:%s - GST_MESSAGE_ERROR: audioSink\n", FILENAME, __FUNCTION__ ); //FIXME: how shall playback handle this event???
+					if (g_strrstr(sourceName, "videosink"))
+						hal_info_c("%s:%s - GST_MESSAGE_ERROR: videosink\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
+					else if (g_strrstr(sourceName, "audiosink"))
+						hal_info_c("%s:%s - GST_MESSAGE_ERROR: audioSink\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
 				}
 			}
 			g_error_free(err);
 
-			end_eof = 1; 		// NOTE: just to exit
-			
+			end_eof = 1;        // NOTE: just to exit
+
 			break;
 		}
-		
+
 		case GST_MESSAGE_INFO:
 		{
 			gchar *debug;
 			GError *inf;
-	
-			gst_message_parse_info (msg, &inf, &debug);
-			g_free (debug);
-			if ( inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE )
+
+			gst_message_parse_info(msg, &inf, &debug);
+			g_free(debug);
+			if (inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE)
 			{
-				if ( g_strrstr(sourceName, "videosink") )
-					hal_info_c( "%s:%s - GST_MESSAGE_INFO: videosink\n", FILENAME, __FUNCTION__ ); //FIXME: how shall playback handle this event???
+				if (g_strrstr(sourceName, "videosink"))
+					hal_info_c("%s:%s - GST_MESSAGE_INFO: videosink\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
 			}
 			g_error_free(inf);
 			break;
 		}
-		
+
 		case GST_MESSAGE_TAG:
 		{
 			GstTagList *tags, *result;
 			gst_message_parse_tag(msg, &tags);
-	
+
 			result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
 			if (result)
 			{
@@ -150,45 +150,45 @@
 					gst_tag_list_free(m_stream_tags);
 				m_stream_tags = result;
 			}
-	
+
 			const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
-			if ( gv_image )
+			if (gv_image)
 			{
 				GstBuffer *buf_image;
-				buf_image = gst_value_get_buffer (gv_image);
-				int fd = open("/tmp/.id3coverart", O_CREAT|O_WRONLY|O_TRUNC, 0644);
-				if(fd >= 0)
+				buf_image = gst_value_get_buffer(gv_image);
+				int fd = open("/tmp/.id3coverart", O_CREAT | O_WRONLY | O_TRUNC, 0644);
+				if (fd >= 0)
 				{
 					int ret = write(fd, GST_BUFFER_DATA(buf_image), GST_BUFFER_SIZE(buf_image));
 					close(fd);
-					hal_info_c( "%s:%s - GST_MESSAGE_INFO: cPlayback::state /tmp/.id3coverart %d bytes written\n", FILENAME, __FUNCTION__ , ret);
+					hal_info_c("%s:%s - GST_MESSAGE_INFO: cPlayback::state /tmp/.id3coverart %d bytes written\n", FILENAME, __FUNCTION__, ret);
 				}
 				//FIXME: how shall playback handle this event???
 			}
 			gst_tag_list_free(tags);
-			hal_info_c( "%s:%s - GST_MESSAGE_INFO: update info tags\n", FILENAME, __FUNCTION__);  //FIXME: how shall playback handle this event???
+			hal_info_c("%s:%s - GST_MESSAGE_INFO: update info tags\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
 			break;
 		}
-		
+
 		case GST_MESSAGE_STATE_CHANGED:
 		{
-			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+			if (GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
 				break;
 
 			GstState old_state, new_state;
 			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
-			
-			if(old_state == new_state)
+
+			if (old_state == new_state)
 				break;
-			hal_info_c( "%s:%s - GST_MESSAGE_STATE_CHANGED: state transition %s -> %s\n", FILENAME, __FUNCTION__, gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
-		
+			hal_info_c("%s:%s - GST_MESSAGE_STATE_CHANGED: state transition %s -> %s\n", FILENAME, __FUNCTION__, gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
+
 			GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
-		
-			switch(transition)
+
+			switch (transition)
 			{
 				case GST_STATE_CHANGE_NULL_TO_READY:
 				{
-				}	break;
+				}   break;
 				case GST_STATE_CHANGE_READY_TO_PAUSED:
 				{
 					GstIterator *children;
@@ -197,7 +197,7 @@
 						gst_object_unref(GST_OBJECT(audioSink));
 						audioSink = NULL;
 					}
-					
+
 					if (videoSink)
 					{
 						gst_object_unref(GST_OBJECT(videoSink));
@@ -207,14 +207,15 @@
 					audioSink = GST_ELEMENT_CAST(gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, (gpointer)"GstDVBAudioSink"));
 					videoSink = GST_ELEMENT_CAST(gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, (gpointer)"GstDVBVideoSink"));
 					gst_iterator_free(children);
-					
-				}	break;
+
+				}
+				break;
 				case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
 				{
-				}	break;
+				}   break;
 				case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
 				{
-				}	break;
+				}   break;
 				case GST_STATE_CHANGE_PAUSED_TO_READY:
 				{
 					if (audioSink)
@@ -227,26 +228,27 @@
 						gst_object_unref(GST_OBJECT(videoSink));
 						videoSink = NULL;
 					}
-				}	break;
+				}
+				break;
 				case GST_STATE_CHANGE_READY_TO_NULL:
 				{
-				}	break;
+				}   break;
 			}
 			break;
 		}
 #if 0
 		case GST_MESSAGE_ELEMENT:
 		{
-			if(gst_structure_has_name(gst_message_get_structure(msg), "prepare-xwindow-id")) 
+			if (gst_structure_has_name(gst_message_get_structure(msg), "prepare-xwindow-id"))
 			{
 				// set window id
-				gst_x_overlay_set_xwindow_id(GST_X_OVERLAY(GST_MESSAGE_SRC (msg)), glfb->getWindowID());
-				
+				gst_x_overlay_set_xwindow_id(GST_X_OVERLAY(GST_MESSAGE_SRC(msg)), glfb->getWindowID());
+
 				// reshape window
-				gst_x_overlay_set_render_rectangle(GST_X_OVERLAY(GST_MESSAGE_SRC (msg)), 0, 0, glfb->getOSDWidth(), glfb->getOSDHeight());
-				
+				gst_x_overlay_set_render_rectangle(GST_X_OVERLAY(GST_MESSAGE_SRC(msg)), 0, 0, glfb->getOSDWidth(), glfb->getOSDHeight());
+
 				// sync frames
-				gst_x_overlay_expose(GST_X_OVERLAY(GST_MESSAGE_SRC (msg)));
+				gst_x_overlay_expose(GST_X_OVERLAY(GST_MESSAGE_SRC(msg)));
 			}
 		}
 #endif
@@ -260,25 +262,25 @@
 
 
 cPlayback::cPlayback(int num)
-{ 
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
-  	const gchar *nano_str;
-  	guint major, minor, micro, nano;
+{
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
+	const gchar *nano_str;
+	guint major, minor, micro, nano;
 
 	gst_init(NULL, NULL);
 
-	gst_version (&major, &minor, &micro, &nano);
+	gst_version(&major, &minor, &micro, &nano);
 
-  	if (nano == 1)
-    		nano_str = "(CVS)";
-  	else if (nano == 2)
-    		nano_str = "(Prerelease)";
+	if (nano == 1)
+		nano_str = "(CVS)";
+	else if (nano == 2)
+		nano_str = "(Prerelease)";
 	else
-    		nano_str = "";
+		nano_str = "";
 
-  	hal_info( "%s:%s - This program is linked against GStreamer %d.%d.%d %s\n",
-		FILENAME, __FUNCTION__,
-          	major, minor, micro, nano_str);
+	hal_info("%s:%s - This program is linked against GStreamer %d.%d.%d %s\n",
+	    FILENAME, __FUNCTION__,
+	    major, minor, micro, nano_str);
 
 	mAudioStream = 0;
 	mSpeed = 0;
@@ -288,8 +290,8 @@
 }
 
 cPlayback::~cPlayback()
-{  
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+{
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 	//FIXME: all deleting stuff is done in Close()
 }
 
@@ -302,21 +304,21 @@
 
 // used by movieplay
 void cPlayback::Close(void)
-{  
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+{
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 
 	Stop();
-	
+
 	// disconnect bus handler
 	if (m_gst_playbin)
 	{
 		// disconnect sync handler callback
-		GstBus * bus = gst_pipeline_get_bus(GST_PIPELINE (m_gst_playbin));
+		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(m_gst_playbin));
 		gst_bus_set_sync_handler(bus, NULL, NULL);
 		gst_object_unref(bus);
-		hal_info( "%s:%s - GST bus handler closed\n", FILENAME, __FUNCTION__);
+		hal_info("%s:%s - GST bus handler closed\n", FILENAME, __FUNCTION__);
 	}
-	
+
 	if (m_stream_tags)
 		gst_tag_list_free(m_stream_tags);
 
@@ -327,22 +329,22 @@
 		{
 			gst_object_unref(GST_OBJECT(audioSink));
 			audioSink = NULL;
-			
-			hal_info( "%s:%s - GST audio Sink closed\n", FILENAME, __FUNCTION__);
+
+			hal_info("%s:%s - GST audio Sink closed\n", FILENAME, __FUNCTION__);
 		}
-		
+
 		if (videoSink)
 		{
 			gst_object_unref(GST_OBJECT(videoSink));
 			videoSink = NULL;
-			
-			hal_info( "%s:%s - GST video Sink closed\n", FILENAME, __FUNCTION__);
+
+			hal_info("%s:%s - GST video Sink closed\n", FILENAME, __FUNCTION__);
 		}
-		
+
 		// unref m_gst_playbin
-		gst_object_unref (GST_OBJECT (m_gst_playbin));
-		hal_info( "%s:%s - GST playbin closed\n", FILENAME, __FUNCTION__);
-		
+		gst_object_unref(GST_OBJECT(m_gst_playbin));
+		hal_info("%s:%s - GST playbin closed\n", FILENAME, __FUNCTION__);
+
 		m_gst_playbin = NULL;
 	}
 }
@@ -350,80 +352,80 @@
 // start
 bool cPlayback::Start(std::string filename, std::string headers)
 {
-	return Start((char*) filename.c_str(),0,0,0,0,0, headers);
+	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers);
 }
 
 bool cPlayback::Start(char *filename, int /*vpid*/, int /*vtype*/, int /*apid*/, int /*ac3*/, int /*duration*/, std::string headers)
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 
 	mAudioStream = 0;
-	
+
 	//create playback path
 	char file[400] = {""};
 	bool isHTTP = false;
 
-	if(!strncmp("http://", filename, 7))
+	if (!strncmp("http://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("file://", filename, 7))
+	else if (!strncmp("file://", filename, 7))
 	{
 		isHTTP = false;
 	}
-	else if(!strncmp("upnp://", filename, 7))
+	else if (!strncmp("upnp://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("rtmp://", filename, 7))
+	else if (!strncmp("rtmp://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("rtsp://", filename, 7))
+	else if (!strncmp("rtsp://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("mms://", filename, 6))
+	else if (!strncmp("mms://", filename, 6))
 	{
 		isHTTP = true;
 	}
 	else
-	    strcat(file, "file://");
-	
+		strcat(file, "file://");
+
 	strcat(file, filename);
-	
+
 	if (isHTTP)
 		uri = g_uri_escape_string(filename, G_URI_RESERVED_CHARS_GENERIC_DELIMITERS, true);
 	else
 		uri = g_filename_to_uri(filename, NULL, NULL);
-	
+
 	hal_info("%s:%s - filename=%s\n", FILENAME, __FUNCTION__, filename);
 
 	// create gst pipeline
 	m_gst_playbin = gst_element_factory_make("playbin2", "playbin");
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		hal_info("%s:%s - m_gst_playbin\n", FILENAME, __FUNCTION__);
 
 		guint flags;
-		g_object_get(G_OBJECT (m_gst_playbin), "flags", &flags, NULL);
+		g_object_get(G_OBJECT(m_gst_playbin), "flags", &flags, NULL);
 		/* avoid video conversion, let the (hardware) sinks handle that */
 		flags |= GST_PLAY_FLAG_NATIVE_VIDEO;
 		/* volume control is done by hardware */
 		flags &= ~GST_PLAY_FLAG_SOFT_VOLUME;
 
-		g_object_set(G_OBJECT (m_gst_playbin), "uri", uri, NULL);
-		g_object_set(G_OBJECT (m_gst_playbin), "flags", flags, NULL);	
-	
+		g_object_set(G_OBJECT(m_gst_playbin), "uri", uri, NULL);
+		g_object_set(G_OBJECT(m_gst_playbin), "flags", flags, NULL);
+
 		//gstbus handler
-		GstBus * bus = gst_pipeline_get_bus( GST_PIPELINE(m_gst_playbin) );
+		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(m_gst_playbin));
 		gst_bus_set_sync_handler(bus, Gst_bus_call, NULL);
-		gst_object_unref(bus); 
-		
+		gst_object_unref(bus);
+
 		// state playing
 		gst_element_set_state(GST_ELEMENT(m_gst_playbin), GST_STATE_PLAYING);
-		
+
 		playing = true;
 		playstate = STATE_PLAY;
 	}
@@ -431,32 +433,32 @@
 	{
 		hal_info("%s:%s - failed to create GStreamer pipeline!, sorry we can not play\n", FILENAME, __FUNCTION__);
 		playing = false;
-		
+
 		return false;
 	}
-	
-	g_free(uri);	
+
+	g_free(uri);
 
 	// set buffer size
 	/* increase the default 2 second / 2 MB buffer limitations to 5s / 5MB */
-	int m_buffer_size = 5*1024*1024;
+	int m_buffer_size = 5 * 1024 * 1024;
 	//g_object_set(G_OBJECT(m_gst_playbin), "buffer-duration", 5LL * GST_SECOND, NULL);
 	g_object_set(G_OBJECT(m_gst_playbin), "buffer-size", m_buffer_size, NULL);
-		
+
 	return true;
 }
 
 bool cPlayback::Play(void)
 {
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);	
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
-	if(playing == true) 
+	if (playing == true)
 		return true;
-	
-	if(m_gst_playbin)
+
+	if (m_gst_playbin)
 	{
 		gst_element_set_state(GST_ELEMENT(m_gst_playbin), GST_STATE_PLAYING);
-		
+
 		playing = true;
 		playstate = STATE_PLAY;
 	}
@@ -466,35 +468,35 @@
 }
 
 bool cPlayback::Stop(void)
-{ 
-	if(playing == false) 
+{
+	if (playing == false)
 		return false;
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
-	
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+
 	// stop
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
 	}
 
 	playing = false;
-	
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
-	
+
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+
 	playstate = STATE_STOP;
 
 	return true;
 }
 
-bool cPlayback::SetAPid(int pid , bool /*ac3*/)
+bool cPlayback::SetAPid(int pid, bool /*ac3*/)
 {
 	hal_info("%s: pid %i\n", __func__, pid);
-	
+
 	int current_audio;
-	
-	if(pid != mAudioStream)
+
+	if (pid != mAudioStream)
 	{
-		g_object_set (G_OBJECT (m_gst_playbin), "current-audio", pid, NULL);
+		g_object_set(G_OBJECT(m_gst_playbin), "current-audio", pid, NULL);
 		printf("%s: switched to audio stream %i\n", __FUNCTION__, pid);
 		mAudioStream = pid;
 	}
@@ -508,18 +510,18 @@
 	gint64 pos = 0;
 	int position;
 	int duration;
-	
-	if( GetPosition(position, duration) )
+
+	if (GetPosition(position, duration))
 	{
 		validposition = true;
 		pos = position;
 	}
 
 	gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
-			
+
 	if (validposition)
 	{
-		if(ratio >= 0.0)
+		if (ratio >= 0.0)
 			gst_element_seek(m_gst_playbin, ratio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, pos, GST_SEEK_TYPE_SET, -1);
 		else
 			gst_element_seek(m_gst_playbin, ratio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_SET, pos);
@@ -527,23 +529,23 @@
 }
 
 bool cPlayback::SetSpeed(int speed)
-{  
-	hal_info( "%s:%s speed %d\n", FILENAME, __FUNCTION__, speed);	
+{
+	hal_info("%s:%s speed %d\n", FILENAME, __FUNCTION__, speed);
 
-	if(playing == false) 
+	if (playing == false)
 		return false;
 
-	if(m_gst_playbin)
-	{	
+	if (m_gst_playbin)
+	{
 		// pause
-		if(speed == 0)
+		if (speed == 0)
 		{
 			gst_element_set_state(m_gst_playbin, GST_STATE_PAUSED);
 			//trickSeek(0);
 			playstate = STATE_PAUSE;
 		}
 		// play/continue
-		else if(speed == 1)
+		else if (speed == 1)
 		{
 			trickSeek(1);
 			//gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
@@ -551,14 +553,14 @@
 			playstate = STATE_PLAY;
 		}
 		//ff
-		else if(speed > 1)
+		else if (speed > 1)
 		{
 			trickSeek(speed);
 			//
 			playstate = STATE_FF;
 		}
 		//rf
-		else if(speed < 0)
+		else if (speed < 0)
 		{
 			trickSeek(speed);
 			//
@@ -572,13 +574,13 @@
 }
 
 bool cPlayback::SetSlow(int slow)
-{  
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);	
+{
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
-	if(playing == false) 
+	if (playing == false)
 		return false;
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		trickSeek(0.5);
 	}
@@ -600,27 +602,27 @@
 // in milliseconds
 bool cPlayback::GetPosition(int &position, int &duration)
 {
-	if(playing == false) 
-		return false;	
+	if (playing == false)
+		return false;
 
 	//EOF
-	if(end_eof)
+	if (end_eof)
 	{
 		end_eof = 0;
 		return false;
 	}
-	
-	if(m_gst_playbin)
+
+	if (m_gst_playbin)
 	{
 		//position
 		GstFormat fmt = GST_FORMAT_TIME; //Returns time in nanosecs
-		
+
 		gint64 pts = 0;
 		unsigned long long int sec = 0;
-		
+
 		gst_element_query_position(m_gst_playbin, &fmt, &pts);
 		position = pts /  1000000.0;
-	
+
 		// duration
 		GstFormat fmt_d = GST_FORMAT_TIME; //Returns time in nanosecs
 		double length = 0;
@@ -628,94 +630,94 @@
 
 		gst_element_query_duration(m_gst_playbin, &fmt_d, &len);
 		length = len / 1000000.0;
-		if(length < 0) 
+		if (length < 0)
 			length = 0;
-		
+
 		duration = (int)(length);
 	}
-	
+
 	return true;
 }
 
 bool cPlayback::SetPosition(int position, bool absolute)
 {
 	hal_info("%s: pos %d abs %d playing %d\n", __func__, position, absolute, playing);
-	
-	if(playing == false) 
+
+	if (playing == false)
 		return false;
-	
+
 	gint64 time_nanoseconds;
 	gint64 pos;
 	GstFormat fmt = GST_FORMAT_TIME;
-		
-	if(m_gst_playbin)
+
+	if (m_gst_playbin)
 	{
 		gst_element_query_position(m_gst_playbin, &fmt, &pos);
 		time_nanoseconds = pos + (position * 1000000.0);
-		if(time_nanoseconds < 0) 
+		if (time_nanoseconds < 0)
 			time_nanoseconds = 0;
-		
+
 		gst_element_seek(m_gst_playbin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH, GST_SEEK_TYPE_SET, time_nanoseconds, GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE);
 	}
 
 	return true;
 }
 
-void cPlayback::FindAllPids(int *apids, unsigned int *ac3flags, unsigned int *numpida, std::string * language)
-{ 
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+void cPlayback::FindAllPids(int *apids, unsigned int *ac3flags, unsigned int *numpida, std::string *language)
+{
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		gint i, n_audio = 0;
 		//GstStructure * structure = NULL;
-		
+
 		// get audio
-		g_object_get (m_gst_playbin, "n-audio", &n_audio, NULL);
+		g_object_get(m_gst_playbin, "n-audio", &n_audio, NULL);
 		printf("%s: %d audio\n", __FUNCTION__, n_audio);
-		
-		if(n_audio == 0)
+
+		if (n_audio == 0)
 			return;
-		
+
 		for (i = 0; i < n_audio; i++)
 		{
 			// apids
-			apids[i]=i;
-			
-			GstPad * pad = 0;
-			g_signal_emit_by_name (m_gst_playbin, "get-audio-pad", i, &pad);
-			GstCaps * caps = gst_pad_get_negotiated_caps(pad);
+			apids[i] = i;
+
+			GstPad *pad = 0;
+			g_signal_emit_by_name(m_gst_playbin, "get-audio-pad", i, &pad);
+			GstCaps *caps = gst_pad_get_negotiated_caps(pad);
 			if (!caps)
 				continue;
-			
-			GstStructure * structure = gst_caps_get_structure(caps, 0);
+
+			GstStructure *structure = gst_caps_get_structure(caps, 0);
 			//const gchar *g_type = gst_structure_get_name(structure);
-		
+
 			//if (!structure)
-				//return atUnknown;
+			//return atUnknown;
 			//ac3flags[0] = 0;
 
 			// ac3flags
-			if ( gst_structure_has_name (structure, "audio/mpeg"))
+			if (gst_structure_has_name(structure, "audio/mpeg"))
 			{
 				gint mpegversion, layer = -1;
-				
-				if (!gst_structure_get_int (structure, "mpegversion", &mpegversion))
+
+				if (!gst_structure_get_int(structure, "mpegversion", &mpegversion))
 					//return atUnknown;
 					ac3flags[i] = 0;
 
-				switch (mpegversion) 
+				switch (mpegversion)
 				{
 					case 1:
 						/*
 						{
-							gst_structure_get_int (structure, "layer", &layer);
-							if ( layer == 3 )
-								return atMP3;
-							else
-								return atMPEG;
-								ac3flags[0] = 4;
-							break;
+						    gst_structure_get_int (structure, "layer", &layer);
+						    if (layer == 3)
+						        return atMP3;
+						    else
+						        return atMPEG;
+						        ac3flags[0] = 4;
+						    break;
 						}
 						*/
 						ac3flags[i] = 4;
@@ -730,35 +732,35 @@
 						ac3flags[i] = 0;
 				}
 			}
-			else if ( gst_structure_has_name (structure, "audio/x-ac3") || gst_structure_has_name (structure, "audio/ac3") )
+			else if (gst_structure_has_name(structure, "audio/x-ac3") || gst_structure_has_name(structure, "audio/ac3"))
 				//return atAC3;
 				ac3flags[i] = 1;
-			else if ( gst_structure_has_name (structure, "audio/x-dts") || gst_structure_has_name (structure, "audio/dts") )
+			else if (gst_structure_has_name(structure, "audio/x-dts") || gst_structure_has_name(structure, "audio/dts"))
 				//return atDTS;
 				ac3flags[i] = 6;
-			else if ( gst_structure_has_name (structure, "audio/x-raw-int") )
+			else if (gst_structure_has_name(structure, "audio/x-raw-int"))
 				//return atPCM;
 				ac3flags[i] = 0;
-			
+
 			gst_caps_unref(caps);
 		}
-		
+
 		// numpids
-		*numpida=i;
+		*numpida = i;
 	}
 }
 
 void cPlayback::getMeta()
 {
-	if(playing) 
+	if (playing)
 		return;
 }
 
 bool cPlayback::SyncAV(void)
 {
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);	
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
-	if(playing == false ) 
+	if (playing == false)
 		return false;
 
 	return true;
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/playback_gst_10.cpp libstb-hal-ddt.git/libgeneric-pc/playback_gst_10.cpp
--- libstb-hal-ddt.git.orig/libgeneric-pc/playback_gst_10.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/playback_gst_10.cpp	2022-07-23 18:18:31.535772387 +0200
@@ -42,7 +42,7 @@
 #define hal_debug_c(args...) _hal_debug(HAL_DEBUG_PLAYBACK, NULL, args)
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_PLAYBACK, NULL, args)
 
-static const char * FILENAME = "[playback.cpp]";
+static const char *FILENAME = "[playback.cpp]";
 
 #include <gst/gst.h>
 #include <gst/tag/tag.h>
@@ -52,26 +52,26 @@
 
 typedef enum
 {
-	GST_PLAY_FLAG_VIDEO				= (1 << 0),
-	GST_PLAY_FLAG_AUDIO				= (1 << 1),
-	GST_PLAY_FLAG_TEXT				= (1 << 2),
-	GST_PLAY_FLAG_VIS				= (1 << 3),
-	GST_PLAY_FLAG_SOFT_VOLUME		= (1 << 4),
-	GST_PLAY_FLAG_NATIVE_AUDIO		= (1 << 5),
-	GST_PLAY_FLAG_NATIVE_VIDEO		= (1 << 6),
-	GST_PLAY_FLAG_DOWNLOAD			= (1 << 7),
-	GST_PLAY_FLAG_BUFFERING			= (1 << 8),
-	GST_PLAY_FLAG_DEINTERLACE		= (1 << 9),
-	GST_PLAY_FLAG_SOFT_COLORBALANCE	= (1 << 10),
-	GST_PLAY_FLAG_FORCE_FILTERS		= (1 << 11),
+	GST_PLAY_FLAG_VIDEO             = (1 << 0),
+	GST_PLAY_FLAG_AUDIO             = (1 << 1),
+	GST_PLAY_FLAG_TEXT              = (1 << 2),
+	GST_PLAY_FLAG_VIS               = (1 << 3),
+	GST_PLAY_FLAG_SOFT_VOLUME       = (1 << 4),
+	GST_PLAY_FLAG_NATIVE_AUDIO      = (1 << 5),
+	GST_PLAY_FLAG_NATIVE_VIDEO      = (1 << 6),
+	GST_PLAY_FLAG_DOWNLOAD          = (1 << 7),
+	GST_PLAY_FLAG_BUFFERING         = (1 << 8),
+	GST_PLAY_FLAG_DEINTERLACE       = (1 << 9),
+	GST_PLAY_FLAG_SOFT_COLORBALANCE = (1 << 10),
+	GST_PLAY_FLAG_FORCE_FILTERS     = (1 << 11),
 } GstPlayFlags;
 
 
-GstElement * m_gst_playbin = NULL;
-GstElement * audioSink = NULL;
-GstElement * videoSink = NULL;
-gchar * uri = NULL;
-GstTagList * m_stream_tags = NULL;
+GstElement *m_gst_playbin = NULL;
+GstElement *audioSink = NULL;
+GstElement *videoSink = NULL;
+gchar *uri = NULL;
+GstTagList *m_stream_tags = NULL;
 pthread_mutex_t mutex_tag_ist;
 
 static int end_eof = 0;
@@ -90,21 +90,25 @@
 
 void resetPids()
 {
-	for (unsigned int i = 0; i < REC_MAX_APIDS; i++) {
+	for (unsigned int i = 0; i < REC_MAX_APIDS; i++)
+	{
 		real_apids[i] = 0;
 	}
 }
 
-void processMpegTsSection(GstMpegtsSection* section)
+void processMpegTsSection(GstMpegtsSection *section)
 {
 	resetPids();
 	int cnt = 0;
-    if (section->section_type == GST_MPEGTS_SECTION_PMT) {
-        const GstMpegtsPMT* pmt = gst_mpegts_section_get_pmt(section);
-        for (guint i = 0; i < pmt->streams->len; ++i) {
-            const GstMpegtsPMTStream* stream = static_cast<const GstMpegtsPMTStream*>(g_ptr_array_index(pmt->streams, i));
-			if (stream->stream_type == 0x05 || stream->stream_type >= 0x80) {
-				hal_info_c( "%s:%s Audio Stream pid: %d\n", FILENAME, __FUNCTION__, stream->pid);
+	if (section->section_type == GST_MPEGTS_SECTION_PMT)
+	{
+		const GstMpegtsPMT *pmt = gst_mpegts_section_get_pmt(section);
+		for (guint i = 0; i < pmt->streams->len; ++i)
+		{
+			const GstMpegtsPMTStream *stream = static_cast<const GstMpegtsPMTStream *>(g_ptr_array_index(pmt->streams, i));
+			if (stream->stream_type == 0x05 || stream->stream_type >= 0x80)
+			{
+				hal_info_c("%s:%s Audio Stream pid: %d\n", FILENAME, __FUNCTION__, stream->pid);
 				real_apids[cnt] = stream->pid;
 				cnt++;
 			}
@@ -115,7 +119,7 @@
 void playbinNotifySource(GObject *object, GParamSpec *param_spec, gpointer user_data)
 {
 	GstElement *source = NULL;
-	cPlayback *_this = (cPlayback*)user_data;
+	cPlayback *_this = (cPlayback *)user_data;
 	g_object_get(object, "source", &source, NULL);
 
 	if (source)
@@ -168,7 +172,7 @@
 				if (!name.empty() && !value.empty())
 				{
 					GValue header;
-					hal_info_c( "%s:%s setting extra-header '%s:%s'\n", FILENAME, __FUNCTION__, name.c_str(), value.c_str());
+					hal_info_c("%s:%s setting extra-header '%s:%s'\n", FILENAME, __FUNCTION__, name.c_str(), value.c_str());
 					memset(&header, 0, sizeof(GValue));
 					g_value_init(&header, G_TYPE_STRING);
 					g_value_set_string(&header, value.c_str());
@@ -176,7 +180,7 @@
 				}
 				else
 				{
-					hal_info_c( "%s:%s Invalid header format %s\n", FILENAME, __FUNCTION__, _this->extra_headers.c_str());
+					hal_info_c("%s:%s Invalid header format %s\n", FILENAME, __FUNCTION__, _this->extra_headers.c_str());
 					break;
 				}
 			}
@@ -193,7 +197,7 @@
 GstBusSyncReply Gst_bus_call(GstBus *bus, GstMessage *msg, gpointer user_data)
 {
 	// source
-	GstObject * source;
+	GstObject *source;
 	source = GST_MESSAGE_SRC(msg);
 
 	if (!GST_IS_OBJECT(source))
@@ -201,223 +205,224 @@
 
 	switch (GST_MESSAGE_TYPE(msg))
 	{
-	case GST_MESSAGE_EOS:
-	{
-		g_message("End-of-stream");
-		end_eof = 1;
-		break;
-	}
+		case GST_MESSAGE_EOS:
+		{
+			g_message("End-of-stream");
+			end_eof = 1;
+			break;
+		}
 
-	case GST_MESSAGE_ERROR:
-	{
-		gchar * debug;
-		GError *err;
-		gst_message_parse_error(msg, &err, &debug);
-		g_free (debug);
-		gchar * sourceName = gst_object_get_name(source);
-		hal_info_c( "%s:%s - GST_MESSAGE_ERROR: %s (%i) from %s\n", FILENAME, __FUNCTION__, err->message, err->code, sourceName );
-		if ( err->domain == GST_STREAM_ERROR )
+		case GST_MESSAGE_ERROR:
 		{
-			if ( err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND )
+			gchar *debug;
+			GError *err;
+			gst_message_parse_error(msg, &err, &debug);
+			g_free(debug);
+			gchar *sourceName = gst_object_get_name(source);
+			hal_info_c("%s:%s - GST_MESSAGE_ERROR: %s (%i) from %s\n", FILENAME, __FUNCTION__, err->message, err->code, sourceName);
+			if (err->domain == GST_STREAM_ERROR)
 			{
-				if ( g_strrstr(sourceName, "videosink") )
-					hal_info_c( "%s:%s - GST_MESSAGE_ERROR: videosink\n", FILENAME, __FUNCTION__ ); //FIXME: how shall playback handle this event???
-				else if ( g_strrstr(sourceName, "audiosink") )
-					hal_info_c( "%s:%s - GST_MESSAGE_ERROR: audioSink\n", FILENAME, __FUNCTION__ ); //FIXME: how shall playback handle this event???
+				if (err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND)
+				{
+					if (g_strrstr(sourceName, "videosink"))
+						hal_info_c("%s:%s - GST_MESSAGE_ERROR: videosink\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
+					else if (g_strrstr(sourceName, "audiosink"))
+						hal_info_c("%s:%s - GST_MESSAGE_ERROR: audioSink\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
+				}
 			}
-		}
-		g_error_free(err);
-		if(sourceName)
-			g_free(sourceName);
-
-		end_eof = 1; 		// NOTE: just to exit
-
-		break;
-	}
-
-	case GST_MESSAGE_INFO:
-	{
-		gchar *debug;
-		GError *inf;
-
-		gst_message_parse_info (msg, &inf, &debug);
-		g_free (debug);
-		if ( inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE )
-		{
-			gchar * sourceName = gst_object_get_name(source);
-			if ( g_strrstr(sourceName, "videosink") )
-				hal_info_c( "%s:%s - GST_MESSAGE_INFO: videosink\n", FILENAME, __FUNCTION__ ); //FIXME: how shall playback handle this event???
-			if(sourceName)
+			g_error_free(err);
+			if (sourceName)
 				g_free(sourceName);
 
-		}
-		g_error_free(inf);
-		break;
-	}
-
-	case GST_MESSAGE_TAG:
-	{
-		GstTagList *tags = NULL, *result = NULL;
-		gst_message_parse_tag(msg, &tags);
+			end_eof = 1;        // NOTE: just to exit
 
-		if(tags == NULL)
-			break;
-		if(!GST_IS_TAG_LIST(tags))
 			break;
+		}
 
-		pthread_mutex_lock (&mutex_tag_ist);
-
-		result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
-		if (result)
+		case GST_MESSAGE_INFO:
 		{
-			if (m_stream_tags && gst_tag_list_is_equal(m_stream_tags, result))
+			gchar *debug;
+			GError *inf;
+
+			gst_message_parse_info(msg, &inf, &debug);
+			g_free(debug);
+			if (inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE)
 			{
-				gst_tag_list_unref(tags);
-				gst_tag_list_unref(result);
+				gchar *sourceName = gst_object_get_name(source);
+				if (g_strrstr(sourceName, "videosink"))
+					hal_info_c("%s:%s - GST_MESSAGE_INFO: videosink\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
+				if (sourceName)
+					g_free(sourceName);
 
-				pthread_mutex_unlock (&mutex_tag_ist);
-				break;
 			}
-			if (m_stream_tags)
-				gst_tag_list_unref(m_stream_tags);
-			m_stream_tags = gst_tag_list_copy(result);
-			gst_tag_list_unref(result);
-		}
-
-		pthread_mutex_unlock (&mutex_tag_ist);
-
-		const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
-		if ( gv_image )
-		{
-			GstBuffer *buf_image;
-			GstSample *sample;
-			sample = (GstSample *)g_value_get_boxed(gv_image);
-			buf_image = gst_sample_get_buffer(sample);
-			int fd = open("/tmp/.id3coverart", O_CREAT|O_WRONLY|O_TRUNC, 0644);
-			if (fd >= 0)
-			{
-				guint8 *data;
-				gsize size;
-				GstMapInfo map;
-				gst_buffer_map(buf_image, &map, GST_MAP_READ);
-				data = map.data;
-				size = map.size;
-				int ret = write(fd, data, size);
-				gst_buffer_unmap(buf_image, &map);
-				close(fd);
-				hal_info_c("%s:%s - /tmp/.id3coverart %d bytes written\n", FILENAME, __FUNCTION__, ret);
-			}
-		}
-		if (tags)
-			gst_tag_list_unref(tags);
-		hal_debug_c( "%s:%s - GST_MESSAGE_INFO: update info tags\n", FILENAME, __FUNCTION__);  //FIXME: how shall playback handle this event???
-		break;
-	}
-    case GST_MESSAGE_ELEMENT:
-	{
-#if 0
-		if(gst_structure_has_name(gst_message_get_structure(msg), "prepare-window-handle")) 
-		{
-			// set window id
-			gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(GST_MESSAGE_SRC (msg)), glfb->getWindowID());
-			
-			// reshape window
-			gst_video_overlay_set_render_rectangle(GST_VIDEO_OVERLAY(GST_MESSAGE_SRC (msg)), 0, 0, glfb->getOSDWidth(), glfb->getOSDHeight());
-			
-			// sync frames
-			gst_video_overlay_expose(GST_VIDEO_OVERLAY(GST_MESSAGE_SRC (msg)));
-		}
-#endif
-		GstMpegtsSection* section = gst_message_parse_mpegts_section(msg);
-		if (section) {
-			processMpegTsSection(section);
-			gst_mpegts_section_unref(section);
-		}
-	}
-	case GST_MESSAGE_STATE_CHANGED:
-	{
-		if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+			g_error_free(inf);
 			break;
+		}
 
-		GstState old_state, new_state;
-		gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
+		case GST_MESSAGE_TAG:
+		{
+			GstTagList *tags = NULL, *result = NULL;
+			gst_message_parse_tag(msg, &tags);
 
-		if(old_state == new_state)
-			break;
-		hal_info_c( "%s:%s - GST_MESSAGE_STATE_CHANGED: state transition %s -> %s\n", FILENAME, __FUNCTION__, gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
+			if (tags == NULL)
+				break;
+			if (!GST_IS_TAG_LIST(tags))
+				break;
 
-		GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
+			pthread_mutex_lock(&mutex_tag_ist);
 
-		switch(transition)
-		{
-		case GST_STATE_CHANGE_NULL_TO_READY:
-		{
-		}	break;
-		case GST_STATE_CHANGE_READY_TO_PAUSED:
-		{
-			GstIterator *children;
-			GValue r = G_VALUE_INIT;
-
-			if (audioSink)
+			result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
+			if (result)
 			{
-				gst_object_unref(GST_OBJECT(audioSink));
-				audioSink = NULL;
-			}
+				if (m_stream_tags && gst_tag_list_is_equal(m_stream_tags, result))
+				{
+					gst_tag_list_unref(tags);
+					gst_tag_list_unref(result);
 
-			if (videoSink)
-			{
-				gst_object_unref(GST_OBJECT(videoSink));
-				videoSink = NULL;
-			}
-			children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
-			if (children && gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &r, (gpointer)"GstDVBAudioSink"))
-			{
-				audioSink = GST_ELEMENT_CAST(g_value_dup_object (&r));
-				g_value_unset (&r);
-				hal_info_c( "%s %s - audio sink created\n", FILENAME, __FUNCTION__);
+					pthread_mutex_unlock(&mutex_tag_ist);
+					break;
+				}
+				if (m_stream_tags)
+					gst_tag_list_unref(m_stream_tags);
+				m_stream_tags = gst_tag_list_copy(result);
+				gst_tag_list_unref(result);
 			}
 
-			gst_iterator_free(children);
-			children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
-			if (children && gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &r, (gpointer)"GstDVBVideoSink"))
+			pthread_mutex_unlock(&mutex_tag_ist);
+
+			const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
+			if (gv_image)
 			{
-				videoSink = GST_ELEMENT_CAST(g_value_dup_object (&r));
-				g_value_unset (&r);
-				hal_info_c( "%s %s - video sink created\n", FILENAME, __FUNCTION__);
+				GstBuffer *buf_image;
+				GstSample *sample;
+				sample = (GstSample *)g_value_get_boxed(gv_image);
+				buf_image = gst_sample_get_buffer(sample);
+				int fd = open("/tmp/.id3coverart", O_CREAT | O_WRONLY | O_TRUNC, 0644);
+				if (fd >= 0)
+				{
+					guint8 *data;
+					gsize size;
+					GstMapInfo map;
+					gst_buffer_map(buf_image, &map, GST_MAP_READ);
+					data = map.data;
+					size = map.size;
+					int ret = write(fd, data, size);
+					gst_buffer_unmap(buf_image, &map);
+					close(fd);
+					hal_info_c("%s:%s - /tmp/.id3coverart %d bytes written\n", FILENAME, __FUNCTION__, ret);
+				}
 			}
-			gst_iterator_free(children);
-
+			if (tags)
+				gst_tag_list_unref(tags);
+			hal_debug_c("%s:%s - GST_MESSAGE_INFO: update info tags\n", FILENAME, __FUNCTION__);   //FIXME: how shall playback handle this event???
+			break;
 		}
-		break;
-		case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
-		{
-		}	break;
-		case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+		case GST_MESSAGE_ELEMENT:
 		{
-		}	break;
-		case GST_STATE_CHANGE_PAUSED_TO_READY:
-		{
-			if (audioSink)
+#if 0
+			if (gst_structure_has_name(gst_message_get_structure(msg), "prepare-window-handle"))
 			{
-				gst_object_unref(GST_OBJECT(audioSink));
-				audioSink = NULL;
+				// set window id
+				gst_video_overlay_set_window_handle(GST_VIDEO_OVERLAY(GST_MESSAGE_SRC(msg)), glfb->getWindowID());
+
+				// reshape window
+				gst_video_overlay_set_render_rectangle(GST_VIDEO_OVERLAY(GST_MESSAGE_SRC(msg)), 0, 0, glfb->getOSDWidth(), glfb->getOSDHeight());
+
+				// sync frames
+				gst_video_overlay_expose(GST_VIDEO_OVERLAY(GST_MESSAGE_SRC(msg)));
 			}
-			if (videoSink)
+#endif
+			GstMpegtsSection *section = gst_message_parse_mpegts_section(msg);
+			if (section)
 			{
-				gst_object_unref(GST_OBJECT(videoSink));
-				videoSink = NULL;
+				processMpegTsSection(section);
+				gst_mpegts_section_unref(section);
 			}
 		}
-		break;
-		case GST_STATE_CHANGE_READY_TO_NULL:
+		case GST_MESSAGE_STATE_CHANGED:
 		{
-		}	break;
+			if (GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
+				break;
+
+			GstState old_state, new_state;
+			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
+
+			if (old_state == new_state)
+				break;
+			hal_info_c("%s:%s - GST_MESSAGE_STATE_CHANGED: state transition %s -> %s\n", FILENAME, __FUNCTION__, gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
+
+			GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
+
+			switch (transition)
+			{
+				case GST_STATE_CHANGE_NULL_TO_READY:
+				{
+				}   break;
+				case GST_STATE_CHANGE_READY_TO_PAUSED:
+				{
+					GstIterator *children;
+					GValue r = G_VALUE_INIT;
+
+					if (audioSink)
+					{
+						gst_object_unref(GST_OBJECT(audioSink));
+						audioSink = NULL;
+					}
+
+					if (videoSink)
+					{
+						gst_object_unref(GST_OBJECT(videoSink));
+						videoSink = NULL;
+					}
+					children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
+					if (children && gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &r, (gpointer)"GstDVBAudioSink"))
+					{
+						audioSink = GST_ELEMENT_CAST(g_value_dup_object(&r));
+						g_value_unset(&r);
+						hal_info_c("%s %s - audio sink created\n", FILENAME, __FUNCTION__);
+					}
+
+					gst_iterator_free(children);
+					children = gst_bin_iterate_recurse(GST_BIN(m_gst_playbin));
+					if (children && gst_iterator_find_custom(children, (GCompareFunc)match_sinktype, &r, (gpointer)"GstDVBVideoSink"))
+					{
+						videoSink = GST_ELEMENT_CAST(g_value_dup_object(&r));
+						g_value_unset(&r);
+						hal_info_c("%s %s - video sink created\n", FILENAME, __FUNCTION__);
+					}
+					gst_iterator_free(children);
+
+				}
+				break;
+				case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+				{
+				}   break;
+				case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+				{
+				}   break;
+				case GST_STATE_CHANGE_PAUSED_TO_READY:
+				{
+					if (audioSink)
+					{
+						gst_object_unref(GST_OBJECT(audioSink));
+						audioSink = NULL;
+					}
+					if (videoSink)
+					{
+						gst_object_unref(GST_OBJECT(videoSink));
+						videoSink = NULL;
+					}
+				}
+				break;
+				case GST_STATE_CHANGE_READY_TO_NULL:
+				{
+				}   break;
+			}
+			break;
 		}
 		break;
-	}
-	break;
-	default:
-		break;
+		default:
+			break;
 	}
 
 	return GST_BUS_DROP;
@@ -426,17 +431,17 @@
 
 cPlayback::cPlayback(int num)
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 	const gchar *nano_str;
 	guint major, minor, micro, nano;
 
 	gst_init(NULL, NULL);
 
-	gst_version (&major, &minor, &micro, &nano);
+	gst_version(&major, &minor, &micro, &nano);
 
 	gst_mpegts_initialize();
 
-	pthread_mutex_init (&mutex_tag_ist, NULL);
+	pthread_mutex_init(&mutex_tag_ist, NULL);
 
 	if (nano == 1)
 		nano_str = "(CVS)";
@@ -445,9 +450,9 @@
 	else
 		nano_str = "";
 
-	hal_info( "%s:%s - This program is linked against GStreamer %d.%d.%d %s\n",
-	         FILENAME, __FUNCTION__,
-	         major, minor, micro, nano_str);
+	hal_info("%s:%s - This program is linked against GStreamer %d.%d.%d %s\n",
+	    FILENAME, __FUNCTION__,
+	    major, minor, micro, nano_str);
 
 	mAudioStream = 0;
 	mSpeed = 0;
@@ -460,12 +465,12 @@
 
 cPlayback::~cPlayback()
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 	//FIXME: all deleting stuff is done in Close()
-	pthread_mutex_lock (&mutex_tag_ist);
+	pthread_mutex_lock(&mutex_tag_ist);
 	if (m_stream_tags)
 		gst_tag_list_unref(m_stream_tags);
-	pthread_mutex_unlock (&mutex_tag_ist);
+	pthread_mutex_unlock(&mutex_tag_ist);
 }
 
 //Used by Fileplay
@@ -480,7 +485,7 @@
 // used by movieplay
 void cPlayback::Close(void)
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 
 	Stop();
 
@@ -488,11 +493,11 @@
 	if (m_gst_playbin)
 	{
 		// disconnect sync handler callback
-		GstBus * bus = gst_pipeline_get_bus(GST_PIPELINE (m_gst_playbin));
+		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(m_gst_playbin));
 		gst_bus_set_sync_handler(bus, NULL, NULL, NULL);
 		if (bus)
 			gst_object_unref(bus);
-		hal_info( "%s:%s - GST bus handler closed\n", FILENAME, __FUNCTION__);
+		hal_info("%s:%s - GST bus handler closed\n", FILENAME, __FUNCTION__);
 	}
 
 	// close gst
@@ -503,7 +508,7 @@
 			gst_object_unref(GST_OBJECT(audioSink));
 			audioSink = NULL;
 
-			hal_info( "%s:%s - GST audio Sink closed\n", FILENAME, __FUNCTION__);
+			hal_info("%s:%s - GST audio Sink closed\n", FILENAME, __FUNCTION__);
 		}
 
 		if (videoSink)
@@ -511,12 +516,12 @@
 			gst_object_unref(GST_OBJECT(videoSink));
 			videoSink = NULL;
 
-			hal_info( "%s:%s - GST video Sink closed\n", FILENAME, __FUNCTION__);
+			hal_info("%s:%s - GST video Sink closed\n", FILENAME, __FUNCTION__);
 		}
 
 		// unref m_gst_playbin
-		gst_object_unref (GST_OBJECT (m_gst_playbin));
-		hal_info( "%s:%s - GST playbin closed\n", FILENAME, __FUNCTION__);
+		gst_object_unref(GST_OBJECT(m_gst_playbin));
+		hal_info("%s:%s - GST playbin closed\n", FILENAME, __FUNCTION__);
 
 		m_gst_playbin = NULL;
 
@@ -527,12 +532,12 @@
 // start
 bool cPlayback::Start(std::string filename, std::string headers)
 {
-	return Start((char*) filename.c_str(),0,0,0,0,0, headers);
+	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers);
 }
 
 bool cPlayback::Start(char *filename, int /*vpid*/, int /*vtype*/, int /*apid*/, int /*ac3*/, int /*duration*/, std::string headers)
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 
 	if (!headers.empty())
 		extra_headers = headers;
@@ -544,68 +549,68 @@
 	mAudioStream = 0;
 	init_jump = -1;
 
-	pthread_mutex_lock (&mutex_tag_ist);
+	pthread_mutex_lock(&mutex_tag_ist);
 	if (m_stream_tags)
 		gst_tag_list_unref(m_stream_tags);
 	m_stream_tags = NULL;
-	pthread_mutex_unlock (&mutex_tag_ist);
+	pthread_mutex_unlock(&mutex_tag_ist);
 
 	unlink("/tmp/.id3coverart");
 
 	//create playback path
 	bool isHTTP = false;
 
-	if(!strncmp("http://", filename, 7))
+	if (!strncmp("http://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("https://", filename, 8))
+	else if (!strncmp("https://", filename, 8))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("file://", filename, 7))
+	else if (!strncmp("file://", filename, 7))
 	{
 		isHTTP = false;
 	}
-	else if(!strncmp("upnp://", filename, 7))
+	else if (!strncmp("upnp://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("rtmp://", filename, 7))
+	else if (!strncmp("rtmp://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("rtsp://", filename, 7))
+	else if (!strncmp("rtsp://", filename, 7))
 	{
 		isHTTP = true;
 	}
-	else if(!strncmp("mms://", filename, 6))
+	else if (!strncmp("mms://", filename, 6))
 	{
 		isHTTP = true;
 	}
 
 	if (isHTTP)
-		uri = g_strdup_printf ("%s", filename);
+		uri = g_strdup_printf("%s", filename);
 	else
 		uri = g_filename_to_uri(filename, NULL, NULL);
 
 	hal_info("%s:%s - filename=%s\n", FILENAME, __FUNCTION__, filename);
 
-	guint flags =	GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_NATIVE_VIDEO;
+	guint flags =   GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_NATIVE_VIDEO;
 
 	/* increase the default 2 second / 2 MB buffer limitations to 5s / 5MB */
-	int m_buffer_size = 5*1024*1024;
+	int m_buffer_size = 5 * 1024 * 1024;
 
 	// create gst pipeline
-	m_gst_playbin = gst_element_factory_make ("playbin", "playbin");
+	m_gst_playbin = gst_element_factory_make("playbin", "playbin");
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		hal_info("%s:%s - m_gst_playbin\n", FILENAME, __FUNCTION__);
 
-		if(isHTTP)
+		if (isHTTP)
 		{
-			g_signal_connect (G_OBJECT (m_gst_playbin), "notify::source", G_CALLBACK (playbinNotifySource), this);
+			g_signal_connect(G_OBJECT(m_gst_playbin), "notify::source", G_CALLBACK(playbinNotifySource), this);
 
 			// set buffer size
 			g_object_set(G_OBJECT(m_gst_playbin), "buffer-size", m_buffer_size, NULL);
@@ -613,12 +618,12 @@
 			flags |= GST_PLAY_FLAG_BUFFERING;
 		}
 
-		g_object_set(G_OBJECT (m_gst_playbin), "flags", flags, NULL);
+		g_object_set(G_OBJECT(m_gst_playbin), "flags", flags, NULL);
 
-		g_object_set(G_OBJECT (m_gst_playbin), "uri", uri, NULL);
+		g_object_set(G_OBJECT(m_gst_playbin), "uri", uri, NULL);
 
 		//gstbus handler
-		GstBus * bus = gst_pipeline_get_bus( GST_PIPELINE(m_gst_playbin) );
+		GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE(m_gst_playbin));
 		gst_bus_set_sync_handler(bus, Gst_bus_call, NULL, NULL);
 		if (bus)
 			gst_object_unref(bus);
@@ -626,7 +631,7 @@
 		first = true;
 
 		// state playing
-		if(isHTTP)
+		if (isHTTP)
 		{
 			gst_element_set_state(GST_ELEMENT(m_gst_playbin), GST_STATE_PLAYING);
 			playstate = STATE_PLAY;
@@ -654,12 +659,12 @@
 
 bool cPlayback::Play(void)
 {
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
-	if(playing == true)
+	if (playing == true)
 		return true;
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		gst_element_set_state(GST_ELEMENT(m_gst_playbin), GST_STATE_PLAYING);
 
@@ -673,19 +678,19 @@
 
 bool cPlayback::Stop(void)
 {
-	if(playing == false)
+	if (playing == false)
 		return false;
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
 	// stop
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
 	}
 
 	playing = false;
 
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
 	playstate = STATE_STOP;
 
@@ -698,15 +703,16 @@
 
 	int to_audio = pid;
 
-	for (unsigned int i = 0; i < REC_MAX_APIDS; i++) {
+	for (unsigned int i = 0; i < REC_MAX_APIDS; i++)
+	{
 		if (real_apids[i])
 			if (real_apids[i] == pid)
 				to_audio = i;
 	}
 
-	if(to_audio != mAudioStream)
+	if (to_audio != mAudioStream)
 	{
-		g_object_set (G_OBJECT (m_gst_playbin), "current-audio", to_audio, NULL);
+		g_object_set(G_OBJECT(m_gst_playbin), "current-audio", to_audio, NULL);
 		printf("%s: switched to audio stream %i\n", __FUNCTION__, to_audio);
 		mAudioStream = to_audio;
 	}
@@ -723,7 +729,7 @@
 
 	if (gst_element_query_position(m_gst_playbin, fmt, &pos))
 	{
-		if(ratio >= 0.0)
+		if (ratio >= 0.0)
 			gst_element_seek(m_gst_playbin, ratio, fmt, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, pos, GST_SEEK_TYPE_SET, -1);
 		else
 			gst_element_seek(m_gst_playbin, ratio, fmt, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_SKIP), GST_SEEK_TYPE_SET, 0, GST_SEEK_TYPE_SET, pos);
@@ -732,22 +738,22 @@
 
 bool cPlayback::SetSpeed(int speed)
 {
-	hal_info( "%s:%s speed %d\n", FILENAME, __FUNCTION__, speed);
+	hal_info("%s:%s speed %d\n", FILENAME, __FUNCTION__, speed);
 
-	if(playing == false)
+	if (playing == false)
 		return false;
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		// pause
-		if(speed == 0)
+		if (speed == 0)
 		{
 			gst_element_set_state(m_gst_playbin, GST_STATE_PAUSED);
 			//trickSeek(0);
 			playstate = STATE_PAUSE;
 		}
 		// play/continue
-		else if(speed == 1)
+		else if (speed == 1)
 		{
 			trickSeek(1);
 			//gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
@@ -755,14 +761,14 @@
 			playstate = STATE_PLAY;
 		}
 		//ff
-		else if(speed > 1)
+		else if (speed > 1)
 		{
 			trickSeek(speed);
 			//
 			playstate = STATE_FF;
 		}
 		//rf
-		else if(speed < 0)
+		else if (speed < 0)
 		{
 			trickSeek(speed);
 			//
@@ -771,7 +777,7 @@
 
 		if (init_jump > -1)
 		{
-			SetPosition(init_jump,true);
+			SetPosition(init_jump, true);
 			init_jump = -1;
 		}
 	}
@@ -783,12 +789,12 @@
 
 bool cPlayback::SetSlow(int slow)
 {
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
-	if(playing == false)
+	if (playing == false)
 		return false;
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		trickSeek(0.5);
 	}
@@ -810,17 +816,17 @@
 // in milliseconds
 bool cPlayback::GetPosition(int &position, int &duration)
 {
-	if(playing == false)
+	if (playing == false)
 		return false;
 
 	//EOF
-	if(end_eof)
+	if (end_eof)
 	{
 		end_eof = 0;
 		return false;
 	}
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		//position
 		GstFormat fmt = GST_FORMAT_TIME; //Returns time in nanosecs
@@ -830,14 +836,14 @@
 			g_signal_emit_by_name(audioSink ? audioSink : videoSink, "get-decoder-time", &pts);
 			if (!GST_CLOCK_TIME_IS_VALID(pts))
 			{
-				hal_info( "%s - %d failed\n", __FUNCTION__, __LINE__);
+				hal_info("%s - %d failed\n", __FUNCTION__, __LINE__);
 			}
 		}
 		else
 		{
-			if(!gst_element_query_position(m_gst_playbin, fmt, &pts))
+			if (!gst_element_query_position(m_gst_playbin, fmt, &pts))
 			{
-				hal_info( "%s - %d failed\n", __FUNCTION__, __LINE__);
+				hal_info("%s - %d failed\n", __FUNCTION__, __LINE__);
 			}
 		}
 		position = pts /  1000000.0;
@@ -848,7 +854,7 @@
 
 		gst_element_query_duration(m_gst_playbin, fmt_d, &len);
 		length = len / 1000000.0;
-		if(length < 0)
+		if (length < 0)
 			length = 0;
 
 		duration = (int)(length);
@@ -862,12 +868,13 @@
 	hal_info("%s: pos %d abs %d playing %d\n", __func__, position, absolute, playing);
 
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
-		if(first){
+		if (first)
+		{
 			GstState state;
 			gst_element_get_state(m_gst_playbin, &state, NULL, GST_CLOCK_TIME_NONE);
-			if ( (state == GST_STATE_PAUSED) && first)
+			if ((state == GST_STATE_PAUSED) && first)
 			{
 				init_jump = position;
 				first = false;
@@ -882,7 +889,7 @@
 		{
 			gst_element_query_position(m_gst_playbin, fmt, &pos);
 			time_nanoseconds = pos + (position * 1000000.0);
-			if(time_nanoseconds < 0)
+			if (time_nanoseconds < 0)
 				time_nanoseconds = 0;
 		}
 		else
@@ -896,19 +903,19 @@
 	return true;
 }
 
-void cPlayback::FindAllPids(int *apids, unsigned int *ac3flags, unsigned int *numpida, std::string * language)
+void cPlayback::FindAllPids(int *apids, unsigned int *ac3flags, unsigned int *numpida, std::string *language)
 {
-	hal_info( "%s:%s\n", FILENAME, __FUNCTION__);
+	hal_info("%s:%s\n", FILENAME, __FUNCTION__);
 
-	if(m_gst_playbin)
+	if (m_gst_playbin)
 	{
 		gint i, n_audio = 0;
 
 		// get audio
-		g_object_get (m_gst_playbin, "n-audio", &n_audio, NULL);
+		g_object_get(m_gst_playbin, "n-audio", &n_audio, NULL);
 		hal_info("%s: %d audio\n", __FUNCTION__, n_audio);
 
-		if(n_audio == 0)
+		if (n_audio == 0)
 			return;
 
 		language->clear();
@@ -916,61 +923,61 @@
 		for (i = 0; i < n_audio && i < *numpida; i++)
 		{
 			// apids
-			apids[i]= real_apids[i] ? real_apids[i] : i;
+			apids[i] = real_apids[i] ? real_apids[i] : i;
 
-			GstPad * pad = 0;
-			g_signal_emit_by_name (m_gst_playbin, "get-audio-pad", i, &pad);
+			GstPad *pad = 0;
+			g_signal_emit_by_name(m_gst_playbin, "get-audio-pad", i, &pad);
 
-			GstCaps * caps = gst_pad_get_current_caps(pad);
+			GstCaps *caps = gst_pad_get_current_caps(pad);
 			if (pad)
 				gst_object_unref(pad);
 
 			if (!caps)
 				continue;
 
-			GstStructure * structure = gst_caps_get_structure(caps, 0);
-			GstTagList * tags = NULL;
-			gchar * g_lang = NULL;
+			GstStructure *structure = gst_caps_get_structure(caps, 0);
+			GstTagList *tags = NULL;
+			gchar *g_lang = NULL;
 
 			// ac3flags
-			if ( gst_structure_has_name (structure, "audio/mpeg"))
+			if (gst_structure_has_name(structure, "audio/mpeg"))
 			{
 				gint mpegversion;
 
-				if (!gst_structure_get_int (structure, "mpegversion", &mpegversion))
+				if (!gst_structure_get_int(structure, "mpegversion", &mpegversion))
 					ac3flags[i] = 0;
 
 				switch (mpegversion)
 				{
-				case 1:
-					ac3flags[i] = 4;
-				case 2:
-					//return atAAC;
-					ac3flags[i] = 5;
-				case 4:
-					//return atAAC;
-					ac3flags[i] = 5;
-				default:
-					//return atUnknown;
-					ac3flags[i] = 0;
+					case 1:
+						ac3flags[i] = 4;
+					case 2:
+						//return atAAC;
+						ac3flags[i] = 5;
+					case 4:
+						//return atAAC;
+						ac3flags[i] = 5;
+					default:
+						//return atUnknown;
+						ac3flags[i] = 0;
 				}
 			}
-			else if ( gst_structure_has_name (structure, "audio/x-ac3") || gst_structure_has_name (structure, "audio/ac3") )
+			else if (gst_structure_has_name(structure, "audio/x-ac3") || gst_structure_has_name(structure, "audio/ac3"))
 				//return atAC3;
 				ac3flags[i] = 1;
-			else if ( gst_structure_has_name (structure, "audio/x-dts") || gst_structure_has_name (structure, "audio/dts") )
+			else if (gst_structure_has_name(structure, "audio/x-dts") || gst_structure_has_name(structure, "audio/dts"))
 				//return atDTS;
 				ac3flags[i] = 6;
-			else if ( gst_structure_has_name (structure, "audio/x-raw-int") )
+			else if (gst_structure_has_name(structure, "audio/x-raw-int"))
 				//return atPCM;
 				ac3flags[i] = 0;
 
 			if (caps)
 				gst_caps_unref(caps);
 
-			//(ac3flags[i] > 2) ?	ac3flags[i] = 1 : ac3flags[i] = 0;
+			//(ac3flags[i] > 2) ?   ac3flags[i] = 1 : ac3flags[i] = 0;
 
-			g_signal_emit_by_name (m_gst_playbin, "get-audio-tags", i, &tags);
+			g_signal_emit_by_name(m_gst_playbin, "get-audio-tags", i, &tags);
 			if (tags)
 			{
 				if (GST_IS_TAG_LIST(tags) && gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang))
@@ -990,21 +997,21 @@
 				gst_tag_list_free(tags);
 			}
 		}
-		*numpida=i;
+		*numpida = i;
 	}
 }
 
 void cPlayback::getMeta()
 {
-	if(playing)
+	if (playing)
 		return;
 }
 
 bool cPlayback::SyncAV(void)
 {
-	hal_info( "%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
+	hal_info("%s:%s playing %d\n", FILENAME, __FUNCTION__, playing);
 
-	if(playing == false )
+	if (playing == false)
 		return false;
 
 	return true;
@@ -1038,18 +1045,20 @@
 	values.clear();
 
 	GstTagList *meta_list = NULL;
-	pthread_mutex_lock (&mutex_tag_ist);
+	pthread_mutex_lock(&mutex_tag_ist);
 
-	if(m_stream_tags){
+	if (m_stream_tags)
+	{
 		meta_list = gst_tag_list_copy(m_stream_tags);
 	}
 
-	pthread_mutex_unlock (&mutex_tag_ist);
+	pthread_mutex_unlock(&mutex_tag_ist);
 
 	if (meta_list == NULL)
 		return;
 
-	if (gst_tag_list_is_empty(meta_list)){
+	if (gst_tag_list_is_empty(meta_list))
+	{
 		gst_tag_list_unref(meta_list);
 		return;
 	}
@@ -1080,14 +1089,14 @@
 			{
 				char buffer [50];
 				keys.push_back(name);
-				sprintf (buffer, "%u", g_value_get_uint(val));
+				sprintf(buffer, "%u", g_value_get_uint(val));
 				values.push_back(buffer);
 			}
 			else if (G_VALUE_HOLDS_DOUBLE(val))
 			{
 				char buffer [50];
 				keys.push_back(name);
-				sprintf (buffer, "%f", g_value_get_double(val));
+				sprintf(buffer, "%f", g_value_get_double(val));
 				values.push_back(buffer);
 			}
 			else if (G_VALUE_HOLDS_BOOLEAN(val))
@@ -1145,7 +1154,7 @@
 int cPlayback::GetAPid(void)
 {
 	gint current_audio = 0;
-	g_object_get (m_gst_playbin, "current-audio", &current_audio, NULL);
+	g_object_get(m_gst_playbin, "current-audio", &current_audio, NULL);
 	hal_info("%s: %d audio\n", __FUNCTION__, current_audio);
 	return real_apids[current_audio] ? real_apids[current_audio] : current_audio;
 }
@@ -1153,7 +1162,7 @@
 int cPlayback::GetVPid(void)
 {
 	gint current_video = 0;
-	g_object_get (m_gst_playbin, "current-video", &current_video, NULL);
+	g_object_get(m_gst_playbin, "current-video", &current_video, NULL);
 	hal_info("%s: %d video\n", __FUNCTION__, current_video);
 	return current_video;
 }
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/playback_gst.h libstb-hal-ddt.git/libgeneric-pc/playback_gst.h
--- libstb-hal-ddt.git.orig/libgeneric-pc/playback_gst.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/playback_gst.h	2022-07-23 18:18:31.535772387 +0200
@@ -46,57 +46,57 @@
 
 class cPlayback
 {
-private:
-	bool playing, first;
-	bool decoders_closed;
-
-	int mSpeed;
-	int mAudioStream;
-	int init_jump;
-
-public:
-	playstate_t playstate;
-
-	cPlayback(int);
-	bool Open(playmode_t PlayMode);
-	void Close(void);
-	bool Start(char *filename, int vpid, int vtype, int apid, int ac3, int duration, std::string headers = "");
-	bool Start(std::string filename, std::string headers = "");
-	bool Play(void);
-	bool SyncAV(void);
-
-	bool Stop(void);
-	bool SetAPid(int pid, bool ac3);
-	bool SetSubtitlePid(int pid);
-	bool SetTeletextPid(int pid);
-
-	void trickSeek(int ratio);
-	bool SetSpeed(int speed);
-	bool SetSlow(int slow);
-	bool GetSpeed(int &speed) const;
-	bool GetPosition(int &position, int &duration);
-	void GetPts(uint64_t &pts);
-	int GetAPid(void);
-	int GetVPid(void);
-	int GetSubtitlePid(void);
-	bool SetPosition(int position, bool absolute = false);
-	void FindAllPids(int *apids, unsigned int *ac3flags, unsigned int *numpida, std::string *language);
-	void FindAllSubtitlePids(int *pids, unsigned int *numpids, std::string *language);
-	void FindAllTeletextsubtitlePids(int *pids, unsigned int *numpidt, std::string *tlanguage, int *mags, int *pages);
-	void RequestAbort(void);
-	void FindAllSubs(uint16_t *pids, unsigned short *supported, uint16_t *numpida, std::string *language);
-	bool SelectSubtitles(int pid);
-	uint64_t GetReadCount(void);
-	void GetChapters(std::vector<int> &positions, std::vector<std::string> &titles);
-	void GetMetadata(std::vector<std::string> &keys, std::vector<std::string> &values);
-	AVFormatContext *GetAVFormatContext();
-	void ReleaseAVFormatContext();
-	std::string extra_headers;
-	std::string user_agent;
-
-	//
-	~cPlayback();
-	void getMeta();
+	private:
+		bool playing, first;
+		bool decoders_closed;
+
+		int mSpeed;
+		int mAudioStream;
+		int init_jump;
+
+	public:
+		playstate_t playstate;
+
+		cPlayback(int);
+		bool Open(playmode_t PlayMode);
+		void Close(void);
+		bool Start(char *filename, int vpid, int vtype, int apid, int ac3, int duration, std::string headers = "");
+		bool Start(std::string filename, std::string headers = "");
+		bool Play(void);
+		bool SyncAV(void);
+
+		bool Stop(void);
+		bool SetAPid(int pid, bool ac3);
+		bool SetSubtitlePid(int pid);
+		bool SetTeletextPid(int pid);
+
+		void trickSeek(int ratio);
+		bool SetSpeed(int speed);
+		bool SetSlow(int slow);
+		bool GetSpeed(int &speed) const;
+		bool GetPosition(int &position, int &duration);
+		void GetPts(uint64_t &pts);
+		int GetAPid(void);
+		int GetVPid(void);
+		int GetSubtitlePid(void);
+		bool SetPosition(int position, bool absolute = false);
+		void FindAllPids(int *apids, unsigned int *ac3flags, unsigned int *numpida, std::string *language);
+		void FindAllSubtitlePids(int *pids, unsigned int *numpids, std::string *language);
+		void FindAllTeletextsubtitlePids(int *pids, unsigned int *numpidt, std::string *tlanguage, int *mags, int *pages);
+		void RequestAbort(void);
+		void FindAllSubs(uint16_t *pids, unsigned short *supported, uint16_t *numpida, std::string *language);
+		bool SelectSubtitles(int pid);
+		uint64_t GetReadCount(void);
+		void GetChapters(std::vector<int> &positions, std::vector<std::string> &titles);
+		void GetMetadata(std::vector<std::string> &keys, std::vector<std::string> &values);
+		AVFormatContext *GetAVFormatContext();
+		void ReleaseAVFormatContext();
+		std::string extra_headers;
+		std::string user_agent;
+
+		//
+		~cPlayback();
+		void getMeta();
 };
 
 #endif // __PLAYBACK_GST_H__
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/playback_lib.h libstb-hal-ddt.git/libgeneric-pc/playback_lib.h
--- libstb-hal-ddt.git.orig/libgeneric-pc/playback_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/playback_lib.h	2022-07-23 18:18:31.535772387 +0200
@@ -5,10 +5,11 @@
 #include <stdint.h>
 #include <vector>
 
-typedef enum {
+typedef enum
+{
 	PLAYMODE_TS = 0,
 	PLAYMODE_FILE,
-} playmode_t; 
+} playmode_t;
 
 struct AVFormatContext;
 class cPlayback
@@ -27,9 +28,15 @@
 		bool SetAPid(int pid, bool ac3);
 		bool SetSubtitlePid(int pid);
 		bool SetTeletextPid(int pid);
-		int GetAPid(void) { return mAudioStream; }
+		int GetAPid(void)
+		{
+			return mAudioStream;
+		}
 		int GetVPid(void);
-		int GetSubtitlePid(void) { return mSubtitleStream; }
+		int GetSubtitlePid(void)
+		{
+			return mSubtitleStream;
+		}
 		int GetTeletextPid(void);
 		void SuspendSubtitle(bool);
 		int GetFirstTeletextPid(void);
@@ -42,7 +49,10 @@
 		void FindAllSubtitlePids(int *pids, unsigned int *numpids, std::string *language);
 		void FindAllTeletextsubtitlePids(int *pids, unsigned int *numpidt, std::string *tlanguage, int *mags, int *pages);
 		void RequestAbort(void);
-		bool IsPlaying(void) { return false; }
+		bool IsPlaying(void)
+		{
+			return false;
+		}
 		uint64_t GetReadCount(void);
 		void FindAllSubs(uint16_t *pids, unsigned short *supported, uint16_t *numpida, std::string *language);
 		bool SelectSubtitles(int pid);
@@ -52,7 +62,10 @@
 		void GetMetadata(std::vector<std::string> &keys, std::vector<std::string> &values);
 		//
 		~cPlayback();
-		AVFormatContext *GetAVFormatContext(){ return NULL; }
+		AVFormatContext *GetAVFormatContext()
+		{
+			return NULL;
+		}
 		void ReleaseAVFormatContext() {}
 };
 
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/record.cpp libstb-hal-ddt.git/libgeneric-pc/record.cpp
--- libstb-hal-ddt.git.orig/libgeneric-pc/record.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/record.cpp	2022-07-23 18:18:31.543772226 +0200
@@ -134,17 +134,21 @@
 	bool found;
 	unsigned short pid;
 	hal_info("%s\n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
 	/* the first PID is the video pid, so start with the second PID... */
-	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+	{
 		found = false;
 		pid = (*i).pid;
-		for (j = 0; j < numapids; j++) {
-			if (pid == apids[j]) {
+		for (j = 0; j < numapids; j++)
+		{
+			if (pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -152,10 +156,13 @@
 		if (!found)
 			dmx->removePid(pid);
 	}
-	for (j = 0; j < numapids; j++) {
+	for (j = 0; j < numapids; j++)
+	{
 		found = false;
-		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
-			if ((*i).pid == apids[j]) {
+		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+		{
+			if ((*i).pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -170,12 +177,14 @@
 {
 	std::vector<pes_pids> pids;
 	hal_info("%s: \n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
-	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i)
+	{
 		if ((*i).pid == pid)
 			return true; /* or is it an error to try to add the same PID twice? */
 	}
@@ -187,14 +196,16 @@
 	char threadname[17];
 	strncpy(threadname, "WriterThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	unsigned int chunk = 0;
-	while (!sem_wait(&sem)) {
+	while (!sem_wait(&sem))
+	{
 		if (!io_len[chunk]) // empty, assume end of recording
 			return;
 		unsigned char *p_buf = io_buf[chunk];
 		size_t p_len = io_len[chunk];
-		while (p_len) {
+		while (p_len)
+		{
 			ssize_t written = write(file_fd, p_buf, p_len);
 			if (written < 0)
 				break;
@@ -214,7 +225,7 @@
 	char threadname[17];
 	strncpy(threadname, "RecordThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	int readsize = bufsize / 16;
 	int buf_pos = 0;
 	int count = 0;
@@ -235,7 +246,7 @@
 	}
 
 	int val = fcntl(file_fd, F_GETFL);
-	if (fcntl(file_fd, F_SETFL, val|O_APPEND))
+	if (fcntl(file_fd, F_SETFL, val | O_APPEND))
 		hal_info("%s: O_APPEND? (%m)\n", __func__);
 
 	memset(&a, 0, sizeof(a));
@@ -250,7 +261,8 @@
 	{
 		if (buf_pos < bufsize)
 		{
-			if (overflow_count) {
+			if (overflow_count)
+			{
 				hal_info("%s: Overflow cleared after %d iterations\n", __func__, overflow_count);
 				overflow_count = 0;
 			}
@@ -259,7 +271,7 @@
 				toread = readsize;
 			ssize_t s = dmx->Read(buf + buf_pos, toread, 50);
 			hal_debug("%s: buf_pos %6d s %6d / %6d\n", __func__,
-				buf_pos, (int)s, bufsize - buf_pos);
+			    buf_pos, (int)s, bufsize - buf_pos);
 			if (s < 0)
 			{
 				if (errno != EAGAIN && (errno != EOVERFLOW || !overflow))
@@ -362,9 +374,9 @@
 	eventServer.registerEvent2(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, "/tmp/neutrino.sock");
 	stream2file_status2_t s;
 	s.status = exit_flag;
-	strncpy(s.filename,basename(myfilename),512);
+	strncpy(s.filename, basename(myfilename), 512);
 	s.filename[511] = '\0';
-	strncpy(s.dir,dirname(myfilename),100);
+	strncpy(s.dir, dirname(myfilename), 100);
 	s.dir[99] = '\0';
 	eventServer.sendEvent(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, &s, sizeof(s));
 	printf("[stream2file]: pthreads exit code: %i, dir: '%s', filename: '%s' myfilename: '%s'\n", exit_flag, s.dir, s.filename, myfilename);
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/record_lib.h libstb-hal-ddt.git/libgeneric-pc/record_lib.h
--- libstb-hal-ddt.git.orig/libgeneric-pc/record_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/record_lib.h	2022-07-23 18:18:31.543772226 +0200
@@ -9,13 +9,14 @@
 #define REC_STATUS_OVERFLOW 2
 #define REC_STATUS_STOPPED 4
 
-typedef enum {
+typedef enum
+{
 	RECORD_RUNNING,
 	RECORD_STOPPED,
-	RECORD_FAILED_READ,	/* failed to read from DMX */
-	RECORD_FAILED_OVERFLOW,	/* cannot write fast enough */
-	RECORD_FAILED_FILE,	/* cannot write to file */
-	RECORD_FAILED_MEMORY	/* out of memory */
+	RECORD_FAILED_READ, /* failed to read from DMX */
+	RECORD_FAILED_OVERFLOW, /* cannot write fast enough */
+	RECORD_FAILED_FILE, /* cannot write to file */
+	RECORD_FAILED_MEMORY    /* out of memory */
 } record_state_t;
 
 class cRecord
@@ -38,8 +39,12 @@
 		unsigned char *io_buf[RECORD_WRITER_CHUNKS];
 		size_t io_len[RECORD_WRITER_CHUNKS];
 	public:
-		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024); 
-		void setFailureCallback(void (*f)(void *), void *d) { failureCallback = f; failureData = d; }
+		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024);
+		void setFailureCallback(void (*f)(void *), void *d)
+		{
+			failureCallback = f;
+			failureData = d;
+		}
 		~cRecord();
 
 		bool Open();
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/video.cpp libstb-hal-ddt.git/libgeneric-pc/video.cpp
--- libstb-hal-ddt.git.orig/libgeneric-pc/video.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libgeneric-pc/video.cpp	2022-07-23 18:18:31.535772387 +0200
@@ -65,13 +65,14 @@
 static uint8_t *dmxbuf;
 static int bufpos;
 
-static const AVRational aspect_ratios[6] = {
+static const AVRational aspect_ratios[6] =
+{
 	{  1, 1 },
 	{  4, 3 },
 	{ 14, 9 },
 	{ 16, 9 },
 	{ 20, 9 },
-	{ -1,-1 }
+	{ -1, -1 }
 };
 
 cVideo::cVideo(int, void *, void *, unsigned int)
@@ -101,7 +102,7 @@
 cVideo::~cVideo(void)
 {
 	Stop();
-	/* ouch :-( */
+	/* ouch :-(*/
 	videoDecoder = NULL;
 }
 
@@ -133,15 +134,13 @@
 	ar = w * 100 * a.num / h / a.den;
 	if (ar < 100 || ar > 225) /* < 4:3, > 20:9 */
 		; /* ret = 0: N/A */
-	else if (ar < 140)	/* 4:3 */
+	else if (ar < 140)  /* 4:3 */
 		ret = 1;
-	else if (ar < 165)	/* 14:9 */
-		ret = 2;
-	else if (ar < 200)	/* 16:9 */
+	else if (ar < 200)  /* 16:9 */
 		ret = 3;
 	else
-		ret = 4;	/* 20:9 */
- out:
+		ret = 4;    /* 20:9 */
+out:
 	buf_m.unlock();
 	return ret;
 }
@@ -163,7 +162,8 @@
 int cVideo::Stop(bool)
 {
 	hal_debug("%s running %d >\n", __func__, thread_running);
-	if (thread_running) {
+	if (thread_running)
+	{
 		thread_running = false;
 		OpenThreads::Thread::join();
 	}
@@ -180,9 +180,9 @@
 {
 	int current_video_system = VIDEO_STD_1080I50;
 
-	if(dec_w < 720)
+	if (dec_w < 720)
 		current_video_system = VIDEO_STD_PAL;
-	else if(dec_w > 720 && dec_w <= 1280)
+	else if (dec_w > 720 && dec_w <= 1280)
 		current_video_system = VIDEO_STD_720P50;
 
 	return current_video_system;
@@ -191,7 +191,7 @@
 int cVideo::SetVideoSystem(int system, bool)
 {
 	int h;
-	switch(system)
+	switch (system)
 	{
 		case VIDEO_STD_NTSC:
 		case VIDEO_STD_480P:
@@ -211,7 +211,7 @@
 			break;
 		case VIDEO_STD_AUTO:
 			hal_info("%s: VIDEO_STD_AUTO not implemented\n", __func__);
-			// fallthrough
+		// fallthrough
 		case VIDEO_STD_SECAM:
 		case VIDEO_STD_PAL:
 		case VIDEO_STD_576P:
@@ -237,11 +237,12 @@
 {
 }
 
-void cVideo::ShowPicture(const char *fname)
+bool cVideo::ShowPicture(const char *fname)
 {
+	bool ret = false;
 	hal_info("%s(%s)\n", __func__, fname);
 	if (access(fname, R_OK))
-		return;
+		return ret;
 	still_m.lock();
 	stillpicture = true;
 	buf_num = 0;
@@ -260,17 +261,21 @@
 	AVFrame *frame, *rgbframe;
 	AVPacket avpkt;
 
-	if (avformat_open_input(&avfc, fname, NULL, NULL) < 0) {
+	if (avformat_open_input(&avfc, fname, NULL, NULL) < 0)
+	{
 		hal_info("%s: Could not open file %s\n", __func__, fname);
-		return;
+		return ret;
 	}
 
-	if (avformat_find_stream_info(avfc, NULL) < 0) {
+	if (avformat_find_stream_info(avfc, NULL) < 0)
+	{
 		hal_info("%s: Could not find file info %s\n", __func__, fname);
 		goto out_close;
 	}
-	for (i = 0; i < avfc->nb_streams; i++) {
-		if (avfc->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
+	for (i = 0; i < avfc->nb_streams; i++)
+	{
+		if (avfc->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
+		{
 			stream_id = i;
 			break;
 		}
@@ -280,24 +285,28 @@
 	p = avfc->streams[stream_id]->codecpar;
 	codec = avcodec_find_decoder(p->codec_id);
 	c = avcodec_alloc_context3(codec);
-	if (avcodec_open2(c, codec, NULL) < 0) {
+	if (avcodec_open2(c, codec, NULL) < 0)
+	{
 		hal_info("%s: Could not find/open the codec, id 0x%x\n", __func__, p->codec_id);
 		goto out_close;
 	}
 	frame = av_frame_alloc();
 	rgbframe = av_frame_alloc();
-	if (!frame || !rgbframe) {
+	if (!frame || !rgbframe)
+	{
 		hal_info("%s: Could not allocate video frame\n", __func__);
 		goto out_free;
 	}
 	av_init_packet(&avpkt);
-	if (av_read_frame(avfc, &avpkt) < 0) {
+	if (av_read_frame(avfc, &avpkt) < 0)
+	{
 		hal_info("%s: av_read_frame < 0\n", __func__);
 		goto out_free;
 	}
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 	av_ret = avcodec_decode_video2(c, frame, &got_frame, &avpkt);
-	if (av_ret < 0) {
+	if (av_ret < 0)
+	{
 		hal_info("%s: avcodec_decode_video2 %d\n", __func__, av_ret);
 		av_packet_unref(&avpkt);
 		goto out_free;
@@ -306,7 +315,8 @@
 		hal_info("%s: WARN: pkt->size %d != len %d\n", __func__, avpkt.size, av_ret);
 #else
 	av_ret = avcodec_send_packet(c, &avpkt);
-	if (av_ret != 0 && av_ret != AVERROR(EAGAIN)) {
+	if (av_ret != 0 && av_ret != AVERROR(EAGAIN))
+	{
 		hal_info("%s: avcodec_send_packet %d\n", __func__, av_ret);
 		av_packet_unref(&avpkt);
 		goto out_free;
@@ -318,22 +328,24 @@
 	got_frame = 1;
 #endif
 
-	if (got_frame) {
+	if (got_frame)
+	{
 		unsigned int need = av_image_get_buffer_size(VDEC_PIXFMT, c->width, c->height, 1);
 		struct SwsContext *convert = sws_getContext(c->width, c->height, c->pix_fmt,
-							    c->width, c->height, VDEC_PIXFMT,
-							    SWS_BICUBIC, 0, 0, 0);
+		        c->width, c->height, VDEC_PIXFMT,
+		        SWS_BICUBIC, 0, 0, 0);
 		if (!convert)
 			hal_info("%s: ERROR setting up SWS context\n", __func__);
-		else {
+		else
+		{
 			buf_m.lock();
 			SWFramebuffer *f = &buffers[buf_in];
 			if (f->size() < need)
 				f->resize(need);
 			av_image_fill_arrays(rgbframe->data, rgbframe->linesize, &(*f)[0], VDEC_PIXFMT,
-					c->width, c->height, 1);
+			    c->width, c->height, 1);
 			sws_scale(convert, frame->data, frame->linesize, 0, c->height,
-					rgbframe->data, rgbframe->linesize);
+			    rgbframe->data, rgbframe->linesize);
 			sws_freeContext(convert);
 			f->width(c->width);
 			f->height(c->height);
@@ -343,24 +355,27 @@
 			buf_in++;
 			buf_in %= VDEC_MAXBUFS;
 			buf_num++;
-			if (buf_num > (VDEC_MAXBUFS - 1)) {
+			if (buf_num > (VDEC_MAXBUFS - 1))
+			{
 				hal_debug("%s: buf_num overflow\n", __func__);
 				buf_out++;
 				buf_out %= VDEC_MAXBUFS;
 				buf_num--;
 			}
 			buf_m.unlock();
+			ret = true;
 		}
 	}
 	av_packet_unref(&avpkt);
- out_free:
+out_free:
 	avcodec_close(c);
 	av_free(c);
 	av_frame_free(&frame);
 	av_frame_free(&rgbframe);
- out_close:
+out_close:
 	avformat_close_input(&avfc);
 	hal_debug("%s(%s) end\n", __func__, fname);
+	return ret;
 }
 
 void cVideo::StopPicture()
@@ -393,7 +408,8 @@
 {
 	width = dec_w;
 	height = dec_h;
-	switch (dec_r) {
+	switch (dec_r)
+	{
 		case 23://23.976fps
 			rate = VIDEO_FRAME_RATE_23_976;
 			break;
@@ -434,7 +450,8 @@
 cVideo::SWFramebuffer *cVideo::getDecBuf(void)
 {
 	buf_m.lock();
-	if (buf_num == 0) {
+	if (buf_num == 0)
+	{
 		buf_m.unlock();
 		return NULL;
 	}
@@ -449,8 +466,10 @@
 static int my_read(void *, uint8_t *buf, int buf_size)
 {
 	int tmp = 0;
-	if (videoDecoder && bufpos < DMX_BUF_SZ - 4096) {
-		while (bufpos < buf_size && ++tmp < 20) { /* retry max 20 times */
+	if (videoDecoder && bufpos < DMX_BUF_SZ - 4096)
+	{
+		while (bufpos < buf_size && ++tmp < 20)   /* retry max 20 times */
+		{
 			int ret = videoDemux->Read(dmxbuf + bufpos, DMX_BUF_SZ - bufpos, 20);
 			if (ret > 0)
 				bufpos += ret;
@@ -458,7 +477,8 @@
 	}
 	if (bufpos == 0)
 		return 0;
-	if (bufpos > buf_size) {
+	if (bufpos > buf_size)
+	{
 		memcpy(buf, dmxbuf, buf_size);
 		memmove(dmxbuf, dmxbuf + buf_size, bufpos - buf_size);
 		bufpos -= buf_size;
@@ -475,7 +495,7 @@
 	hal_info("====================== start decoder thread ================================\n");
 	AVCodec *codec;
 	AVCodecParameters *p = NULL;
-	AVCodecContext *c= NULL;
+	AVCodecContext *c = NULL;
 	AVFormatContext *avfc = NULL;
 	AVInputFormat *inp;
 	AVFrame *frame, *rgbframe;
@@ -496,18 +516,19 @@
 	av_init_packet(&avpkt);
 	inp = av_find_input_format("mpegts");
 	AVIOContext *pIOCtx = avio_alloc_context(inbuf, INBUF_SIZE, // internal Buffer and its size
-			0,		// bWriteable (1=true,0=false)
-			NULL,		// user data; will be passed to our callback functions
-			my_read,	// read callback
-			NULL,		// write callback
-			NULL);		// seek callback
+	        0,      // bWriteable (1=true,0=false)
+	        NULL,       // user data; will be passed to our callback functions
+	        my_read,    // read callback
+	        NULL,       // write callback
+	        NULL);      // seek callback
 	avfc = avformat_alloc_context();
 	avfc->pb = pIOCtx;
 	avfc->iformat = inp;
-	avfc->probesize = 188*5;
+	avfc->probesize = 188 * 5;
 
 	thread_running = true;
-	if (avformat_open_input(&avfc, NULL, inp, NULL) < 0) {
+	if (avformat_open_input(&avfc, NULL, inp, NULL) < 0)
+	{
 		hal_info("%s: Could not open input\n", __func__);
 		goto out;
 	}
@@ -526,25 +547,31 @@
 		hal_info("%s: no video codec? 0x%x\n", __func__, p->codec_type);
 
 	codec = avcodec_find_decoder(p->codec_id);
-	if (!codec) {
+	if (!codec)
+	{
 		hal_info("%s: Codec for %s not found\n", __func__, avcodec_get_name(p->codec_id));
 		goto out;
 	}
 	c = avcodec_alloc_context3(codec);
-	if (avcodec_open2(c, codec, NULL) < 0) {
+	if (avcodec_open2(c, codec, NULL) < 0)
+	{
 		hal_info("%s: Could not open codec\n", __func__);
 		goto out;
 	}
 	frame = av_frame_alloc();
 	rgbframe = av_frame_alloc();
-	if (!frame || !rgbframe) {
+	if (!frame || !rgbframe)
+	{
 		hal_info("%s: Could not allocate video frame\n", __func__);
 		goto out2;
 	}
 	hal_info("decoding %s\n", avcodec_get_name(c->codec_id));
-	while (thread_running) {
-		if (av_read_frame(avfc, &avpkt) < 0) {
-			if (warn_r - time(NULL) > 4) {
+	while (thread_running)
+	{
+		if (av_read_frame(avfc, &avpkt) < 0)
+		{
+			if (warn_r - time(NULL) > 4)
+			{
 				hal_info("%s: av_read_frame < 0\n", __func__);
 				warn_r = time(NULL);
 			}
@@ -554,8 +581,10 @@
 		int got_frame = 0;
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 		av_ret = avcodec_decode_video2(c, frame, &got_frame, &avpkt);
-		if (av_ret < 0) {
-			if (warn_d - time(NULL) > 4) {
+		if (av_ret < 0)
+		{
+			if (warn_d - time(NULL) > 4)
+			{
 				hal_info("%s: avcodec_decode_video2 %d\n", __func__, av_ret);
 				warn_d = time(NULL);
 			}
@@ -566,8 +595,10 @@
 			hal_info("%s: WARN: pkt->size %d != len %d\n", __func__, avpkt.size, av_ret);
 #else
 		av_ret = avcodec_send_packet(c, &avpkt);
-		if (av_ret != 0 && av_ret != AVERROR(EAGAIN)) {
-			if (warn_d - time(NULL) > 4) {
+		if (av_ret != 0 && av_ret != AVERROR(EAGAIN))
+		{
+			if (warn_d - time(NULL) > 4)
+			{
 				hal_info("%s: avcodec_send_packet %d\n", __func__, av_ret);
 				warn_d = time(NULL);
 			}
@@ -579,26 +610,29 @@
 			got_frame = 1;
 #endif
 		still_m.lock();
-		if (got_frame && ! stillpicture) {
+		if (got_frame && ! stillpicture)
+		{
 			unsigned int need = av_image_get_buffer_size(VDEC_PIXFMT, c->width, c->height, 1);
 			convert = sws_getCachedContext(convert,
-						       c->width, c->height, c->pix_fmt,
-						       c->width, c->height, VDEC_PIXFMT,
-						       SWS_BICUBIC, 0, 0, 0);
+			        c->width, c->height, c->pix_fmt,
+			        c->width, c->height, VDEC_PIXFMT,
+			        SWS_BICUBIC, 0, 0, 0);
 			if (!convert)
 				hal_info("%s: ERROR setting up SWS context\n", __func__);
-			else {
+			else
+			{
 				buf_m.lock();
 				SWFramebuffer *f = &buffers[buf_in];
 				if (f->size() < need)
 					f->resize(need);
 				av_image_fill_arrays(rgbframe->data, rgbframe->linesize, &(*f)[0], VDEC_PIXFMT,
-						c->width, c->height, 1);
+				    c->width, c->height, 1);
 				sws_scale(convert, frame->data, frame->linesize, 0, c->height,
-						rgbframe->data, rgbframe->linesize);
-				if (dec_w != c->width || dec_h != c->height) {
+				    rgbframe->data, rgbframe->linesize);
+				if (dec_w != c->width || dec_h != c->height)
+				{
 					hal_info("%s: pic changed %dx%d -> %dx%d\n", __func__,
-							dec_w, dec_h, c->width, c->height);
+					    dec_w, dec_h, c->width, c->height);
 					dec_w = c->width;
 					dec_h = c->height;
 					w_h_changed = true;
@@ -613,14 +647,14 @@
 				/* a/v delay determined experimentally :-) */
 #if USE_OPENGL
 				if (v_format == VIDEO_FORMAT_MPEG2)
-					vpts += 90000*4/10; /* 400ms */
+					vpts += 90000 * 4 / 10; /* 400ms */
 				else
-					vpts += 90000*3/10; /* 300ms */
+					vpts += 90000 * 3 / 10; /* 300ms */
 #endif
 #if USE_CLUTTER
 				/* no idea why there's a difference between OpenGL and clutter rendering... */
 				if (v_format == VIDEO_FORMAT_MPEG2)
-					vpts += 90000*3/10; /* 300ms */
+					vpts += 90000 * 3 / 10; /* 300ms */
 #endif
 				f->pts(vpts);
 				AVRational a = av_guess_sample_aspect_ratio(avfc, avfc->streams[0], frame);
@@ -628,41 +662,44 @@
 				buf_in++;
 				buf_in %= VDEC_MAXBUFS;
 				buf_num++;
-				if (buf_num > (VDEC_MAXBUFS - 1)) {
+				if (buf_num > (VDEC_MAXBUFS - 1))
+				{
 					hal_debug("%s: buf_num overflow\n", __func__);
 					buf_out++;
 					buf_out %= VDEC_MAXBUFS;
 					buf_num--;
 				}
-				dec_r = c->time_base.den/(c->time_base.num * c->ticks_per_frame);
+				dec_r = c->time_base.den / (c->time_base.num * c->ticks_per_frame);
 				buf_m.unlock();
 			}
 			hal_debug("%s: time_base: %d/%d, ticks: %d rate: %d pts 0x%" PRIx64 "\n", __func__,
-					c->time_base.num, c->time_base.den, c->ticks_per_frame, dec_r,
+			    c->time_base.num, c->time_base.den, c->ticks_per_frame, dec_r,
 #if (LIBAVUTIL_VERSION_MAJOR < 54)
-					av_frame_get_best_effort_timestamp(frame));
+			    av_frame_get_best_effort_timestamp(frame));
 #else
-					frame->best_effort_timestamp);
+			    frame->best_effort_timestamp);
 #endif
-		} else
+		}
+		else
 			hal_debug("%s: got_frame: %d stillpicture: %d\n", __func__, got_frame, stillpicture);
 		still_m.unlock();
 		av_packet_unref(&avpkt);
 	}
 	sws_freeContext(convert);
- out2:
+out2:
 	avcodec_close(c);
 	av_free(c);
 	av_frame_free(&frame);
 	av_frame_free(&rgbframe);
- out:
+out:
 	avformat_close_input(&avfc);
 	av_free(pIOCtx->buffer);
 	av_free(pIOCtx);
 	/* reset output buffers */
 	bufpos = 0;
 	still_m.lock();
-	if (!stillpicture) {
+	if (!stillpicture)
+	{
 		buf_num = 0;
 		buf_in = 0;
 		buf_out = 0;
@@ -677,50 +714,57 @@
 	int len = 0;
 	struct SwsContext *scale = NULL;
 	scale = sws_getCachedContext(scale, sw, sh, sfmt, dw, dh, AV_PIX_FMT_RGB32, SWS_BICUBIC, 0, 0, 0);
-	if (!scale) {
+	if (!scale)
+	{
 		hal_info_c("%s: ERROR setting up SWS context\n", __func__);
 		return ret;
 	}
 	AVFrame *sframe = av_frame_alloc();
 	AVFrame *dframe = av_frame_alloc();
-	if (sframe && dframe) {
+	if (sframe && dframe)
+	{
 		len = av_image_fill_arrays(sframe->data, sframe->linesize, &(src)[0], sfmt, sw, sh, 1);
-		if(len>-1)
+		if (len > -1)
 			ret = true;
 
-		if(ret && (len = av_image_fill_arrays(dframe->data, dframe->linesize, &(dst)[0], AV_PIX_FMT_RGB32, dw, dh, 1)<0))
+		if (ret && (len = av_image_fill_arrays(dframe->data, dframe->linesize, &(dst)[0], AV_PIX_FMT_RGB32, dw, dh, 1) < 0))
 			ret = false;
 
-		if(ret && (len = sws_scale(scale, sframe->data, sframe->linesize, 0, sh, dframe->data, dframe->linesize)<0))
+		if (ret && (len = sws_scale(scale, sframe->data, sframe->linesize, 0, sh, dframe->data, dframe->linesize) < 0))
 			ret = false;
 		else
 			ret = true;
-	}else{
+	}
+	else
+	{
 		hal_info_c("%s: could not alloc sframe (%p) or dframe (%p)\n", __func__, sframe, dframe);
 		ret = false;
 	}
 
-	if(sframe){
+	if (sframe)
+	{
 		av_frame_free(&sframe);
 		sframe = NULL;
 	}
-	if(dframe){
+	if (dframe)
+	{
 		av_frame_free(&dframe);
 		dframe = NULL;
 	}
-	if(scale){
+	if (scale)
+	{
 		sws_freeContext(scale);
 		scale = NULL;
 	}
-	hal_info_c("%s: %s scale %ix%i to %ix%i ,len %i\n",ret?" ":"ERROR",__func__, sw, sh, dw, dh,len);
+	hal_info_c("%s: %s scale %ix%i to %ix%i ,len %i\n", ret ? " " : "ERROR", __func__, sw, sh, dw, dh, len);
 
 	return ret;
 }
 
-bool cVideo::GetScreenImage(unsigned char * &data, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
+bool cVideo::GetScreenImage(unsigned char*&data, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
 {
 	hal_info("%s: data 0x%p xres %d yres %d vid %d osd %d scale %d\n",
-		__func__, data, xres, yres, get_video, get_osd, scale_to_video);
+	    __func__, data, xres, yres, get_video, get_osd, scale_to_video);
 	SWFramebuffer video;
 	std::vector<unsigned char> *osd = NULL;
 	std::vector<unsigned char> s_osd; /* scaled OSD */
@@ -729,13 +773,15 @@
 	int osd_h = glfb_priv->getOSDHeight();
 	xres = osd_w;
 	yres = osd_h;
-	if (get_video) {
+	if (get_video)
+	{
 		buf_m.lock();
 		video = buffers[buf_out];
 		buf_m.unlock();
 		vid_w = video.width();
 		vid_h = video.height();
-		if (scale_to_video || !get_osd) {
+		if (scale_to_video || !get_osd)
+		{
 			xres = vid_w;
 			yres = vid_h;
 			AVRational a = video.AR();
@@ -744,8 +790,9 @@
 				xres = vid_w * a.num / a.den;
 		}
 	}
-	if(video.empty()){
-		get_video=false;
+	if (video.empty())
+	{
+		get_video = false;
 		xres = osd_w;
 		yres = osd_h;
 	}
@@ -753,53 +800,66 @@
 		osd = glfb_priv->getOSDBuffer();
 	unsigned int need = av_image_get_buffer_size(AV_PIX_FMT_RGB32, xres, yres, 1);
 	data = (unsigned char *)realloc(data, need); /* will be freed by caller */
-	if (data == NULL)	/* out of memory? */
+	if (data == NULL)   /* out of memory? */
 		return false;
 
-	if (get_video) {
+	if (get_video)
+	{
 #if USE_OPENGL //memcpy dont work with copy BGR24 to RGB32
-		if (vid_w != xres || vid_h != yres){ /* scale video into data... */
+		if (vid_w != xres || vid_h != yres)  /* scale video into data... */
+		{
 #endif
-			bool ret = swscale(&video[0], data, vid_w, vid_h, xres, yres,VDEC_PIXFMT);
-			if(!ret){
+			bool ret = swscale(&video[0], data, vid_w, vid_h, xres, yres, VDEC_PIXFMT);
+			if (!ret)
+			{
 				free(data);
 				return false;
 			}
 #if USE_OPENGL //memcpy dont work with copy BGR24 to RGB32
-		}else{ /* get_video and no fancy scaling needed */
+		}
+		else   /* get_video and no fancy scaling needed */
+		{
 			memcpy(data, &video[0], xres * yres * sizeof(uint32_t));
 		}
 #endif
 	}
 
-	if (get_osd && (osd_w != xres || osd_h != yres)) {
+	if (get_osd && (osd_w != xres || osd_h != yres))
+	{
 		/* rescale osd */
 		s_osd.resize(need);
-		bool ret = swscale(&(*osd)[0], &s_osd[0], osd_w, osd_h, xres, yres,AV_PIX_FMT_RGB32);
-		if(!ret){
+		bool ret = swscale(&(*osd)[0], &s_osd[0], osd_w, osd_h, xres, yres, AV_PIX_FMT_RGB32);
+		if (!ret)
+		{
 			free(data);
 			return false;
 		}
 		osd = &s_osd;
 	}
 
-	if (get_video && get_osd) {
+	if (get_video && get_osd)
+	{
 		/* alpha blend osd onto data (video). TODO: maybe libavcodec can do this? */
 		uint32_t *d = (uint32_t *)data;
-		uint32_t *pixpos = (uint32_t *)&(*osd)[0];
-		for (int count = 0; count < yres; count++) {
-			for (int count2 = 0; count2 < xres; count2++ ) {
+		uint32_t *pixpos = (uint32_t *) & (*osd)[0];
+		for (int count = 0; count < yres; count++)
+		{
+			for (int count2 = 0; count2 < xres; count2++)
+			{
 				uint32_t pix = *pixpos;
 				if ((pix & 0xff000000) == 0xff000000)
 					*d = pix;
-				else {
+				else
+				{
 					uint8_t *in = (uint8_t *)(pixpos);
 					uint8_t *out = (uint8_t *)d;
-					int a = in[3];	/* TODO: big/little endian? */
+					int a = in[3];  /* TODO: big/little endian? */
 					*out = (*out + ((*in - *out) * a) / 256);
-					in++; out++;
+					in++;
+					out++;
 					*out = (*out + ((*in - *out) * a) / 256);
-					in++; out++;
+					in++;
+					out++;
 					*out = (*out + ((*in - *out) * a) / 256);
 				}
 				d++;
diff -Nur libstb-hal-ddt.git.orig/libgeneric-pc/video_lib.h libstb-hal-ddt.git/libgeneric-pc/video_lib.h
--- libstb-hal-ddt.git.orig/libgeneric-pc/video_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libgeneric-pc/video_lib.h	2022-07-23 18:18:31.535772387 +0200
@@ -11,7 +11,8 @@
 #include <libavutil/rational.h>
 }
 
-typedef enum {
+typedef enum
+{
 	ANALOG_SD_RGB_CINCH = 0x00,
 	ANALOG_SD_YPRPB_CINCH,
 	ANALOG_HD_RGB_CINCH,
@@ -23,7 +24,8 @@
 	ANALOG_SCART_MASK = 0x10
 } analog_mode_t;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_FORMAT_MPEG2 = 0,
 	VIDEO_FORMAT_MPEG4_H264,
 	VIDEO_FORMAT_VC1,
@@ -34,7 +36,8 @@
 	VIDEO_FORMAT_AVS = 16
 } VIDEO_FORMAT;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_SD = 0,
 	VIDEO_HD,
 	VIDEO_120x60i,
@@ -43,7 +46,8 @@
 	VIDEO_360x288i
 } VIDEO_DEFINITION;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_FRAME_RATE_23_976 = 0,
 	VIDEO_FRAME_RATE_24,
 	VIDEO_FRAME_RATE_25,
@@ -54,29 +58,31 @@
 	VIDEO_FRAME_RATE_60
 } VIDEO_FRAME_RATE;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_1_1,
 	DISPLAY_AR_4_3,
-	DISPLAY_AR_14_9,
 	DISPLAY_AR_16_9,
 	DISPLAY_AR_20_9,
 	DISPLAY_AR_RAW
 } DISPLAY_AR;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_MODE_PANSCAN = 0,
 	DISPLAY_AR_MODE_LETTERBOX,
-	DISPLAY_AR_MODE_NONE,
-	DISPLAY_AR_MODE_PANSCAN2
+	DISPLAY_AR_MODE_NONE
 } DISPLAY_AR_MODE;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_DB_DR_NEITHER = 0,
 	VIDEO_DB_ON,
 	VIDEO_DB_DR_BOTH
 } VIDEO_DB_DR;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_PLAY_STILL = 0,
 	VIDEO_PLAY_CLIP,
 	VIDEO_PLAY_TRICK,
@@ -84,7 +90,8 @@
 	VIDEO_PLAY_MOTION_NO_SYNC
 } VIDEO_PLAY_MODE;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_STD_NTSC,
 	VIDEO_STD_SECAM,
 	VIDEO_STD_PAL,
@@ -98,12 +105,13 @@
 	VIDEO_STD_1080P24,
 	VIDEO_STD_1080P25,
 	VIDEO_STD_AUTO,
-	VIDEO_STD_1080P50,	/* SPARK only */
+	VIDEO_STD_1080P50,  /* SPARK only */
 	VIDEO_STD_MAX
 } VIDEO_STD;
 
 /* not used, for dummy functions */
-typedef enum {
+typedef enum
+{
 	VIDEO_HDMI_CEC_MODE_OFF = 0,
 	VIDEO_HDMI_CEC_MODE_TUNER,
 	VIDEO_HDMI_CEC_MODE_RECORDER
@@ -111,6 +119,13 @@
 
 typedef enum
 {
+	VIDEO_HDMI_CEC_VOL_OFF = 0,
+	VIDEO_HDMI_CEC_VOL_AUDIOSYSTEM = 1,
+	VIDEO_HDMI_CEC_VOL_TV = 2
+} VIDEO_HDMI_CEC_VOL;
+
+typedef enum
+{
 	VIDEO_CONTROL_BRIGHTNESS = 0,
 	VIDEO_CONTROL_CONTRAST,
 	VIDEO_CONTROL_SATURATION,
@@ -123,27 +138,51 @@
 #define VDEC_MAXBUFS 0x40
 class cVideo : public OpenThreads::Thread
 {
-	friend class GLFbPC;
-	friend class cDemux;
+		friend class GLFbPC;
+		friend class cDemux;
 	private:
 		/* called from GL thread */
 		class SWFramebuffer : public std::vector<unsigned char>
 		{
-		public:
-			SWFramebuffer() : mWidth(0), mHeight(0) {}
-			void width(int w) { mWidth = w; }
-			void height(int h) { mHeight = h; }
-			void pts(uint64_t p) { mPts = p; }
-			void AR(AVRational a) { mAR = a; }
-			int width() const { return mWidth; }
-			int height() const { return mHeight; }
-			int64_t pts() const { return mPts; }
-			AVRational AR() const { return mAR; }
-		private:
-			int mWidth;
-			int mHeight;
-			int64_t mPts;
-			AVRational mAR;
+			public:
+				SWFramebuffer() : mWidth(0), mHeight(0) {}
+				void width(int w)
+				{
+					mWidth = w;
+				}
+				void height(int h)
+				{
+					mHeight = h;
+				}
+				void pts(uint64_t p)
+				{
+					mPts = p;
+				}
+				void AR(AVRational a)
+				{
+					mAR = a;
+				}
+				int width() const
+				{
+					return mWidth;
+				}
+				int height() const
+				{
+					return mHeight;
+				}
+				int64_t pts() const
+				{
+					return mPts;
+				}
+				AVRational AR() const
+				{
+					return mAR;
+				}
+			private:
+				int mWidth;
+				int mHeight;
+				int64_t mPts;
+				AVRational mAR;
 		};
 		int buf_in, buf_out, buf_num;
 		int64_t GetPTS(void);
@@ -152,8 +191,16 @@
 		cVideo(int mode, void *, void *, unsigned int unit = 0);
 		~cVideo(void);
 
-		void * GetTVEnc() { return NULL; };
-		void * GetTVEncSD() { return NULL; };
+		void setAVInput(int val) { return; };
+
+		void *GetTVEnc()
+		{
+			return NULL;
+		};
+		void *GetTVEncSD()
+		{
+			return NULL;
+		};
 
 		/* aspect ratio */
 		int getAspectRatio(void);
@@ -180,27 +227,61 @@
 		bool Pause(void);
 
 		int SetStreamType(VIDEO_FORMAT type);
-		void ShowPicture(const char * fname);
+		bool ShowPicture(const char *fname);
 
 		void SetSyncMode(AVSYNC_TYPE mode);
-		bool SetCECMode(VIDEO_HDMI_CEC_MODE) { return true; };
-		void SetCECAutoView(bool) { return; };
-		void SetCECAutoStandby(bool) { return; };
+		bool SetCECMode(VIDEO_HDMI_CEC_MODE)
+		{
+			return true;
+		};
+		void SetCECAutoView(bool)
+		{
+			return;
+		};
+		void SetCECAutoStandby(bool)
+		{
+			return;
+		};
+		int  GetAudioDestination()
+		{
+			return 0;
+		};
+		void SetAudioDestination(int audio_dest) { };
 		void StopPicture();
 		void Standby(unsigned int bOn);
 		void Pig(int x, int y, int w, int h, int osd_w = 1064, int osd_h = 600, int startx = 0, int starty = 0, int endx = 1279, int endy = 719);
-		void SetControl(int, int) { return; };
+		void SetControl(int, int)
+		{
+			return;
+		};
 		void setContrast(int val);
 		void SetVideoMode(analog_mode_t mode);
-		void SetDBDR(int) { return; };
-		void SetAudioHandle(void *) { return; };
-		void SetAutoModes(int [VIDEO_STD_MAX]) { return; };
-		int  OpenVBI(int) { return 0; };
-		int  CloseVBI(void) { return 0; };
-		int  StartVBI(unsigned short) { return 0; };
-		int  StopVBI(void) { return 0; };
+		void SetDBDR(int)
+		{
+			return;
+		};
+		void SetAudioHandle(void *)
+		{
+			return;
+		};
+		int  OpenVBI(int)
+		{
+			return 0;
+		};
+		int  CloseVBI(void)
+		{
+			return 0;
+		};
+		int  StartVBI(unsigned short)
+		{
+			return 0;
+		};
+		int  StopVBI(void)
+		{
+			return 0;
+		};
 		void SetDemux(cDemux *dmx);
-		bool GetScreenImage(unsigned char * &data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
+		bool GetScreenImage(unsigned char*&data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
 		SWFramebuffer *getDecBuf(void);
 	private:
 		void run();
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/audio.cpp libstb-hal-ddt.git/libmipsbox/audio.cpp
--- libstb-hal-ddt.git.orig/libmipsbox/audio.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libmipsbox/audio.cpp	2022-07-23 18:18:31.499773109 +0200
@@ -8,23 +8,58 @@
 
 #include <linux/dvb/audio.h>
 
+#include <hardware_caps.h>
 #include <proc_tools.h>
 
 #include "audio_lib.h"
 #include "hal_debug.h"
-#include <config.h>
 
-#define AUDIO_DEVICE	"/dev/dvb/adapter0/audio0"
 #define hal_debug(args...) _hal_debug(HAL_DEBUG_AUDIO, this, args)
 #define hal_info(args...) _hal_info(HAL_DEBUG_AUDIO, this, args)
 
+#define fop(cmd, args...) ({                \
+    int _r;                     \
+    if (fd >= 0) {                  \
+        if ((_r = ::cmd(fd, args)) < 0)     \
+            hal_info(#cmd"(fd, "#args")\n");\
+        else                    \
+            hal_debug(#cmd"(fd, "#args")\n");\
+    }                       \
+    else { _r = fd; }               \
+    _r;                     \
+})
+
 #include <linux/soundcard.h>
 
-cAudio * audioDecoder = NULL;
+enum
+{
+	ENCODER,
+	AUX
+};
+
+cAudio *audioDecoder = NULL;
+cAudio *pipAudioDecoder[3] = { NULL, NULL, NULL };
 
-cAudio::cAudio(void *, void *, void *)
+static const char *ADEV[] =
 {
+	"/dev/dvb/adapter0/audio0",
+	"/dev/dvb/adapter0/audio1",
+	"/dev/dvb/adapter0/audio2",
+	"/dev/dvb/adapter0/audio3"
+};
+
+cAudio::cAudio(void *, void *, void *, unsigned int unit)
+{
+	hw_caps_t *hwcaps = get_hwcaps();
+	if (unit > (unsigned int) hwcaps->pip_devs)
+	{
+		hal_info("%s: unit %d out of range, setting to 0\n", __func__, unit);
+		devnum = 0;
+	}
+	else
+		devnum = unit;
 	fd = -1;
+	fdd = false;
 	clipfd = -1;
 	mixer_fd = -1;
 	openDevice();
@@ -40,7 +75,7 @@
 {
 	if (fd < 0)
 	{
-		if ((fd = open(AUDIO_DEVICE, O_RDWR)) < 0)
+		if ((fd = open(ADEV[devnum], O_RDWR)) < 0)
 			hal_info("openDevice: open failed (%m)\n");
 		fcntl(fd, F_SETFD, FD_CLOEXEC);
 		//do_mute(true, false);
@@ -51,20 +86,70 @@
 
 void cAudio::closeDevice(void)
 {
-	if (fd > -1) {
+	if (fd > -1)
+	{
 		close(fd);
 		fd = -1;
 	}
-	if (clipfd > -1) {
+	if (clipfd > -1)
+	{
 		close(clipfd);
 		clipfd = -1;
 	}
-	if (mixer_fd > -1) {
+	if (mixer_fd > -1)
+	{
 		close(mixer_fd);
 		mixer_fd = -1;
 	}
 }
 
+#ifndef AUDIO_SOURCE_HDMI
+#define AUDIO_SOURCE_HDMI 2
+#endif
+
+void cAudio::open_AVInput_Device(void)
+{
+	hal_debug("%s\n", __func__);
+
+	if (fdd) /* already open */
+		return;
+
+	fop(ioctl, AUDIO_SELECT_SOURCE, AUDIO_SOURCE_HDMI);
+	fop(ioctl, AUDIO_PLAY);
+	fdd = true;
+}
+
+void cAudio::close_AVInput_Device(void)
+{
+	hal_debug("%s\n", __func__);
+
+	if (fdd)
+	{
+		fop(ioctl, AUDIO_STOP);
+	}
+	fdd = false;
+}
+
+void cAudio::setAVInput(int val)
+{
+	hal_info("%s - switching to: %s\n", __func__, val == AUX ? "AUX" : "ENCODER");
+
+	if (val == AUX)
+	{
+		Stop();
+		open_AVInput_Device();
+	}
+	else
+	{
+		if (fdd)
+		{
+			close_AVInput_Device();
+			fop(ioctl, AUDIO_SELECT_SOURCE, AUDIO_SOURCE_DEMUX);
+			Start();
+		}
+	}
+}
+
 int cAudio::do_mute(bool enable, bool remember)
 {
 	hal_debug("%s(%d, %d)\n", __FUNCTION__, enable, remember);
@@ -157,39 +242,12 @@
 	ioctl(fd, AUDIO_SET_AV_SYNC, Mode);
 }
 
-#define AUDIO_STREAMTYPE_AC3	0
-#define AUDIO_STREAMTYPE_MPEG	1
-#define AUDIO_STREAMTYPE_DTS	2
-#define AUDIO_STREAMTYPE_AAC	8
-#define AUDIO_STREAMTYPE_AACHE	9
-
-void cAudio::SetStreamType(AUDIO_FORMAT type)
-{
-	int bypass = AUDIO_STREAMTYPE_MPEG;
-	hal_debug("%s %d\n", __FUNCTION__, type);
-	StreamType = type;
+void cAudio::SetStreamType(int bypass)
+{
+	StreamType = bypass;
 
-	switch (type)
-	{
-		case AUDIO_FMT_DD_PLUS:
-		case AUDIO_FMT_DOLBY_DIGITAL:
-			bypass = AUDIO_STREAMTYPE_AC3;
-			break;
-		case AUDIO_FMT_AAC:
-			bypass = AUDIO_STREAMTYPE_AAC;
-			break;
-		case AUDIO_FMT_AAC_PLUS:
-			bypass = AUDIO_STREAMTYPE_AACHE;
-			break;
-		case AUDIO_FMT_DTS:
-			bypass = AUDIO_STREAMTYPE_DTS;
-			break;
-		default:
-			break;
-	}
+	hal_info("%s %d (0x%x)\n", __FUNCTION__, bypass, bypass);
 
-	// Normaly the encoding should be set using AUDIO_SET_ENCODING
-	// But as we implemented the behavior to bypass (cause of e2) this is correct here
 	if (ioctl(fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
 		hal_info("%s: AUDIO_SET_BYPASS_MODE failed (%m)\n", __func__);
 }
@@ -207,7 +265,8 @@
 	const char *dsp_dev = getenv("DSP_DEVICE");
 	const char *mix_dev = getenv("MIX_DEVICE");
 	hal_info("cAudio::%s ch %d srate %d bits %d le %d\n", __FUNCTION__, ch, srate, bits, little_endian);
-	if (clipfd > -1) {
+	if (clipfd > -1)
+	{
 		hal_info("%s: clipfd already opened (%d)\n", __func__, clipfd);
 		return -1;
 	}
@@ -221,22 +280,25 @@
 	 *   export MIX_DEVICE=/dev/sound/mixer2
 	 *   neutrino
 	 */
-	if ((!dsp_dev) || (access(dsp_dev, W_OK))) {
+	if ((!dsp_dev) || (access(dsp_dev, W_OK)))
+	{
 		if (dsp_dev)
 			hal_info("%s: DSP_DEVICE is set (%s) but cannot be opened,"
-				" fall back to /dev/dsp\n", __func__, dsp_dev);
+			    " fall back to /dev/dsp\n", __func__, dsp_dev);
 		dsp_dev = "/dev/dsp";
 	}
-	if ((!mix_dev) || (access(mix_dev, W_OK))) {
+	if ((!mix_dev) || (access(mix_dev, W_OK)))
+	{
 		if (mix_dev)
 			hal_info("%s: MIX_DEVICE is set (%s) but cannot be opened,"
-					" fall back to /dev/mixer\n", __func__, dsp_dev);
+			    " fall back to /dev/mixer\n", __func__, dsp_dev);
 		mix_dev = "/dev/mixer";
 	}
 	hal_info("cAudio::%s: dsp_dev %s mix_dev %s\n", __func__, dsp_dev, mix_dev); /* NULL mix_dev is ok */
 	/* the tdoss dsp driver seems to work only on the second open(). really. */
 	clipfd = open(dsp_dev, O_WRONLY);
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s open %s: %m\n", dsp_dev, __FUNCTION__);
 		return -1;
 	}
@@ -261,42 +323,50 @@
 		return 0;
 
 	mixer_fd = open(mix_dev, O_RDWR);
-	if (mixer_fd < 0) {
+	if (mixer_fd < 0)
+	{
 		hal_info("%s: open mixer %s failed (%m)\n", __func__, mix_dev);
 		/* not a real error */
 		return 0;
 	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_DEVMASK, &devmask) == -1) {
+	if (ioctl(mixer_fd, SOUND_MIXER_READ_DEVMASK, &devmask) == -1)
+	{
 		hal_info("%s: SOUND_MIXER_READ_DEVMASK %m\n", __func__);
 		devmask = 0;
 	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_STEREODEVS, &stereo) == -1) {
+	if (ioctl(mixer_fd, SOUND_MIXER_READ_STEREODEVS, &stereo) == -1)
+	{
 		hal_info("%s: SOUND_MIXER_READ_STEREODEVS %m\n", __func__);
 		stereo = 0;
 	}
 	usable = devmask & stereo;
-	if (usable == 0) {
+	if (usable == 0)
+	{
 		hal_info("%s: devmask: %08x stereo: %08x, no usable dev :-(\n",
-			__func__, devmask, stereo);
+		    __func__, devmask, stereo);
 		close(mixer_fd);
 		mixer_fd = -1;
 		return 0; /* TODO: should we treat this as error? */
 	}
 	/* __builtin_popcount needs GCC, it counts the set bits... */
-	if (__builtin_popcount (usable) != 1) {
+	if (__builtin_popcount(usable) != 1)
+	{
 		/* TODO: this code is not yet tested as I have only single-mixer devices... */
 		hal_info("%s: more than one mixer control: devmask %08x stereo %08x\n"
-			"%s: querying MIX_NUMBER environment variable...\n",
-			__func__, devmask, stereo, __func__);
+		    "%s: querying MIX_NUMBER environment variable...\n",
+		    __func__, devmask, stereo, __func__);
 		const char *tmp = getenv("MIX_NUMBER");
 		if (tmp)
 			mixer_num = atoi(tmp);
 		hal_info("%s: mixer_num is %d -> device %08x\n",
-			__func__, mixer_num, (mixer_num >= 0) ? (1 << mixer_num) : 0);
+		    __func__, mixer_num, (mixer_num >= 0) ? (1 << mixer_num) : 0);
 		/* no error checking, you'd better know what you are doing... */
-	} else {
+	}
+	else
+	{
 		mixer_num = 0;
-		while (!(usable & 0x01)) {
+		while (!(usable & 0x01))
+		{
 			mixer_num++;
 			usable >>= 1;
 		}
@@ -308,9 +378,10 @@
 
 int cAudio::WriteClip(unsigned char *buffer, int size)
 {
-	int ret, __attribute__ ((unused)) count = 1;
+	int ret, __attribute__((unused)) count = 1;
 	// hal_debug("cAudio::%s\n", __FUNCTION__);
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
 		return -1;
 	}
@@ -318,12 +389,14 @@
 again:
 #endif
 	ret = write(clipfd, buffer, size);
-	if (ret < 0) {
+	if (ret < 0)
+	{
 		hal_info("%s: write error (%m)\n", __FUNCTION__);
 		return ret;
 	}
 #if BOXMODEL_BRE2ZE4K || BOXMODEL_HD51 || BOXMODEL_H7
-	if (ret != size) {
+	if (ret != size)
+	{
 		hal_info("cAudio::%s: difference > to write (%d) != written (%d) try (%d) > reset dsp and restart write\n", __FUNCTION__, size, ret, count);
 		if (ioctl(clipfd, SNDCTL_DSP_RESET))
 			perror("SNDCTL_DSP_RESET");
@@ -339,7 +412,8 @@
 {
 	hal_info("cAudio::%s\n", __FUNCTION__);
 
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
 		return -1;
 	}
@@ -348,7 +422,8 @@
 #endif
 	close(clipfd);
 	clipfd = -1;
-	if (mixer_fd > -1) {
+	if (mixer_fd > -1)
+	{
 		close(mixer_fd);
 		mixer_fd = -1;
 	}
@@ -376,24 +451,24 @@
 
 	type = atype;
 #if 0
-/* this does not work, some of the values are negative?? */
+	/* this does not work, some of the values are negative?? */
 	AMPEGStatus A;
 	memcpy(&A, &i.word00, sizeof(i.word00));
 	layer   = A.audio_mpeg_layer;
 	mode    = A.audio_mpeg_mode;
 	bitrate = A.audio_mpeg_bitrate;
-	switch(A.audio_mpeg_frequency)
+	switch (A.audio_mpeg_frequency)
 #endif
-	/* layer and bitrate are not used anyway... */
-	layer   = 0; //(i.word00 >> 17) & 3;
+		/* layer and bitrate are not used anyway... */
+		layer   = 0; //(i.word00 >> 17) & 3;
 	bitrate = 0; //(i.word00 >> 12) & 3;
 	switch (type)
 	{
-		case 0:	/* MPEG */
+		case 0: /* MPEG */
 			mode = (i.word00 >> 6) & 3;
 			freq = freq_mpg[(i.word00 >> 10) & 3];
 			break;
-		case 1:	/* AC3 */
+		case 1: /* AC3 */
 			mode = (i.word00 >> 28) & 7;
 			freq = freq_ac3[(i.word00 >> 16) & 3];
 			break;
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/audio_lib.h libstb-hal-ddt.git/libmipsbox/audio_lib.h
--- libstb-hal-ddt.git.orig/libmipsbox/audio_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libmipsbox/audio_lib.h	2022-07-23 18:18:31.499773109 +0200
@@ -4,6 +4,7 @@
 #define __AUDIO_LIB_H__
 
 #include "cs_types.h"
+#include <config.h>
 
 typedef enum
 {
@@ -12,44 +13,29 @@
 	AUDIO_SYNC_AUDIO_MASTER
 } AUDIO_SYNC_MODE;
 
-typedef enum {
+typedef enum
+{
 	HDMI_ENCODED_OFF,
 	HDMI_ENCODED_AUTO,
 	HDMI_ENCODED_FORCED
 } HDMI_ENCODED_MODE;
 
-typedef enum
-{
-	AUDIO_FMT_AUTO = 0,
-	AUDIO_FMT_MPEG,
-	AUDIO_FMT_MP3,
-	AUDIO_FMT_DOLBY_DIGITAL,
-	AUDIO_FMT_BASIC = AUDIO_FMT_DOLBY_DIGITAL,
-	AUDIO_FMT_AAC,
-	AUDIO_FMT_AAC_PLUS,
-	AUDIO_FMT_DD_PLUS,
-	AUDIO_FMT_DTS,
-	AUDIO_FMT_AVS,
-	AUDIO_FMT_MLP,
-	AUDIO_FMT_WMA,
-	AUDIO_FMT_MPG1, // TD only. For Movieplayer / cPlayback
-	AUDIO_FMT_ADVANCED = AUDIO_FMT_MLP
-} AUDIO_FORMAT;
-
 class mixerVolume;
 
 class cAudio
 {
-	friend class cPlayback;
+		friend class cPlayback;
 	private:
 		int fd;
+		bool fdd;
+		unsigned int devnum;
 		bool Muted;
 
 		int clipfd; /* for pcm playback */
 		int mixer_fd;  /* if we are using the OSS mixer */
 		int mixer_num; /* oss mixer to use, if any */
 
-		AUDIO_FORMAT	StreamType;
+		int StreamType;
 		AUDIO_SYNC_MODE    SyncMode;
 		bool started;
 
@@ -57,41 +43,67 @@
 
 		int do_mute(bool enable, bool remember);
 		void setBypassMode(bool disable);
-
 	public:
 		/* construct & destruct */
-		cAudio(void *, void *, void *);
+		cAudio(void *, void *, void *, unsigned int unit = 0);
 		~cAudio(void);
 
+		/* used internally by playback */
 		void openDevice(void);
 		void closeDevice(void);
 
-		void *GetHandle() { return NULL; };
+		void open_AVInput_Device(void);
+		void close_AVInput_Device(void);
+
+		void setAVInput(int val);
+
+		void *GetHandle()
+		{
+			return NULL;
+		};
 		/* shut up */
-		int mute(bool remember = true) { return do_mute(true, remember); };
-		int unmute(bool remember = true) { return do_mute(false, remember); };
+		int mute(bool remember = true)
+		{
+			return do_mute(true, remember);
+		};
+		int unmute(bool remember = true)
+		{
+			return do_mute(false, remember);
+		};
 
 		/* volume, min = 0, max = 255 */
 		int setVolume(unsigned int left, unsigned int right);
-		int getVolume(void) { return volume;}
-		bool getMuteStatus(void) { return Muted; };
+		int getVolume(void)
+		{
+			return volume;
+		}
+		bool getMuteStatus(void)
+		{
+			return Muted;
+		};
 
 		/* start and stop audio */
 		int Start(void);
 		int Stop(void);
 		bool Pause(bool Pcm = true);
-		void SetStreamType(AUDIO_FORMAT type);
-		AUDIO_FORMAT GetStreamType(void) { return StreamType; }
+		void SetStreamType(int bypass);
+		int GetStreamType(void)
+		{
+			return StreamType;
+		}
 		void SetSyncMode(AVSYNC_TYPE Mode);
 
 		/* select channels */
 		int setChannel(int channel);
 		int PrepareClipPlay(int uNoOfChannels, int uSampleRate, int uBitsPerSample, int bLittleEndian);
-		int WriteClip(unsigned char * buffer, int size);
+		int WriteClip(unsigned char *buffer, int size);
 		int StopClip();
-		void getAudioInfo(int &type, int &layer, int& freq, int &bitrate, int &mode);
+		void getAudioInfo(int &type, int &layer, int &freq, int &bitrate, int &mode);
 		void SetSRS(int iq_enable, int nmgr_enable, int iq_mode, int iq_level);
-		bool IsHdmiDDSupported() { return true; };
+		bool IsHdmiDDSupported()
+		{
+			return true;
+		};
 		void SetHdmiDD(bool enable);
 		void SetSpdifDD(bool enable);
 		void ScheduleMute(bool On);
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/dmx.cpp libstb-hal-ddt.git/libmipsbox/dmx.cpp
--- libstb-hal-ddt.git.orig/libmipsbox/dmx.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libmipsbox/dmx.cpp	2022-07-23 18:18:31.499773109 +0200
@@ -50,15 +50,19 @@
 #define hal_debug_z(args...) _hal_debug(HAL_DEBUG_DEMUX, thiz, args)
 
 #define dmx_err(_errfmt, _errstr, _revents) do { \
-	hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
-		__func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
+    hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
+        __func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
 } while(0);
 
 cDemux *videoDemux = NULL;
 cDemux *audioDemux = NULL;
 //cDemux *pcrDemux = NULL;
 
-static const char *DMX_T[] = {
+cDemux *pipVideoDemux[3] = { NULL, NULL, NULL };
+cDemux *pipAudioDemux[3] = { NULL, NULL, NULL };
+
+static const char *DMX_T[] =
+{
 	"DMX_INVALID",
 	"DMX_VIDEO",
 	"DMX_AUDIO",
@@ -74,7 +78,7 @@
 #if BOXMODEL_VUULTIMO4K
 #define NUM_DEMUX 24
 #else
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 #define NUM_DEMUX 16
 #else
 #define NUM_DEMUX 4
@@ -84,65 +88,44 @@
 #if BOXMODEL_VUULTIMO4K
 static int dmx_source[NUM_DEMUX] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 #else
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 static int dmx_source[NUM_DEMUX] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
 #else
 static int dmx_source[NUM_DEMUX] = { 0, 0, 0, 0 };
 #endif
 #endif
 
+char dmxdev[32];
+static char *devname(int adapter, int demux)
+{
+	snprintf(dmxdev, sizeof(dmxdev), "/dev/dvb/adapter%d/demux%d", adapter, demux);
+	return dmxdev;
+}
+
 /* map the device numbers. */
 #if BOXMODEL_VUULTIMO4K
 #define NUM_DEMUXDEV 24
 #else
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 #define NUM_DEMUXDEV 16
 #else
 #define NUM_DEMUXDEV 8
 #endif
 #endif
-static const char *devname[NUM_DEMUXDEV] = {
-	"/dev/dvb/adapter0/demux0",
-	"/dev/dvb/adapter0/demux1",
-	"/dev/dvb/adapter0/demux2",
-	"/dev/dvb/adapter0/demux3",
-	"/dev/dvb/adapter0/demux4",
-	"/dev/dvb/adapter0/demux5",
-	"/dev/dvb/adapter0/demux6",
-	"/dev/dvb/adapter0/demux7"
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
-	, "/dev/dvb/adapter0/demux8"
-	, "/dev/dvb/adapter0/demux9"
-	, "/dev/dvb/adapter0/demux10"
-	, "/dev/dvb/adapter0/demux11"
-	, "/dev/dvb/adapter0/demux12"
-	, "/dev/dvb/adapter0/demux13"
-	, "/dev/dvb/adapter0/demux14"
-	, "/dev/dvb/adapter0/demux15"
-#if BOXMODEL_VUULTIMO4K
-	, "/dev/dvb/adapter0/demux16"
-	, "/dev/dvb/adapter0/demux17"
-	, "/dev/dvb/adapter0/demux18"
-	, "/dev/dvb/adapter0/demux19"
-	, "/dev/dvb/adapter0/demux20"
-	, "/dev/dvb/adapter0/demux21"
-	, "/dev/dvb/adapter0/demux22"
-	, "/dev/dvb/adapter0/demux23"
-#endif
-#endif
-};
+
 /* did we already DMX_SET_SOURCE on that demux device? */
 #if BOXMODEL_VUULTIMO4K
 static bool init[NUM_DEMUXDEV] = { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false };
 #else
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 static bool init[NUM_DEMUXDEV] = { false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false };
 #else
 static bool init[NUM_DEMUXDEV] = { false, false, false, false, false, false, false, false };
 #endif
 #endif
 
-typedef struct dmx_pdata {
+typedef struct dmx_pdata
+{
 	int last_source;
 	OpenThreads::Mutex *mutex;
 } dmx_pdata;
@@ -190,31 +173,33 @@
 
 static bool _open(cDemux *thiz, int num, int &fd, int &last_source, DMX_CHANNEL_TYPE dmx_type, int buffersize)
 {
-	int flags = O_RDWR|O_CLOEXEC;
+	int flags = O_RDWR | O_CLOEXEC;
 	int devnum = dmx_source[num];
-	if (last_source == devnum) {
+	if (last_source == devnum)
+	{
 		hal_debug_z("%s #%d: source (%d) did not change\n", __func__, num, last_source);
 		if (fd > -1)
 			return true;
 	}
-	if (fd > -1) {
+	if (fd > -1)
+	{
 		/* we changed source -> close and reopen the fd */
 		hal_debug_z("%s #%d: FD ALREADY OPENED fd = %d lastsource %d devnum %d\n",
-				__func__, num, fd, last_source, devnum);
+		    __func__, num, fd, last_source, devnum);
 		close(fd);
 	}
 
 	if (dmx_type != DMX_PSI_CHANNEL)
 		flags |= O_NONBLOCK;
 
-	fd = open(devname[devnum], flags);
+	fd = open(devname(0, devnum), flags);
 	if (fd < 0)
 	{
-		hal_info_z("%s %s: %m\n", __FUNCTION__, devname[devnum]);
+		hal_info_z("%s %s: %m\n", __FUNCTION__, devname(0, devnum));
 		return false;
 	}
 	hal_debug_z("%s #%d pes_type: %s(%d), uBufferSize: %d fd: %d\n", __func__,
-		 num, DMX_T[dmx_type], dmx_type, buffersize, fd);
+	    num, DMX_T[dmx_type], dmx_type, buffersize, fd);
 
 	/* this would actually need locking, but the worst that weill happen is, that
 	 * we'll DMX_SET_SOURCE twice per device, so don't bother... */
@@ -222,7 +207,7 @@
 	{
 		/* this should not change anything... */
 		int n = DMX_SOURCE_FRONT0 + devnum;
-		hal_info_z("%s: setting %s to source %d\n", __func__, devname[devnum], n);
+		hal_info_z("%s: setting %s to source %d\n", __func__, devname(0, devnum), n);
 		if (ioctl(fd, DMX_SET_SOURCE, &n) < 0)
 			hal_info_z("%s DMX_SET_SOURCE failed!\n", __func__);
 		else
@@ -285,7 +270,7 @@
 #if 0
 	if (len != 4095 && timeout != 10)
 		fprintf(stderr, "cDemux::%s #%d fd: %d type: %s len: %d timeout: %d\n",
-			__FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
+		    __FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
 #endif
 	if (fd < 0)
 	{
@@ -298,7 +283,7 @@
 	int to = timeout;
 	struct pollfd ufds;
 	ufds.fd = fd;
-	ufds.events = POLLIN|POLLPRI|POLLERR;
+	ufds.events = POLLIN | POLLPRI | POLLERR;
 	ufds.revents = 0;
 
 	/* hack: if the frontend loses and regains lock, the demuxer often will not
@@ -309,7 +294,7 @@
 
 	if (to > 0)
 	{
- retry:
+retry:
 		rc = ::poll(&ufds, 1, to);
 		if (ufds.fd != fd)
 		{
@@ -354,8 +339,9 @@
 			return 0;
 		}
 	}
-	if (ufds.fd != fd)	/* does this ever happen? and if, is it harmful? */
-	{			/* read(-1,...) will just return EBADF anyway... */
+	if (ufds.fd != fd)  /* does this ever happen? and if, is it harmful? */
+	{
+		/* read(-1,...) will just return EBADF anyway... */
 		hal_info("%s:2 ========== fd has changed, %d->%d ==========\n", __func__, ufds.fd, fd);
 		return -1;
 	}
@@ -368,9 +354,9 @@
 	return rc;
 }
 
-bool cDemux::sectionFilter(unsigned short _pid, const unsigned char * const filter,
-			   const unsigned char * const mask, int len, int timeout,
-			   const unsigned char * const negmask)
+bool cDemux::sectionFilter(unsigned short _pid, const unsigned char *const filter,
+    const unsigned char *const mask, int len, int timeout,
+    const unsigned char *const negmask)
 {
 	struct dmx_sct_filter_params s_flt;
 	memset(&s_flt, 0, sizeof(s_flt));
@@ -391,7 +377,7 @@
 	if (negmask != NULL)
 		memcpy(s_flt.filter.mode, negmask, len);
 
-	s_flt.flags = DMX_IMMEDIATE_START|DMX_CHECK_CRC;
+	s_flt.flags = DMX_IMMEDIATE_START | DMX_CHECK_CRC;
 
 	int to = 0;
 	switch (filter[0])
@@ -476,13 +462,22 @@
 		s_flt.timeout = to;
 
 	hal_debug("%s #%d pid:0x%04hx fd:%d type:%s len:%d to:%d flags:%x flt[0]:%02x\n", __func__, num,
-		pid, fd, DMX_T[dmx_type], len, s_flt.timeout, s_flt.flags, s_flt.filter.filter[0]);
-#if 0
-	fprintf(stderr,"filt: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.filter[i]); fprintf(stderr, "\n");
-	fprintf(stderr,"mask: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mask  [i]); fprintf(stderr, "\n");
-	fprintf(stderr,"mode: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mode  [i]); fprintf(stderr, "\n");
-#endif
-	ioctl (fd, DMX_STOP);
+	    pid, fd, DMX_T[dmx_type], len, s_flt.timeout, s_flt.flags, s_flt.filter.filter[0]);
+
+	if (debuglevel == 2)
+	{
+		fprintf(stderr, "filt: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.filter[i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mask: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mask  [i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mode: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mode  [i]);
+		fprintf(stderr, "\n");
+	}
+
+	ioctl(fd, DMX_STOP);
 	if (ioctl(fd, DMX_SET_FILTER, &s_flt) < 0)
 		return false;
 
@@ -498,7 +493,7 @@
 	 * this check originally is from tuxbox cvs but I'm not sure
 	 * what it is good for...
 	if (pid <= 0x0001 && dmx_type != DMX_PCR_ONLY_CHANNEL)
-		return false;
+	    return false;
 	 */
 	if ((pid >= 0x0002 && pid <= 0x000f) || pid >= 0x1fff)
 		return false;
@@ -509,31 +504,50 @@
 
 	memset(&p_flt, 0, sizeof(p_flt));
 	p_flt.pid    = pid;
-	p_flt.output = DMX_OUT_DECODER;
 	p_flt.input  = DMX_IN_FRONTEND;
+	p_flt.output = DMX_OUT_DECODER;
 	p_flt.flags  = 0;
 
 	switch (dmx_type)
 	{
-		case DMX_PCR_ONLY_CHANNEL:
-			p_flt.pes_type = DMX_PES_PCR;
-			break;
-		case DMX_AUDIO_CHANNEL:
-			p_flt.pes_type = DMX_PES_AUDIO;
-			break;
 		case DMX_VIDEO_CHANNEL:
-			p_flt.pes_type = DMX_PES_VIDEO;
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_VIDEO0; break;
+				case 1: p_flt.pes_type = DMX_PES_VIDEO1; break;
+				case 2: p_flt.pes_type = DMX_PES_VIDEO2; break;
+				case 3: p_flt.pes_type = DMX_PES_VIDEO3; break;
+			}
 			break;
-		case DMX_PIP_CHANNEL: /* PIP is a special version of DMX_VIDEO_CHANNEL */
-			p_flt.pes_type = DMX_PES_VIDEO1;
+		case DMX_AUDIO_CHANNEL:
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_AUDIO0; break;
+				case 1: p_flt.pes_type = DMX_PES_AUDIO1; break;
+				case 2: p_flt.pes_type = DMX_PES_AUDIO2; break;
+				case 3: p_flt.pes_type = DMX_PES_AUDIO3; break;
+			}
 			break;
 		case DMX_PES_CHANNEL:
 			p_flt.pes_type = DMX_PES_OTHER;
-			p_flt.output  = DMX_OUT_TAP;
+			p_flt.output   = DMX_OUT_TAP;
+			break;
+#if 0
+		case DMX_PSI_CHANNEL:
 			break;
+#endif
 		case DMX_TP_CHANNEL:
 			p_flt.pes_type = DMX_PES_OTHER;
-			p_flt.output  = DMX_OUT_TSDEMUX_TAP;
+			p_flt.output   = DMX_OUT_TSDEMUX_TAP;
+			break;
+		case DMX_PCR_ONLY_CHANNEL:
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_PCR0; break;
+				case 1: p_flt.pes_type = DMX_PES_PCR1; break;
+				case 2: p_flt.pes_type = DMX_PES_PCR2; break;
+				case 3: p_flt.pes_type = DMX_PES_PCR3; break;
+			}
 			break;
 		default:
 			hal_info("%s #%d invalid dmx_type %d!\n", __func__, num, dmx_type);
@@ -590,7 +604,8 @@
 	}
 	for (std::vector<pes_pids>::iterator i = pesfds.begin(); i != pesfds.end(); ++i)
 	{
-		if ((*i).pid == Pid) {
+		if ((*i).pid == Pid)
+		{
 			hal_debug("removePid: removing demux fd %d pid 0x%04x\n", fd, Pid);
 			if (ioctl(fd, DMX_REMOVE_PID, Pid) < 0)
 				hal_info("%s: (DMX_REMOVE_PID, 0x%04hx): %m\n", __func__, Pid);
@@ -601,7 +616,7 @@
 	hal_info("%s pid 0x%04x not found\n", __FUNCTION__, Pid);
 }
 
-void cDemux::getSTC(int64_t * STC)
+void cDemux::getSTC(int64_t *STC)
 {
 	/* apparently I can only get the PTS of the video decoder,
 	 * but that's good enough for dvbsub */
@@ -623,7 +638,8 @@
 
 bool cDemux::SetSource(int unit, int source)
 {
-	if (unit >= NUM_DEMUX || unit < 0) {
+	if (unit >= NUM_DEMUX || unit < 0)
+	{
 		hal_info_c("%s: unit (%d) out of range, NUM_DEMUX %d\n", __func__, unit, NUM_DEMUX);
 		return false;
 	}
@@ -637,7 +653,8 @@
 
 int cDemux::GetSource(int unit)
 {
-	if (unit >= NUM_DEMUX || unit < 0) {
+	if (unit >= NUM_DEMUX || unit < 0)
+	{
 		hal_info_c("%s: unit (%d) out of range, NUM_DEMUX %d\n", __func__, unit, NUM_DEMUX);
 		return -1;
 	}
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/hardware_caps.c libstb-hal-ddt.git/libmipsbox/hardware_caps.c
--- libstb-hal-ddt.git.orig/libmipsbox/hardware_caps.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libmipsbox/hardware_caps.c	2022-07-23 18:18:31.535772387 +0200
@@ -29,6 +29,12 @@
 
 	memset(&caps, 0, sizeof(hw_caps_t));
 
+	caps.pip_devs = 0;
+	if (access("/dev/dvb/adapter0/video1", F_OK) != -1) caps.pip_devs = 1;
+	if (access("/dev/dvb/adapter0/video2", F_OK) != -1) caps.pip_devs = 2;
+	if (access("/dev/dvb/adapter0/video3", F_OK) != -1) caps.pip_devs = 3;
+	if (caps.pip_devs > 0) caps.can_pip = 1;
+
 #if BOXMODEL_VUDUO
 	initialized = 1;
 	caps.has_CI = 2;
@@ -42,9 +48,31 @@
 	caps.has_button_timer = 1;
 	caps.has_HDMI = 1;
 	caps.has_SCART = 1;
+//	caps.has_SCART_input = 1;
 	strcpy(caps.boxvendor, "VU+");
 	strcpy(caps.boxname, "DUO");
 	strcpy(caps.boxarch, "BCM7335");
 #endif
+#if BOXMODEL_DM8000
+	initialized = 1;
+	caps.has_CI = 4;
+	caps.can_cec = 0;
+	caps.can_shutdown = 1;
+	caps.display_xres = 400;
+	caps.display_yres = 240;
+	caps.display_type = HW_DISPLAY_GFX;
+	caps.display_can_deepstandby = 1;
+	caps.display_can_set_brightness = 1;
+	caps.display_has_statusline = 1;
+	caps.display_has_colon = 0;
+	caps.has_button_timer = 1;
+	caps.has_HDMI = 1;          // wrong (has only DVI), only for testing
+	caps.has_SCART = 2;
+//	caps.has_SCART_input = 1;
+//	caps.has_DVI = 1;
+	strcpy(caps.boxvendor, "DM");
+	strcpy(caps.boxname, "8000HD");
+	strcpy(caps.boxarch, "BCM7400D2");
+#endif
 	return &caps;
 }
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/hdmi_cec.cpp libstb-hal-ddt.git/libmipsbox/hdmi_cec.cpp
--- libstb-hal-ddt.git.orig/libmipsbox/hdmi_cec.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libmipsbox/hdmi_cec.cpp	2022-07-23 18:18:31.499773109 +0200
@@ -1,26 +1,26 @@
 /*
-	Copyright (C) 2018 TangoCash
+    Copyright (C) 2018-2021 TangoCash
 
-	License: GPLv2
+    License: GPLv2
 
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation;
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation;
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include <fcntl.h>
 #include <sys/ioctl.h>
 #include <sys/mman.h>
-#include <sys/poll.h>
+#include <sys/epoll.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -28,6 +28,7 @@
 #include <errno.h>
 #include <ctype.h>
 
+#include <array>
 #include <cstring>
 #include <cstdio>
 #include <cstdlib>
@@ -40,38 +41,51 @@
 #include "hal_debug.h"
 
 #define RED "\x1B[31m"
+#define GREEN "\x1B[32m"
 #define NORMAL "\x1B[0m"
 
+#define EPOLL_WAIT_TIMEOUT (-1)
+#define EPOLL_MAX_EVENTS (1)
+
 #define hal_debug(args...) _hal_debug(HAL_DEBUG_INIT, this, args)
 #define hal_info(args...) _hal_info(HAL_DEBUG_INIT, this, args)
 #define hal_debug_c(args...) _hal_debug(HAL_DEBUG_INIT, NULL, args)
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_INIT, NULL, args)
 
-#define fop(cmd, args...) ({				\
-	int _r;						\
-	if (fd >= 0) { 					\
-		if ((_r = ::cmd(fd, args)) < 0)		\
-			hal_info(#cmd"(fd, "#args")\n");	\
-		else					\
-			hal_debug(#cmd"(fd, "#args")\n");\
-	}						\
-	else { _r = fd; } 				\
-	_r;						\
+#define fop(cmd, args...) ({                \
+    int _r;                     \
+    if (fd >= 0) {                  \
+        if ((_r = ::cmd(fd, args)) < 0)     \
+            hal_info(#cmd"(fd, "#args")\n");    \
+        else                    \
+            hal_debug(#cmd"(fd, "#args")\n");\
+    }                       \
+    else { _r = fd; }               \
+    _r;                     \
 })
 
-#define CEC_DEVICE "/dev/cec0"
+#define CEC_FALLBACK_DEVICE "/dev/cec0"
+#define CEC_HDMIDEV "/dev/hdmi_cec"
+#if BOXMODEL_H7
+#define RC_DEVICE  "/dev/input/event2"
+#else
 #define RC_DEVICE  "/dev/input/event1"
+#endif
 
-hdmi_cec * hdmi_cec::hdmi_cec_instance = NULL;
+hdmi_cec *hdmi_cec::hdmi_cec_instance = NULL;
 
 //hack to get an instance before first call
-hdmi_cec * CEC = hdmi_cec::getInstance();
+hdmi_cec *CEC = hdmi_cec::getInstance();
 
 hdmi_cec::hdmi_cec()
 {
 	standby_cec_activ = autoview_cec_activ = standby = muted = false;
 	hdmiFd = -1;
 	volume = 0;
+	fallback = false;
+	tv_off = true;
+	deviceType = CEC_LOG_ADDR_TYPE_UNREGISTERED;
+	audio_destination = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
 }
 
 hdmi_cec::~hdmi_cec()
@@ -83,12 +97,12 @@
 	}
 }
 
-hdmi_cec* hdmi_cec::getInstance()
+hdmi_cec *hdmi_cec::getInstance()
 {
 	if (hdmi_cec_instance == NULL)
 	{
 		hdmi_cec_instance = new hdmi_cec();
-		hal_debug_c("[CEC] new instance created \n");
+		hal_info_c(GREEN "[CEC] new instance created \n" NORMAL);
 	}
 	return hdmi_cec_instance;
 }
@@ -102,91 +116,111 @@
 	if (_deviceType == VIDEO_HDMI_CEC_MODE_OFF)
 	{
 		Stop();
-		hal_debug("[CEC] switch off %s\n", __func__);
+		hal_info(GREEN "[CEC] switch off %s\n" NORMAL, __func__);
 		return false;
 	}
 	else
 		deviceType = _deviceType;
 
-	hal_debug("[CEC] switch on %s\n", __func__);
+	hal_info(GREEN "[CEC] switch on %s\n" NORMAL, __func__);
 
+#if BOXMODEL_VUPLUS_ALL
 	if (hdmiFd == -1)
 	{
-		hdmiFd = open(CEC_DEVICE, O_RDWR | O_CLOEXEC);
+		hdmiFd = ::open(CEC_HDMIDEV, O_RDWR | O_NONBLOCK | O_CLOEXEC);
+		if (hdmiFd >= 0)
+		{
+			::ioctl(hdmiFd, 0); /* flush old messages */
+		}
 	}
+#endif
 
-	if (hdmiFd >= 0)
+	if (hdmiFd == -1)
 	{
-		__u32 monitor = CEC_MODE_INITIATOR | CEC_MODE_FOLLOWER;
-		struct cec_caps caps = {};
+		hdmiFd = open(CEC_FALLBACK_DEVICE, O_RDWR | O_CLOEXEC);
 
-		if (ioctl(hdmiFd, CEC_ADAP_G_CAPS, &caps) < 0)
-			hal_debug("[CEC] %s: get caps failed (%m)\n", __func__);
-
-		if (caps.capabilities & CEC_CAP_LOG_ADDRS)
+		if (hdmiFd >= 0)
 		{
-			struct cec_log_addrs laddrs = {};
+			fallback = true;
+#if BOXMODEL_VUPLUS_ALL
+			hal_info(RED "[CEC] fallback on %s\n" NORMAL, __func__);
+#endif
 
-			if (ioctl(hdmiFd, CEC_ADAP_S_LOG_ADDRS, &laddrs) < 0)
-				hal_debug("[CEC] %s: reset log addr failed (%m)\n", __func__);
+			__u32 monitor = CEC_MODE_INITIATOR | CEC_MODE_FOLLOWER;
+			struct cec_caps caps = {};
 
-			memset(&laddrs, 0, sizeof(laddrs));
+			if (ioctl(hdmiFd, CEC_ADAP_G_CAPS, &caps) < 0)
+				hal_info(RED "[CEC] %s: get caps failed (%m)\n" NORMAL, __func__);
 
-			/*
-			 * NOTE: cec_version, osd_name and deviceType should be made configurable,
-			 * CEC_ADAP_S_LOG_ADDRS delayed till the desired values are available
-			 * (saves us some startup speed as well, polling for a free logical address
-			 * takes some time)
-			 */
-			laddrs.cec_version = CEC_OP_CEC_VERSION_2_0;
-			strcpy(laddrs.osd_name, "neutrino");
-			laddrs.vendor_id = CEC_VENDOR_ID_NONE;
-
-			switch (deviceType)
+			if (caps.capabilities & CEC_CAP_LOG_ADDRS)
 			{
-			case CEC_LOG_ADDR_TV:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_TV;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_TV;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_TV;
-				break;
-			case CEC_LOG_ADDR_RECORD_1:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_RECORD;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_RECORD;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_RECORD;
-				break;
-			case CEC_LOG_ADDR_TUNER_1:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_TUNER;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_TUNER;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_TUNER;
-				break;
-			case CEC_LOG_ADDR_PLAYBACK_1:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_PLAYBACK;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_PLAYBACK;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_PLAYBACK;
-				break;
-			case CEC_LOG_ADDR_AUDIOSYSTEM:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_AUDIOSYSTEM;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
-				break;
-			default:
-				laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_UNREGISTERED;
-				laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_SWITCH;
-				laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_SWITCH;
-				break;
+				struct cec_log_addrs laddrs = {};
+
+				if (ioctl(hdmiFd, CEC_ADAP_S_LOG_ADDRS, &laddrs) < 0)
+					hal_info(RED "[CEC] %s: reset log addr failed (%m)\n" NORMAL, __func__);
+
+				memset(&laddrs, 0, sizeof(laddrs));
+
+				/*
+				 * NOTE: cec_version, osd_name and deviceType should be made configurable,
+				 * CEC_ADAP_S_LOG_ADDRS delayed till the desired values are available
+				 * (saves us some startup speed as well, polling for a free logical address
+				 * takes some time)
+				 */
+				laddrs.cec_version = CEC_OP_CEC_VERSION_2_0;
+				strcpy(laddrs.osd_name, "neutrino");
+				laddrs.vendor_id = CEC_VENDOR_ID_NONE;
+
+				switch (deviceType)
+				{
+					case CEC_LOG_ADDR_TV:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_TV;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_TV;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_TV;
+						break;
+					case CEC_LOG_ADDR_RECORD_1:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_RECORD;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_RECORD;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_RECORD;
+						break;
+					case CEC_LOG_ADDR_TUNER_1:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_TUNER;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_TUNER;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_TUNER;
+						break;
+					case CEC_LOG_ADDR_PLAYBACK_1:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_PLAYBACK;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_PLAYBACK;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_PLAYBACK;
+						break;
+					case CEC_LOG_ADDR_AUDIOSYSTEM:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_AUDIOSYSTEM;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
+						break;
+					default:
+						laddrs.log_addr_type[laddrs.num_log_addrs] = CEC_LOG_ADDR_TYPE_UNREGISTERED;
+						laddrs.all_device_types[laddrs.num_log_addrs] = CEC_OP_ALL_DEVTYPE_SWITCH;
+						laddrs.primary_device_type[laddrs.num_log_addrs] = CEC_OP_PRIM_DEVTYPE_SWITCH;
+						break;
+				}
+				laddrs.num_log_addrs++;
+
+				if (ioctl(hdmiFd, CEC_ADAP_S_LOG_ADDRS, &laddrs) < 0)
+					hal_info(RED "[CEC] %s: et log addr failed (%m)\n" NORMAL, __func__);
 			}
-			laddrs.num_log_addrs++;
 
-			if (ioctl(hdmiFd, CEC_ADAP_S_LOG_ADDRS, &laddrs) < 0)
-				hal_debug("[CEC] %s: et log addr failed (%m)\n", __func__);
-		}
+			if (ioctl(hdmiFd, CEC_S_MODE, &monitor) < 0)
+				hal_info(RED "[CEC] %s: monitor failed (%m)\n" NORMAL, __func__);
 
-		if (ioctl(hdmiFd, CEC_S_MODE, &monitor) < 0)
-			hal_debug("[CEC] %s: monitor failed (%m)\n", __func__);
+		}
+	}
 
+	if (hdmiFd >= 0)
+	{
 		GetCECAddressInfo();
 
-		if(autoview_cec_activ)
+		if (autoview_cec_activ)
 			SetCECState(false);
 
 		Start();
@@ -200,48 +234,62 @@
 {
 	if (hdmiFd >= 0)
 	{
+		bool hasdata = false;
 		struct addressinfo addressinfo;
 
-		__u16 phys_addr;
-		struct cec_log_addrs laddrs = {};
+		if (fallback)
+		{
+			__u16 phys_addr;
+			struct cec_log_addrs laddrs = {};
 
-		::ioctl(hdmiFd, CEC_ADAP_G_PHYS_ADDR, &phys_addr);
-		addressinfo.physical[0] = (phys_addr >> 8) & 0xff;
-		addressinfo.physical[1] = phys_addr & 0xff;
+			::ioctl(hdmiFd, CEC_ADAP_G_PHYS_ADDR, &phys_addr);
+			addressinfo.physical[0] = (phys_addr >> 8) & 0xff;
+			addressinfo.physical[1] = phys_addr & 0xff;
 
-		::ioctl(hdmiFd, CEC_ADAP_G_LOG_ADDRS, &laddrs);
-		addressinfo.logical = laddrs.log_addr[0];
+			::ioctl(hdmiFd, CEC_ADAP_G_LOG_ADDRS, &laddrs);
+			addressinfo.logical = laddrs.log_addr[0];
 
-		switch (laddrs.log_addr_type[0])
+			switch (laddrs.log_addr_type[0])
+			{
+				case CEC_LOG_ADDR_TYPE_TV:
+					addressinfo.type = CEC_LOG_ADDR_TV;
+					break;
+				case CEC_LOG_ADDR_TYPE_RECORD:
+					addressinfo.type = CEC_LOG_ADDR_RECORD_1;
+					break;
+				case CEC_LOG_ADDR_TYPE_TUNER:
+					addressinfo.type = CEC_LOG_ADDR_TUNER_1;
+					break;
+				case CEC_LOG_ADDR_TYPE_PLAYBACK:
+					addressinfo.type = CEC_LOG_ADDR_PLAYBACK_1;
+					break;
+				case CEC_LOG_ADDR_TYPE_AUDIOSYSTEM:
+					addressinfo.type = CEC_LOG_ADDR_AUDIOSYSTEM;
+					break;
+				case CEC_LOG_ADDR_TYPE_UNREGISTERED:
+				default:
+					addressinfo.type = CEC_LOG_ADDR_UNREGISTERED;
+					break;
+			}
+			hasdata = true;
+		}
+		else
 		{
-		case CEC_LOG_ADDR_TYPE_TV:
-			addressinfo.type = CEC_LOG_ADDR_TV;
-			break;
-		case CEC_LOG_ADDR_TYPE_RECORD:
-			addressinfo.type = CEC_LOG_ADDR_RECORD_1;
-			break;
-		case CEC_LOG_ADDR_TYPE_TUNER:
-			addressinfo.type = CEC_LOG_ADDR_TUNER_1;
-			break;
-		case CEC_LOG_ADDR_TYPE_PLAYBACK:
-			addressinfo.type = CEC_LOG_ADDR_PLAYBACK_1;
-			break;
-		case CEC_LOG_ADDR_TYPE_AUDIOSYSTEM:
-			addressinfo.type = CEC_LOG_ADDR_AUDIOSYSTEM;
-			break;
-		case CEC_LOG_ADDR_TYPE_UNREGISTERED:
-		default:
-			addressinfo.type = CEC_LOG_ADDR_UNREGISTERED;
-			break;
+			if (::ioctl(hdmiFd, 1, &addressinfo) >= 0)
+			{
+				hasdata = true;
+			}
 		}
-
-		deviceType = addressinfo.type;
-		logicalAddress = addressinfo.logical;
-		if (memcmp(physicalAddress, addressinfo.physical, sizeof(physicalAddress)))
+		if (hasdata)
 		{
-			hal_info("[CEC] %s: detected physical address change: %02X%02X --> %02X%02X\n", __func__, physicalAddress[0], physicalAddress[1], addressinfo.physical[0], addressinfo.physical[1]);
-			memcpy(physicalAddress, addressinfo.physical, sizeof(physicalAddress));
-			ReportPhysicalAddress();
+			deviceType = addressinfo.type;
+			logicalAddress = addressinfo.logical;
+			if (memcmp(physicalAddress, addressinfo.physical, sizeof(physicalAddress)))
+			{
+				hal_info(GREEN "[CEC] %s: detected physical address change: %02X%02X --> %02X%02X\n" NORMAL, __func__, physicalAddress[0], physicalAddress[1], addressinfo.physical[0], addressinfo.physical[1]);
+				memcpy(physicalAddress, addressinfo.physical, sizeof(physicalAddress));
+				ReportPhysicalAddress();
+			}
 		}
 	}
 }
@@ -259,21 +307,36 @@
 	SendCECMessage(txmessage);
 }
 
-void hdmi_cec::SendCECMessage(struct cec_message &txmessage)
+void hdmi_cec::SendCECMessage(struct cec_message &txmessage, int sleeptime)
 {
 	if (hdmiFd >= 0)
 	{
-		char str[txmessage.length*6];
+
+		char str[txmessage.length * 6];
 		for (int i = 0; i < txmessage.length; i++)
 		{
-			sprintf(str+(i*6),"[0x%02X]", txmessage.data[i]);
+			sprintf(str + (i * 6), "[0x%02X]", txmessage.data[i]);
 		}
-		hal_info("[CEC] send message %s to %s (0x%02X>>0x%02X) '%s' (%s)\n",ToString((cec_logical_address)txmessage.initiator), txmessage.destination == 0xf ? "all" : ToString((cec_logical_address)txmessage.destination), txmessage.initiator, txmessage.destination, ToString((cec_opcode)txmessage.data[0]), str);
-		struct cec_msg msg;
-		cec_msg_init(&msg, txmessage.initiator, txmessage.destination);
-		memcpy(&msg.msg[1], txmessage.data, txmessage.length);
-		msg.len = txmessage.length + 1;
-		ioctl(hdmiFd, CEC_TRANSMIT, &msg);
+		hal_info(GREEN "[CEC] send message %s to %s (0x%02X>>0x%02X) '%s' (%s)\n" NORMAL, ToString((cec_logical_address)txmessage.initiator), txmessage.destination == 0xf ? "all" : ToString((cec_logical_address)txmessage.destination), txmessage.initiator, txmessage.destination, ToString((cec_opcode)txmessage.data[0]), str);
+
+		if (fallback)
+		{
+			struct cec_msg msg;
+			cec_msg_init(&msg, txmessage.initiator, txmessage.destination);
+			memcpy(&msg.msg[1], txmessage.data, txmessage.length);
+			msg.len = txmessage.length + 1;
+			ioctl(hdmiFd, CEC_TRANSMIT, &msg);
+		}
+		else
+		{
+			struct cec_message_fb message;
+			message.address = txmessage.destination;
+			message.length = txmessage.length;
+			memcpy(&message.data, txmessage.data, txmessage.length);
+			::write(hdmiFd, &message, 2 + message.length);
+		}
+
+		usleep(sleeptime * 1000);
 	}
 }
 
@@ -300,23 +363,53 @@
 		message.data[0] = CEC_MSG_STANDBY;
 		message.length = 1;
 		SendCECMessage(message);
+
+		message.initiator = logicalAddress;
+		message.destination = CEC_OP_PRIM_DEVTYPE_TV;
+		message.data[0] = CEC_MSG_GIVE_DEVICE_POWER_STATUS;
+		message.length = 1;
+		SendCECMessage(message);
 	}
 
 	if ((autoview_cec_activ) && !state)
 	{
 		message.initiator = logicalAddress;
-		message.destination = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
-		message.data[0] = CEC_MSG_GIVE_SYSTEM_AUDIO_MODE_STATUS;
+		message.destination = CEC_OP_PRIM_DEVTYPE_TV;
+		message.data[0] = CEC_MSG_GET_CEC_VERSION;
 		message.length = 1;
 		SendCECMessage(message);
-		usleep(10000);
 
 		message.initiator = logicalAddress;
 		message.destination = CEC_OP_PRIM_DEVTYPE_TV;
-		message.data[0] = CEC_MSG_IMAGE_VIEW_ON;
+		message.data[0] = CEC_MSG_GIVE_DEVICE_POWER_STATUS;
 		message.length = 1;
 		SendCECMessage(message);
-		usleep(10000);
+
+#if BOXMODEL_VUPLUS_ALL
+		int cnt = 0;
+
+		while (tv_off && (cnt < 5))
+		{
+#endif
+
+			message.initiator = logicalAddress;
+			message.destination = CEC_OP_PRIM_DEVTYPE_TV;
+			message.data[0] = CEC_MSG_IMAGE_VIEW_ON;
+			message.length = 1;
+			SendCECMessage(message);
+
+			message.initiator = logicalAddress;
+			message.destination = CEC_OP_PRIM_DEVTYPE_TV;
+			message.data[0] = CEC_MSG_GIVE_DEVICE_POWER_STATUS;
+			message.length = 1;
+			SendCECMessage(message);
+
+#if BOXMODEL_VUPLUS_ALL
+			cnt++;
+		}
+#endif
+
+		GetCECAddressInfo();
 
 		message.initiator = logicalAddress;
 		message.destination = CEC_LOG_ADDR_BROADCAST;
@@ -325,7 +418,20 @@
 		message.data[2] = physicalAddress[1];
 		message.length = 3;
 		SendCECMessage(message);
-		usleep(10000);
+
+		message.initiator = logicalAddress;
+		message.destination = CEC_LOG_ADDR_BROADCAST;
+		message.data[0] = CEC_OPCODE_SET_OSD_NAME;
+		message.data[1] = 0x6e; //n
+		message.data[2] = 0x65; //e
+		message.data[3] = 0x75; //u
+		message.data[4] = 0x74; //t
+		message.data[5] = 0x72; //r
+		message.data[6] = 0x69; //i
+		message.data[7] = 0x6e; //n
+		message.data[8] = 0x6f; //o
+		message.length = 9;
+		SendCECMessage(message);
 
 		request_audio_status();
 	}
@@ -337,114 +443,114 @@
 	long key = 0;
 	switch (code)
 	{
-	case CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL:
-		key = KEY_MENU;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER0:
-		key = KEY_0;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER1:
-		key = KEY_1;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER2:
-		key = KEY_2;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER3:
-		key = KEY_3;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER4:
-		key = KEY_4;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER5:
-		key = KEY_5;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER6:
-		key = KEY_6;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER7:
-		key = KEY_7;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER8:
-		key = KEY_8;
-		break;
-	case CEC_USER_CONTROL_CODE_NUMBER9:
-		key = KEY_9;
-		break;
-	case CEC_USER_CONTROL_CODE_CHANNEL_UP:
-		key = KEY_CHANNELUP;
-		break;
-	case CEC_USER_CONTROL_CODE_CHANNEL_DOWN:
-		key = KEY_CHANNELDOWN;
-		break;
-	case CEC_USER_CONTROL_CODE_PLAY:
-		key = KEY_PLAY;
-		break;
-	case CEC_USER_CONTROL_CODE_STOP:
-		key = KEY_STOP;
-		break;
-	case CEC_USER_CONTROL_CODE_PAUSE:
-		key = KEY_PAUSE;
-		break;
-	case CEC_USER_CONTROL_CODE_RECORD:
-		key = KEY_RECORD;
-		break;
-	case CEC_USER_CONTROL_CODE_REWIND:
-		key = KEY_REWIND;
-		break;
-	case CEC_USER_CONTROL_CODE_FAST_FORWARD:
-		key = KEY_FASTFORWARD;
-		break;
-	case CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE:
-		key = KEY_INFO;
-		break;
-	case CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING:
-		key = KEY_PROGRAM;
-		break;
-	case CEC_USER_CONTROL_CODE_PLAY_FUNCTION:
-		key = KEY_PLAY;
-		break;
-	case CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION:
-		key = KEY_PLAYPAUSE;
-		break;
-	case CEC_USER_CONTROL_CODE_RECORD_FUNCTION:
-		key = KEY_RECORD;
-		break;
-	case CEC_USER_CONTROL_CODE_STOP_FUNCTION:
-		key = KEY_STOP;
-		break;
-	case CEC_USER_CONTROL_CODE_SELECT:
-		key = KEY_OK;
-		break;
-	case CEC_USER_CONTROL_CODE_LEFT:
-		key = KEY_LEFT;
-		break;
-	case CEC_USER_CONTROL_CODE_RIGHT:
-		key = KEY_RIGHT;
-		break;
-	case CEC_USER_CONTROL_CODE_UP:
-		key = KEY_UP;
-		break;
-	case CEC_USER_CONTROL_CODE_DOWN:
-		key = KEY_DOWN;
-		break;
-	case CEC_USER_CONTROL_CODE_EXIT:
-		key = KEY_EXIT;
-		break;
-	case CEC_USER_CONTROL_CODE_F2_RED:
-		key = KEY_RED;
-		break;
-	case CEC_USER_CONTROL_CODE_F3_GREEN:
-		key = KEY_GREEN;
-		break;
-	case CEC_USER_CONTROL_CODE_F4_YELLOW:
-		key = KEY_YELLOW;
-		break;
-	case CEC_USER_CONTROL_CODE_F1_BLUE:
-		key = KEY_BLUE;
-		break;
-	default:
-		key = KEY_MENU;
-		break;
+		case CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL:
+			key = KEY_MENU;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER0:
+			key = KEY_0;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER1:
+			key = KEY_1;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER2:
+			key = KEY_2;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER3:
+			key = KEY_3;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER4:
+			key = KEY_4;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER5:
+			key = KEY_5;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER6:
+			key = KEY_6;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER7:
+			key = KEY_7;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER8:
+			key = KEY_8;
+			break;
+		case CEC_USER_CONTROL_CODE_NUMBER9:
+			key = KEY_9;
+			break;
+		case CEC_USER_CONTROL_CODE_CHANNEL_UP:
+			key = KEY_CHANNELUP;
+			break;
+		case CEC_USER_CONTROL_CODE_CHANNEL_DOWN:
+			key = KEY_CHANNELDOWN;
+			break;
+		case CEC_USER_CONTROL_CODE_PLAY:
+			key = KEY_PLAY;
+			break;
+		case CEC_USER_CONTROL_CODE_STOP:
+			key = KEY_STOP;
+			break;
+		case CEC_USER_CONTROL_CODE_PAUSE:
+			key = KEY_PAUSE;
+			break;
+		case CEC_USER_CONTROL_CODE_RECORD:
+			key = KEY_RECORD;
+			break;
+		case CEC_USER_CONTROL_CODE_REWIND:
+			key = KEY_REWIND;
+			break;
+		case CEC_USER_CONTROL_CODE_FAST_FORWARD:
+			key = KEY_FASTFORWARD;
+			break;
+		case CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE:
+			key = KEY_INFO;
+			break;
+		case CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING:
+			key = KEY_PROGRAM;
+			break;
+		case CEC_USER_CONTROL_CODE_PLAY_FUNCTION:
+			key = KEY_PLAY;
+			break;
+		case CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION:
+			key = KEY_PLAYPAUSE;
+			break;
+		case CEC_USER_CONTROL_CODE_RECORD_FUNCTION:
+			key = KEY_RECORD;
+			break;
+		case CEC_USER_CONTROL_CODE_STOP_FUNCTION:
+			key = KEY_STOP;
+			break;
+		case CEC_USER_CONTROL_CODE_SELECT:
+			key = KEY_OK;
+			break;
+		case CEC_USER_CONTROL_CODE_LEFT:
+			key = KEY_LEFT;
+			break;
+		case CEC_USER_CONTROL_CODE_RIGHT:
+			key = KEY_RIGHT;
+			break;
+		case CEC_USER_CONTROL_CODE_UP:
+			key = KEY_UP;
+			break;
+		case CEC_USER_CONTROL_CODE_DOWN:
+			key = KEY_DOWN;
+			break;
+		case CEC_USER_CONTROL_CODE_EXIT:
+			key = KEY_EXIT;
+			break;
+		case CEC_USER_CONTROL_CODE_F2_RED:
+			key = KEY_RED;
+			break;
+		case CEC_USER_CONTROL_CODE_F3_GREEN:
+			key = KEY_GREEN;
+			break;
+		case CEC_USER_CONTROL_CODE_F4_YELLOW:
+			key = KEY_YELLOW;
+			break;
+		case CEC_USER_CONTROL_CODE_F1_BLUE:
+			key = KEY_BLUE;
+			break;
+		default:
+			key = KEY_MENU;
+			break;
 	}
 	return key;
 }
@@ -458,6 +564,7 @@
 		return false;
 
 	running = true;
+	OpenThreads::Thread::setSchedulePriority(THREAD_PRIORITY_MIN);
 	return (OpenThreads::Thread::start() == 0);
 }
 
@@ -467,7 +574,7 @@
 		return false;
 
 	running = false;
-	
+
 	OpenThreads::Thread::cancel();
 
 	if (hdmiFd >= 0)
@@ -482,90 +589,157 @@
 void hdmi_cec::run()
 {
 	OpenThreads::Thread::setCancelModeAsynchronous();
-	struct pollfd pfd;
+	int n;
+	int epollfd = epoll_create1(0);
+	struct epoll_event event;
+	event.data.fd = hdmiFd;
+	event.events = EPOLLIN;
+
+	epoll_ctl(epollfd, EPOLL_CTL_ADD, hdmiFd, &event);
 
-	pfd.fd = hdmiFd;
-	pfd.events = (POLLIN | POLLPRI);
+	std::array<struct epoll_event, EPOLL_MAX_EVENTS> events;
 
 	while (running)
 	{
-		if (poll(&pfd, 1, 0) > 0)
-			Receive();
+		n = epoll_wait(epollfd, events.data(), EPOLL_MAX_EVENTS, EPOLL_WAIT_TIMEOUT);
+		for (int i = 0; i < n; ++i)
+		{
+			if (events[i].events & EPOLLIN)
+				Receive(events[i].events);
+		}
 	}
 }
 
-void hdmi_cec::Receive()
+void hdmi_cec::Receive(int what)
 {
-	bool hasdata = false;
-	struct cec_message rxmessage;
-	struct cec_message txmessage;
-
-	struct cec_msg msg;
-	if (::ioctl(hdmiFd, CEC_RECEIVE, &msg) >= 0)
-	{
-		rxmessage.length = msg.len - 1;
-		rxmessage.initiator = cec_msg_initiator(&msg);
-		rxmessage.destination = cec_msg_destination(&msg);
-		rxmessage.opcode = cec_msg_opcode(&msg);
-		memcpy(&rxmessage.data, &msg.msg[1], rxmessage.length);
-		hasdata = true;
-	}
-
-	if (hasdata)
+	if (what & EPOLLIN)
 	{
-		bool keypressed = false;
-		static unsigned char pressedkey = 0;
 
-		char str[rxmessage.length*6];
-		for (int i = 0; i < rxmessage.length; i++)
-		{
-			sprintf(str+(i*6),"[0x%02X]", rxmessage.data[i]);
-		}
-		hal_info("[CEC] received message %s to %s (0x%02X>>0x%02X) '%s' (%s)\n",ToString((cec_logical_address)rxmessage.initiator), rxmessage.destination == 0xf ? "all" : ToString((cec_logical_address)rxmessage.destination), rxmessage.initiator, rxmessage.destination, ToString((cec_opcode)rxmessage.opcode), str);
+		bool hasdata = false;
+		struct cec_message rxmessage;
+		struct cec_message txmessage;
 
-		switch (rxmessage.opcode)
+		if (fallback)
 		{
-		case CEC_OPCODE_REPORT_AUDIO_STATUS:
-		{
-			muted = ((rxmessage.data[1] & 0x80) == 0x80);
-			volume = ((rxmessage.data[1] & 0x7F) / 127.0) * 100.0;
-			if (muted)
-				hal_debug("[CEC] %s volume muted\n", ToString((cec_logical_address)rxmessage.initiator));
-			else
-				hal_debug("[CEC] %s volume %d \n", ToString((cec_logical_address)rxmessage.initiator), volume);
-			break;
-		}
-		case CEC_OPCODE_DEVICE_VENDOR_ID:
-		case CEC_OPCODE_VENDOR_COMMAND_WITH_ID:
-		{
-			uint64_t iVendorId =	((uint64_t)rxmessage.data[1] << 16) +
-			                        ((uint64_t)rxmessage.data[2] << 8) +
-			                        (uint64_t)rxmessage.data[3];
-			hal_debug("[CEC] decoded message '%s' (%s)\n", ToString((cec_opcode)rxmessage.opcode), ToString((cec_vendor_id)iVendorId));
-			break;
+			struct cec_msg msg;
+			if (::ioctl(hdmiFd, CEC_RECEIVE, &msg) >= 0)
+			{
+				rxmessage.length = msg.len - 1;
+				rxmessage.initiator = cec_msg_initiator(&msg);
+				rxmessage.destination = cec_msg_destination(&msg);
+				rxmessage.opcode = cec_msg_opcode(&msg);
+				memcpy(&rxmessage.data, &msg.msg[1], rxmessage.length);
+				hasdata = true;
+			}
 		}
-		case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
+		else
 		{
-			txmessage.destination = rxmessage.initiator;
-			txmessage.initiator = rxmessage.destination;
-			txmessage.data[0] = GetResponseOpcode((cec_opcode)rxmessage.opcode);
-			txmessage.data[1] = standby ? CEC_POWER_STATUS_STANDBY : CEC_POWER_STATUS_ON;
-			txmessage.length = 2;
-			SendCECMessage(txmessage);
-			break;
+			struct cec_message_fb rx_message;
+			if (::read(hdmiFd, &rx_message, 2) == 2)
+			{
+				if (::read(hdmiFd, &rx_message.data, rx_message.length) == rx_message.length)
+				{
+					rxmessage.length = rx_message.length;
+					rxmessage.initiator = rx_message.address;
+					rxmessage.destination = logicalAddress;
+					rxmessage.opcode = rx_message.data[0];
+					memcpy(&rxmessage.data, rx_message.data, rx_message.length);
+					hasdata = true;
+				}
+			}
 		}
-		case CEC_OPCODE_USER_CONTROL_PRESSED: /* key pressed */
-		{
-			keypressed = true;
-			pressedkey = rxmessage.data[1];
-		} // fall through
-		case CEC_OPCODE_USER_CONTROL_RELEASE: /* key released */
+
+		if (hasdata)
 		{
-			long code = translateKey(pressedkey);
-			hal_debug("[CEC] decoded key %s (%ld)\n",ToString((cec_user_control_code)pressedkey), code);
-			handleCode(code,keypressed);
-			break;
-		}
+			bool keypressed = false;
+			static unsigned char pressedkey = 0;
+
+			char str[rxmessage.length * 6];
+			for (int i = 0; i < rxmessage.length; i++)
+			{
+				sprintf(str + (i * 6), "[0x%02X]", rxmessage.data[i]);
+			}
+			hal_info(GREEN "[CEC] received message %s to %s (0x%02X>>0x%02X) '%s' (%s)\n" NORMAL, ToString((cec_logical_address)rxmessage.initiator), rxmessage.destination == 0xf ? "all" : ToString((cec_logical_address)rxmessage.destination), rxmessage.initiator, rxmessage.destination, ToString((cec_opcode)rxmessage.opcode), str);
+
+			switch (rxmessage.opcode)
+			{
+				//case CEC_OPCODE_ACTIVE_SOURCE:
+				case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
+				{
+					txmessage.destination = CEC_LOG_ADDR_BROADCAST; //rxmessage.initiator;
+					txmessage.initiator = logicalAddress; //rxmessage.destination;
+					txmessage.data[0] = CEC_MSG_ACTIVE_SOURCE;
+					txmessage.data[1] = physicalAddress[0];
+					txmessage.data[2] = physicalAddress[1];
+					txmessage.length = 3;
+					if (!standby)
+						SendCECMessage(txmessage);
+					break;
+				}
+				case CEC_OPCODE_REPORT_AUDIO_STATUS:
+				{
+					muted = ((rxmessage.data[1] & 0x80) == 0x80);
+					volume = ((rxmessage.data[1] & 0x7F) / 127.0) * 100.0;
+					if (muted)
+						hal_info(GREEN "[CEC] %s volume muted\n" NORMAL, ToString((cec_logical_address)rxmessage.initiator));
+					else
+						hal_info(GREEN "[CEC] %s volume %d \n" NORMAL, ToString((cec_logical_address)rxmessage.initiator), volume);
+					break;
+				}
+				case CEC_OPCODE_DEVICE_VENDOR_ID:
+				case CEC_OPCODE_VENDOR_COMMAND_WITH_ID:
+				{
+					uint64_t iVendorId = ((uint64_t)rxmessage.data[1] << 16) +
+					    ((uint64_t)rxmessage.data[2] << 8) +
+					    (uint64_t)rxmessage.data[3];
+					hal_info(GREEN "[CEC] decoded message '%s' (%s)\n" NORMAL, ToString((cec_opcode)rxmessage.opcode), ToString((cec_vendor_id)iVendorId));
+					break;
+				}
+				case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
+				{
+					txmessage.destination = rxmessage.initiator;
+					txmessage.initiator = rxmessage.destination;
+					txmessage.data[0] = GetResponseOpcode((cec_opcode)rxmessage.opcode);
+					txmessage.data[1] = standby ? CEC_POWER_STATUS_STANDBY : CEC_POWER_STATUS_ON;
+					txmessage.length = 2;
+					SendCECMessage(txmessage);
+					break;
+				}
+				case CEC_OPCODE_REPORT_POWER_STATUS:
+				{
+					if ((rxmessage.data[1] == CEC_POWER_STATUS_ON) || (rxmessage.data[1] == CEC_POWER_STATUS_IN_TRANSITION_STANDBY_TO_ON))
+					{
+						hal_info(GREEN "[CEC] %s reporting state on (%d)\n" NORMAL, ToString((cec_logical_address)rxmessage.initiator), rxmessage.data[1]);
+						if (rxmessage.initiator == CEC_OP_PRIM_DEVTYPE_TV)
+							tv_off = false;
+					}
+					else
+					{
+						hal_info(GREEN "[CEC] %s reporting state off (%d)\n" NORMAL, ToString((cec_logical_address)rxmessage.initiator), rxmessage.data[1]);
+						if (rxmessage.initiator == CEC_OP_PRIM_DEVTYPE_TV)
+							tv_off = true;
+					}
+					break;
+				}
+				case CEC_OPCODE_STANDBY:
+				{
+					if (rxmessage.initiator == CEC_OP_PRIM_DEVTYPE_TV)
+						tv_off = true;
+					break;
+				}
+				case CEC_OPCODE_USER_CONTROL_PRESSED: /* key pressed */
+				{
+					keypressed = true;
+					pressedkey = rxmessage.data[1];
+				} // fall through
+				case CEC_OPCODE_USER_CONTROL_RELEASE: /* key released */
+				{
+					long code = translateKey(pressedkey);
+					hal_info(GREEN "[CEC] decoded key %s (%ld)\n" NORMAL, ToString((cec_user_control_code)pressedkey), code);
+					handleCode(code, keypressed);
+					break;
+				}
+			}
 		}
 	}
 }
@@ -575,14 +749,14 @@
 	int evd = open(RC_DEVICE, O_RDWR);
 	if (evd < 0)
 	{
-		hal_debug("[CEC] opening " RC_DEVICE " failed");
+		hal_info(RED "[CEC] opening " RC_DEVICE " failed" NORMAL);
 		return;
 	}
 	if (keypressed)
 	{
 		if (rc_send(evd, code, CEC_KEY_PRESSED) < 0)
 		{
-			hal_debug("[CEC] writing 'KEY_PRESSED' event failed");
+			hal_info(RED "[CEC] writing 'KEY_PRESSED' event failed" NORMAL);
 			close(evd);
 			return;
 		}
@@ -592,7 +766,7 @@
 	{
 		if (rc_send(evd, code, CEC_KEY_RELEASED) < 0)
 		{
-			hal_debug("[CEC] writing 'KEY_RELEASED' event failed");
+			hal_info(RED "[CEC] writing 'KEY_RELEASED' event failed" NORMAL);
 			close(evd);
 			return;
 		}
@@ -630,41 +804,52 @@
 	txmessage.data[0] = CEC_OPCODE_USER_CONTROL_PRESSED;
 	txmessage.data[1] = key;
 	txmessage.length = 2;
-	SendCECMessage(txmessage);
-	usleep(10000);
+	SendCECMessage(txmessage, 1);
 
 	txmessage.destination = destination;
 	txmessage.initiator = logicalAddress;
 	txmessage.data[0] = CEC_OPCODE_USER_CONTROL_RELEASE;
 	txmessage.length = 1;
-	SendCECMessage(txmessage);
+	SendCECMessage(txmessage, 0);
 }
 
 void hdmi_cec::request_audio_status()
 {
 	struct cec_message txmessage;
-	txmessage.destination = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
+	txmessage.destination = audio_destination;
 	txmessage.initiator = logicalAddress;
 	txmessage.data[0] = CEC_OPCODE_GIVE_AUDIO_STATUS;
 	txmessage.length = 1;
-	SendCECMessage(txmessage);
+	SendCECMessage(txmessage, 0);
 }
 
 void hdmi_cec::vol_up()
 {
-	send_key(CEC_USER_CONTROL_CODE_VOLUME_UP, CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM);
-	usleep(50000);
+	send_key(CEC_USER_CONTROL_CODE_VOLUME_UP, audio_destination);
 	request_audio_status();
 }
 void hdmi_cec::vol_down()
 {
-	send_key(CEC_USER_CONTROL_CODE_VOLUME_DOWN, CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM);
-	usleep(50000);
+	send_key(CEC_USER_CONTROL_CODE_VOLUME_DOWN, audio_destination);
 	request_audio_status();
 }
 void hdmi_cec::toggle_mute()
 {
-	send_key(CEC_USER_CONTROL_CODE_MUTE, CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM);
-	usleep(50000);
+	send_key(CEC_USER_CONTROL_CODE_MUTE, audio_destination);
 	request_audio_status();
 }
+
+void hdmi_cec::SetAudioDestination(int audio_dest)
+{
+	switch (audio_dest)
+	{
+		case 2:
+			audio_destination = CEC_OP_PRIM_DEVTYPE_TV;
+			break;
+		case 1:
+		default:
+			audio_destination = CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM;
+			break;
+	}
+}
+
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/hdmi_cec.h libstb-hal-ddt.git/libmipsbox/hdmi_cec.h
--- libstb-hal-ddt.git.orig/libmipsbox/hdmi_cec.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libmipsbox/hdmi_cec.h	2022-07-23 18:18:31.499773109 +0200
@@ -2,22 +2,22 @@
 #define __HDMI_CEC_H__
 
 /*
-	Copyright (C) 2018 TangoCash
+    Copyright (C) 2018-2021 TangoCash
 
-	License: GPLv2
+    License: GPLv2
 
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation;
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation;
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include <OpenThreads/Thread>
@@ -34,6 +34,13 @@
 	unsigned char length;
 } __attribute__((packed));
 
+struct cec_message_fb
+{
+	unsigned char address;
+	unsigned char length;
+	unsigned char data[256];
+} __attribute__((packed));
+
 struct addressinfo
 {
 	unsigned char logical;
@@ -50,50 +57,58 @@
 
 class hdmi_cec : public OpenThreads::Thread
 {
-private:
-	hdmi_cec();
-	static hdmi_cec *hdmi_cec_instance;
-	void run();
-	bool Start();
-	bool Stop();
-	void Receive();
-	unsigned char physicalAddress[2];
-	bool autoview_cec_activ;
-	unsigned char deviceType, logicalAddress;
-	int hdmiFd;
-	long translateKey(unsigned char code);
-	void handleCode(long code, bool keypressed);
-	int rc_send(int fd, unsigned int code, unsigned int value);
-	void rc_sync(int fd);
-	bool standby;
-	void send_key(unsigned char key, unsigned char destination);
-	void request_audio_status();
-	bool muted;
-	int volume;
-protected:
-	bool running;
-public:
-	~hdmi_cec();
-	static hdmi_cec* getInstance();
-	bool SetCECMode(VIDEO_HDMI_CEC_MODE);
-	void SetCECAutoView(bool);
-	void SetCECAutoStandby(bool);
-	void GetCECAddressInfo();
-	void SendCECMessage(struct cec_message &message);
-	void SetCECState(bool state);
-	void ReportPhysicalAddress();
-	bool standby_cec_activ;
-	void vol_up();
-	void vol_down();
-	void toggle_mute();
-	int GetVolume()
-	{
-		return volume;
-	};
-	bool isMuted()
-	{
-		return muted;
-	};
+	private:
+		hdmi_cec();
+		static hdmi_cec *hdmi_cec_instance;
+		void run();
+		bool Start();
+		bool Stop();
+		void Receive(int what);
+		unsigned char physicalAddress[2];
+		bool autoview_cec_activ;
+		unsigned char deviceType, logicalAddress;
+		int hdmiFd;
+		long translateKey(unsigned char code);
+		void handleCode(long code, bool keypressed);
+		int rc_send(int fd, unsigned int code, unsigned int value);
+		void rc_sync(int fd);
+		bool standby;
+		void send_key(unsigned char key, unsigned char destination);
+		void request_audio_status();
+		bool muted;
+		int volume;
+		bool fallback;
+		bool tv_off;
+		unsigned char audio_destination;
+	protected:
+		bool running;
+	public:
+		~hdmi_cec();
+		static hdmi_cec *getInstance();
+		bool SetCECMode(VIDEO_HDMI_CEC_MODE);
+		void SetCECAutoView(bool);
+		void SetCECAutoStandby(bool);
+		void GetCECAddressInfo();
+		void SendCECMessage(struct cec_message &message, int sleeptime = 250);
+		void SetCECState(bool state);
+		void ReportPhysicalAddress();
+		bool standby_cec_activ;
+		void vol_up();
+		void vol_down();
+		void toggle_mute();
+		int GetVolume()
+		{
+			return volume;
+		};
+		bool isMuted()
+		{
+			return muted;
+		};
+		int GetAudioDestination()
+		{
+			return (int)audio_destination;
+		}
+		void SetAudioDestination(int audio_dest);
 };
 
 #endif // __HDMI_CEC_H__
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/hdmi_cec_types.h libstb-hal-ddt.git/libmipsbox/hdmi_cec_types.h
--- libstb-hal-ddt.git.orig/libmipsbox/hdmi_cec_types.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libmipsbox/hdmi_cec_types.h	2022-07-23 18:18:31.499773109 +0200
@@ -245,148 +245,148 @@
 {
 	switch (opcode)
 	{
-	case CEC_OPCODE_ACTIVE_SOURCE:
-		return "active source";
-	case CEC_OPCODE_IMAGE_VIEW_ON:
-		return "image view on";
-	case CEC_OPCODE_TEXT_VIEW_ON:
-		return "text view on";
-	case CEC_OPCODE_INACTIVE_SOURCE:
-		return "inactive source";
-	case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
-		return "request active source";
-	case CEC_OPCODE_ROUTING_CHANGE:
-		return "routing change";
-	case CEC_OPCODE_ROUTING_INFORMATION:
-		return "routing information";
-	case CEC_OPCODE_SET_STREAM_PATH:
-		return "set stream path";
-	case CEC_OPCODE_STANDBY:
-		return "standby";
-	case CEC_OPCODE_RECORD_OFF:
-		return "record off";
-	case CEC_OPCODE_RECORD_ON:
-		return "record on";
-	case CEC_OPCODE_RECORD_STATUS:
-		return "record status";
-	case CEC_OPCODE_RECORD_TV_SCREEN:
-		return "record tv screen";
-	case CEC_OPCODE_CLEAR_ANALOGUE_TIMER:
-		return "clear analogue timer";
-	case CEC_OPCODE_CLEAR_DIGITAL_TIMER:
-		return "clear digital timer";
-	case CEC_OPCODE_CLEAR_EXTERNAL_TIMER:
-		return "clear external timer";
-	case CEC_OPCODE_SET_ANALOGUE_TIMER:
-		return "set analogue timer";
-	case CEC_OPCODE_SET_DIGITAL_TIMER:
-		return "set digital timer";
-	case CEC_OPCODE_SET_EXTERNAL_TIMER:
-		return "set external timer";
-	case CEC_OPCODE_SET_TIMER_PROGRAM_TITLE:
-		return "set timer program title";
-	case CEC_OPCODE_TIMER_CLEARED_STATUS:
-		return "timer cleared status";
-	case CEC_OPCODE_TIMER_STATUS:
-		return "timer status";
-	case CEC_OPCODE_CEC_VERSION:
-		return "cec version";
-	case CEC_OPCODE_GET_CEC_VERSION:
-		return "get cec version";
-	case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
-		return "give physical address";
-	case CEC_OPCODE_GET_MENU_LANGUAGE:
-		return "get menu language";
-	case CEC_OPCODE_REPORT_PHYSICAL_ADDRESS:
-		return "report physical address";
-	case CEC_OPCODE_SET_MENU_LANGUAGE:
-		return "set menu language";
-	case CEC_OPCODE_DECK_CONTROL:
-		return "deck control";
-	case CEC_OPCODE_DECK_STATUS:
-		return "deck status";
-	case CEC_OPCODE_GIVE_DECK_STATUS:
-		return "give deck status";
-	case CEC_OPCODE_PLAY:
-		return "play";
-	case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS:
-		return "give tuner status";
-	case CEC_OPCODE_SELECT_ANALOGUE_SERVICE:
-		return "select analogue service";
-	case CEC_OPCODE_SELECT_DIGITAL_SERVICE:
-		return "set digital service";
-	case CEC_OPCODE_TUNER_DEVICE_STATUS:
-		return "tuner device status";
-	case CEC_OPCODE_TUNER_STEP_DECREMENT:
-		return "tuner step decrement";
-	case CEC_OPCODE_TUNER_STEP_INCREMENT:
-		return "tuner step increment";
-	case CEC_OPCODE_DEVICE_VENDOR_ID:
-		return "device vendor id";
-	case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
-		return "give device vendor id";
-	case CEC_OPCODE_VENDOR_COMMAND:
-		return "vendor command";
-	case CEC_OPCODE_VENDOR_COMMAND_WITH_ID:
-		return "vendor command with id";
-	case CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN:
-		return "vendor remote button down";
-	case CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP:
-		return "vendor remote button up";
-	case CEC_OPCODE_SET_OSD_STRING:
-		return "set osd string";
-	case CEC_OPCODE_GIVE_OSD_NAME:
-		return "give osd name";
-	case CEC_OPCODE_SET_OSD_NAME:
-		return "set osd name";
-	case CEC_OPCODE_MENU_REQUEST:
-		return "menu request";
-	case CEC_OPCODE_MENU_STATUS:
-		return "menu status";
-	case CEC_OPCODE_USER_CONTROL_PRESSED:
-		return "user control pressed";
-	case CEC_OPCODE_USER_CONTROL_RELEASE:
-		return "user control release";
-	case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
-		return "give device power status";
-	case CEC_OPCODE_REPORT_POWER_STATUS:
-		return "report power status";
-	case CEC_OPCODE_FEATURE_ABORT:
-		return "feature abort";
-	case CEC_OPCODE_ABORT:
-		return "abort";
-	case CEC_OPCODE_GIVE_AUDIO_STATUS:
-		return "give audio status";
-	case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS:
-		return "give audio mode status";
-	case CEC_OPCODE_REPORT_AUDIO_STATUS:
-		return "report audio status";
-	case CEC_OPCODE_SET_SYSTEM_AUDIO_MODE:
-		return "set system audio mode";
-	case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST:
-		return "system audio mode request";
-	case CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS:
-		return "system audio mode status";
-	case CEC_OPCODE_SET_AUDIO_RATE:
-		return "set audio rate";
-	case CEC_OPCODE_START_ARC:
-		return "start ARC";
-	case CEC_OPCODE_REPORT_ARC_STARTED:
-		return "report ARC started";
-	case CEC_OPCODE_REPORT_ARC_ENDED:
-		return "report ARC ended";
-	case CEC_OPCODE_REQUEST_ARC_START:
-		return "request ARC start";
-	case CEC_OPCODE_REQUEST_ARC_END:
-		return "request ARC end";
-	case CEC_OPCODE_END_ARC:
-		return "end ARC";
-	case CEC_OPCODE_CDC:
-		return "CDC";
-	case CEC_OPCODE_NONE:
-		return "poll";
-	default:
-		return "UNKNOWN";
+		case CEC_OPCODE_ACTIVE_SOURCE:
+			return "active source";
+		case CEC_OPCODE_IMAGE_VIEW_ON:
+			return "image view on";
+		case CEC_OPCODE_TEXT_VIEW_ON:
+			return "text view on";
+		case CEC_OPCODE_INACTIVE_SOURCE:
+			return "inactive source";
+		case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
+			return "request active source";
+		case CEC_OPCODE_ROUTING_CHANGE:
+			return "routing change";
+		case CEC_OPCODE_ROUTING_INFORMATION:
+			return "routing information";
+		case CEC_OPCODE_SET_STREAM_PATH:
+			return "set stream path";
+		case CEC_OPCODE_STANDBY:
+			return "standby";
+		case CEC_OPCODE_RECORD_OFF:
+			return "record off";
+		case CEC_OPCODE_RECORD_ON:
+			return "record on";
+		case CEC_OPCODE_RECORD_STATUS:
+			return "record status";
+		case CEC_OPCODE_RECORD_TV_SCREEN:
+			return "record tv screen";
+		case CEC_OPCODE_CLEAR_ANALOGUE_TIMER:
+			return "clear analogue timer";
+		case CEC_OPCODE_CLEAR_DIGITAL_TIMER:
+			return "clear digital timer";
+		case CEC_OPCODE_CLEAR_EXTERNAL_TIMER:
+			return "clear external timer";
+		case CEC_OPCODE_SET_ANALOGUE_TIMER:
+			return "set analogue timer";
+		case CEC_OPCODE_SET_DIGITAL_TIMER:
+			return "set digital timer";
+		case CEC_OPCODE_SET_EXTERNAL_TIMER:
+			return "set external timer";
+		case CEC_OPCODE_SET_TIMER_PROGRAM_TITLE:
+			return "set timer program title";
+		case CEC_OPCODE_TIMER_CLEARED_STATUS:
+			return "timer cleared status";
+		case CEC_OPCODE_TIMER_STATUS:
+			return "timer status";
+		case CEC_OPCODE_CEC_VERSION:
+			return "cec version";
+		case CEC_OPCODE_GET_CEC_VERSION:
+			return "get cec version";
+		case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
+			return "give physical address";
+		case CEC_OPCODE_GET_MENU_LANGUAGE:
+			return "get menu language";
+		case CEC_OPCODE_REPORT_PHYSICAL_ADDRESS:
+			return "report physical address";
+		case CEC_OPCODE_SET_MENU_LANGUAGE:
+			return "set menu language";
+		case CEC_OPCODE_DECK_CONTROL:
+			return "deck control";
+		case CEC_OPCODE_DECK_STATUS:
+			return "deck status";
+		case CEC_OPCODE_GIVE_DECK_STATUS:
+			return "give deck status";
+		case CEC_OPCODE_PLAY:
+			return "play";
+		case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS:
+			return "give tuner status";
+		case CEC_OPCODE_SELECT_ANALOGUE_SERVICE:
+			return "select analogue service";
+		case CEC_OPCODE_SELECT_DIGITAL_SERVICE:
+			return "set digital service";
+		case CEC_OPCODE_TUNER_DEVICE_STATUS:
+			return "tuner device status";
+		case CEC_OPCODE_TUNER_STEP_DECREMENT:
+			return "tuner step decrement";
+		case CEC_OPCODE_TUNER_STEP_INCREMENT:
+			return "tuner step increment";
+		case CEC_OPCODE_DEVICE_VENDOR_ID:
+			return "device vendor id";
+		case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
+			return "give device vendor id";
+		case CEC_OPCODE_VENDOR_COMMAND:
+			return "vendor command";
+		case CEC_OPCODE_VENDOR_COMMAND_WITH_ID:
+			return "vendor command with id";
+		case CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN:
+			return "vendor remote button down";
+		case CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP:
+			return "vendor remote button up";
+		case CEC_OPCODE_SET_OSD_STRING:
+			return "set osd string";
+		case CEC_OPCODE_GIVE_OSD_NAME:
+			return "give osd name";
+		case CEC_OPCODE_SET_OSD_NAME:
+			return "set osd name";
+		case CEC_OPCODE_MENU_REQUEST:
+			return "menu request";
+		case CEC_OPCODE_MENU_STATUS:
+			return "menu status";
+		case CEC_OPCODE_USER_CONTROL_PRESSED:
+			return "user control pressed";
+		case CEC_OPCODE_USER_CONTROL_RELEASE:
+			return "user control release";
+		case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
+			return "give device power status";
+		case CEC_OPCODE_REPORT_POWER_STATUS:
+			return "report power status";
+		case CEC_OPCODE_FEATURE_ABORT:
+			return "feature abort";
+		case CEC_OPCODE_ABORT:
+			return "abort";
+		case CEC_OPCODE_GIVE_AUDIO_STATUS:
+			return "give audio status";
+		case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+			return "give audio mode status";
+		case CEC_OPCODE_REPORT_AUDIO_STATUS:
+			return "report audio status";
+		case CEC_OPCODE_SET_SYSTEM_AUDIO_MODE:
+			return "set system audio mode";
+		case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST:
+			return "system audio mode request";
+		case CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS:
+			return "system audio mode status";
+		case CEC_OPCODE_SET_AUDIO_RATE:
+			return "set audio rate";
+		case CEC_OPCODE_START_ARC:
+			return "start ARC";
+		case CEC_OPCODE_REPORT_ARC_STARTED:
+			return "report ARC started";
+		case CEC_OPCODE_REPORT_ARC_ENDED:
+			return "report ARC ended";
+		case CEC_OPCODE_REQUEST_ARC_START:
+			return "request ARC start";
+		case CEC_OPCODE_REQUEST_ARC_END:
+			return "request ARC end";
+		case CEC_OPCODE_END_ARC:
+			return "end ARC";
+		case CEC_OPCODE_CDC:
+			return "CDC";
+		case CEC_OPCODE_NONE:
+			return "poll";
+		default:
+			return "UNKNOWN";
 	}
 }
 
@@ -394,59 +394,59 @@
 {
 	switch (vendor)
 	{
-	case CEC_VENDOR_SAMSUNG:
-		return "Samsung";
-	case CEC_VENDOR_LG:
-		return "LG";
-	case CEC_VENDOR_PANASONIC:
-		return "Panasonic";
-	case CEC_VENDOR_PIONEER:
-		return "Pioneer";
-	case CEC_VENDOR_ONKYO:
-		return "Onkyo";
-	case CEC_VENDOR_YAMAHA:
-		return "Yamaha";
-	case CEC_VENDOR_PHILIPS:
-		return "Philips";
-	case CEC_VENDOR_SONY:
-		return "Sony";
-	case CEC_VENDOR_TOSHIBA:
-	case CEC_VENDOR_TOSHIBA2:
-		return "Toshiba";
-	case CEC_VENDOR_AKAI:
-		return "Akai";
-	case CEC_VENDOR_AOC:
-		return "AOC";
-	case CEC_VENDOR_BENQ:
-		return "Benq";
-	case CEC_VENDOR_DAEWOO:
-		return "Daewoo";
-	case CEC_VENDOR_GRUNDIG:
-		return "Grundig";
-	case CEC_VENDOR_MEDION:
-		return "Medion";
-	case CEC_VENDOR_SHARP:
-	case CEC_VENDOR_SHARP2:
-		return "Sharp";
-	case CEC_VENDOR_VIZIO:
-		return "Vizio";
-	case CEC_VENDOR_BROADCOM:
-		return "Broadcom";
-	case CEC_VENDOR_LOEWE:
-		return "Loewe";
-	case CEC_VENDOR_DENON:
-		return "Denon";
-	case CEC_VENDOR_MARANTZ:
-		return "Marantz";
-	case CEC_VENDOR_HARMAN_KARDON:
-	case CEC_VENDOR_HARMAN_KARDON2:
-		return "Harman/Kardon";
-	case CEC_VENDOR_PULSE_EIGHT:
-		return "Pulse Eight";
-	case CEC_VENDOR_GOOGLE:
-		return "Google";
-	default:
-		return "Unknown";
+		case CEC_VENDOR_SAMSUNG:
+			return "Samsung";
+		case CEC_VENDOR_LG:
+			return "LG";
+		case CEC_VENDOR_PANASONIC:
+			return "Panasonic";
+		case CEC_VENDOR_PIONEER:
+			return "Pioneer";
+		case CEC_VENDOR_ONKYO:
+			return "Onkyo";
+		case CEC_VENDOR_YAMAHA:
+			return "Yamaha";
+		case CEC_VENDOR_PHILIPS:
+			return "Philips";
+		case CEC_VENDOR_SONY:
+			return "Sony";
+		case CEC_VENDOR_TOSHIBA:
+		case CEC_VENDOR_TOSHIBA2:
+			return "Toshiba";
+		case CEC_VENDOR_AKAI:
+			return "Akai";
+		case CEC_VENDOR_AOC:
+			return "AOC";
+		case CEC_VENDOR_BENQ:
+			return "Benq";
+		case CEC_VENDOR_DAEWOO:
+			return "Daewoo";
+		case CEC_VENDOR_GRUNDIG:
+			return "Grundig";
+		case CEC_VENDOR_MEDION:
+			return "Medion";
+		case CEC_VENDOR_SHARP:
+		case CEC_VENDOR_SHARP2:
+			return "Sharp";
+		case CEC_VENDOR_VIZIO:
+			return "Vizio";
+		case CEC_VENDOR_BROADCOM:
+			return "Broadcom";
+		case CEC_VENDOR_LOEWE:
+			return "Loewe";
+		case CEC_VENDOR_DENON:
+			return "Denon";
+		case CEC_VENDOR_MARANTZ:
+			return "Marantz";
+		case CEC_VENDOR_HARMAN_KARDON:
+		case CEC_VENDOR_HARMAN_KARDON2:
+			return "Harman/Kardon";
+		case CEC_VENDOR_PULSE_EIGHT:
+			return "Pulse Eight";
+		case CEC_VENDOR_GOOGLE:
+			return "Google";
+		default:
+			return "Unknown";
 	}
 }
 
@@ -454,182 +454,182 @@
 {
 	switch (key)
 	{
-	case CEC_USER_CONTROL_CODE_SELECT:
-		return "select";
-	case CEC_USER_CONTROL_CODE_UP:
-		return "up";
-	case CEC_USER_CONTROL_CODE_DOWN:
-		return "down";
-	case CEC_USER_CONTROL_CODE_LEFT:
-		return "left";
-	case CEC_USER_CONTROL_CODE_RIGHT:
-		return "right";
-	case CEC_USER_CONTROL_CODE_RIGHT_UP:
-		return "right+up";
-	case CEC_USER_CONTROL_CODE_RIGHT_DOWN:
-		return "right+down";
-	case CEC_USER_CONTROL_CODE_LEFT_UP:
-		return "left+up";
-	case CEC_USER_CONTROL_CODE_LEFT_DOWN:
-		return "left+down";
-	case CEC_USER_CONTROL_CODE_ROOT_MENU:
-		return "root menu";
-	case CEC_USER_CONTROL_CODE_SETUP_MENU:
-		return "setup menu";
-	case CEC_USER_CONTROL_CODE_CONTENTS_MENU:
-		return "contents menu";
-	case CEC_USER_CONTROL_CODE_FAVORITE_MENU:
-		return "favourite menu";
-	case CEC_USER_CONTROL_CODE_EXIT:
-		return "exit";
-	case CEC_USER_CONTROL_CODE_TOP_MENU:
-		return "top menu";
-	case CEC_USER_CONTROL_CODE_DVD_MENU:
-		return "dvd menu";
-	case CEC_USER_CONTROL_CODE_NUMBER_ENTRY_MODE:
-		return "number entry mode";
-	case CEC_USER_CONTROL_CODE_NUMBER11:
-		return "11";
-	case CEC_USER_CONTROL_CODE_NUMBER12:
-		return "12";
-	case CEC_USER_CONTROL_CODE_NUMBER0:
-		return "0";
-	case CEC_USER_CONTROL_CODE_NUMBER1:
-		return "1";
-	case CEC_USER_CONTROL_CODE_NUMBER2:
-		return "2";
-	case CEC_USER_CONTROL_CODE_NUMBER3:
-		return "3";
-	case CEC_USER_CONTROL_CODE_NUMBER4:
-		return "4";
-	case CEC_USER_CONTROL_CODE_NUMBER5:
-		return "5";
-	case CEC_USER_CONTROL_CODE_NUMBER6:
-		return "6";
-	case CEC_USER_CONTROL_CODE_NUMBER7:
-		return "7";
-	case CEC_USER_CONTROL_CODE_NUMBER8:
-		return "8";
-	case CEC_USER_CONTROL_CODE_NUMBER9:
-		return "9";
-	case CEC_USER_CONTROL_CODE_DOT:
-		return ".";
-	case CEC_USER_CONTROL_CODE_ENTER:
-		return "enter";
-	case CEC_USER_CONTROL_CODE_CLEAR:
-		return "clear";
-	case CEC_USER_CONTROL_CODE_NEXT_FAVORITE:
-		return "next favourite";
-	case CEC_USER_CONTROL_CODE_CHANNEL_UP:
-		return "channel up";
-	case CEC_USER_CONTROL_CODE_CHANNEL_DOWN:
-		return "channel down";
-	case CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL:
-		return "previous channel";
-	case CEC_USER_CONTROL_CODE_SOUND_SELECT:
-		return "sound select";
-	case CEC_USER_CONTROL_CODE_INPUT_SELECT:
-		return "input select";
-	case CEC_USER_CONTROL_CODE_DISPLAY_INFORMATION:
-		return "display information";
-	case CEC_USER_CONTROL_CODE_HELP:
-		return "help";
-	case CEC_USER_CONTROL_CODE_PAGE_UP:
-		return "page up";
-	case CEC_USER_CONTROL_CODE_PAGE_DOWN:
-		return "page down";
-	case CEC_USER_CONTROL_CODE_POWER:
-		return "power";
-	case CEC_USER_CONTROL_CODE_VOLUME_UP:
-		return "volume up";
-	case CEC_USER_CONTROL_CODE_VOLUME_DOWN:
-		return "volume down";
-	case CEC_USER_CONTROL_CODE_MUTE:
-		return "mute";
-	case CEC_USER_CONTROL_CODE_PLAY:
-		return "play";
-	case CEC_USER_CONTROL_CODE_STOP:
-		return "stop";
-	case CEC_USER_CONTROL_CODE_PAUSE:
-		return "pause";
-	case CEC_USER_CONTROL_CODE_RECORD:
-		return "record";
-	case CEC_USER_CONTROL_CODE_REWIND:
-		return "rewind";
-	case CEC_USER_CONTROL_CODE_FAST_FORWARD:
-		return "Fast forward";
-	case CEC_USER_CONTROL_CODE_EJECT:
-		return "eject";
-	case CEC_USER_CONTROL_CODE_FORWARD:
-		return "forward";
-	case CEC_USER_CONTROL_CODE_BACKWARD:
-		return "backward";
-	case CEC_USER_CONTROL_CODE_STOP_RECORD:
-		return "stop record";
-	case CEC_USER_CONTROL_CODE_PAUSE_RECORD:
-		return "pause record";
-	case CEC_USER_CONTROL_CODE_ANGLE:
-		return "angle";
-	case CEC_USER_CONTROL_CODE_SUB_PICTURE:
-		return "sub picture";
-	case CEC_USER_CONTROL_CODE_VIDEO_ON_DEMAND:
-		return "video on demand";
-	case CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE:
-		return "electronic program guide";
-	case CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING:
-		return "timer programming";
-	case CEC_USER_CONTROL_CODE_INITIAL_CONFIGURATION:
-		return "initial configuration";
-	case CEC_USER_CONTROL_CODE_SELECT_BROADCAST_TYPE:
-		return "select broadcast type";
-	case CEC_USER_CONTROL_CODE_SELECT_SOUND_PRESENTATION:
-		return "select sound presentation";
-	case CEC_USER_CONTROL_CODE_PLAY_FUNCTION:
-		return "play (function)";
-	case CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION:
-		return "pause play (function)";
-	case CEC_USER_CONTROL_CODE_RECORD_FUNCTION:
-		return "record (function)";
-	case CEC_USER_CONTROL_CODE_PAUSE_RECORD_FUNCTION:
-		return "pause record (function)";
-	case CEC_USER_CONTROL_CODE_STOP_FUNCTION:
-		return "stop (function)";
-	case CEC_USER_CONTROL_CODE_MUTE_FUNCTION:
-		return "mute (function)";
-	case CEC_USER_CONTROL_CODE_RESTORE_VOLUME_FUNCTION:
-		return "restore volume";
-	case CEC_USER_CONTROL_CODE_TUNE_FUNCTION:
-		return "tune";
-	case CEC_USER_CONTROL_CODE_SELECT_MEDIA_FUNCTION:
-		return "select media";
-	case CEC_USER_CONTROL_CODE_SELECT_AV_INPUT_FUNCTION:
-		return "select AV input";
-	case CEC_USER_CONTROL_CODE_SELECT_AUDIO_INPUT_FUNCTION:
-		return "select audio input";
-	case CEC_USER_CONTROL_CODE_POWER_TOGGLE_FUNCTION:
-		return "power toggle";
-	case CEC_USER_CONTROL_CODE_POWER_OFF_FUNCTION:
-		return "power off";
-	case CEC_USER_CONTROL_CODE_POWER_ON_FUNCTION:
-		return "power on";
-	case CEC_USER_CONTROL_CODE_F1_BLUE:
-		return "F1 (blue)";
-	case CEC_USER_CONTROL_CODE_F2_RED:
-		return "F2 (red)";
-	case CEC_USER_CONTROL_CODE_F3_GREEN:
-		return "F3 (green)";
-	case CEC_USER_CONTROL_CODE_F4_YELLOW:
-		return "F4 (yellow)";
-	case CEC_USER_CONTROL_CODE_F5:
-		return "F5";
-	case CEC_USER_CONTROL_CODE_DATA:
-		return "data";
-	case CEC_USER_CONTROL_CODE_AN_RETURN:
-		return "return (Samsung)";
-	case CEC_USER_CONTROL_CODE_AN_CHANNELS_LIST:
-		return "channels list (Samsung)";
-	default:
-		return "unknown";
+		case CEC_USER_CONTROL_CODE_SELECT:
+			return "select";
+		case CEC_USER_CONTROL_CODE_UP:
+			return "up";
+		case CEC_USER_CONTROL_CODE_DOWN:
+			return "down";
+		case CEC_USER_CONTROL_CODE_LEFT:
+			return "left";
+		case CEC_USER_CONTROL_CODE_RIGHT:
+			return "right";
+		case CEC_USER_CONTROL_CODE_RIGHT_UP:
+			return "right+up";
+		case CEC_USER_CONTROL_CODE_RIGHT_DOWN:
+			return "right+down";
+		case CEC_USER_CONTROL_CODE_LEFT_UP:
+			return "left+up";
+		case CEC_USER_CONTROL_CODE_LEFT_DOWN:
+			return "left+down";
+		case CEC_USER_CONTROL_CODE_ROOT_MENU:
+			return "root menu";
+		case CEC_USER_CONTROL_CODE_SETUP_MENU:
+			return "setup menu";
+		case CEC_USER_CONTROL_CODE_CONTENTS_MENU:
+			return "contents menu";
+		case CEC_USER_CONTROL_CODE_FAVORITE_MENU:
+			return "favourite menu";
+		case CEC_USER_CONTROL_CODE_EXIT:
+			return "exit";
+		case CEC_USER_CONTROL_CODE_TOP_MENU:
+			return "top menu";
+		case CEC_USER_CONTROL_CODE_DVD_MENU:
+			return "dvd menu";
+		case CEC_USER_CONTROL_CODE_NUMBER_ENTRY_MODE:
+			return "number entry mode";
+		case CEC_USER_CONTROL_CODE_NUMBER11:
+			return "11";
+		case CEC_USER_CONTROL_CODE_NUMBER12:
+			return "12";
+		case CEC_USER_CONTROL_CODE_NUMBER0:
+			return "0";
+		case CEC_USER_CONTROL_CODE_NUMBER1:
+			return "1";
+		case CEC_USER_CONTROL_CODE_NUMBER2:
+			return "2";
+		case CEC_USER_CONTROL_CODE_NUMBER3:
+			return "3";
+		case CEC_USER_CONTROL_CODE_NUMBER4:
+			return "4";
+		case CEC_USER_CONTROL_CODE_NUMBER5:
+			return "5";
+		case CEC_USER_CONTROL_CODE_NUMBER6:
+			return "6";
+		case CEC_USER_CONTROL_CODE_NUMBER7:
+			return "7";
+		case CEC_USER_CONTROL_CODE_NUMBER8:
+			return "8";
+		case CEC_USER_CONTROL_CODE_NUMBER9:
+			return "9";
+		case CEC_USER_CONTROL_CODE_DOT:
+			return ".";
+		case CEC_USER_CONTROL_CODE_ENTER:
+			return "enter";
+		case CEC_USER_CONTROL_CODE_CLEAR:
+			return "clear";
+		case CEC_USER_CONTROL_CODE_NEXT_FAVORITE:
+			return "next favourite";
+		case CEC_USER_CONTROL_CODE_CHANNEL_UP:
+			return "channel up";
+		case CEC_USER_CONTROL_CODE_CHANNEL_DOWN:
+			return "channel down";
+		case CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL:
+			return "previous channel";
+		case CEC_USER_CONTROL_CODE_SOUND_SELECT:
+			return "sound select";
+		case CEC_USER_CONTROL_CODE_INPUT_SELECT:
+			return "input select";
+		case CEC_USER_CONTROL_CODE_DISPLAY_INFORMATION:
+			return "display information";
+		case CEC_USER_CONTROL_CODE_HELP:
+			return "help";
+		case CEC_USER_CONTROL_CODE_PAGE_UP:
+			return "page up";
+		case CEC_USER_CONTROL_CODE_PAGE_DOWN:
+			return "page down";
+		case CEC_USER_CONTROL_CODE_POWER:
+			return "power";
+		case CEC_USER_CONTROL_CODE_VOLUME_UP:
+			return "volume up";
+		case CEC_USER_CONTROL_CODE_VOLUME_DOWN:
+			return "volume down";
+		case CEC_USER_CONTROL_CODE_MUTE:
+			return "mute";
+		case CEC_USER_CONTROL_CODE_PLAY:
+			return "play";
+		case CEC_USER_CONTROL_CODE_STOP:
+			return "stop";
+		case CEC_USER_CONTROL_CODE_PAUSE:
+			return "pause";
+		case CEC_USER_CONTROL_CODE_RECORD:
+			return "record";
+		case CEC_USER_CONTROL_CODE_REWIND:
+			return "rewind";
+		case CEC_USER_CONTROL_CODE_FAST_FORWARD:
+			return "Fast forward";
+		case CEC_USER_CONTROL_CODE_EJECT:
+			return "eject";
+		case CEC_USER_CONTROL_CODE_FORWARD:
+			return "forward";
+		case CEC_USER_CONTROL_CODE_BACKWARD:
+			return "backward";
+		case CEC_USER_CONTROL_CODE_STOP_RECORD:
+			return "stop record";
+		case CEC_USER_CONTROL_CODE_PAUSE_RECORD:
+			return "pause record";
+		case CEC_USER_CONTROL_CODE_ANGLE:
+			return "angle";
+		case CEC_USER_CONTROL_CODE_SUB_PICTURE:
+			return "sub picture";
+		case CEC_USER_CONTROL_CODE_VIDEO_ON_DEMAND:
+			return "video on demand";
+		case CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE:
+			return "electronic program guide";
+		case CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING:
+			return "timer programming";
+		case CEC_USER_CONTROL_CODE_INITIAL_CONFIGURATION:
+			return "initial configuration";
+		case CEC_USER_CONTROL_CODE_SELECT_BROADCAST_TYPE:
+			return "select broadcast type";
+		case CEC_USER_CONTROL_CODE_SELECT_SOUND_PRESENTATION:
+			return "select sound presentation";
+		case CEC_USER_CONTROL_CODE_PLAY_FUNCTION:
+			return "play (function)";
+		case CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION:
+			return "pause play (function)";
+		case CEC_USER_CONTROL_CODE_RECORD_FUNCTION:
+			return "record (function)";
+		case CEC_USER_CONTROL_CODE_PAUSE_RECORD_FUNCTION:
+			return "pause record (function)";
+		case CEC_USER_CONTROL_CODE_STOP_FUNCTION:
+			return "stop (function)";
+		case CEC_USER_CONTROL_CODE_MUTE_FUNCTION:
+			return "mute (function)";
+		case CEC_USER_CONTROL_CODE_RESTORE_VOLUME_FUNCTION:
+			return "restore volume";
+		case CEC_USER_CONTROL_CODE_TUNE_FUNCTION:
+			return "tune";
+		case CEC_USER_CONTROL_CODE_SELECT_MEDIA_FUNCTION:
+			return "select media";
+		case CEC_USER_CONTROL_CODE_SELECT_AV_INPUT_FUNCTION:
+			return "select AV input";
+		case CEC_USER_CONTROL_CODE_SELECT_AUDIO_INPUT_FUNCTION:
+			return "select audio input";
+		case CEC_USER_CONTROL_CODE_POWER_TOGGLE_FUNCTION:
+			return "power toggle";
+		case CEC_USER_CONTROL_CODE_POWER_OFF_FUNCTION:
+			return "power off";
+		case CEC_USER_CONTROL_CODE_POWER_ON_FUNCTION:
+			return "power on";
+		case CEC_USER_CONTROL_CODE_F1_BLUE:
+			return "F1 (blue)";
+		case CEC_USER_CONTROL_CODE_F2_RED:
+			return "F2 (red)";
+		case CEC_USER_CONTROL_CODE_F3_GREEN:
+			return "F3 (green)";
+		case CEC_USER_CONTROL_CODE_F4_YELLOW:
+			return "F4 (yellow)";
+		case CEC_USER_CONTROL_CODE_F5:
+			return "F5";
+		case CEC_USER_CONTROL_CODE_DATA:
+			return "data";
+		case CEC_USER_CONTROL_CODE_AN_RETURN:
+			return "return (Samsung)";
+		case CEC_USER_CONTROL_CODE_AN_CHANNELS_LIST:
+			return "channels list (Samsung)";
+		default:
+			return "unknown";
 	}
 }
 
@@ -637,39 +637,39 @@
 {
 	switch (la & 0xf)
 	{
-	case CECDEVICE_TV:
-		return "TV";
-	case CECDEVICE_RECORDINGDEVICE1:
-		return "Recording Device 1";
-	case CECDEVICE_RECORDINGDEVICE2:
-		return "Recording Device 2";
-	case CECDEVICE_TUNER1:
-		return "Tuner 1";
-	case CECDEVICE_PLAYBACKDEVICE1:
-		return "Playback Device 1";
-	case CECDEVICE_AUDIOSYSTEM:
-		return "Audio System";
-	case CECDEVICE_TUNER2:
-		return "Tuner 2";
-	case CECDEVICE_TUNER3:
-		return "Tuner 3";
-	case CECDEVICE_PLAYBACKDEVICE2:
-		return "Playback Device 2";
-	case CECDEVICE_RECORDINGDEVICE3:
-		return "Recording Device 3";
-	case CECDEVICE_TUNER4:
-		return "Tuner 4";
-	case CECDEVICE_PLAYBACKDEVICE3:
-		return "Playback Device 3";
-	case CECDEVICE_RESERVED1:
-		return "Reserved 1";
-	case CECDEVICE_RESERVED2:
-		return "Reserved 2";
-	case CECDEVICE_FREEUSE:
-		return "Free use";
-	case CECDEVICE_UNREGISTERED:
-	default:
-		return "Unregistered";
+		case CECDEVICE_TV:
+			return "TV";
+		case CECDEVICE_RECORDINGDEVICE1:
+			return "Recording Device 1";
+		case CECDEVICE_RECORDINGDEVICE2:
+			return "Recording Device 2";
+		case CECDEVICE_TUNER1:
+			return "Tuner 1";
+		case CECDEVICE_PLAYBACKDEVICE1:
+			return "Playback Device 1";
+		case CECDEVICE_AUDIOSYSTEM:
+			return "Audio System";
+		case CECDEVICE_TUNER2:
+			return "Tuner 2";
+		case CECDEVICE_TUNER3:
+			return "Tuner 3";
+		case CECDEVICE_PLAYBACKDEVICE2:
+			return "Playback Device 2";
+		case CECDEVICE_RECORDINGDEVICE3:
+			return "Recording Device 3";
+		case CECDEVICE_TUNER4:
+			return "Tuner 4";
+		case CECDEVICE_PLAYBACKDEVICE3:
+			return "Playback Device 3";
+		case CECDEVICE_RESERVED1:
+			return "Reserved 1";
+		case CECDEVICE_RESERVED2:
+			return "Reserved 2";
+		case CECDEVICE_FREEUSE:
+			return "Free use";
+		case CECDEVICE_UNREGISTERED:
+		default:
+			return "Unregistered";
 	}
 }
 
@@ -677,34 +677,34 @@
 {
 	switch (opcode)
 	{
-	case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
-		return CEC_OPCODE_ACTIVE_SOURCE;
-	case CEC_OPCODE_GET_CEC_VERSION:
-		return CEC_OPCODE_CEC_VERSION;
-	case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
-		return CEC_OPCODE_REPORT_PHYSICAL_ADDRESS;
-	case CEC_OPCODE_GET_MENU_LANGUAGE:
-		return CEC_OPCODE_SET_MENU_LANGUAGE;
-	case CEC_OPCODE_GIVE_DECK_STATUS:
-		return CEC_OPCODE_DECK_STATUS;
-	case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS:
-		return CEC_OPCODE_TUNER_DEVICE_STATUS;
-	case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
-		return CEC_OPCODE_DEVICE_VENDOR_ID;
-	case CEC_OPCODE_GIVE_OSD_NAME:
-		return CEC_OPCODE_SET_OSD_NAME;
-	case CEC_OPCODE_MENU_REQUEST:
-		return CEC_OPCODE_MENU_STATUS;
-	case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
-		return CEC_OPCODE_REPORT_POWER_STATUS;
-	case CEC_OPCODE_GIVE_AUDIO_STATUS:
-		return CEC_OPCODE_REPORT_AUDIO_STATUS;
-	case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS:
-		return CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS;
-	case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST:
-		return CEC_OPCODE_SET_SYSTEM_AUDIO_MODE;
-	default:
-		break;
+		case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
+			return CEC_OPCODE_ACTIVE_SOURCE;
+		case CEC_OPCODE_GET_CEC_VERSION:
+			return CEC_OPCODE_CEC_VERSION;
+		case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
+			return CEC_OPCODE_REPORT_PHYSICAL_ADDRESS;
+		case CEC_OPCODE_GET_MENU_LANGUAGE:
+			return CEC_OPCODE_SET_MENU_LANGUAGE;
+		case CEC_OPCODE_GIVE_DECK_STATUS:
+			return CEC_OPCODE_DECK_STATUS;
+		case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS:
+			return CEC_OPCODE_TUNER_DEVICE_STATUS;
+		case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
+			return CEC_OPCODE_DEVICE_VENDOR_ID;
+		case CEC_OPCODE_GIVE_OSD_NAME:
+			return CEC_OPCODE_SET_OSD_NAME;
+		case CEC_OPCODE_MENU_REQUEST:
+			return CEC_OPCODE_MENU_STATUS;
+		case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
+			return CEC_OPCODE_REPORT_POWER_STATUS;
+		case CEC_OPCODE_GIVE_AUDIO_STATUS:
+			return CEC_OPCODE_REPORT_AUDIO_STATUS;
+		case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+			return CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS;
+		case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST:
+			return CEC_OPCODE_SET_SYSTEM_AUDIO_MODE;
+		default:
+			break;
 	}
 
 	return CEC_OPCODE_NONE;
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/init.cpp libstb-hal-ddt.git/libmipsbox/init.cpp
--- libstb-hal-ddt.git.orig/libmipsbox/init.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libmipsbox/init.cpp	2022-07-23 18:18:31.499773109 +0200
@@ -26,8 +26,6 @@
 	hal_info("%s begin, initialized=%d, debug=0x%02x\n", __FUNCTION__, (int)initialized, debuglevel);
 	if (!initialized)
 	{
-		cCpuFreqManager f;
-		f.SetCpuFreq(0);	/* CPUFREQ == 0 is the trigger for leaving standby */
 		char buffer[64];
 		sprintf(buffer, "%x", 0);
 		proc_put("/proc/stb/fb/dst_top", buffer, strlen(buffer));
@@ -38,9 +36,10 @@
 		proc_put("/proc/stb/fb/dst_width", buffer, strlen(buffer));
 		sprintf(buffer, "%x", 1);
 		proc_put("/proc/stb/fb/dst_apply", buffer, strlen(buffer));
-#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
 		sprintf(buffer, "%s", "enable");
 		proc_put("/proc/stb/frontend/fbc/fcc", buffer, strlen(buffer));
+		proc_put("/proc/stb/video/decodermode", "normal", strlen("normal"));
 #endif
 	}
 	initialized = true;
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/linux-uapi-cec.h libstb-hal-ddt.git/libmipsbox/linux-uapi-cec.h
--- libstb-hal-ddt.git.orig/libmipsbox/linux-uapi-cec.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libmipsbox/linux-uapi-cec.h	2022-07-23 18:18:31.499773109 +0200
@@ -44,50 +44,51 @@
 
 #include <linux/types.h>
 
-#define CEC_MAX_MSG_SIZE	16
+#define CEC_MAX_MSG_SIZE    16
 
 /**
  * struct cec_msg - CEC message structure.
- * @tx_ts:	Timestamp in nanoseconds using CLOCK_MONOTONIC. Set by the
- *		driver when the message transmission has finished.
- * @rx_ts:	Timestamp in nanoseconds using CLOCK_MONOTONIC. Set by the
- *		driver when the message was received.
- * @len:	Length in bytes of the message.
- * @timeout:	The timeout (in ms) that is used to timeout CEC_RECEIVE.
- *		Set to 0 if you want to wait forever. This timeout can also be
- *		used with CEC_TRANSMIT as the timeout for waiting for a reply.
- *		If 0, then it will use a 1 second timeout instead of waiting
- *		forever as is done with CEC_RECEIVE.
- * @sequence:	The framework assigns a sequence number to messages that are
- *		sent. This can be used to track replies to previously sent
- *		messages.
- * @flags:	Set to 0.
- * @msg:	The message payload.
- * @reply:	This field is ignored with CEC_RECEIVE and is only used by
- *		CEC_TRANSMIT. If non-zero, then wait for a reply with this
- *		opcode. Set to CEC_MSG_FEATURE_ABORT if you want to wait for
- *		a possible ABORT reply. If there was an error when sending the
- *		msg or FeatureAbort was returned, then reply is set to 0.
- *		If reply is non-zero upon return, then len/msg are set to
- *		the received message.
- *		If reply is zero upon return and status has the
- *		CEC_TX_STATUS_FEATURE_ABORT bit set, then len/msg are set to
- *		the received feature abort message.
- *		If reply is zero upon return and status has the
- *		CEC_TX_STATUS_MAX_RETRIES bit set, then no reply was seen at
- *		all. If reply is non-zero for CEC_TRANSMIT and the message is a
- *		broadcast, then -EINVAL is returned.
- *		if reply is non-zero, then timeout is set to 1000 (the required
- *		maximum response time).
- * @rx_status:	The message receive status bits. Set by the driver.
- * @tx_status:	The message transmit status bits. Set by the driver.
+ * @tx_ts:  Timestamp in nanoseconds using CLOCK_MONOTONIC. Set by the
+ *      driver when the message transmission has finished.
+ * @rx_ts:  Timestamp in nanoseconds using CLOCK_MONOTONIC. Set by the
+ *      driver when the message was received.
+ * @len:    Length in bytes of the message.
+ * @timeout:    The timeout (in ms) that is used to timeout CEC_RECEIVE.
+ *      Set to 0 if you want to wait forever. This timeout can also be
+ *      used with CEC_TRANSMIT as the timeout for waiting for a reply.
+ *      If 0, then it will use a 1 second timeout instead of waiting
+ *      forever as is done with CEC_RECEIVE.
+ * @sequence:   The framework assigns a sequence number to messages that are
+ *      sent. This can be used to track replies to previously sent
+ *      messages.
+ * @flags:  Set to 0.
+ * @msg:    The message payload.
+ * @reply:  This field is ignored with CEC_RECEIVE and is only used by
+ *      CEC_TRANSMIT. If non-zero, then wait for a reply with this
+ *      opcode. Set to CEC_MSG_FEATURE_ABORT if you want to wait for
+ *      a possible ABORT reply. If there was an error when sending the
+ *      msg or FeatureAbort was returned, then reply is set to 0.
+ *      If reply is non-zero upon return, then len/msg are set to
+ *      the received message.
+ *      If reply is zero upon return and status has the
+ *      CEC_TX_STATUS_FEATURE_ABORT bit set, then len/msg are set to
+ *      the received feature abort message.
+ *      If reply is zero upon return and status has the
+ *      CEC_TX_STATUS_MAX_RETRIES bit set, then no reply was seen at
+ *      all. If reply is non-zero for CEC_TRANSMIT and the message is a
+ *      broadcast, then -EINVAL is returned.
+ *      if reply is non-zero, then timeout is set to 1000 (the required
+ *      maximum response time).
+ * @rx_status:  The message receive status bits. Set by the driver.
+ * @tx_status:  The message transmit status bits. Set by the driver.
  * @tx_arb_lost_cnt: The number of 'Arbitration Lost' events. Set by the driver.
  * @tx_nack_cnt: The number of 'Not Acknowledged' events. Set by the driver.
  * @tx_low_drive_cnt: The number of 'Low Drive Detected' events. Set by the
- *		driver.
+ *      driver.
  * @tx_error_cnt: The number of 'Error' events. Set by the driver.
  */
-struct cec_msg {
+struct cec_msg
+{
 	__u64 tx_ts;
 	__u64 rx_ts;
 	__u32 len;
@@ -106,7 +107,7 @@
 
 /**
  * cec_msg_initiator - return the initiator's logical address.
- * @msg:	the message structure
+ * @msg:    the message structure
  */
 static inline __u8 cec_msg_initiator(const struct cec_msg *msg)
 {
@@ -115,7 +116,7 @@
 
 /**
  * cec_msg_destination - return the destination's logical address.
- * @msg:	the message structure
+ * @msg:    the message structure
  */
 static inline __u8 cec_msg_destination(const struct cec_msg *msg)
 {
@@ -124,7 +125,7 @@
 
 /**
  * cec_msg_opcode - return the opcode of the message, -1 for poll
- * @msg:	the message structure
+ * @msg:    the message structure
  */
 static inline int cec_msg_opcode(const struct cec_msg *msg)
 {
@@ -133,7 +134,7 @@
 
 /**
  * cec_msg_is_broadcast - return true if this is a broadcast message.
- * @msg:	the message structure
+ * @msg:    the message structure
  */
 static inline bool cec_msg_is_broadcast(const struct cec_msg *msg)
 {
@@ -142,15 +143,15 @@
 
 /**
  * cec_msg_init - initialize the message structure.
- * @msg:	the message structure
- * @initiator:	the logical address of the initiator
+ * @msg:    the message structure
+ * @initiator:  the logical address of the initiator
  * @destination:the logical address of the destination (0xf for broadcast)
  *
  * The whole structure is zeroed, the len field is set to 1 (i.e. a poll
  * message) and the initiator and destination are filled in.
  */
 static inline void cec_msg_init(struct cec_msg *msg,
-				__u8 initiator, __u8 destination)
+    __u8 initiator, __u8 destination)
 {
 	memset(msg, 0, sizeof(*msg));
 	msg->msg[0] = (initiator << 4) | destination;
@@ -159,33 +160,33 @@
 
 /**
  * cec_msg_set_reply_to - fill in destination/initiator in a reply message.
- * @msg:	the message structure for the reply
- * @orig:	the original message structure
+ * @msg:    the message structure for the reply
+ * @orig:   the original message structure
  *
  * Set the msg destination to the orig initiator and the msg initiator to the
  * orig destination. Note that msg and orig may be the same pointer, in which
  * case the change is done in place.
  */
 static inline void cec_msg_set_reply_to(struct cec_msg *msg,
-					struct cec_msg *orig)
+    struct cec_msg *orig)
 {
 	/* The destination becomes the initiator and vice versa */
 	msg->msg[0] = (cec_msg_destination(orig) << 4) |
-		      cec_msg_initiator(orig);
+	    cec_msg_initiator(orig);
 	msg->reply = msg->timeout = 0;
 }
 
 /* cec status field */
-#define CEC_TX_STATUS_OK		(1 << 0)
-#define CEC_TX_STATUS_ARB_LOST		(1 << 1)
-#define CEC_TX_STATUS_NACK		(1 << 2)
-#define CEC_TX_STATUS_LOW_DRIVE		(1 << 3)
-#define CEC_TX_STATUS_ERROR		(1 << 4)
-#define CEC_TX_STATUS_MAX_RETRIES	(1 << 5)
-
-#define CEC_RX_STATUS_OK		(1 << 0)
-#define CEC_RX_STATUS_TIMEOUT		(1 << 1)
-#define CEC_RX_STATUS_FEATURE_ABORT	(1 << 2)
+#define CEC_TX_STATUS_OK        (1 << 0)
+#define CEC_TX_STATUS_ARB_LOST      (1 << 1)
+#define CEC_TX_STATUS_NACK      (1 << 2)
+#define CEC_TX_STATUS_LOW_DRIVE     (1 << 3)
+#define CEC_TX_STATUS_ERROR     (1 << 4)
+#define CEC_TX_STATUS_MAX_RETRIES   (1 << 5)
+
+#define CEC_RX_STATUS_OK        (1 << 0)
+#define CEC_RX_STATUS_TIMEOUT       (1 << 1)
+#define CEC_RX_STATUS_FEATURE_ABORT (1 << 2)
 
 static inline bool cec_msg_status_is_ok(const struct cec_msg *msg)
 {
@@ -198,8 +199,8 @@
 	return !(msg->rx_status & CEC_RX_STATUS_FEATURE_ABORT);
 }
 
-#define CEC_LOG_ADDR_INVALID		0xff
-#define CEC_PHYS_ADDR_INVALID		0xffff
+#define CEC_LOG_ADDR_INVALID        0xff
+#define CEC_PHYS_ADDR_INVALID       0xffff
 
 /*
  * The maximum number of logical addresses one device can be assigned to.
@@ -209,53 +210,53 @@
 #define CEC_MAX_LOG_ADDRS 4
 
 /* The logical addresses defined by CEC 2.0 */
-#define CEC_LOG_ADDR_TV			0
-#define CEC_LOG_ADDR_RECORD_1		1
-#define CEC_LOG_ADDR_RECORD_2		2
-#define CEC_LOG_ADDR_TUNER_1		3
-#define CEC_LOG_ADDR_PLAYBACK_1		4
-#define CEC_LOG_ADDR_AUDIOSYSTEM	5
-#define CEC_LOG_ADDR_TUNER_2		6
-#define CEC_LOG_ADDR_TUNER_3		7
-#define CEC_LOG_ADDR_PLAYBACK_2		8
-#define CEC_LOG_ADDR_RECORD_3		9
-#define CEC_LOG_ADDR_TUNER_4		10
-#define CEC_LOG_ADDR_PLAYBACK_3		11
-#define CEC_LOG_ADDR_BACKUP_1		12
-#define CEC_LOG_ADDR_BACKUP_2		13
-#define CEC_LOG_ADDR_SPECIFIC		14
-#define CEC_LOG_ADDR_UNREGISTERED	15 /* as initiator address */
-#define CEC_LOG_ADDR_BROADCAST		15 /* ad destination address */
+#define CEC_LOG_ADDR_TV         0
+#define CEC_LOG_ADDR_RECORD_1       1
+#define CEC_LOG_ADDR_RECORD_2       2
+#define CEC_LOG_ADDR_TUNER_1        3
+#define CEC_LOG_ADDR_PLAYBACK_1     4
+#define CEC_LOG_ADDR_AUDIOSYSTEM    5
+#define CEC_LOG_ADDR_TUNER_2        6
+#define CEC_LOG_ADDR_TUNER_3        7
+#define CEC_LOG_ADDR_PLAYBACK_2     8
+#define CEC_LOG_ADDR_RECORD_3       9
+#define CEC_LOG_ADDR_TUNER_4        10
+#define CEC_LOG_ADDR_PLAYBACK_3     11
+#define CEC_LOG_ADDR_BACKUP_1       12
+#define CEC_LOG_ADDR_BACKUP_2       13
+#define CEC_LOG_ADDR_SPECIFIC       14
+#define CEC_LOG_ADDR_UNREGISTERED   15 /* as initiator address */
+#define CEC_LOG_ADDR_BROADCAST      15 /* ad destination address */
 
 /* The logical address types that the CEC device wants to claim */
-#define CEC_LOG_ADDR_TYPE_TV		0
-#define CEC_LOG_ADDR_TYPE_RECORD	1
-#define CEC_LOG_ADDR_TYPE_TUNER		2
-#define CEC_LOG_ADDR_TYPE_PLAYBACK	3
-#define CEC_LOG_ADDR_TYPE_AUDIOSYSTEM	4
-#define CEC_LOG_ADDR_TYPE_SPECIFIC	5
-#define CEC_LOG_ADDR_TYPE_UNREGISTERED	6
+#define CEC_LOG_ADDR_TYPE_TV        0
+#define CEC_LOG_ADDR_TYPE_RECORD    1
+#define CEC_LOG_ADDR_TYPE_TUNER     2
+#define CEC_LOG_ADDR_TYPE_PLAYBACK  3
+#define CEC_LOG_ADDR_TYPE_AUDIOSYSTEM   4
+#define CEC_LOG_ADDR_TYPE_SPECIFIC  5
+#define CEC_LOG_ADDR_TYPE_UNREGISTERED  6
 /*
  * Switches should use UNREGISTERED.
  * Processors should use SPECIFIC.
  */
 
-#define CEC_LOG_ADDR_MASK_TV		(1 << CEC_LOG_ADDR_TV)
-#define CEC_LOG_ADDR_MASK_RECORD	((1 << CEC_LOG_ADDR_RECORD_1) | \
-					 (1 << CEC_LOG_ADDR_RECORD_2) | \
-					 (1 << CEC_LOG_ADDR_RECORD_3))
-#define CEC_LOG_ADDR_MASK_TUNER		((1 << CEC_LOG_ADDR_TUNER_1) | \
-					 (1 << CEC_LOG_ADDR_TUNER_2) | \
-					 (1 << CEC_LOG_ADDR_TUNER_3) | \
-					 (1 << CEC_LOG_ADDR_TUNER_4))
-#define CEC_LOG_ADDR_MASK_PLAYBACK	((1 << CEC_LOG_ADDR_PLAYBACK_1) | \
-					 (1 << CEC_LOG_ADDR_PLAYBACK_2) | \
-					 (1 << CEC_LOG_ADDR_PLAYBACK_3))
-#define CEC_LOG_ADDR_MASK_AUDIOSYSTEM	(1 << CEC_LOG_ADDR_AUDIOSYSTEM)
-#define CEC_LOG_ADDR_MASK_BACKUP	((1 << CEC_LOG_ADDR_BACKUP_1) | \
-					 (1 << CEC_LOG_ADDR_BACKUP_2))
-#define CEC_LOG_ADDR_MASK_SPECIFIC	(1 << CEC_LOG_ADDR_SPECIFIC)
-#define CEC_LOG_ADDR_MASK_UNREGISTERED	(1 << CEC_LOG_ADDR_UNREGISTERED)
+#define CEC_LOG_ADDR_MASK_TV        (1 << CEC_LOG_ADDR_TV)
+#define CEC_LOG_ADDR_MASK_RECORD    ((1 << CEC_LOG_ADDR_RECORD_1) | \
+                     (1 << CEC_LOG_ADDR_RECORD_2) | \
+                     (1 << CEC_LOG_ADDR_RECORD_3))
+#define CEC_LOG_ADDR_MASK_TUNER     ((1 << CEC_LOG_ADDR_TUNER_1) | \
+                     (1 << CEC_LOG_ADDR_TUNER_2) | \
+                     (1 << CEC_LOG_ADDR_TUNER_3) | \
+                     (1 << CEC_LOG_ADDR_TUNER_4))
+#define CEC_LOG_ADDR_MASK_PLAYBACK  ((1 << CEC_LOG_ADDR_PLAYBACK_1) | \
+                     (1 << CEC_LOG_ADDR_PLAYBACK_2) | \
+                     (1 << CEC_LOG_ADDR_PLAYBACK_3))
+#define CEC_LOG_ADDR_MASK_AUDIOSYSTEM   (1 << CEC_LOG_ADDR_AUDIOSYSTEM)
+#define CEC_LOG_ADDR_MASK_BACKUP    ((1 << CEC_LOG_ADDR_BACKUP_1) | \
+                     (1 << CEC_LOG_ADDR_BACKUP_2))
+#define CEC_LOG_ADDR_MASK_SPECIFIC  (1 << CEC_LOG_ADDR_SPECIFIC)
+#define CEC_LOG_ADDR_MASK_UNREGISTERED  (1 << CEC_LOG_ADDR_UNREGISTERED)
 
 static inline bool cec_has_tv(__u16 log_addr_mask)
 {
@@ -306,38 +307,38 @@
  * Use this if there is no vendor ID (CEC_G_VENDOR_ID) or if the vendor ID
  * should be disabled (CEC_S_VENDOR_ID)
  */
-#define CEC_VENDOR_ID_NONE		0xffffffff
+#define CEC_VENDOR_ID_NONE      0xffffffff
 
 /* The message handling modes */
 /* Modes for initiator */
-#define CEC_MODE_NO_INITIATOR		(0x0 << 0)
-#define CEC_MODE_INITIATOR		(0x1 << 0)
-#define CEC_MODE_EXCL_INITIATOR		(0x2 << 0)
-#define CEC_MODE_INITIATOR_MSK		0x0f
+#define CEC_MODE_NO_INITIATOR       (0x0 << 0)
+#define CEC_MODE_INITIATOR      (0x1 << 0)
+#define CEC_MODE_EXCL_INITIATOR     (0x2 << 0)
+#define CEC_MODE_INITIATOR_MSK      0x0f
 
 /* Modes for follower */
-#define CEC_MODE_NO_FOLLOWER		(0x0 << 4)
-#define CEC_MODE_FOLLOWER		(0x1 << 4)
-#define CEC_MODE_EXCL_FOLLOWER		(0x2 << 4)
-#define CEC_MODE_EXCL_FOLLOWER_PASSTHRU	(0x3 << 4)
-#define CEC_MODE_MONITOR		(0xe << 4)
-#define CEC_MODE_MONITOR_ALL		(0xf << 4)
-#define CEC_MODE_FOLLOWER_MSK		0xf0
+#define CEC_MODE_NO_FOLLOWER        (0x0 << 4)
+#define CEC_MODE_FOLLOWER       (0x1 << 4)
+#define CEC_MODE_EXCL_FOLLOWER      (0x2 << 4)
+#define CEC_MODE_EXCL_FOLLOWER_PASSTHRU (0x3 << 4)
+#define CEC_MODE_MONITOR        (0xe << 4)
+#define CEC_MODE_MONITOR_ALL        (0xf << 4)
+#define CEC_MODE_FOLLOWER_MSK       0xf0
 
 /* Userspace has to configure the physical address */
-#define CEC_CAP_PHYS_ADDR	(1 << 0)
+#define CEC_CAP_PHYS_ADDR   (1 << 0)
 /* Userspace has to configure the logical addresses */
-#define CEC_CAP_LOG_ADDRS	(1 << 1)
+#define CEC_CAP_LOG_ADDRS   (1 << 1)
 /* Userspace can transmit messages (and thus become follower as well) */
-#define CEC_CAP_TRANSMIT	(1 << 2)
+#define CEC_CAP_TRANSMIT    (1 << 2)
 /*
  * Passthrough all messages instead of processing them.
  */
-#define CEC_CAP_PASSTHROUGH	(1 << 3)
+#define CEC_CAP_PASSTHROUGH (1 << 3)
 /* Supports remote control */
-#define CEC_CAP_RC		(1 << 4)
+#define CEC_CAP_RC      (1 << 4)
 /* Hardware can monitor all messages, not just directed and broadcast. */
-#define CEC_CAP_MONITOR_ALL	(1 << 5)
+#define CEC_CAP_MONITOR_ALL (1 << 5)
 
 /**
  * struct cec_caps - CEC capabilities structure.
@@ -347,7 +348,8 @@
  * @capabilities: capabilities of the CEC adapter.
  * @version: version of the CEC adapter framework.
  */
-struct cec_caps {
+struct cec_caps
+{
 	char driver[32];
 	char name[32];
 	__u32 available_log_addrs;
@@ -360,20 +362,21 @@
  * @log_addr: the claimed logical addresses. Set by the driver.
  * @log_addr_mask: current logical address mask. Set by the driver.
  * @cec_version: the CEC version that the adapter should implement. Set by the
- *	caller.
+ *  caller.
  * @num_log_addrs: how many logical addresses should be claimed. Set by the
- *	caller.
+ *  caller.
  * @vendor_id: the vendor ID of the device. Set by the caller.
  * @flags: flags.
  * @osd_name: the OSD name of the device. Set by the caller.
  * @primary_device_type: the primary device type for each logical address.
- *	Set by the caller.
+ *  Set by the caller.
  * @log_addr_type: the logical address types. Set by the caller.
  * @all_device_types: CEC 2.0: all device types represented by the logical
- *	address. Set by the caller.
- * @features:	CEC 2.0: The logical address features. Set by the caller.
+ *  address. Set by the caller.
+ * @features:   CEC 2.0: The logical address features. Set by the caller.
  */
-struct cec_log_addrs {
+struct cec_log_addrs
+{
 	__u8 log_addr[CEC_MAX_LOG_ADDRS];
 	__u16 log_addr_mask;
 	__u8 cec_version;
@@ -390,26 +393,27 @@
 };
 
 /* Allow a fallback to unregistered */
-#define CEC_LOG_ADDRS_FL_ALLOW_UNREG_FALLBACK	(1 << 0)
+#define CEC_LOG_ADDRS_FL_ALLOW_UNREG_FALLBACK   (1 << 0)
 
 /* Events */
 
 /* Event that occurs when the adapter state changes */
-#define CEC_EVENT_STATE_CHANGE		1
+#define CEC_EVENT_STATE_CHANGE      1
 /*
  * This event is sent when messages are lost because the application
  * didn't empty the message queue in time
  */
-#define CEC_EVENT_LOST_MSGS		2
+#define CEC_EVENT_LOST_MSGS     2
 
-#define CEC_EVENT_FL_INITIAL_STATE	(1 << 0)
+#define CEC_EVENT_FL_INITIAL_STATE  (1 << 0)
 
 /**
  * struct cec_event_state_change - used when the CEC adapter changes state.
  * @phys_addr: the current physical address
  * @log_addr_mask: the current logical address mask
  */
-struct cec_event_state_change {
+struct cec_event_state_change
+{
 	__u16 phys_addr;
 	__u16 log_addr_mask;
 };
@@ -418,7 +422,8 @@
  * struct cec_event_lost_msgs - tells you how many messages were lost due.
  * @lost_msgs: how many messages were lost.
  */
-struct cec_event_lost_msgs {
+struct cec_event_lost_msgs
+{
 	__u32 lost_msgs;
 };
 
@@ -431,11 +436,13 @@
  * @lost_msgs: the event payload for CEC_EVENT_LOST_MSGS.
  * @raw: array to pad the union.
  */
-struct cec_event {
+struct cec_event
+{
 	__u64 ts;
 	__u32 event;
 	__u32 flags;
-	union {
+	union
+	{
 		struct cec_event_state_change state_change;
 		struct cec_event_lost_msgs lost_msgs;
 		__u32 raw[16];
@@ -445,7 +452,7 @@
 /* ioctls */
 
 /* Adapter capabilities */
-#define CEC_ADAP_G_CAPS		_IOWR('a',  0, struct cec_caps)
+#define CEC_ADAP_G_CAPS     _IOWR('a',  0, struct cec_caps)
 
 /*
  * phys_addr is either 0 (if this is the CEC root device)
@@ -459,8 +466,8 @@
  * The CEC_ADAP_S_PHYS_ADDR ioctl may not be available if that is handled
  * internally.
  */
-#define CEC_ADAP_G_PHYS_ADDR	_IOR('a',  1, __u16)
-#define CEC_ADAP_S_PHYS_ADDR	_IOW('a',  2, __u16)
+#define CEC_ADAP_G_PHYS_ADDR    _IOR('a',  1, __u16)
+#define CEC_ADAP_S_PHYS_ADDR    _IOW('a',  2, __u16)
 
 /*
  * Configure the CEC adapter. It sets the device type and which
@@ -470,21 +477,21 @@
  * is no physical address assigned.
  */
 
-#define CEC_ADAP_G_LOG_ADDRS	_IOR('a',  3, struct cec_log_addrs)
-#define CEC_ADAP_S_LOG_ADDRS	_IOWR('a',  4, struct cec_log_addrs)
+#define CEC_ADAP_G_LOG_ADDRS    _IOR('a',  3, struct cec_log_addrs)
+#define CEC_ADAP_S_LOG_ADDRS    _IOWR('a',  4, struct cec_log_addrs)
 
 /* Transmit/receive a CEC command */
-#define CEC_TRANSMIT		_IOWR('a',  5, struct cec_msg)
-#define CEC_RECEIVE		_IOWR('a',  6, struct cec_msg)
+#define CEC_TRANSMIT        _IOWR('a',  5, struct cec_msg)
+#define CEC_RECEIVE     _IOWR('a',  6, struct cec_msg)
 
 /* Dequeue CEC events */
-#define CEC_DQEVENT		_IOWR('a',  7, struct cec_event)
+#define CEC_DQEVENT     _IOWR('a',  7, struct cec_event)
 
 /*
  * Get and set the message handling mode for this filehandle.
  */
-#define CEC_G_MODE		_IOR('a',  8, __u32)
-#define CEC_S_MODE		_IOW('a',  9, __u32)
+#define CEC_G_MODE      _IOR('a',  8, __u32)
+#define CEC_S_MODE      _IOW('a',  9, __u32)
 
 /*
  * The remainder of this header defines all CEC messages and operands.
@@ -504,511 +511,511 @@
 /* Messages */
 
 /* One Touch Play Feature */
-#define CEC_MSG_ACTIVE_SOURCE				0x82
-#define CEC_MSG_IMAGE_VIEW_ON				0x04
-#define CEC_MSG_TEXT_VIEW_ON				0x0d
+#define CEC_MSG_ACTIVE_SOURCE               0x82
+#define CEC_MSG_IMAGE_VIEW_ON               0x04
+#define CEC_MSG_TEXT_VIEW_ON                0x0d
 
 
 /* Routing Control Feature */
 
 /*
  * Has also:
- *	CEC_MSG_ACTIVE_SOURCE
+ *  CEC_MSG_ACTIVE_SOURCE
  */
 
-#define CEC_MSG_INACTIVE_SOURCE				0x9d
-#define CEC_MSG_REQUEST_ACTIVE_SOURCE			0x85
-#define CEC_MSG_ROUTING_CHANGE				0x80
-#define CEC_MSG_ROUTING_INFORMATION			0x81
-#define CEC_MSG_SET_STREAM_PATH				0x86
+#define CEC_MSG_INACTIVE_SOURCE             0x9d
+#define CEC_MSG_REQUEST_ACTIVE_SOURCE           0x85
+#define CEC_MSG_ROUTING_CHANGE              0x80
+#define CEC_MSG_ROUTING_INFORMATION         0x81
+#define CEC_MSG_SET_STREAM_PATH             0x86
 
 
 /* Standby Feature */
-#define CEC_MSG_STANDBY					0x36
+#define CEC_MSG_STANDBY                 0x36
 
 
 /* One Touch Record Feature */
-#define CEC_MSG_RECORD_OFF				0x0b
-#define CEC_MSG_RECORD_ON				0x09
+#define CEC_MSG_RECORD_OFF              0x0b
+#define CEC_MSG_RECORD_ON               0x09
 /* Record Source Type Operand (rec_src_type) */
-#define CEC_OP_RECORD_SRC_OWN				1
-#define CEC_OP_RECORD_SRC_DIGITAL			2
-#define CEC_OP_RECORD_SRC_ANALOG			3
-#define CEC_OP_RECORD_SRC_EXT_PLUG			4
-#define CEC_OP_RECORD_SRC_EXT_PHYS_ADDR			5
+#define CEC_OP_RECORD_SRC_OWN               1
+#define CEC_OP_RECORD_SRC_DIGITAL           2
+#define CEC_OP_RECORD_SRC_ANALOG            3
+#define CEC_OP_RECORD_SRC_EXT_PLUG          4
+#define CEC_OP_RECORD_SRC_EXT_PHYS_ADDR         5
 /* Service Identification Method Operand (service_id_method) */
-#define CEC_OP_SERVICE_ID_METHOD_BY_DIG_ID		0
-#define CEC_OP_SERVICE_ID_METHOD_BY_CHANNEL		1
+#define CEC_OP_SERVICE_ID_METHOD_BY_DIG_ID      0
+#define CEC_OP_SERVICE_ID_METHOD_BY_CHANNEL     1
 /* Digital Service Broadcast System Operand (dig_bcast_system) */
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_GEN	0x00
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_GEN	0x01
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_GEN		0x02
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_BS		0x08
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_CS		0x09
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_T		0x0a
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_CABLE	0x10
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_SAT	0x11
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_T		0x12
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_C		0x18
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_S		0x19
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_S2		0x1a
-#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_T		0x1b
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_GEN    0x00
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_GEN    0x01
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_GEN     0x02
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_BS     0x08
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_CS     0x09
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_T      0x0a
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_CABLE  0x10
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_SAT    0x11
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_T      0x12
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_C       0x18
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_S       0x19
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_S2      0x1a
+#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_T       0x1b
 /* Analogue Broadcast Type Operand (ana_bcast_type) */
-#define CEC_OP_ANA_BCAST_TYPE_CABLE			0
-#define CEC_OP_ANA_BCAST_TYPE_SATELLITE			1
-#define CEC_OP_ANA_BCAST_TYPE_TERRESTRIAL		2
+#define CEC_OP_ANA_BCAST_TYPE_CABLE         0
+#define CEC_OP_ANA_BCAST_TYPE_SATELLITE         1
+#define CEC_OP_ANA_BCAST_TYPE_TERRESTRIAL       2
 /* Broadcast System Operand (bcast_system) */
-#define CEC_OP_BCAST_SYSTEM_PAL_BG			0x00
-#define CEC_OP_BCAST_SYSTEM_SECAM_LQ			0x01 /* SECAM L' */
-#define CEC_OP_BCAST_SYSTEM_PAL_M			0x02
-#define CEC_OP_BCAST_SYSTEM_NTSC_M			0x03
-#define CEC_OP_BCAST_SYSTEM_PAL_I			0x04
-#define CEC_OP_BCAST_SYSTEM_SECAM_DK			0x05
-#define CEC_OP_BCAST_SYSTEM_SECAM_BG			0x06
-#define CEC_OP_BCAST_SYSTEM_SECAM_L			0x07
-#define CEC_OP_BCAST_SYSTEM_PAL_DK			0x08
-#define CEC_OP_BCAST_SYSTEM_OTHER			0x1f
+#define CEC_OP_BCAST_SYSTEM_PAL_BG          0x00
+#define CEC_OP_BCAST_SYSTEM_SECAM_LQ            0x01 /* SECAM L' */
+#define CEC_OP_BCAST_SYSTEM_PAL_M           0x02
+#define CEC_OP_BCAST_SYSTEM_NTSC_M          0x03
+#define CEC_OP_BCAST_SYSTEM_PAL_I           0x04
+#define CEC_OP_BCAST_SYSTEM_SECAM_DK            0x05
+#define CEC_OP_BCAST_SYSTEM_SECAM_BG            0x06
+#define CEC_OP_BCAST_SYSTEM_SECAM_L         0x07
+#define CEC_OP_BCAST_SYSTEM_PAL_DK          0x08
+#define CEC_OP_BCAST_SYSTEM_OTHER           0x1f
 /* Channel Number Format Operand (channel_number_fmt) */
-#define CEC_OP_CHANNEL_NUMBER_FMT_1_PART		0x01
-#define CEC_OP_CHANNEL_NUMBER_FMT_2_PART		0x02
+#define CEC_OP_CHANNEL_NUMBER_FMT_1_PART        0x01
+#define CEC_OP_CHANNEL_NUMBER_FMT_2_PART        0x02
 
-#define CEC_MSG_RECORD_STATUS				0x0a
+#define CEC_MSG_RECORD_STATUS               0x0a
 /* Record Status Operand (rec_status) */
-#define CEC_OP_RECORD_STATUS_CUR_SRC			0x01
-#define CEC_OP_RECORD_STATUS_DIG_SERVICE		0x02
-#define CEC_OP_RECORD_STATUS_ANA_SERVICE		0x03
-#define CEC_OP_RECORD_STATUS_EXT_INPUT			0x04
-#define CEC_OP_RECORD_STATUS_NO_DIG_SERVICE		0x05
-#define CEC_OP_RECORD_STATUS_NO_ANA_SERVICE		0x06
-#define CEC_OP_RECORD_STATUS_NO_SERVICE			0x07
-#define CEC_OP_RECORD_STATUS_INVALID_EXT_PLUG		0x09
-#define CEC_OP_RECORD_STATUS_INVALID_EXT_PHYS_ADDR	0x0a
-#define CEC_OP_RECORD_STATUS_UNSUP_CA			0x0b
-#define CEC_OP_RECORD_STATUS_NO_CA_ENTITLEMENTS		0x0c
-#define CEC_OP_RECORD_STATUS_CANT_COPY_SRC		0x0d
-#define CEC_OP_RECORD_STATUS_NO_MORE_COPIES		0x0e
-#define CEC_OP_RECORD_STATUS_NO_MEDIA			0x10
-#define CEC_OP_RECORD_STATUS_PLAYING			0x11
-#define CEC_OP_RECORD_STATUS_ALREADY_RECORDING		0x12
-#define CEC_OP_RECORD_STATUS_MEDIA_PROT			0x13
-#define CEC_OP_RECORD_STATUS_NO_SIGNAL			0x14
-#define CEC_OP_RECORD_STATUS_MEDIA_PROBLEM		0x15
-#define CEC_OP_RECORD_STATUS_NO_SPACE			0x16
-#define CEC_OP_RECORD_STATUS_PARENTAL_LOCK		0x17
-#define CEC_OP_RECORD_STATUS_TERMINATED_OK		0x1a
-#define CEC_OP_RECORD_STATUS_ALREADY_TERM		0x1b
-#define CEC_OP_RECORD_STATUS_OTHER			0x1f
+#define CEC_OP_RECORD_STATUS_CUR_SRC            0x01
+#define CEC_OP_RECORD_STATUS_DIG_SERVICE        0x02
+#define CEC_OP_RECORD_STATUS_ANA_SERVICE        0x03
+#define CEC_OP_RECORD_STATUS_EXT_INPUT          0x04
+#define CEC_OP_RECORD_STATUS_NO_DIG_SERVICE     0x05
+#define CEC_OP_RECORD_STATUS_NO_ANA_SERVICE     0x06
+#define CEC_OP_RECORD_STATUS_NO_SERVICE         0x07
+#define CEC_OP_RECORD_STATUS_INVALID_EXT_PLUG       0x09
+#define CEC_OP_RECORD_STATUS_INVALID_EXT_PHYS_ADDR  0x0a
+#define CEC_OP_RECORD_STATUS_UNSUP_CA           0x0b
+#define CEC_OP_RECORD_STATUS_NO_CA_ENTITLEMENTS     0x0c
+#define CEC_OP_RECORD_STATUS_CANT_COPY_SRC      0x0d
+#define CEC_OP_RECORD_STATUS_NO_MORE_COPIES     0x0e
+#define CEC_OP_RECORD_STATUS_NO_MEDIA           0x10
+#define CEC_OP_RECORD_STATUS_PLAYING            0x11
+#define CEC_OP_RECORD_STATUS_ALREADY_RECORDING      0x12
+#define CEC_OP_RECORD_STATUS_MEDIA_PROT         0x13
+#define CEC_OP_RECORD_STATUS_NO_SIGNAL          0x14
+#define CEC_OP_RECORD_STATUS_MEDIA_PROBLEM      0x15
+#define CEC_OP_RECORD_STATUS_NO_SPACE           0x16
+#define CEC_OP_RECORD_STATUS_PARENTAL_LOCK      0x17
+#define CEC_OP_RECORD_STATUS_TERMINATED_OK      0x1a
+#define CEC_OP_RECORD_STATUS_ALREADY_TERM       0x1b
+#define CEC_OP_RECORD_STATUS_OTHER          0x1f
 
-#define CEC_MSG_RECORD_TV_SCREEN			0x0f
+#define CEC_MSG_RECORD_TV_SCREEN            0x0f
 
 
 /* Timer Programming Feature */
-#define CEC_MSG_CLEAR_ANALOGUE_TIMER			0x33
+#define CEC_MSG_CLEAR_ANALOGUE_TIMER            0x33
 /* Recording Sequence Operand (recording_seq) */
-#define CEC_OP_REC_SEQ_SUNDAY				0x01
-#define CEC_OP_REC_SEQ_MONDAY				0x02
-#define CEC_OP_REC_SEQ_TUESDAY				0x04
-#define CEC_OP_REC_SEQ_WEDNESDAY			0x08
-#define CEC_OP_REC_SEQ_THURSDAY				0x10
-#define CEC_OP_REC_SEQ_FRIDAY				0x20
-#define CEC_OP_REC_SEQ_SATERDAY				0x40
-#define CEC_OP_REC_SEQ_ONCE_ONLY			0x00
+#define CEC_OP_REC_SEQ_SUNDAY               0x01
+#define CEC_OP_REC_SEQ_MONDAY               0x02
+#define CEC_OP_REC_SEQ_TUESDAY              0x04
+#define CEC_OP_REC_SEQ_WEDNESDAY            0x08
+#define CEC_OP_REC_SEQ_THURSDAY             0x10
+#define CEC_OP_REC_SEQ_FRIDAY               0x20
+#define CEC_OP_REC_SEQ_SATERDAY             0x40
+#define CEC_OP_REC_SEQ_ONCE_ONLY            0x00
 
-#define CEC_MSG_CLEAR_DIGITAL_TIMER			0x99
+#define CEC_MSG_CLEAR_DIGITAL_TIMER         0x99
 
-#define CEC_MSG_CLEAR_EXT_TIMER				0xa1
+#define CEC_MSG_CLEAR_EXT_TIMER             0xa1
 /* External Source Specifier Operand (ext_src_spec) */
-#define CEC_OP_EXT_SRC_PLUG				0x04
-#define CEC_OP_EXT_SRC_PHYS_ADDR			0x05
+#define CEC_OP_EXT_SRC_PLUG             0x04
+#define CEC_OP_EXT_SRC_PHYS_ADDR            0x05
 
-#define CEC_MSG_SET_ANALOGUE_TIMER			0x34
-#define CEC_MSG_SET_DIGITAL_TIMER			0x97
-#define CEC_MSG_SET_EXT_TIMER				0xa2
+#define CEC_MSG_SET_ANALOGUE_TIMER          0x34
+#define CEC_MSG_SET_DIGITAL_TIMER           0x97
+#define CEC_MSG_SET_EXT_TIMER               0xa2
 
-#define CEC_MSG_SET_TIMER_PROGRAM_TITLE			0x67
-#define CEC_MSG_TIMER_CLEARED_STATUS			0x43
+#define CEC_MSG_SET_TIMER_PROGRAM_TITLE         0x67
+#define CEC_MSG_TIMER_CLEARED_STATUS            0x43
 /* Timer Cleared Status Data Operand (timer_cleared_status) */
-#define CEC_OP_TIMER_CLR_STAT_RECORDING			0x00
-#define CEC_OP_TIMER_CLR_STAT_NO_MATCHING		0x01
-#define CEC_OP_TIMER_CLR_STAT_NO_INFO			0x02
-#define CEC_OP_TIMER_CLR_STAT_CLEARED			0x80
+#define CEC_OP_TIMER_CLR_STAT_RECORDING         0x00
+#define CEC_OP_TIMER_CLR_STAT_NO_MATCHING       0x01
+#define CEC_OP_TIMER_CLR_STAT_NO_INFO           0x02
+#define CEC_OP_TIMER_CLR_STAT_CLEARED           0x80
 
-#define CEC_MSG_TIMER_STATUS				0x35
+#define CEC_MSG_TIMER_STATUS                0x35
 /* Timer Overlap Warning Operand (timer_overlap_warning) */
-#define CEC_OP_TIMER_OVERLAP_WARNING_NO_OVERLAP		0
-#define CEC_OP_TIMER_OVERLAP_WARNING_OVERLAP		1
+#define CEC_OP_TIMER_OVERLAP_WARNING_NO_OVERLAP     0
+#define CEC_OP_TIMER_OVERLAP_WARNING_OVERLAP        1
 /* Media Info Operand (media_info) */
-#define CEC_OP_MEDIA_INFO_UNPROT_MEDIA			0
-#define CEC_OP_MEDIA_INFO_PROT_MEDIA			1
-#define CEC_OP_MEDIA_INFO_NO_MEDIA			2
+#define CEC_OP_MEDIA_INFO_UNPROT_MEDIA          0
+#define CEC_OP_MEDIA_INFO_PROT_MEDIA            1
+#define CEC_OP_MEDIA_INFO_NO_MEDIA          2
 /* Programmed Indicator Operand (prog_indicator) */
-#define CEC_OP_PROG_IND_NOT_PROGRAMMED			0
-#define CEC_OP_PROG_IND_PROGRAMMED			1
+#define CEC_OP_PROG_IND_NOT_PROGRAMMED          0
+#define CEC_OP_PROG_IND_PROGRAMMED          1
 /* Programmed Info Operand (prog_info) */
-#define CEC_OP_PROG_INFO_ENOUGH_SPACE			0x08
-#define CEC_OP_PROG_INFO_NOT_ENOUGH_SPACE		0x09
-#define CEC_OP_PROG_INFO_MIGHT_NOT_BE_ENOUGH_SPACE	0x0b
-#define CEC_OP_PROG_INFO_NONE_AVAILABLE			0x0a
+#define CEC_OP_PROG_INFO_ENOUGH_SPACE           0x08
+#define CEC_OP_PROG_INFO_NOT_ENOUGH_SPACE       0x09
+#define CEC_OP_PROG_INFO_MIGHT_NOT_BE_ENOUGH_SPACE  0x0b
+#define CEC_OP_PROG_INFO_NONE_AVAILABLE         0x0a
 /* Not Programmed Error Info Operand (prog_error) */
-#define CEC_OP_PROG_ERROR_NO_FREE_TIMER			0x01
-#define CEC_OP_PROG_ERROR_DATE_OUT_OF_RANGE		0x02
-#define CEC_OP_PROG_ERROR_REC_SEQ_ERROR			0x03
-#define CEC_OP_PROG_ERROR_INV_EXT_PLUG			0x04
-#define CEC_OP_PROG_ERROR_INV_EXT_PHYS_ADDR		0x05
-#define CEC_OP_PROG_ERROR_CA_UNSUPP			0x06
-#define CEC_OP_PROG_ERROR_INSUF_CA_ENTITLEMENTS		0x07
-#define CEC_OP_PROG_ERROR_RESOLUTION_UNSUPP		0x08
-#define CEC_OP_PROG_ERROR_PARENTAL_LOCK			0x09
-#define CEC_OP_PROG_ERROR_CLOCK_FAILURE			0x0a
-#define CEC_OP_PROG_ERROR_DUPLICATE			0x0e
+#define CEC_OP_PROG_ERROR_NO_FREE_TIMER         0x01
+#define CEC_OP_PROG_ERROR_DATE_OUT_OF_RANGE     0x02
+#define CEC_OP_PROG_ERROR_REC_SEQ_ERROR         0x03
+#define CEC_OP_PROG_ERROR_INV_EXT_PLUG          0x04
+#define CEC_OP_PROG_ERROR_INV_EXT_PHYS_ADDR     0x05
+#define CEC_OP_PROG_ERROR_CA_UNSUPP         0x06
+#define CEC_OP_PROG_ERROR_INSUF_CA_ENTITLEMENTS     0x07
+#define CEC_OP_PROG_ERROR_RESOLUTION_UNSUPP     0x08
+#define CEC_OP_PROG_ERROR_PARENTAL_LOCK         0x09
+#define CEC_OP_PROG_ERROR_CLOCK_FAILURE         0x0a
+#define CEC_OP_PROG_ERROR_DUPLICATE         0x0e
 
 
 /* System Information Feature */
-#define CEC_MSG_CEC_VERSION				0x9e
+#define CEC_MSG_CEC_VERSION             0x9e
 /* CEC Version Operand (cec_version) */
-#define CEC_OP_CEC_VERSION_1_3A				4
-#define CEC_OP_CEC_VERSION_1_4				5
-#define CEC_OP_CEC_VERSION_2_0				6
-
-#define CEC_MSG_GET_CEC_VERSION				0x9f
-#define CEC_MSG_GIVE_PHYSICAL_ADDR			0x83
-#define CEC_MSG_GET_MENU_LANGUAGE			0x91
-#define CEC_MSG_REPORT_PHYSICAL_ADDR			0x84
+#define CEC_OP_CEC_VERSION_1_3A             4
+#define CEC_OP_CEC_VERSION_1_4              5
+#define CEC_OP_CEC_VERSION_2_0              6
+
+#define CEC_MSG_GET_CEC_VERSION             0x9f
+#define CEC_MSG_GIVE_PHYSICAL_ADDR          0x83
+#define CEC_MSG_GET_MENU_LANGUAGE           0x91
+#define CEC_MSG_REPORT_PHYSICAL_ADDR            0x84
 /* Primary Device Type Operand (prim_devtype) */
-#define CEC_OP_PRIM_DEVTYPE_TV				0
-#define CEC_OP_PRIM_DEVTYPE_RECORD			1
-#define CEC_OP_PRIM_DEVTYPE_TUNER			3
-#define CEC_OP_PRIM_DEVTYPE_PLAYBACK			4
-#define CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM			5
-#define CEC_OP_PRIM_DEVTYPE_SWITCH			6
-#define CEC_OP_PRIM_DEVTYPE_PROCESSOR			7
+#define CEC_OP_PRIM_DEVTYPE_TV              0
+#define CEC_OP_PRIM_DEVTYPE_RECORD          1
+#define CEC_OP_PRIM_DEVTYPE_TUNER           3
+#define CEC_OP_PRIM_DEVTYPE_PLAYBACK            4
+#define CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM         5
+#define CEC_OP_PRIM_DEVTYPE_SWITCH          6
+#define CEC_OP_PRIM_DEVTYPE_PROCESSOR           7
 
-#define CEC_MSG_SET_MENU_LANGUAGE			0x32
-#define CEC_MSG_REPORT_FEATURES				0xa6	/* HDMI 2.0 */
+#define CEC_MSG_SET_MENU_LANGUAGE           0x32
+#define CEC_MSG_REPORT_FEATURES             0xa6    /* HDMI 2.0 */
 /* All Device Types Operand (all_device_types) */
-#define CEC_OP_ALL_DEVTYPE_TV				0x80
-#define CEC_OP_ALL_DEVTYPE_RECORD			0x40
-#define CEC_OP_ALL_DEVTYPE_TUNER			0x20
-#define CEC_OP_ALL_DEVTYPE_PLAYBACK			0x10
-#define CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM			0x08
-#define CEC_OP_ALL_DEVTYPE_SWITCH			0x04
+#define CEC_OP_ALL_DEVTYPE_TV               0x80
+#define CEC_OP_ALL_DEVTYPE_RECORD           0x40
+#define CEC_OP_ALL_DEVTYPE_TUNER            0x20
+#define CEC_OP_ALL_DEVTYPE_PLAYBACK         0x10
+#define CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM          0x08
+#define CEC_OP_ALL_DEVTYPE_SWITCH           0x04
 /*
  * And if you wondering what happened to PROCESSOR devices: those should
  * be mapped to a SWITCH.
  */
 
 /* Valid for RC Profile and Device Feature operands */
-#define CEC_OP_FEAT_EXT					0x80	/* Extension bit */
+#define CEC_OP_FEAT_EXT                 0x80    /* Extension bit */
 /* RC Profile Operand (rc_profile) */
-#define CEC_OP_FEAT_RC_TV_PROFILE_NONE			0x00
-#define CEC_OP_FEAT_RC_TV_PROFILE_1			0x02
-#define CEC_OP_FEAT_RC_TV_PROFILE_2			0x06
-#define CEC_OP_FEAT_RC_TV_PROFILE_3			0x0a
-#define CEC_OP_FEAT_RC_TV_PROFILE_4			0x0e
-#define CEC_OP_FEAT_RC_SRC_HAS_DEV_ROOT_MENU		0x50
-#define CEC_OP_FEAT_RC_SRC_HAS_DEV_SETUP_MENU		0x48
-#define CEC_OP_FEAT_RC_SRC_HAS_CONTENTS_MENU		0x44
-#define CEC_OP_FEAT_RC_SRC_HAS_MEDIA_TOP_MENU		0x42
-#define CEC_OP_FEAT_RC_SRC_HAS_MEDIA_CONTEXT_MENU	0x41
+#define CEC_OP_FEAT_RC_TV_PROFILE_NONE          0x00
+#define CEC_OP_FEAT_RC_TV_PROFILE_1         0x02
+#define CEC_OP_FEAT_RC_TV_PROFILE_2         0x06
+#define CEC_OP_FEAT_RC_TV_PROFILE_3         0x0a
+#define CEC_OP_FEAT_RC_TV_PROFILE_4         0x0e
+#define CEC_OP_FEAT_RC_SRC_HAS_DEV_ROOT_MENU        0x50
+#define CEC_OP_FEAT_RC_SRC_HAS_DEV_SETUP_MENU       0x48
+#define CEC_OP_FEAT_RC_SRC_HAS_CONTENTS_MENU        0x44
+#define CEC_OP_FEAT_RC_SRC_HAS_MEDIA_TOP_MENU       0x42
+#define CEC_OP_FEAT_RC_SRC_HAS_MEDIA_CONTEXT_MENU   0x41
 /* Device Feature Operand (dev_features) */
-#define CEC_OP_FEAT_DEV_HAS_RECORD_TV_SCREEN		0x40
-#define CEC_OP_FEAT_DEV_HAS_SET_OSD_STRING		0x20
-#define CEC_OP_FEAT_DEV_HAS_DECK_CONTROL		0x10
-#define CEC_OP_FEAT_DEV_HAS_SET_AUDIO_RATE		0x08
-#define CEC_OP_FEAT_DEV_SINK_HAS_ARC_TX			0x04
-#define CEC_OP_FEAT_DEV_SOURCE_HAS_ARC_RX		0x02
+#define CEC_OP_FEAT_DEV_HAS_RECORD_TV_SCREEN        0x40
+#define CEC_OP_FEAT_DEV_HAS_SET_OSD_STRING      0x20
+#define CEC_OP_FEAT_DEV_HAS_DECK_CONTROL        0x10
+#define CEC_OP_FEAT_DEV_HAS_SET_AUDIO_RATE      0x08
+#define CEC_OP_FEAT_DEV_SINK_HAS_ARC_TX         0x04
+#define CEC_OP_FEAT_DEV_SOURCE_HAS_ARC_RX       0x02
 
-#define CEC_MSG_GIVE_FEATURES				0xa5	/* HDMI 2.0 */
+#define CEC_MSG_GIVE_FEATURES               0xa5    /* HDMI 2.0 */
 
 
 /* Deck Control Feature */
-#define CEC_MSG_DECK_CONTROL				0x42
+#define CEC_MSG_DECK_CONTROL                0x42
 /* Deck Control Mode Operand (deck_control_mode) */
-#define CEC_OP_DECK_CTL_MODE_SKIP_FWD			1
-#define CEC_OP_DECK_CTL_MODE_SKIP_REV			2
-#define CEC_OP_DECK_CTL_MODE_STOP			3
-#define CEC_OP_DECK_CTL_MODE_EJECT			4
+#define CEC_OP_DECK_CTL_MODE_SKIP_FWD           1
+#define CEC_OP_DECK_CTL_MODE_SKIP_REV           2
+#define CEC_OP_DECK_CTL_MODE_STOP           3
+#define CEC_OP_DECK_CTL_MODE_EJECT          4
 
-#define CEC_MSG_DECK_STATUS				0x1b
+#define CEC_MSG_DECK_STATUS             0x1b
 /* Deck Info Operand (deck_info) */
-#define CEC_OP_DECK_INFO_PLAY				0x11
-#define CEC_OP_DECK_INFO_RECORD				0x12
-#define CEC_OP_DECK_INFO_PLAY_REV			0x13
-#define CEC_OP_DECK_INFO_STILL				0x14
-#define CEC_OP_DECK_INFO_SLOW				0x15
-#define CEC_OP_DECK_INFO_SLOW_REV			0x16
-#define CEC_OP_DECK_INFO_FAST_FWD			0x17
-#define CEC_OP_DECK_INFO_FAST_REV			0x18
-#define CEC_OP_DECK_INFO_NO_MEDIA			0x19
-#define CEC_OP_DECK_INFO_STOP				0x1a
-#define CEC_OP_DECK_INFO_SKIP_FWD			0x1b
-#define CEC_OP_DECK_INFO_SKIP_REV			0x1c
-#define CEC_OP_DECK_INFO_INDEX_SEARCH_FWD		0x1d
-#define CEC_OP_DECK_INFO_INDEX_SEARCH_REV		0x1e
-#define CEC_OP_DECK_INFO_OTHER				0x1f
+#define CEC_OP_DECK_INFO_PLAY               0x11
+#define CEC_OP_DECK_INFO_RECORD             0x12
+#define CEC_OP_DECK_INFO_PLAY_REV           0x13
+#define CEC_OP_DECK_INFO_STILL              0x14
+#define CEC_OP_DECK_INFO_SLOW               0x15
+#define CEC_OP_DECK_INFO_SLOW_REV           0x16
+#define CEC_OP_DECK_INFO_FAST_FWD           0x17
+#define CEC_OP_DECK_INFO_FAST_REV           0x18
+#define CEC_OP_DECK_INFO_NO_MEDIA           0x19
+#define CEC_OP_DECK_INFO_STOP               0x1a
+#define CEC_OP_DECK_INFO_SKIP_FWD           0x1b
+#define CEC_OP_DECK_INFO_SKIP_REV           0x1c
+#define CEC_OP_DECK_INFO_INDEX_SEARCH_FWD       0x1d
+#define CEC_OP_DECK_INFO_INDEX_SEARCH_REV       0x1e
+#define CEC_OP_DECK_INFO_OTHER              0x1f
 
-#define CEC_MSG_GIVE_DECK_STATUS			0x1a
+#define CEC_MSG_GIVE_DECK_STATUS            0x1a
 /* Status Request Operand (status_req) */
-#define CEC_OP_STATUS_REQ_ON				1
-#define CEC_OP_STATUS_REQ_OFF				2
-#define CEC_OP_STATUS_REQ_ONCE				3
+#define CEC_OP_STATUS_REQ_ON                1
+#define CEC_OP_STATUS_REQ_OFF               2
+#define CEC_OP_STATUS_REQ_ONCE              3
 
-#define CEC_MSG_PLAY					0x41
+#define CEC_MSG_PLAY                    0x41
 /* Play Mode Operand (play_mode) */
-#define CEC_OP_PLAY_MODE_PLAY_FWD			0x24
-#define CEC_OP_PLAY_MODE_PLAY_REV			0x20
-#define CEC_OP_PLAY_MODE_PLAY_STILL			0x25
-#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MIN		0x05
-#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MED		0x06
-#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MAX		0x07
-#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MIN		0x09
-#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MED		0x0a
-#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MAX		0x0b
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MIN		0x15
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MED		0x16
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MAX		0x17
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MIN		0x19
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MED		0x1a
-#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MAX		0x1b
+#define CEC_OP_PLAY_MODE_PLAY_FWD           0x24
+#define CEC_OP_PLAY_MODE_PLAY_REV           0x20
+#define CEC_OP_PLAY_MODE_PLAY_STILL         0x25
+#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MIN      0x05
+#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MED      0x06
+#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MAX      0x07
+#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MIN      0x09
+#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MED      0x0a
+#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MAX      0x0b
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MIN      0x15
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MED      0x16
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MAX      0x17
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MIN      0x19
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MED      0x1a
+#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MAX      0x1b
 
 
 /* Tuner Control Feature */
-#define CEC_MSG_GIVE_TUNER_DEVICE_STATUS		0x08
-#define CEC_MSG_SELECT_ANALOGUE_SERVICE			0x92
-#define CEC_MSG_SELECT_DIGITAL_SERVICE			0x93
-#define CEC_MSG_TUNER_DEVICE_STATUS			0x07
+#define CEC_MSG_GIVE_TUNER_DEVICE_STATUS        0x08
+#define CEC_MSG_SELECT_ANALOGUE_SERVICE         0x92
+#define CEC_MSG_SELECT_DIGITAL_SERVICE          0x93
+#define CEC_MSG_TUNER_DEVICE_STATUS         0x07
 /* Recording Flag Operand (rec_flag) */
-#define CEC_OP_REC_FLAG_USED				0
-#define CEC_OP_REC_FLAG_NOT_USED			1
+#define CEC_OP_REC_FLAG_USED                0
+#define CEC_OP_REC_FLAG_NOT_USED            1
 /* Tuner Display Info Operand (tuner_display_info) */
-#define CEC_OP_TUNER_DISPLAY_INFO_DIGITAL		0
-#define CEC_OP_TUNER_DISPLAY_INFO_NONE			1
-#define CEC_OP_TUNER_DISPLAY_INFO_ANALOGUE		2
+#define CEC_OP_TUNER_DISPLAY_INFO_DIGITAL       0
+#define CEC_OP_TUNER_DISPLAY_INFO_NONE          1
+#define CEC_OP_TUNER_DISPLAY_INFO_ANALOGUE      2
 
-#define CEC_MSG_TUNER_STEP_DECREMENT			0x06
-#define CEC_MSG_TUNER_STEP_INCREMENT			0x05
+#define CEC_MSG_TUNER_STEP_DECREMENT            0x06
+#define CEC_MSG_TUNER_STEP_INCREMENT            0x05
 
 
 /* Vendor Specific Commands Feature */
 
 /*
  * Has also:
- *	CEC_MSG_CEC_VERSION
- *	CEC_MSG_GET_CEC_VERSION
+ *  CEC_MSG_CEC_VERSION
+ *  CEC_MSG_GET_CEC_VERSION
  */
-#define CEC_MSG_DEVICE_VENDOR_ID			0x87
-#define CEC_MSG_GIVE_DEVICE_VENDOR_ID			0x8c
-#define CEC_MSG_VENDOR_COMMAND				0x89
-#define CEC_MSG_VENDOR_COMMAND_WITH_ID			0xa0
-#define CEC_MSG_VENDOR_REMOTE_BUTTON_DOWN		0x8a
-#define CEC_MSG_VENDOR_REMOTE_BUTTON_UP			0x8b
+#define CEC_MSG_DEVICE_VENDOR_ID            0x87
+#define CEC_MSG_GIVE_DEVICE_VENDOR_ID           0x8c
+#define CEC_MSG_VENDOR_COMMAND              0x89
+#define CEC_MSG_VENDOR_COMMAND_WITH_ID          0xa0
+#define CEC_MSG_VENDOR_REMOTE_BUTTON_DOWN       0x8a
+#define CEC_MSG_VENDOR_REMOTE_BUTTON_UP         0x8b
 
 
 /* OSD Display Feature */
-#define CEC_MSG_SET_OSD_STRING				0x64
+#define CEC_MSG_SET_OSD_STRING              0x64
 /* Display Control Operand (disp_ctl) */
-#define CEC_OP_DISP_CTL_DEFAULT				0x00
-#define CEC_OP_DISP_CTL_UNTIL_CLEARED			0x40
-#define CEC_OP_DISP_CTL_CLEAR				0x80
+#define CEC_OP_DISP_CTL_DEFAULT             0x00
+#define CEC_OP_DISP_CTL_UNTIL_CLEARED           0x40
+#define CEC_OP_DISP_CTL_CLEAR               0x80
 
 
 /* Device OSD Transfer Feature */
-#define CEC_MSG_GIVE_OSD_NAME				0x46
-#define CEC_MSG_SET_OSD_NAME				0x47
+#define CEC_MSG_GIVE_OSD_NAME               0x46
+#define CEC_MSG_SET_OSD_NAME                0x47
 
 
 /* Device Menu Control Feature */
-#define CEC_MSG_MENU_REQUEST				0x8d
+#define CEC_MSG_MENU_REQUEST                0x8d
 /* Menu Request Type Operand (menu_req) */
-#define CEC_OP_MENU_REQUEST_ACTIVATE			0x00
-#define CEC_OP_MENU_REQUEST_DEACTIVATE			0x01
-#define CEC_OP_MENU_REQUEST_QUERY			0x02
+#define CEC_OP_MENU_REQUEST_ACTIVATE            0x00
+#define CEC_OP_MENU_REQUEST_DEACTIVATE          0x01
+#define CEC_OP_MENU_REQUEST_QUERY           0x02
 
-#define CEC_MSG_MENU_STATUS				0x8e
+#define CEC_MSG_MENU_STATUS             0x8e
 /* Menu State Operand (menu_state) */
-#define CEC_OP_MENU_STATE_ACTIVATED			0x00
-#define CEC_OP_MENU_STATE_DEACTIVATED			0x01
+#define CEC_OP_MENU_STATE_ACTIVATED         0x00
+#define CEC_OP_MENU_STATE_DEACTIVATED           0x01
 
-#define CEC_MSG_USER_CONTROL_PRESSED			0x44
+#define CEC_MSG_USER_CONTROL_PRESSED            0x44
 /* UI Broadcast Type Operand (ui_bcast_type) */
-#define CEC_OP_UI_BCAST_TYPE_TOGGLE_ALL			0x00
-#define CEC_OP_UI_BCAST_TYPE_TOGGLE_DIG_ANA		0x01
-#define CEC_OP_UI_BCAST_TYPE_ANALOGUE			0x10
-#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_T			0x20
-#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_CABLE		0x30
-#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_SAT		0x40
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL			0x50
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL_T			0x60
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL_CABLE		0x70
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL_SAT		0x80
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL_COM_SAT		0x90
-#define CEC_OP_UI_BCAST_TYPE_DIGITAL_COM_SAT2		0x91
-#define CEC_OP_UI_BCAST_TYPE_IP				0xa0
+#define CEC_OP_UI_BCAST_TYPE_TOGGLE_ALL         0x00
+#define CEC_OP_UI_BCAST_TYPE_TOGGLE_DIG_ANA     0x01
+#define CEC_OP_UI_BCAST_TYPE_ANALOGUE           0x10
+#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_T         0x20
+#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_CABLE     0x30
+#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_SAT       0x40
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL            0x50
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL_T          0x60
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL_CABLE      0x70
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL_SAT        0x80
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL_COM_SAT        0x90
+#define CEC_OP_UI_BCAST_TYPE_DIGITAL_COM_SAT2       0x91
+#define CEC_OP_UI_BCAST_TYPE_IP             0xa0
 /* UI Sound Presentation Control Operand (ui_snd_pres_ctl) */
-#define CEC_OP_UI_SND_PRES_CTL_DUAL_MONO		0x10
-#define CEC_OP_UI_SND_PRES_CTL_KARAOKE			0x20
-#define CEC_OP_UI_SND_PRES_CTL_DOWNMIX			0x80
-#define CEC_OP_UI_SND_PRES_CTL_REVERB			0x90
-#define CEC_OP_UI_SND_PRES_CTL_EQUALIZER		0xa0
-#define CEC_OP_UI_SND_PRES_CTL_BASS_UP			0xb1
-#define CEC_OP_UI_SND_PRES_CTL_BASS_NEUTRAL		0xb2
-#define CEC_OP_UI_SND_PRES_CTL_BASS_DOWN		0xb3
-#define CEC_OP_UI_SND_PRES_CTL_TREBLE_UP		0xc1
-#define CEC_OP_UI_SND_PRES_CTL_TREBLE_NEUTRAL		0xc2
-#define CEC_OP_UI_SND_PRES_CTL_TREBLE_DOWN		0xc3
+#define CEC_OP_UI_SND_PRES_CTL_DUAL_MONO        0x10
+#define CEC_OP_UI_SND_PRES_CTL_KARAOKE          0x20
+#define CEC_OP_UI_SND_PRES_CTL_DOWNMIX          0x80
+#define CEC_OP_UI_SND_PRES_CTL_REVERB           0x90
+#define CEC_OP_UI_SND_PRES_CTL_EQUALIZER        0xa0
+#define CEC_OP_UI_SND_PRES_CTL_BASS_UP          0xb1
+#define CEC_OP_UI_SND_PRES_CTL_BASS_NEUTRAL     0xb2
+#define CEC_OP_UI_SND_PRES_CTL_BASS_DOWN        0xb3
+#define CEC_OP_UI_SND_PRES_CTL_TREBLE_UP        0xc1
+#define CEC_OP_UI_SND_PRES_CTL_TREBLE_NEUTRAL       0xc2
+#define CEC_OP_UI_SND_PRES_CTL_TREBLE_DOWN      0xc3
 
-#define CEC_MSG_USER_CONTROL_RELEASED			0x45
+#define CEC_MSG_USER_CONTROL_RELEASED           0x45
 
 
 /* Remote Control Passthrough Feature */
 
 /*
  * Has also:
- *	CEC_MSG_USER_CONTROL_PRESSED
- *	CEC_MSG_USER_CONTROL_RELEASED
+ *  CEC_MSG_USER_CONTROL_PRESSED
+ *  CEC_MSG_USER_CONTROL_RELEASED
  */
 
 
 /* Power Status Feature */
-#define CEC_MSG_GIVE_DEVICE_POWER_STATUS		0x8f
-#define CEC_MSG_REPORT_POWER_STATUS			0x90
+#define CEC_MSG_GIVE_DEVICE_POWER_STATUS        0x8f
+#define CEC_MSG_REPORT_POWER_STATUS         0x90
 /* Power Status Operand (pwr_state) */
-#define CEC_OP_POWER_STATUS_ON				0
-#define CEC_OP_POWER_STATUS_STANDBY			1
-#define CEC_OP_POWER_STATUS_TO_ON			2
-#define CEC_OP_POWER_STATUS_TO_STANDBY			3
+#define CEC_OP_POWER_STATUS_ON              0
+#define CEC_OP_POWER_STATUS_STANDBY         1
+#define CEC_OP_POWER_STATUS_TO_ON           2
+#define CEC_OP_POWER_STATUS_TO_STANDBY          3
 
 
 /* General Protocol Messages */
-#define CEC_MSG_FEATURE_ABORT				0x00
+#define CEC_MSG_FEATURE_ABORT               0x00
 /* Abort Reason Operand (reason) */
-#define CEC_OP_ABORT_UNRECOGNIZED_OP			0
-#define CEC_OP_ABORT_INCORRECT_MODE			1
-#define CEC_OP_ABORT_NO_SOURCE				2
-#define CEC_OP_ABORT_INVALID_OP				3
-#define CEC_OP_ABORT_REFUSED				4
-#define CEC_OP_ABORT_UNDETERMINED			5
+#define CEC_OP_ABORT_UNRECOGNIZED_OP            0
+#define CEC_OP_ABORT_INCORRECT_MODE         1
+#define CEC_OP_ABORT_NO_SOURCE              2
+#define CEC_OP_ABORT_INVALID_OP             3
+#define CEC_OP_ABORT_REFUSED                4
+#define CEC_OP_ABORT_UNDETERMINED           5
 
-#define CEC_MSG_ABORT					0xff
+#define CEC_MSG_ABORT                   0xff
 
 
 /* System Audio Control Feature */
 
 /*
  * Has also:
- *	CEC_MSG_USER_CONTROL_PRESSED
- *	CEC_MSG_USER_CONTROL_RELEASED
+ *  CEC_MSG_USER_CONTROL_PRESSED
+ *  CEC_MSG_USER_CONTROL_RELEASED
  */
-#define CEC_MSG_GIVE_AUDIO_STATUS			0x71
-#define CEC_MSG_GIVE_SYSTEM_AUDIO_MODE_STATUS		0x7d
-#define CEC_MSG_REPORT_AUDIO_STATUS			0x7a
+#define CEC_MSG_GIVE_AUDIO_STATUS           0x71
+#define CEC_MSG_GIVE_SYSTEM_AUDIO_MODE_STATUS       0x7d
+#define CEC_MSG_REPORT_AUDIO_STATUS         0x7a
 /* Audio Mute Status Operand (aud_mute_status) */
-#define CEC_OP_AUD_MUTE_STATUS_OFF			0
-#define CEC_OP_AUD_MUTE_STATUS_ON			1
+#define CEC_OP_AUD_MUTE_STATUS_OFF          0
+#define CEC_OP_AUD_MUTE_STATUS_ON           1
 
-#define CEC_MSG_REPORT_SHORT_AUDIO_DESCRIPTOR		0xa3
-#define CEC_MSG_REQUEST_SHORT_AUDIO_DESCRIPTOR		0xa4
-#define CEC_MSG_SET_SYSTEM_AUDIO_MODE			0x72
+#define CEC_MSG_REPORT_SHORT_AUDIO_DESCRIPTOR       0xa3
+#define CEC_MSG_REQUEST_SHORT_AUDIO_DESCRIPTOR      0xa4
+#define CEC_MSG_SET_SYSTEM_AUDIO_MODE           0x72
 /* System Audio Status Operand (sys_aud_status) */
-#define CEC_OP_SYS_AUD_STATUS_OFF			0
-#define CEC_OP_SYS_AUD_STATUS_ON			1
+#define CEC_OP_SYS_AUD_STATUS_OFF           0
+#define CEC_OP_SYS_AUD_STATUS_ON            1
 
-#define CEC_MSG_SYSTEM_AUDIO_MODE_REQUEST		0x70
-#define CEC_MSG_SYSTEM_AUDIO_MODE_STATUS		0x7e
+#define CEC_MSG_SYSTEM_AUDIO_MODE_REQUEST       0x70
+#define CEC_MSG_SYSTEM_AUDIO_MODE_STATUS        0x7e
 /* Audio Format ID Operand (audio_format_id) */
-#define CEC_OP_AUD_FMT_ID_CEA861			0
-#define CEC_OP_AUD_FMT_ID_CEA861_CXT			1
+#define CEC_OP_AUD_FMT_ID_CEA861            0
+#define CEC_OP_AUD_FMT_ID_CEA861_CXT            1
 
 
 /* Audio Rate Control Feature */
-#define CEC_MSG_SET_AUDIO_RATE				0x9a
+#define CEC_MSG_SET_AUDIO_RATE              0x9a
 /* Audio Rate Operand (audio_rate) */
-#define CEC_OP_AUD_RATE_OFF				0
-#define CEC_OP_AUD_RATE_WIDE_STD			1
-#define CEC_OP_AUD_RATE_WIDE_FAST			2
-#define CEC_OP_AUD_RATE_WIDE_SLOW			3
-#define CEC_OP_AUD_RATE_NARROW_STD			4
-#define CEC_OP_AUD_RATE_NARROW_FAST			5
-#define CEC_OP_AUD_RATE_NARROW_SLOW			6
+#define CEC_OP_AUD_RATE_OFF             0
+#define CEC_OP_AUD_RATE_WIDE_STD            1
+#define CEC_OP_AUD_RATE_WIDE_FAST           2
+#define CEC_OP_AUD_RATE_WIDE_SLOW           3
+#define CEC_OP_AUD_RATE_NARROW_STD          4
+#define CEC_OP_AUD_RATE_NARROW_FAST         5
+#define CEC_OP_AUD_RATE_NARROW_SLOW         6
 
 
 /* Audio Return Channel Control Feature */
-#define CEC_MSG_INITIATE_ARC				0xc0
-#define CEC_MSG_REPORT_ARC_INITIATED			0xc1
-#define CEC_MSG_REPORT_ARC_TERMINATED			0xc2
-#define CEC_MSG_REQUEST_ARC_INITIATION			0xc3
-#define CEC_MSG_REQUEST_ARC_TERMINATION			0xc4
-#define CEC_MSG_TERMINATE_ARC				0xc5
+#define CEC_MSG_INITIATE_ARC                0xc0
+#define CEC_MSG_REPORT_ARC_INITIATED            0xc1
+#define CEC_MSG_REPORT_ARC_TERMINATED           0xc2
+#define CEC_MSG_REQUEST_ARC_INITIATION          0xc3
+#define CEC_MSG_REQUEST_ARC_TERMINATION         0xc4
+#define CEC_MSG_TERMINATE_ARC               0xc5
 
 
 /* Dynamic Audio Lipsync Feature */
 /* Only for CEC 2.0 and up */
-#define CEC_MSG_REQUEST_CURRENT_LATENCY			0xa7
-#define CEC_MSG_REPORT_CURRENT_LATENCY			0xa8
+#define CEC_MSG_REQUEST_CURRENT_LATENCY         0xa7
+#define CEC_MSG_REPORT_CURRENT_LATENCY          0xa8
 /* Low Latency Mode Operand (low_latency_mode) */
-#define CEC_OP_LOW_LATENCY_MODE_OFF			0
-#define CEC_OP_LOW_LATENCY_MODE_ON			1
+#define CEC_OP_LOW_LATENCY_MODE_OFF         0
+#define CEC_OP_LOW_LATENCY_MODE_ON          1
 /* Audio Output Compensated Operand (audio_out_compensated) */
-#define CEC_OP_AUD_OUT_COMPENSATED_NA			0
-#define CEC_OP_AUD_OUT_COMPENSATED_DELAY		1
-#define CEC_OP_AUD_OUT_COMPENSATED_NO_DELAY		2
-#define CEC_OP_AUD_OUT_COMPENSATED_PARTIAL_DELAY	3
+#define CEC_OP_AUD_OUT_COMPENSATED_NA           0
+#define CEC_OP_AUD_OUT_COMPENSATED_DELAY        1
+#define CEC_OP_AUD_OUT_COMPENSATED_NO_DELAY     2
+#define CEC_OP_AUD_OUT_COMPENSATED_PARTIAL_DELAY    3
 
 
 /* Capability Discovery and Control Feature */
-#define CEC_MSG_CDC_MESSAGE				0xf8
+#define CEC_MSG_CDC_MESSAGE             0xf8
 /* Ethernet-over-HDMI: nobody ever does this... */
-#define CEC_MSG_CDC_HEC_INQUIRE_STATE			0x00
-#define CEC_MSG_CDC_HEC_REPORT_STATE			0x01
+#define CEC_MSG_CDC_HEC_INQUIRE_STATE           0x00
+#define CEC_MSG_CDC_HEC_REPORT_STATE            0x01
 /* HEC Functionality State Operand (hec_func_state) */
-#define CEC_OP_HEC_FUNC_STATE_NOT_SUPPORTED		0
-#define CEC_OP_HEC_FUNC_STATE_INACTIVE			1
-#define CEC_OP_HEC_FUNC_STATE_ACTIVE			2
-#define CEC_OP_HEC_FUNC_STATE_ACTIVATION_FIELD		3
+#define CEC_OP_HEC_FUNC_STATE_NOT_SUPPORTED     0
+#define CEC_OP_HEC_FUNC_STATE_INACTIVE          1
+#define CEC_OP_HEC_FUNC_STATE_ACTIVE            2
+#define CEC_OP_HEC_FUNC_STATE_ACTIVATION_FIELD      3
 /* Host Functionality State Operand (host_func_state) */
-#define CEC_OP_HOST_FUNC_STATE_NOT_SUPPORTED		0
-#define CEC_OP_HOST_FUNC_STATE_INACTIVE			1
-#define CEC_OP_HOST_FUNC_STATE_ACTIVE			2
+#define CEC_OP_HOST_FUNC_STATE_NOT_SUPPORTED        0
+#define CEC_OP_HOST_FUNC_STATE_INACTIVE         1
+#define CEC_OP_HOST_FUNC_STATE_ACTIVE           2
 /* ENC Functionality State Operand (enc_func_state) */
-#define CEC_OP_ENC_FUNC_STATE_EXT_CON_NOT_SUPPORTED	0
-#define CEC_OP_ENC_FUNC_STATE_EXT_CON_INACTIVE		1
-#define CEC_OP_ENC_FUNC_STATE_EXT_CON_ACTIVE		2
+#define CEC_OP_ENC_FUNC_STATE_EXT_CON_NOT_SUPPORTED 0
+#define CEC_OP_ENC_FUNC_STATE_EXT_CON_INACTIVE      1
+#define CEC_OP_ENC_FUNC_STATE_EXT_CON_ACTIVE        2
 /* CDC Error Code Operand (cdc_errcode) */
-#define CEC_OP_CDC_ERROR_CODE_NONE			0
-#define CEC_OP_CDC_ERROR_CODE_CAP_UNSUPPORTED		1
-#define CEC_OP_CDC_ERROR_CODE_WRONG_STATE		2
-#define CEC_OP_CDC_ERROR_CODE_OTHER			3
+#define CEC_OP_CDC_ERROR_CODE_NONE          0
+#define CEC_OP_CDC_ERROR_CODE_CAP_UNSUPPORTED       1
+#define CEC_OP_CDC_ERROR_CODE_WRONG_STATE       2
+#define CEC_OP_CDC_ERROR_CODE_OTHER         3
 /* HEC Support Operand (hec_support) */
-#define CEC_OP_HEC_SUPPORT_NO				0
-#define CEC_OP_HEC_SUPPORT_YES				1
+#define CEC_OP_HEC_SUPPORT_NO               0
+#define CEC_OP_HEC_SUPPORT_YES              1
 /* HEC Activation Operand (hec_activation) */
-#define CEC_OP_HEC_ACTIVATION_ON			0
-#define CEC_OP_HEC_ACTIVATION_OFF			1
+#define CEC_OP_HEC_ACTIVATION_ON            0
+#define CEC_OP_HEC_ACTIVATION_OFF           1
 
-#define CEC_MSG_CDC_HEC_SET_STATE_ADJACENT		0x02
-#define CEC_MSG_CDC_HEC_SET_STATE			0x03
+#define CEC_MSG_CDC_HEC_SET_STATE_ADJACENT      0x02
+#define CEC_MSG_CDC_HEC_SET_STATE           0x03
 /* HEC Set State Operand (hec_set_state) */
-#define CEC_OP_HEC_SET_STATE_DEACTIVATE			0
-#define CEC_OP_HEC_SET_STATE_ACTIVATE			1
+#define CEC_OP_HEC_SET_STATE_DEACTIVATE         0
+#define CEC_OP_HEC_SET_STATE_ACTIVATE           1
 
-#define CEC_MSG_CDC_HEC_REQUEST_DEACTIVATION		0x04
-#define CEC_MSG_CDC_HEC_NOTIFY_ALIVE			0x05
-#define CEC_MSG_CDC_HEC_DISCOVER			0x06
+#define CEC_MSG_CDC_HEC_REQUEST_DEACTIVATION        0x04
+#define CEC_MSG_CDC_HEC_NOTIFY_ALIVE            0x05
+#define CEC_MSG_CDC_HEC_DISCOVER            0x06
 /* Hotplug Detect messages */
-#define CEC_MSG_CDC_HPD_SET_STATE			0x10
+#define CEC_MSG_CDC_HPD_SET_STATE           0x10
 /* HPD State Operand (hpd_state) */
-#define CEC_OP_HPD_STATE_CP_EDID_DISABLE		0
-#define CEC_OP_HPD_STATE_CP_EDID_ENABLE			1
-#define CEC_OP_HPD_STATE_CP_EDID_DISABLE_ENABLE		2
-#define CEC_OP_HPD_STATE_EDID_DISABLE			3
-#define CEC_OP_HPD_STATE_EDID_ENABLE			4
-#define CEC_OP_HPD_STATE_EDID_DISABLE_ENABLE		5
-#define CEC_MSG_CDC_HPD_REPORT_STATE			0x11
+#define CEC_OP_HPD_STATE_CP_EDID_DISABLE        0
+#define CEC_OP_HPD_STATE_CP_EDID_ENABLE         1
+#define CEC_OP_HPD_STATE_CP_EDID_DISABLE_ENABLE     2
+#define CEC_OP_HPD_STATE_EDID_DISABLE           3
+#define CEC_OP_HPD_STATE_EDID_ENABLE            4
+#define CEC_OP_HPD_STATE_EDID_DISABLE_ENABLE        5
+#define CEC_MSG_CDC_HPD_REPORT_STATE            0x11
 /* HPD Error Code Operand (hpd_error) */
-#define CEC_OP_HPD_ERROR_NONE				0
-#define CEC_OP_HPD_ERROR_INITIATOR_NOT_CAPABLE		1
-#define CEC_OP_HPD_ERROR_INITIATOR_WRONG_STATE		2
-#define CEC_OP_HPD_ERROR_OTHER				3
-#define CEC_OP_HPD_ERROR_NONE_NO_VIDEO			4
+#define CEC_OP_HPD_ERROR_NONE               0
+#define CEC_OP_HPD_ERROR_INITIATOR_NOT_CAPABLE      1
+#define CEC_OP_HPD_ERROR_INITIATOR_WRONG_STATE      2
+#define CEC_OP_HPD_ERROR_OTHER              3
+#define CEC_OP_HPD_ERROR_NONE_NO_VIDEO          4
 
 #endif
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/playback_libeplayer3.cpp libstb-hal-ddt.git/libmipsbox/playback_libeplayer3.cpp
--- libstb-hal-ddt.git.orig/libmipsbox/playback_libeplayer3.cpp	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libmipsbox/playback_libeplayer3.cpp	2022-07-23 18:18:31.503773029 +0200
@@ -11,11 +11,11 @@
 
 extern "C" {
 #include <common.h>
-extern OutputHandler_t      OutputHandler;
-extern PlaybackHandler_t    PlaybackHandler;
-extern ContainerHandler_t   ContainerHandler;
-extern ManagerHandler_t     ManagerHandler;
-extern int32_t ffmpeg_av_dict_set( const char *key, const char *value, int32_t flags);
+	extern OutputHandler_t      OutputHandler;
+	extern PlaybackHandler_t    PlaybackHandler;
+	extern ContainerHandler_t   ContainerHandler;
+	extern ManagerHandler_t     ManagerHandler;
+	extern int32_t ffmpeg_av_dict_set(const char *key, const char *value, int32_t flags);
 }
 
 #include "playback_libeplayer3.h"
@@ -54,6 +54,7 @@
 	last_size = 0;
 	nPlaybackSpeed = 0;
 	init_jump = -1;
+	avft = avformat_alloc_context();
 
 	if (!player)
 	{
@@ -87,7 +88,7 @@
 
 	//Dagobert: movieplayer does not call stop, it calls close ;)
 	mutex.lock();
-	if(playing)
+	if (playing)
 		Stop();
 	mutex.unlock();
 
@@ -101,7 +102,7 @@
 
 bool cPlayback::Start(std::string filename, std::string headers, std::string filename2)
 {
-	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers,filename2);
+	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers, filename2);
 }
 
 bool cPlayback::Start(char *filename, int vpid, int vtype, int apid, int ac3, int, std::string headers, std::string filename2)
@@ -117,7 +118,6 @@
 	mAudioStream = 0;
 	mSubtitleStream = -1;
 	mTeletextStream = -1;
-	unlink("/tmp/.id3coverart");
 	std::string file;
 
 	if (*filename == '/')
@@ -140,7 +140,7 @@
 	else
 		isHTTP = true;
 
-	if(isHTTP && headers.empty())
+	if (isHTTP && headers.empty())
 	{
 		size_t pos = file.find('#');
 		if (pos != std::string::npos)
@@ -148,17 +148,19 @@
 			headers = file.substr(pos + 1);
 			pos = headers.find("User-Agent=");
 			if (pos != std::string::npos)
-				headers.replace(pos+10, 1, ": ");
+				headers.replace(pos + 10, 1, ": ");
 		}
 	}
-	if(!headers.empty()){
+	if (!headers.empty())
+	{
 		const char hkey[] = "headers";
 		ffmpeg_av_dict_set(hkey, headers.c_str(), 0);
 	}
 
 	std::string szSecondFile;
 	char *file2 = NULL;
-	if(!filename2.empty()){
+	if (!filename2.empty())
+	{
 		szSecondFile = filename2;
 		file2 = (char *) szSecondFile.c_str();
 	}
@@ -180,7 +182,7 @@
 			//AUDIO
 			if (player && player->manager && player->manager->audio)
 			{
-				char ** TrackList = NULL;
+				char **TrackList = NULL;
 				player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
 				if (TrackList != NULL)
 				{
@@ -199,13 +201,13 @@
 			//SUB
 			if (player && player->manager && player->manager->subtitle)
 			{
-				char ** TrackList = NULL;
+				char **TrackList = NULL;
 				player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
 				if (TrackList != NULL)
 				{
 					printf("SubtitleTrack List\n");
 					int i = 0;
-					for (i = 0; TrackList[i] != NULL; i+=2)
+					for (i = 0; TrackList[i] != NULL; i += 2)
 					{
 						printf("\t%s - %s\n", TrackList[i], TrackList[i + 1]);
 						free(TrackList[i]);
@@ -219,27 +221,27 @@
 			//Teletext
 			if (player && player->manager && player->manager->teletext)
 			{
-				char ** TrackList = NULL;
-				player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
-				if (TrackList != NULL)
-				{
-					printf("TeletextTrack List\n");
-					 int i = 0;
-					for (i = 0; TrackList[i] != NULL; i += 2)
-					{
-						printf("\t%s - %s\n", TrackList[i], TrackList[i + 1]);
-						free(TrackList[i]);
-						free(TrackList[i + 1]);
-					}
-					free(TrackList);
-				}
+			    char ** TrackList = NULL;
+			    player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
+			    if (TrackList != NULL)
+			    {
+			        printf("TeletextTrack List\n");
+			         int i = 0;
+			        for (i = 0; TrackList[i] != NULL; i += 2)
+			        {
+			            printf("\t%s - %s\n", TrackList[i], TrackList[i + 1]);
+			            free(TrackList[i]);
+			            free(TrackList[i + 1]);
+			        }
+			        free(TrackList);
+			    }
 			}
 
 			*/
 			//Chapters
 			if (player && player->manager && player->manager->chapter)
 			{
-				char ** TrackList = NULL;
+				char **TrackList = NULL;
 				player->manager->chapter->Command(player, MANAGER_LIST, &TrackList);
 				if (TrackList != NULL)
 				{
@@ -334,7 +336,7 @@
 	if (pid != mTeletextStream)
 	{
 		//if (player && player->playback)
-		//	player->playback->Command(player, PLAYBACK_SWITCH_TELETEXT, (void*)&i);
+		//  player->playback->Command(player, PLAYBACK_SWITCH_TELETEXT, (void*)&i);
 		mTeletextStream = pid;
 	}
 	return true;
@@ -364,6 +366,11 @@
 	if (player && player->playback)
 	{
 		int result = 0;
+		if (nPlaybackSpeed == 0 && speed > 1)
+		{
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+		}
+
 		nPlaybackSpeed = speed;
 
 		if (speed > 1)
@@ -649,36 +656,36 @@
 	//int max_numpids = *numpids;
 	*numpids = 0;
 
-/*	if (player && player->manager && player->manager->teletext)
-	{
-		char **TrackList = NULL;
-		player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
-		if (TrackList != NULL)
-		{
-			printf("Teletext List\n");
-			int i = 0, j = 0;
-			for (i = 0, j = 0; TrackList[i] != NULL; i += 2)
-			{
-				int type = 0;
-				printf("\t%s - %s\n", TrackList[i], TrackList[i + 1]);
-				if (j < max_numpids)
-				{
-					int _pid;
-					if (2 != sscanf(TrackList[i], "%d %*s %d %*d %*d", &_pid, &type))
-						continue;
-					if (type != 2 && type != 5) // return subtitles only
-						continue;
-					pids[j] = _pid;
-					language[j] = std::string(TrackList[i]);
-					j++;
-				}
-				free(TrackList[i]);
-				free(TrackList[i + 1]);
-			}
-			free(TrackList);
-			*numpids = j;
-		}
-	} */
+	/*  if (player && player->manager && player->manager->teletext)
+	    {
+	        char **TrackList = NULL;
+	        player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
+	        if (TrackList != NULL)
+	        {
+	            printf("Teletext List\n");
+	            int i = 0, j = 0;
+	            for (i = 0, j = 0; TrackList[i] != NULL; i += 2)
+	            {
+	                int type = 0;
+	                printf("\t%s - %s\n", TrackList[i], TrackList[i + 1]);
+	                if (j < max_numpids)
+	                {
+	                    int _pid;
+	                    if (2 != sscanf(TrackList[i], "%d %*s %d %*d %*d", &_pid, &type))
+	                        continue;
+	                    if (type != 2 && type != 5) // return subtitles only
+	                        continue;
+	                    pids[j] = _pid;
+	                    language[j] = std::string(TrackList[i]);
+	                    j++;
+	                }
+	                free(TrackList[i]);
+	                free(TrackList[i + 1]);
+	            }
+	            free(TrackList);
+	            *numpids = j;
+	        }
+	    } */
 }
 
 int cPlayback::GetTeletextPid(void)
@@ -686,31 +693,31 @@
 	hal_info("%s\n", __func__);
 	int pid = -1;
 
-/*	if (player && player->manager && player->manager->teletext)
-	{
-		char **TrackList = NULL;
-		player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
-		if (TrackList != NULL)
-		{
-			printf("Teletext List\n");
-			int i = 0;
-			for (i = 0; TrackList[i] != NULL; i += 2)
-			{
-				int type = 0;
-				printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
-				if (pid < 0)
-				{
-					if (2 != sscanf(TrackList[i], "%*d %d %*s %d %*d %*d", &pid, &type))
-						continue;
-					if (type != 1)
-						pid = -1;
-				}
-				free(TrackList[i]);
-				free(TrackList[i + 1]);
-			}
-			free(TrackList);
-		}
-	} */
+	/*  if (player && player->manager && player->manager->teletext)
+	    {
+	        char **TrackList = NULL;
+	        player->manager->teletext->Command(player, MANAGER_LIST, &TrackList);
+	        if (TrackList != NULL)
+	        {
+	            printf("Teletext List\n");
+	            int i = 0;
+	            for (i = 0; TrackList[i] != NULL; i += 2)
+	            {
+	                int type = 0;
+	                printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+	                if (pid < 0)
+	                {
+	                    if (2 != sscanf(TrackList[i], "%*d %d %*s %d %*d %*d", &pid, &type))
+	                        continue;
+	                    if (type != 1)
+	                        pid = -1;
+	                }
+	                free(TrackList[i]);
+	                free(TrackList[i + 1]);
+	            }
+	            free(TrackList);
+	        }
+	    } */
 
 	printf("teletext pid id %d (0x%x)\n", pid, pid);
 	return pid;
@@ -814,9 +821,9 @@
 			Stop();
 			player->playback->abortRequested = 1;
 		}
-		else if(player->playback->isHttp && !player->playback->isPlaying &&!player->playback->abortRequested)
+		else if (player->playback->isHttp && !player->playback->isPlaying && !player->playback->abortRequested)
 		{
-				player->playback->abortRequested = 1;
+			player->playback->abortRequested = 1;
 		}
 
 		mutex.unlock();
@@ -842,11 +849,17 @@
 
 AVFormatContext *cPlayback::GetAVFormatContext()
 {
-	return NULL;
+	if (player && player->container && player->container->selectedContainer)
+	{
+		player->container->selectedContainer->Command(player, CONTAINER_GET_AVFCONTEXT, avft);
+	}
+	return avft;
 }
 
 void cPlayback::ReleaseAVFormatContext()
 {
+	avft->streams = NULL;
+	avft->nb_streams = 0;
 }
 
 #if 0
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/playback_libeplayer3.h libstb-hal-ddt.git/libmipsbox/playback_libeplayer3.h
--- libstb-hal-ddt.git.orig/libmipsbox/playback_libeplayer3.h	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/libmipsbox/playback_libeplayer3.h	2022-07-23 18:18:31.503773029 +0200
@@ -15,7 +15,7 @@
 
 class cPlayback
 {
-	friend class CStreamInfo2;
+		friend class CStreamInfo2;
 
 	private:
 		static OpenThreads::Mutex mutex;
@@ -35,6 +35,7 @@
 		std::string fn_xml;
 		off64_t last_size;
 		int init_jump;
+		AVFormatContext *avft;
 	public:
 		cPlayback(int num = 0);
 		~cPlayback();
@@ -47,9 +48,18 @@
 		bool SetVPid(int /*pid*/);
 		bool SetSubtitlePid(int pid);
 		bool SetTeletextPid(int pid);
-		int GetAPid(void) { return mAudioStream; }
-		int GetVPid(void) { return 0; }
-		int GetSubtitlePid(void) { return mSubtitleStream; }
+		int GetAPid(void)
+		{
+			return mAudioStream;
+		}
+		int GetVPid(void)
+		{
+			return 0;
+		}
+		int GetSubtitlePid(void)
+		{
+			return mSubtitleStream;
+		}
 		int GetTeletextPid(void);
 		bool SetSpeed(int speed);
 		bool GetSpeed(int &speed) const;
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/record.cpp libstb-hal-ddt.git/libmipsbox/record.cpp
--- libstb-hal-ddt.git.orig/libmipsbox/record.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libmipsbox/record.cpp	2022-07-23 18:18:31.503773029 +0200
@@ -1,5 +1,5 @@
 /*
- * (C) 
+ * (C)
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -150,17 +150,21 @@
 	bool found;
 	unsigned short pid;
 	hal_info("%s\n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
 	/* the first PID is the video pid, so start with the second PID... */
-	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+	{
 		found = false;
 		pid = (*i).pid;
-		for (j = 0; j < numapids; j++) {
-			if (pid == apids[j]) {
+		for (j = 0; j < numapids; j++)
+		{
+			if (pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -168,10 +172,13 @@
 		if (!found)
 			dmx->removePid(pid);
 	}
-	for (j = 0; j < numapids; j++) {
+	for (j = 0; j < numapids; j++)
+	{
 		found = false;
-		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
-			if ((*i).pid == apids[j]) {
+		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+		{
+			if ((*i).pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -186,12 +193,14 @@
 {
 	std::vector<pes_pids> pids;
 	hal_info("%s: \n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
-	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i)
+	{
 		if ((*i).pid == pid)
 			return true; /* or is it an error to try to add the same PID twice? */
 	}
@@ -203,14 +212,16 @@
 	char threadname[17];
 	strncpy(threadname, "WriterThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	unsigned int chunk = 0;
-	while (!sem_wait(&sem)) {
+	while (!sem_wait(&sem))
+	{
 		if (!io_len[chunk]) // empty, assume end of recording
 			return;
 		unsigned char *p_buf = io_buf[chunk];
 		size_t p_len = io_len[chunk];
-		while (p_len) {
+		while (p_len)
+		{
 			ssize_t written = write(file_fd, p_buf, p_len);
 			if (written < 0)
 				break;
@@ -230,7 +241,7 @@
 	char threadname[17];
 	strncpy(threadname, "RecordThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	int readsize = bufsize / 16;
 	int buf_pos = 0;
 	int count = 0;
@@ -251,7 +262,7 @@
 	}
 
 	int val = fcntl(file_fd, F_GETFL);
-	if (fcntl(file_fd, F_SETFL, val|O_APPEND))
+	if (fcntl(file_fd, F_SETFL, val | O_APPEND))
 		hal_info("%s: O_APPEND? (%m)\n", __func__);
 
 	memset(&a, 0, sizeof(a));
@@ -266,7 +277,8 @@
 	{
 		if (buf_pos < bufsize)
 		{
-			if (overflow_count) {
+			if (overflow_count)
+			{
 				hal_info("%s: Overflow cleared after %d iterations\n", __func__, overflow_count);
 				overflow_count = 0;
 			}
@@ -275,7 +287,7 @@
 				toread = readsize;
 			ssize_t s = dmx->Read(buf + buf_pos, toread, 50);
 			hal_debug("%s: buf_pos %6d s %6d / %6d\n", __func__,
-				buf_pos, (int)s, bufsize - buf_pos);
+			    buf_pos, (int)s, bufsize - buf_pos);
 			if (s < 0)
 			{
 				if (errno != EAGAIN && (errno != EOVERFLOW || !overflow))
@@ -378,9 +390,9 @@
 	eventServer.registerEvent2(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, "/tmp/neutrino.sock");
 	stream2file_status2_t s;
 	s.status = exit_flag;
-	strncpy(s.filename,basename(myfilename),512);
+	strncpy(s.filename, basename(myfilename), 512);
 	s.filename[511] = '\0';
-	strncpy(s.dir,dirname(myfilename),100);
+	strncpy(s.dir, dirname(myfilename), 100);
 	s.dir[99] = '\0';
 	eventServer.sendEvent(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, &s, sizeof(s));
 	printf("[stream2file]: pthreads exit code: %i, dir: '%s', filename: '%s' myfilename: '%s'\n", exit_flag, s.dir, s.filename, myfilename);
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/record_lib.h libstb-hal-ddt.git/libmipsbox/record_lib.h
--- libstb-hal-ddt.git.orig/libmipsbox/record_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libmipsbox/record_lib.h	2022-07-23 18:18:31.503773029 +0200
@@ -9,13 +9,14 @@
 #define REC_STATUS_OVERFLOW 2
 #define REC_STATUS_STOPPED 4
 
-typedef enum {
+typedef enum
+{
 	RECORD_RUNNING,
 	RECORD_STOPPED,
-	RECORD_FAILED_READ,	/* failed to read from DMX */
-	RECORD_FAILED_OVERFLOW,	/* cannot write fast enough */
-	RECORD_FAILED_FILE,	/* cannot write to file */
-	RECORD_FAILED_MEMORY	/* out of memory */
+	RECORD_FAILED_READ, /* failed to read from DMX */
+	RECORD_FAILED_OVERFLOW, /* cannot write fast enough */
+	RECORD_FAILED_FILE, /* cannot write to file */
+	RECORD_FAILED_MEMORY    /* out of memory */
 } record_state_t;
 
 class cRecord
@@ -38,8 +39,12 @@
 		unsigned char *io_buf[RECORD_WRITER_CHUNKS];
 		size_t io_len[RECORD_WRITER_CHUNKS];
 	public:
-		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024); 
-		void setFailureCallback(void (*f)(void *), void *d) { failureCallback = f; failureData = d; }
+		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024);
+		void setFailureCallback(void (*f)(void *), void *d)
+		{
+			failureCallback = f;
+			failureData = d;
+		}
 		~cRecord();
 
 		bool Open();
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/video.cpp libstb-hal-ddt.git/libmipsbox/video.cpp
--- libstb-hal-ddt.git.orig/libmipsbox/video.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libmipsbox/video.cpp	2022-07-23 18:18:31.503773029 +0200
@@ -38,6 +38,7 @@
 #include "hal_debug.h"
 #include "hdmi_cec.h"
 
+#include <hardware_caps.h>
 #include <proc_tools.h>
 
 extern "C"
@@ -53,16 +54,16 @@
 #define hal_debug_c(args...) _hal_debug(HAL_DEBUG_VIDEO, NULL, args)
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_VIDEO, NULL, args)
 
-#define fop(cmd, args...) ({				\
-	int _r;						\
-	if (fd >= 0) { 					\
-		if ((_r = ::cmd(fd, args)) < 0)		\
-			hal_info(#cmd"(fd, "#args")\n");	\
-		else					\
-			hal_debug(#cmd"(fd, "#args")\n");\
-	}						\
-	else { _r = fd; } 				\
-	_r;						\
+#define fop(cmd, args...) ({                \
+    int _r;                     \
+    if (fd >= 0) {                  \
+        if ((_r = ::cmd(fd, args)) < 0)     \
+            hal_info(#cmd"(fd, "#args")\n");\
+        else                    \
+            hal_debug(#cmd"(fd, "#args")\n");\
+    }                       \
+    else { _r = fd; }               \
+    _r;                     \
 })
 
 #ifndef VIDEO_GET_SIZE
@@ -72,97 +73,129 @@
 #define VIDEO_GET_FRAME_RATE       _IOR('o', 56, unsigned int)
 #endif
 
-cVideo * videoDecoder = NULL;
-cVideo * pipDecoder = NULL;
+enum
+{
+	ENCODER,
+	AUX
+};
+
+cVideo *videoDecoder = NULL;
+cVideo *pipVideoDecoder[3] = { NULL, NULL, NULL };
 
 int system_rev = 0;
 
 static bool stillpicture = false;
 
-static const char *VDEV[] = {
+static const char *VDEV[] =
+{
 	"/dev/dvb/adapter0/video0",
 	"/dev/dvb/adapter0/video1",
 	"/dev/dvb/adapter0/video2",
 	"/dev/dvb/adapter0/video3"
 };
-static const char *VMPEG_aspect[] = {
+static const char *VMPEG_aspect[] =
+{
 	"/proc/stb/vmpeg/0/aspect",
 	"/proc/stb/vmpeg/1/aspect",
 	"/proc/stb/vmpeg/2/aspect",
 	"/proc/stb/vmpeg/3/aspect"
 };
 
-static const char *VMPEG_xres[] = {
+static const char *VMPEG_xres[] =
+{
 	"/proc/stb/vmpeg/0/xres",
 	"/proc/stb/vmpeg/1/xres",
 	"/proc/stb/vmpeg/2/xres",
 	"/proc/stb/vmpeg/3/xres"
 };
 
-static const char *VMPEG_yres[] = {
+static const char *VMPEG_yres[] =
+{
 	"/proc/stb/vmpeg/0/yres",
 	"/proc/stb/vmpeg/1/yres",
 	"/proc/stb/vmpeg/2/yres",
 	"/proc/stb/vmpeg/3/yres"
 };
 
-static const char *VMPEG_dst_height[] = {
+static const char *VMPEG_dst_height[] =
+{
 	"/proc/stb/vmpeg/0/dst_height",
 	"/proc/stb/vmpeg/1/dst_height",
 	"/proc/stb/vmpeg/2/dst_height",
 	"/proc/stb/vmpeg/3/dst_height"
 };
 
-static const char *VMPEG_dst_width[] = {
+static const char *VMPEG_dst_width[] =
+{
 	"/proc/stb/vmpeg/0/dst_width",
 	"/proc/stb/vmpeg/1/dst_width",
 	"/proc/stb/vmpeg/2/dst_width",
 	"/proc/stb/vmpeg/3/dst_width"
 };
 
-static const char *VMPEG_dst_top[] = {
+static const char *VMPEG_dst_top[] =
+{
 	"/proc/stb/vmpeg/0/dst_top",
 	"/proc/stb/vmpeg/1/dst_top",
 	"/proc/stb/vmpeg/2/dst_top",
 	"/proc/stb/vmpeg/3/dst_top"
 };
 
-static const char *VMPEG_dst_left[] = {
+static const char *VMPEG_dst_left[] =
+{
 	"/proc/stb/vmpeg/0/dst_left",
 	"/proc/stb/vmpeg/1/dst_left",
 	"/proc/stb/vmpeg/2/dst_left",
 	"/proc/stb/vmpeg/3/dst_left"
 };
 
-static const char *VMPEG_framerate[] = {
+static const char *VMPEG_dst_apply[] =
+{
+	"/proc/stb/vmpeg/0/dst_apply",
+	"/proc/stb/vmpeg/1/dst_apply",
+	"/proc/stb/vmpeg/2/dst_apply",
+	"/proc/stb/vmpeg/3/dst_apply"
+};
+
+static const char *VMPEG_framerate[] =
+{
 	"/proc/stb/vmpeg/0/framerate",
 	"/proc/stb/vmpeg/1/framerate",
 	"/proc/stb/vmpeg/2/framerate",
 	"/proc/stb/vmpeg/3/framerate"
 };
 
-static const char *vid_modes[] = {
-	"pal",		// VIDEO_STD_NTSC
-	"pal",		// VIDEO_STD_SECAM
-	"pal",		// VIDEO_STD_PAL
-	"480p",		// VIDEO_STD_480P
-	"576p50",	// VIDEO_STD_576P
-	"720p60",	// VIDEO_STD_720P60
-	"1080i60",	// VIDEO_STD_1080I60
-	"720p50",	// VIDEO_STD_720P50
-	"1080i50",	// VIDEO_STD_1080I50
-	"1080p30",	// VIDEO_STD_1080P30
-	"1080p24",	// VIDEO_STD_1080P24
-	"1080p25",	// VIDEO_STD_1080P25
-	"1080p50",	// VIDEO_STD_1080P50
-	"1080p60",	// VIDEO_STD_1080P60
-	"1080p2397",	// VIDEO_STD_1080P2397
-	"1080p2997",	// VIDEO_STD_1080P2997
-	"2160p24",	// VIDEO_STD_2160P24
-	"2160p25",	// VIDEO_STD_2160P25
-	"2160p30",	// VIDEO_STD_2160P30
-	"2160p50",	// VIDEO_STD_2160P50
-	"720p50"	// VIDEO_STD_AUTO
+static const char *VMPEG_visible[] =
+{
+	"/proc/stb/vmpeg/0/visible",
+	"/proc/stb/vmpeg/1/visible",
+	"/proc/stb/vmpeg/2/visible",
+	"/proc/stb/vmpeg/3/visible"
+};
+
+static const char *vid_modes[] =
+{
+	"pal",      // VIDEO_STD_NTSC
+	"pal",      // VIDEO_STD_SECAM
+	"pal",      // VIDEO_STD_PAL
+	"480p",     // VIDEO_STD_480P
+	"576p50",   // VIDEO_STD_576P
+	"720p60",   // VIDEO_STD_720P60
+	"1080i60",  // VIDEO_STD_1080I60
+	"720p50",   // VIDEO_STD_720P50
+	"1080i50",  // VIDEO_STD_1080I50
+	"1080p30",  // VIDEO_STD_1080P30
+	"1080p24",  // VIDEO_STD_1080P24
+	"1080p25",  // VIDEO_STD_1080P25
+	"1080p50",  // VIDEO_STD_1080P50
+	"1080p60",  // VIDEO_STD_1080P60
+	"1080p2397",    // VIDEO_STD_1080P2397
+	"1080p2997",    // VIDEO_STD_1080P2997
+	"2160p24",  // VIDEO_STD_2160P24
+	"2160p25",  // VIDEO_STD_2160P25
+	"2160p30",  // VIDEO_STD_2160P30
+	"2160p50",  // VIDEO_STD_2160P50
+	"720p50"    // VIDEO_STD_AUTO
 };
 
 #define VIDEO_STREAMTYPE_MPEG2 0
@@ -177,7 +210,7 @@
 ssize_t write_all(int fd, const void *buf, size_t count)
 {
 	int retval;
-	char *ptr = (char*)buf;
+	char *ptr = (char *)buf;
 	size_t handledcount = 0;
 	while (handledcount < count)
 	{
@@ -195,65 +228,81 @@
 	return handledcount;
 }
 
-void init_parameters(AVFrame* in_frame, AVCodecContext *codec_context)
+void init_parameters(AVFrame *in_frame, AVCodecContext *codec_context)
 {
 	/* put sample parameters */
 	codec_context->bit_rate = 400000;
 	/* resolution must be a multiple of two */
-	codec_context->width = (in_frame->width/2)*2;
-	codec_context->height = (in_frame->height/2)*2;
+	codec_context->width = (in_frame->width / 2) * 2;
+	codec_context->height = (in_frame->height / 2) * 2;
 	/* frames per second */
-	codec_context->time_base = (AVRational ) { 1, 60 };
+	codec_context->time_base = (AVRational)
+	{
+		1, 60
+	};
 	codec_context->gop_size = 10; /* emit one intra frame every ten frames */
 	codec_context->max_b_frames = 1;
 	codec_context->pix_fmt = AV_PIX_FMT_YUV420P;
 }
 
-void write_frame(AVFrame* in_frame, int fd)
+void write_frame(AVFrame *in_frame, int fd)
 {
-	if(in_frame == NULL)
+	if (in_frame == NULL)
 		return;
 	static const unsigned char pes_header[] = {0x0, 0x0, 0x1, 0xe0, 0x00, 0x00, 0x80, 0x80, 0x5, 0x21, 0x0, 0x1, 0x0, 0x1};
 
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
 	AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MPEG2VIDEO);
+#else
+	const AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MPEG2VIDEO);
+#endif
 	if (codec)
 	{
 		AVCodecContext *codec_context = avcodec_alloc_context3(codec);
 		if (codec_context)
 		{
 			init_parameters(in_frame, codec_context);
-			if (avcodec_open2(codec_context, codec, 0) != -1){
+			if (avcodec_open2(codec_context, codec, 0) != -1)
+			{
 				AVPacket pkt;
 				av_init_packet(&pkt);
 				/* encode the image */
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 				int got_output = 0;
 				int ret = avcodec_encode_video2(codec_context, &pkt, in_frame, &got_output);
-				if (ret != -1){
+				if (ret != -1)
+				{
 #else
 				int ret = avcodec_send_frame(codec_context, in_frame);
-				if (!ret) {
+				if (!ret)
+				{
 					/* signalling end of stream */
 					ret = avcodec_send_frame(codec_context, NULL);
 				}
-				if (!ret) {
+				if (!ret)
+				{
 #endif
 					int i = 1;
 					/* get the delayed frames */
 					in_frame->pts = i;
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 					ret = avcodec_encode_video2(codec_context, &pkt, 0, &got_output);
-					if (ret != -1 && got_output){
+					if (ret != -1 && got_output)
+					{
 #else
 					ret = avcodec_receive_packet(codec_context, &pkt);
-					if (!ret) {
+					if (!ret)
+					{
 #endif
-						if ((pkt.data[3] >> 4) != 0xE){
+						if ((pkt.data[3] >> 4) != 0xE)
+						{
 							write_all(fd, pes_header, sizeof(pes_header));
-						}else{
+						}
+						else
+						{
 							pkt.data[4] = pkt.data[5] = 0x00;
 						}
-						write_all(fd,pkt.data, pkt.size);
+						write_all(fd, pkt.data, pkt.size);
 						av_packet_unref(&pkt);
 					}
 				}
@@ -264,13 +313,15 @@
 	}
 }
 
-int decode_frame(AVCodecContext *codecContext,AVPacket &packet, int fd)
+int decode_frame(AVCodecContext *codecContext, AVPacket &packet, int fd)
 {
 	AVFrame *frame = av_frame_alloc();
-	if(frame){
+	if (frame)
+	{
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 		int decode_ok = 0;
-		if ((avcodec_decode_video2(codecContext, frame, &decode_ok, &packet)) < 0 || !decode_ok){
+		if ((avcodec_decode_video2(codecContext, frame, &decode_ok, &packet)) < 0 || !decode_ok)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
@@ -279,25 +330,29 @@
 		ret = avcodec_send_packet(codecContext, &packet);
 		// In particular, we don't expect AVERROR(EAGAIN), because we read all
 		// decoded frames with avcodec_receive_frame() until done.
-		if (ret < 0) {
+		if (ret < 0)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
 		ret = avcodec_receive_frame(codecContext, frame);
-		if (ret < 0) {
+		if (ret < 0)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
 #endif
 		AVFrame *dest_frame = av_frame_alloc();
-		if(dest_frame){
-			dest_frame->height = (frame->height/2)*2;
-			dest_frame->width = (frame->width/2)*2;
+		if (dest_frame)
+		{
+			dest_frame->height = (frame->height / 2) * 2;
+			dest_frame->width = (frame->width / 2) * 2;
 			dest_frame->format = AV_PIX_FMT_YUV420P;
 			av_frame_get_buffer(dest_frame, 32);
 			struct SwsContext *convert = NULL;
 			convert = sws_getContext(frame->width, frame->height, (AVPixelFormat)frame->format, dest_frame->width, dest_frame->height, AV_PIX_FMT_YUVJ420P, SWS_FAST_BILINEAR, NULL, NULL, NULL);
-			if(convert){
+			if (convert)
+			{
 				sws_scale(convert, frame->data, frame->linesize, 0, frame->height, dest_frame->data, dest_frame->linesize);
 				sws_freeContext(convert);
 			}
@@ -310,19 +365,27 @@
 
 }
 
-AVCodecContext* open_codec(AVMediaType mediaType, AVFormatContext* formatContext)
+AVCodecContext *open_codec(AVMediaType mediaType, AVFormatContext *formatContext)
 {
-	AVCodec * codec = NULL;
-	AVCodecContext * codecContext = NULL;
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
+	AVCodec *codec = NULL;
+#else
+	const AVCodec *codec = NULL;
+#endif
+	AVCodecContext *codecContext = NULL;
 	int stream_index;
-#if (LIBAVFORMAT_VERSION_INT < AV_VERSION_INT( 57,25,101 ))
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(57,25,101)
 	stream_index = av_find_best_stream(formatContext, mediaType, -1, -1, NULL, 0);
-	if (stream_index >= 0) {
+	if (stream_index >= 0)
+	{
 		codecContext = formatContext->streams[stream_index]->codec;
-		if (codecContext) {
+		if (codecContext)
+		{
 			codec = avcodec_find_decoder(codecContext->codec_id);
-			if (codec) {
-				if ((avcodec_open2(codecContext, codec, NULL)) != 0) {
+			if (codec)
+			{
+				if ((avcodec_open2(codecContext, codec, NULL)) != 0)
+				{
 					return NULL;
 				}
 			}
@@ -332,13 +395,17 @@
 	return NULL;
 #else
 	stream_index = av_find_best_stream(formatContext, mediaType, -1, -1, &codec, 0);
-	if (stream_index >= 0) {
+	if (stream_index >= 0)
+	{
 		codec = avcodec_find_decoder(formatContext->streams[stream_index]->codecpar->codec_id);
-		if (codec) {
+		if (codec)
+		{
 			codecContext = avcodec_alloc_context3(codec);
 		}
-		if (codecContext) {
-			if ((avcodec_open2(codecContext, codec, NULL)) != 0) {
+		if (codecContext)
+		{
+			if ((avcodec_open2(codecContext, codec, NULL)) != 0)
+			{
 				return NULL;
 			}
 			return codecContext;
@@ -357,16 +424,20 @@
 #endif
 
 	AVFormatContext *formatContext = avformat_alloc_context();
-	if (formatContext && (ret = avformat_open_input(&formatContext, image_name, NULL, NULL)) == 0){
+	if (formatContext && (ret = avformat_open_input(&formatContext, image_name, NULL, NULL)) == 0)
+	{
 		AVCodecContext *codecContext = open_codec(AVMEDIA_TYPE_VIDEO, formatContext);
-		if(codecContext){
+		if (codecContext)
+		{
 			AVPacket packet;
 			av_init_packet(&packet);
-			if ((ret = av_read_frame(formatContext, &packet)) !=-1){
-				if((ret = decode_frame(codecContext, packet, fd)) != 1){
-				/* add sequence end code to have a real mpeg file */
+			if ((ret = av_read_frame(formatContext, &packet)) != -1)
+			{
+				if ((ret = decode_frame(codecContext, packet, fd)) != 1)
+				{
+					/* add sequence end code to have a real mpeg file */
 					uint8_t endcode[] = { 0, 0, 1, 0xb7 };
-					write_all(fd,endcode, sizeof(endcode));
+					write_all(fd, endcode, sizeof(endcode));
 				}
 				av_packet_unref(&packet);
 			}
@@ -378,15 +449,62 @@
 	av_free(formatContext);
 	return ret;
 }
-enum{ENCODER,AUX};
-void setAVInput(int val)
+
+#ifndef VIDEO_SOURCE_HDMI
+#define VIDEO_SOURCE_HDMI 2
+#endif
+
+void cVideo::open_AVInput_Device(void)
+{
+	hal_debug("%s\n", __func__);
+
+	if (fdd) /* already open */
+		return;
+
+	fop(ioctl, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_HDMI);
+	fop(ioctl, VIDEO_PLAY);
+	fdd = true;
+}
+
+void cVideo::close_AVInput_Device(void)
+{
+	hal_debug("%s\n", __func__);
+
+	if (fdd)
+	{
+		fop(ioctl, VIDEO_STOP);
+		fop(ioctl, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
+	}
+	fdd = false;
+}
+
+void cVideo::setAVInput(int val)
 {
+	hal_info("%s - switching to: %s\n", __func__, val == AUX ? "AUX" : "ENCODER");
+
+	if (val == AUX)
+	{
+		setBlank(1);
+		open_AVInput_Device();
+	}
+	else
+	{
+		if (fdd)
+		{
+			close_AVInput_Device();
+			setBlank(0);
+		}
+	}
+
+#if 0 // not working
 	int input_fd = open("/proc/stb/avs/0/input", O_WRONLY);
-	if(input_fd){
+	if (input_fd)
+	{
 		const char *input[] = {"encoder", "aux"};
 		write(input_fd, input[val], strlen(input[val]));
 		close(input_fd);
 	}
+#endif
 }
 
 cVideo::cVideo(int, void *, void *, unsigned int unit)
@@ -398,20 +516,29 @@
 	saturation = -1;
 	hue = -1;
 	video_standby = 0;
-	if (unit > 1) {
+	blank_mode = 0;
+	hw_caps_t *hwcaps = get_hwcaps();
+	if (unit > (unsigned int) hwcaps->pip_devs)
+	{
 		hal_info("%s: unit %d out of range, setting to 0\n", __func__, unit);
 		devnum = 0;
-	} else
+	}
+	else
 		devnum = unit;
 	fd = -1;
+	fdd = false;
 	openDevice();
+#if 0
 	setAVInput(ENCODER);
+#endif
 }
 
 cVideo::~cVideo(void)
 {
-	if(fd >= 0)
+#if 0
+	if (fd >= 0)
 		setAVInput(AUX);
+#endif
 	if (hdmi_cec::getInstance()->standby_cec_activ && fd >= 0)
 		hdmi_cec::getInstance()->SetCECState(true);
 
@@ -426,7 +553,7 @@
 	if (fd != -1) /* already open */
 		return;
 retry:
-	if ((fd = open(VDEV[devnum], O_RDWR|O_CLOEXEC)) < 0)
+	if ((fd = open(VDEV[devnum], O_RDWR | O_CLOEXEC)) < 0)
 	{
 		if (errno == EBUSY)
 		{
@@ -453,12 +580,12 @@
 
 int cVideo::setAspectRatio(int aspect, int mode)
 {
-	static const char *a[] = { "n/a", "4:3", "14:9", "16:9" };
+	static const char *a[] = { "n/a", "4:3", "16:9" };
 //	static const char *m[] = { "panscan", "letterbox", "bestfit", "nonlinear", "(unset)" };
 	static const char *m[] = { "letterbox", "panscan", "bestfit", "nonlinear", "(unset)" };
 	int n;
 
-	int mo = (mode < 0||mode > 3) ? 4 : mode;
+	int mo = (mode < 0 || mode > 3) ? 4 : mode;
 	hal_debug("%s: a:%d m:%d  %s\n", __func__, aspect, mode, m[mo]);
 
 	if (aspect > 3 || aspect == 0)
@@ -525,7 +652,8 @@
 		fop(ioctl, MPEG_VID_CONTINUE);
 #endif
 	/* implicitly do StopPicture() on video->Start() */
-	if (stillpicture) {
+	if (stillpicture)
+	{
 		hal_info("%s: stillpicture == true, doing implicit StopPicture()\n", __func__);
 		stillpicture = false;
 		Stop(1);
@@ -533,22 +661,27 @@
 	playstate = VIDEO_PLAYING;
 	fop(ioctl, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
 	int res = fop(ioctl, VIDEO_PLAY);
-	if (brightness > -1) {
+	if (brightness > -1)
+	{
 		SetControl(VIDEO_CONTROL_BRIGHTNESS, brightness);
 		brightness = -1;
 	}
-	if (contrast > -1) {
+	if (contrast > -1)
+	{
 		SetControl(VIDEO_CONTROL_CONTRAST, contrast);
 		contrast = -1;
 	}
-	if (saturation > -1) {
+	if (saturation > -1)
+	{
 		SetControl(VIDEO_CONTROL_SATURATION, saturation);
 		saturation = -1;
 	}
-	if (hue > -1) {
+	if (hue > -1)
+	{
 		SetControl(VIDEO_CONTROL_HUE, hue);
 		hue = -1;
 	}
+	blank_mode = 0;
 	return res;
 }
 
@@ -561,16 +694,22 @@
 		return -1;
 	}
 	playstate = blank ? VIDEO_STOPPED : VIDEO_FREEZED;
+	blank_mode = blank;
 	return fop(ioctl, VIDEO_STOP, blank ? 1 : 0);
 }
 
-int cVideo::setBlank(int)
+int cVideo::setBlank(int enable)
 {
 	fop(ioctl, VIDEO_PLAY);
 	fop(ioctl, VIDEO_CONTINUE);
-	video_still_picture sp = { NULL, 0 };
-	fop(ioctl, VIDEO_STILLPICTURE, &sp);
-	return Stop(1);
+	if (enable)
+	{
+		video_still_picture sp = { NULL, 0 };
+		fop(ioctl, VIDEO_STILLPICTURE, &sp);
+		return Stop(1);
+	}
+	else
+		return Start();
 }
 
 int cVideo::SetVideoSystem(int video_system, bool remember)
@@ -597,7 +736,7 @@
 		Stop();
 		stopped = true;
 	}
-	ret = proc_put("/proc/stb/video/videomode", vid_modes[video_system],strlen(vid_modes[video_system]));
+	ret = proc_put("/proc/stb/video/videomode", vid_modes[video_system], strlen(vid_modes[video_system]));
 	if (stopped)
 		Start();
 
@@ -621,10 +760,12 @@
 {
 	if (system == -1)
 		system = GetVideoSystem();
-	if (system < 0 || system > VIDEO_STD_1080P50) {
+	if (system < 0 || system > VIDEO_STD_1080P50)
+	{
 		hal_info("%s: invalid system %d\n", __func__, system);
 		strcpy(format->format, "invalid");
-	} else
+	}
+	else
 		strcpy(format->format, vid_modes[system]);
 }
 
@@ -633,43 +774,27 @@
 	return playstate;
 }
 
-void cVideo::SetVideoMode(analog_mode_t mode)
+bool cVideo::ShowPicture(const char *fname)
 {
-	hal_debug("#%d: %s(%d)\n", devnum, __func__, mode);
-	if (!(mode & ANALOG_SCART_MASK))
-	{
-		hal_debug("%s: non-SCART mode ignored\n", __func__);
-		return;
-	}
-	const char *m;
-	switch(mode)
-	{
-		case ANALOG_SD_YPRPB_SCART:
-			m = "yuv";
-			break;
-		case ANALOG_SD_RGB_SCART:
-			m = "rgb";
-			break;
-		default:
-			hal_info("%s unknown mode %d\n", __func__, mode);
-			m = "rgb";
-			break; /* default to rgb */
-	}
-	proc_put("/proc/stb/avs/0/colorformat", m, strlen(m));
-}
-
-void cVideo::ShowPicture(const char * fname)
-{
-	hal_info("%s(%s)\n", __func__, fname);
+	bool ret = false;
+	hal_debug("%s(%s)\n", __func__, fname);
 	if (video_standby)
 	{
 		/* does not work and the driver does not seem to like it */
 		hal_info("%s: video_standby == true\n", __func__);
-		return;
+		return ret;
 	}
+	/* in movieplayer mode, fd is not opened */
+	if (fd == -1)
+	{
+		hal_info("%s: decoder not opened\n", __func__);
+		return ret;
+	}
+
 	struct stat st;
-	if (stat(fname, &st)){
-		return;
+	if (stat(fname, &st))
+	{
+		return ret;
 	}
 	closeDevice();
 	openDevice();
@@ -684,13 +809,14 @@
 		ioctl(fd, VIDEO_CLEAR_BUFFER);
 		image_to_mpeg2(fname, fd);
 		unsigned char iframe[8192];
-		memset(iframe,0xff,sizeof(iframe));
+		memset(iframe, 0xff, sizeof(iframe));
 		write_all(fd, iframe, 8192);
 		usleep(150000);
 		ioctl(fd, VIDEO_STOP, 0);
 		ioctl(fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
+		ret = true;
 	}
-	return;
+	return ret;
 }
 
 void cVideo::StopPicture()
@@ -708,12 +834,16 @@
 	if (bOn)
 	{
 		closeDevice();
+#if 0
 		setAVInput(AUX);
+#endif
 	}
 	else
 	{
 		openDevice();
+#if 0
 		setAVInput(ENCODER);
+#endif
 	}
 	video_standby = bOn;
 	hdmi_cec::getInstance()->SetCECState(video_standby);
@@ -721,9 +851,60 @@
 
 int cVideo::getBlank(void)
 {
+#if 0
 	int ret = proc_get_hex(VMPEG_xres[devnum]);
 	hal_debug("%s => %d\n", __func__, !ret);
 	return !ret;
+#else
+	hal_debug("%s => %d\n", __func__, blank_mode);
+	return blank_mode;
+#endif
+}
+
+void cVideo::QuadPiP(bool active, int _x, int _y, int _w, int _h)
+{
+	char buffer[64];
+	int _a = 1;
+	if (active) {
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+		proc_put("/proc/stb/video/decodermode", "mosaic", strlen("mosaic"));
+#endif
+		for (unsigned int i = 0; i < 4; i++) {
+			sprintf(buffer, "%x", _x);
+			proc_put(VMPEG_dst_left[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", _y);
+			proc_put(VMPEG_dst_top[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", _w);
+			proc_put(VMPEG_dst_width[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", _h);
+			proc_put(VMPEG_dst_height[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", _a);
+			proc_put(VMPEG_dst_apply[i], buffer, strlen(buffer));
+		}
+	} else {
+		for (unsigned int i = 0; i < 4; i++) {
+			sprintf(buffer, "%x", 0);
+			proc_put(VMPEG_dst_left[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", 0);
+			proc_put(VMPEG_dst_top[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", 0);
+			proc_put(VMPEG_dst_width[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", 0);
+			proc_put(VMPEG_dst_height[i], buffer, strlen(buffer));
+			sprintf(buffer, "%x", _a);
+			proc_put(VMPEG_dst_apply[i], buffer, strlen(buffer));
+		}
+#if BOXMODEL_VUSOLO4K || BOXMODEL_VUDUO4K || BOXMODEL_VUDUO4KSE || BOXMODEL_VUULTIMO4K || BOXMODEL_VUUNO4KSE || BOXMODEL_VUUNO4K
+		proc_put("/proc/stb/video/decodermode", "normal", strlen("normal"));
+#endif
+	}
+}
+
+void cVideo::ShowPig(int _x)
+{
+	char buffer[64];
+	sprintf(buffer, "%d", _x);
+	proc_put(VMPEG_visible[devnum], buffer, strlen(buffer));
 }
 
 void cVideo::Pig(int x, int y, int w, int h, int osd_w, int osd_h, int startx, int starty, int endx, int endy)
@@ -772,6 +953,9 @@
 
 	sprintf(buffer, "%x", _h);
 	proc_put(VMPEG_dst_height[devnum], buffer, strlen(buffer));
+
+	sprintf(buffer, "%x", 1);
+	proc_put(VMPEG_dst_apply[devnum], buffer, strlen(buffer));
 }
 
 static inline int rate2csapi(int rate)
@@ -836,7 +1020,8 @@
 
 int cVideo::SetStreamType(VIDEO_FORMAT type)
 {
-	static const char *VF[] = {
+	static const char *VF[] =
+	{
 		"VIDEO_FORMAT_MPEG2",
 		"VIDEO_FORMAT_MPEG4",
 		"VIDEO_FORMAT_VC1",
@@ -888,67 +1073,69 @@
 void cVideo::SetControl(int control, int value)
 {
 	const char *p = NULL;
-	switch (control) {
-	case VIDEO_CONTROL_BRIGHTNESS:
-		brightness = value;
-		p = "/proc/stb/vmpeg/0/pep_brightness";
-		break;
-	case VIDEO_CONTROL_CONTRAST:
-		contrast = value;
-		p = "/proc/stb/vmpeg/0/pep_contrast";
-		break;
-	case VIDEO_CONTROL_SATURATION:
-		saturation = value;
-		p = "/proc/stb/vmpeg/0/pep_saturation";
-		break;
-	case VIDEO_CONTROL_HUE:
-		hue = value;
-		p = "/proc/stb/vmpeg/0/pep_hue";
-		break;
-	case VIDEO_CONTROL_SHARPNESS:
-		sharpness = value;
-		p = "/proc/stb/vmpeg/0/pep_sharpness";
-		break;
-	case VIDEO_CONTROL_BLOCK_NOISE_REDUCTION:
-		block_noise_reduction = value;
-		p = "/proc/stb/vmpeg/0/pep_block_noise_reduction";
-		break;
-	case VIDEO_CONTROL_MOSQUITO_NOISE_REDUCTION:
-		mosquito_noise_reduction = value;
-		p = "/proc/stb/vmpeg/0/pep_mosquito_noise_reduction";
-		break;
-	case VIDEO_CONTROL_DIGITAL_CONTOUR_REMOVAL:
-		digital_contour_removal = value;
-		p = "/proc/stb/vmpeg/0/pep_digital_contour_removal";
-		break;
-	case VIDEO_CONTROL_AUTO_FLESH:
-		auto_flesh = value;
-		p = "/proc/stb/vmpeg/0/pep_auto_flesh";
-		break;
-	case VIDEO_CONTROL_GREEN_BOOST:
-		green_boost = value;
-		p = "/proc/stb/vmpeg/0/pep_green_boost";
-		break;
-	case VIDEO_CONTROL_BLUE_BOOST:
-		blue_boost = value;
-		p = "/proc/stb/vmpeg/0/pep_blue_boost";
-		break;
-	case VIDEO_CONTROL_DYNAMIC_CONTRAST:
-		dynamic_contrast = value;
-		p = "/proc/stb/vmpeg/0/pep_dynamic_contrast";
-		break;
-	case VIDEO_CONTROL_SCALER_SHARPNESS:
-		scaler_sharpness = value;
-		p = "/proc/stb/vmpeg/0/pep_scaler_sharpness";
-		break;
-	case VIDEO_CONTROL_ZAPPING_MODE:
-		zapping_mode = value;
-		const char *mode_zapping[] = { "mute", "hold", "mutetilllock", "holdtilllock"};
-		proc_put("/proc/stb/video/zapmode", mode_zapping[zapping_mode], strlen(mode_zapping[zapping_mode]));
+	switch (control)
+	{
+		case VIDEO_CONTROL_BRIGHTNESS:
+			brightness = value;
+			p = "/proc/stb/vmpeg/0/pep_brightness";
+			break;
+		case VIDEO_CONTROL_CONTRAST:
+			contrast = value;
+			p = "/proc/stb/vmpeg/0/pep_contrast";
+			break;
+		case VIDEO_CONTROL_SATURATION:
+			saturation = value;
+			p = "/proc/stb/vmpeg/0/pep_saturation";
+			break;
+		case VIDEO_CONTROL_HUE:
+			hue = value;
+			p = "/proc/stb/vmpeg/0/pep_hue";
+			break;
+		case VIDEO_CONTROL_SHARPNESS:
+			sharpness = value;
+			p = "/proc/stb/vmpeg/0/pep_sharpness";
+			break;
+		case VIDEO_CONTROL_BLOCK_NOISE_REDUCTION:
+			block_noise_reduction = value;
+			p = "/proc/stb/vmpeg/0/pep_block_noise_reduction";
+			break;
+		case VIDEO_CONTROL_MOSQUITO_NOISE_REDUCTION:
+			mosquito_noise_reduction = value;
+			p = "/proc/stb/vmpeg/0/pep_mosquito_noise_reduction";
+			break;
+		case VIDEO_CONTROL_DIGITAL_CONTOUR_REMOVAL:
+			digital_contour_removal = value;
+			p = "/proc/stb/vmpeg/0/pep_digital_contour_removal";
+			break;
+		case VIDEO_CONTROL_AUTO_FLESH:
+			auto_flesh = value;
+			p = "/proc/stb/vmpeg/0/pep_auto_flesh";
+			break;
+		case VIDEO_CONTROL_GREEN_BOOST:
+			green_boost = value;
+			p = "/proc/stb/vmpeg/0/pep_green_boost";
+			break;
+		case VIDEO_CONTROL_BLUE_BOOST:
+			blue_boost = value;
+			p = "/proc/stb/vmpeg/0/pep_blue_boost";
+			break;
+		case VIDEO_CONTROL_DYNAMIC_CONTRAST:
+			dynamic_contrast = value;
+			p = "/proc/stb/vmpeg/0/pep_dynamic_contrast";
+			break;
+		case VIDEO_CONTROL_SCALER_SHARPNESS:
+			scaler_sharpness = value;
+			p = "/proc/stb/vmpeg/0/pep_scaler_sharpness";
+			break;
+		case VIDEO_CONTROL_ZAPPING_MODE:
+			zapping_mode = value;
+			const char *mode_zapping[] = { "mute", "hold", "mutetilllock", "holdtilllock"};
+			proc_put("/proc/stb/video/zapmode", mode_zapping[zapping_mode], strlen(mode_zapping[zapping_mode]));
 //		proc_put("/proc/stb/video/zapping_mode", mode_zapping[zapping_mode], strlen(mode_zapping[zapping_mode]));
-		break;
+			break;
 	}
-	if (p) {
+	if (p)
+	{
 		char buf[20];
 		int fix_value = value * 256;
 		int len = snprintf(buf, sizeof(buf), "%.8X", fix_value);
@@ -957,55 +1144,64 @@
 	}
 }
 
-void cVideo::SetColorFormat(COLOR_FORMAT color_format)
+#if BOXMODEL_VUPLUS_ARM
+void cVideo::SetHDMIColorimetry(HDMI_COLORIMETRY hdmi_colorimetry)
 {
 	const char *p = NULL;
-	switch(color_format) {
-	case COLORFORMAT_RGB:
-		p = "rgb";
-		break;
-	case COLORFORMAT_YUV:
-		p = "yuv";
-		break;
-	case COLORFORMAT_CVBS:
-		p = "cvbs";
-		break;
-	case COLORFORMAT_SVIDEO:
-		p = "svideo";
-		break;
-	case COLORFORMAT_HDMI_AUTO:
-		p = "Edid(Auto)";
-		break;
-	case COLORFORMAT_HDMI_RGB:
-		p = "Hdmi_Rgb";
-		break;
-	case COLORFORMAT_HDMI_YCBCR444:
-		p = "444";
-		break;
-	case COLORFORMAT_HDMI_YCBCR422:
-		p = "422";
-		break;
-	case COLORFORMAT_HDMI_YCBCR420:
-		p = "420";
-		break;
+	switch (hdmi_colorimetry)
+	{
+		case HDMI_COLORIMETRY_AUTO:
+			p = "Edit(Auto)";
+			break;
+		case HDMI_COLORIMETRY_BT709:
+			p = "Itu_R_BT_709";
+			break;
+		case HDMI_COLORIMETRY_BT470:
+			p = "Itu_R_BT_470_2_BG";
+			break;
 	}
 	if (p)
 		proc_put("/proc/stb/video/hdmi_colorspace", p, strlen(p));
 }
+#else
+void cVideo::SetHDMIColorimetry(HDMI_COLORIMETRY hdmi_colorimetry)
+{
+	const char *p = NULL;
+	switch (hdmi_colorimetry)
+	{
+		case HDMI_COLORIMETRY_AUTO:
+			p = "auto";
+			break;
+		case HDMI_COLORIMETRY_BT2020NCL:
+			p = "bt2020ncl";
+			break;
+		case HDMI_COLORIMETRY_BT2020CL:
+			p = "bt2020cl";
+			break;
+		case HDMI_COLORIMETRY_BT709:
+			p = "bt709";
+			break;
+	}
+	if (p)
+		proc_put("/proc/stb/video/hdmi_colorimetry", p, strlen(p));
+}
+#endif
 
 bool getvideo2(unsigned char *video, int xres, int yres)
 {
 	bool ret = false;
-	if(video ==  NULL)
+	if (video ==  NULL)
 		return ret;
 	char videosnapshot[] = "/dev/dvb/adapter0/video0";
 	int fd_video = open(videosnapshot, O_RDONLY);
-	if (fd_video < 0) {
+	if (fd_video < 0)
+	{
 		perror(videosnapshot);
 		return ret;
 	}
 	ssize_t r = read(fd_video, video, xres * yres * 3);
-	if(r){
+	if (r)
+	{
 		ret = true;
 	}
 	close(fd_video);
@@ -1017,42 +1213,49 @@
 	int len = 0;
 	struct SwsContext *scale = NULL;
 	scale = sws_getCachedContext(scale, sw, sh, sfmt, dw, dh, AV_PIX_FMT_RGB32, SWS_BICUBIC, 0, 0, 0);
-	if (!scale) {
+	if (!scale)
+	{
 		hal_info_c("%s: ERROR setting up SWS context\n", __func__);
 		return ret;
 	}
 	AVFrame *sframe = av_frame_alloc();
 	AVFrame *dframe = av_frame_alloc();
-	if (sframe && dframe) {
+	if (sframe && dframe)
+	{
 		len = av_image_fill_arrays(sframe->data, sframe->linesize, &(src)[0], sfmt, sw, sh, 1);
-		if(len>-1)
+		if (len > -1)
 			ret = true;
 
-		if(ret && (len = av_image_fill_arrays(dframe->data, dframe->linesize, &(dst)[0], AV_PIX_FMT_RGB32, dw, dh, 1)<0))
+		if (ret && (len = av_image_fill_arrays(dframe->data, dframe->linesize, &(dst)[0], AV_PIX_FMT_RGB32, dw, dh, 1) < 0))
 			ret = false;
 
-		if(ret && (len = sws_scale(scale, sframe->data, sframe->linesize, 0, sh, dframe->data, dframe->linesize)<0))
+		if (ret && (len = sws_scale(scale, sframe->data, sframe->linesize, 0, sh, dframe->data, dframe->linesize) < 0))
 			ret = false;
 		else
 			ret = true;
-	}else{
+	}
+	else
+	{
 		hal_info_c("%s: could not alloc sframe (%p) or dframe (%p)\n", __func__, sframe, dframe);
 		ret = false;
 	}
 
-	if(sframe){
+	if (sframe)
+	{
 		av_frame_free(&sframe);
 		sframe = NULL;
 	}
-	if(dframe){
+	if (dframe)
+	{
 		av_frame_free(&dframe);
 		dframe = NULL;
 	}
-	if(scale){
+	if (scale)
+	{
 		sws_freeContext(scale);
 		scale = NULL;
 	}
-	hal_info_c("%s: %s scale %ix%i to %ix%i ,len %i\n",ret?" ":"ERROR",__func__, sw, sh, dw, dh,len);
+	hal_info_c("%s: %s scale %ix%i to %ix%i ,len %i\n", ret ? " " : "ERROR", __func__, sw, sh, dw, dh, len);
 
 	return ret;
 }
@@ -1060,7 +1263,7 @@
 // grabing the osd picture
 void get_osd_size(int &xres, int &yres, int &bits_per_pixel)
 {
-	int fb=open("/dev/fb/0", O_RDWR);
+	int fb = open("/dev/fb/0", O_RDWR);
 	if (fb == -1)
 	{
 		fprintf(stderr, "Framebuffer failed\n");
@@ -1068,7 +1271,7 @@
 	}
 
 	struct fb_var_screeninfo var_screeninfo;
-	if(ioctl(fb, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
+	if (ioctl(fb, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
 	{
 		fprintf(stderr, "Framebuffer: <FBIOGET_VSCREENINFO failed>\n");
 		close(fb);
@@ -1077,9 +1280,9 @@
 	close(fb);
 
 	bits_per_pixel = var_screeninfo.bits_per_pixel;
-	xres=var_screeninfo.xres;
-	yres=var_screeninfo.yres;
-	fprintf(stderr, "... Framebuffer-Size: %d x %d\n",xres,yres);
+	xres = var_screeninfo.xres;
+	yres = var_screeninfo.yres;
+	fprintf(stderr, "... Framebuffer-Size: %d x %d\n", xres, yres);
 
 }
 void get_osd_buf(unsigned char *osd_data)
@@ -1088,45 +1291,47 @@
 	struct fb_fix_screeninfo fix_screeninfo;
 	struct fb_var_screeninfo var_screeninfo;
 
-	int fb=open("/dev/fb/0", O_RDWR);
+	int fb = open("/dev/fb/0", O_RDWR);
 	if (fb == -1)
 	{
 		fprintf(stderr, "Framebuffer failed\n");
 		return;
 	}
 
-	if(ioctl(fb, FBIOGET_FSCREENINFO, &fix_screeninfo) == -1)
+	if (ioctl(fb, FBIOGET_FSCREENINFO, &fix_screeninfo) == -1)
 	{
 		fprintf(stderr, "Framebuffer: <FBIOGET_FSCREENINFO failed>\n");
 		close(fb);
 		return;
 	}
 
-	if(ioctl(fb, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
+	if (ioctl(fb, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
 	{
 		fprintf(stderr, "Framebuffer: <FBIOGET_VSCREENINFO failed>\n");
 		close(fb);
 		return;
 	}
 
-	if(!(lfb = (unsigned char*)mmap(0, fix_screeninfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb, 0)))
+	if (!(lfb = (unsigned char *)mmap(0, fix_screeninfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fb, 0)))
 	{
 		fprintf(stderr, "Framebuffer: <Memmapping failed>\n");
 		close(fb);
 		return;
 	}
 
-	if ( var_screeninfo.bits_per_pixel == 32 )
+	if (var_screeninfo.bits_per_pixel == 32)
 	{
 		fprintf(stderr, "Grabbing 32bit Framebuffer ...\n");
 		// get 32bit framebuffer
-		memcpy(osd_data,lfb,fix_screeninfo.line_length*var_screeninfo.yres);
+		memcpy(osd_data, lfb, fix_screeninfo.line_length * var_screeninfo.yres);
 	}
 	close(fb);
 }
 
-inline void rgb24torgb32(unsigned char  *src, unsigned char *dest,int picsize) {
-	for (int i = 0; i < picsize; i++) {
+inline void rgb24torgb32(unsigned char  *src, unsigned char *dest, int picsize)
+{
+	for (int i = 0; i < picsize; i++)
+	{
 		*dest++ = *src++;
 		*dest++ = *src++;
 		*dest++ = *src++;
@@ -1135,30 +1340,32 @@
 }
 
 /* TODO: aspect ratio correction and PIP */
-bool cVideo::GetScreenImage(unsigned char * &out_data, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
+bool cVideo::GetScreenImage(unsigned char*&out_data, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
 {
 #define VDEC_PIXFMT AV_PIX_FMT_BGR24
 
 	hal_info("%s: out_data 0x%p xres %d yres %d vid %d osd %d scale %d\n",
-		__func__, out_data, xres, yres, get_video, get_osd, scale_to_video);
+	    __func__, out_data, xres, yres, get_video, get_osd, scale_to_video);
 	int aspect = 0;
 	getPictureInfo(xres, yres, aspect); /* aspect is dummy here */
 	aspect = getAspectRatio();
-	if(xres < 1 || yres < 1 )
+	if (xres < 1 || yres < 1)
 		get_video = false;
 
 
-	if(!get_video && !get_osd)
+	if (!get_video && !get_osd)
 		return false;
 
 	int osd_w = 0;
 	int osd_h = 0;
 	int bits_per_pixel = 0;
-	if(get_osd){
+	if (get_osd)
+	{
 		get_osd_size(osd_w, osd_h, bits_per_pixel);
-		if(osd_w < 1 || osd_h < 1 || bits_per_pixel != 32)
+		if (osd_w < 1 || osd_h < 1 || bits_per_pixel != 32)
 			get_osd = false;
-		if(!scale_to_video && get_osd){
+		if (!scale_to_video && get_osd)
+		{
 			xres = osd_w;
 			yres = osd_h;
 		}
@@ -1168,41 +1375,52 @@
 	if (out_data == NULL)
 		return false;
 
-	if (get_video) {
-		const int grab_w = 1920; const int grab_h = 1080; //hd51 video0 is always 1920x1080 
+	if (get_video)
+	{
+		const int grab_w = 1920;
+		const int grab_h = 1080; //hd51 video0 is always 1920x1080
 		unsigned char *video_src = (unsigned char *)malloc(grab_w * grab_h * 3);
 		if (video_src == NULL)
 			return false;
-		if(getvideo2(video_src, grab_w,grab_h) == false){
+		if (getvideo2(video_src, grab_w, grab_h) == false)
+		{
 			free(out_data);
 			free(video_src);
 			return false;
 		}
-		if (grab_w != xres || grab_h != yres){ /* scale video into data... */
-			bool ret = swscale(video_src, out_data, grab_w, grab_h, xres, yres,VDEC_PIXFMT);
-			if(!ret){
+		if (grab_w != xres || grab_h != yres)  /* scale video into data... */
+		{
+			bool ret = swscale(video_src, out_data, grab_w, grab_h, xres, yres, VDEC_PIXFMT);
+			if (!ret)
+			{
 				free(out_data);
 				free(video_src);
 				return false;
 			}
-		}else{ /* get_video and no fancy scaling needed */
+		}
+		else   /* get_video and no fancy scaling needed */
+		{
 			rgb24torgb32(video_src, out_data, grab_w * grab_h);
 		}
 		free(video_src);
 	}
 
-	if(get_osd){
+	if (get_osd)
+	{
 		osd_data = (unsigned char *)malloc(osd_w * osd_h * 4);
-		if(osd_data)
+		if (osd_data)
 			get_osd_buf(osd_data);
 	}
 
-	if (get_osd && (osd_w != xres || osd_h != yres)) {
+	if (get_osd && (osd_w != xres || osd_h != yres))
+	{
 		/* rescale osd */
 		unsigned char *osd_src = (unsigned char *)malloc(xres * yres * 4);
-		if(osd_src){
-			bool ret = swscale(osd_data, osd_src, osd_w, osd_h, xres, yres,AV_PIX_FMT_RGB32);
-			if(!ret){
+		if (osd_src)
+		{
+			bool ret = swscale(osd_data, osd_src, osd_w, osd_h, xres, yres, AV_PIX_FMT_RGB32);
+			if (!ret)
+			{
 				free(out_data);
 				free(osd_data);
 				free(osd_src);
@@ -1211,30 +1429,38 @@
 			free(osd_data);
 			osd_data = NULL;
 			osd_data = osd_src;
-		}else{
+		}
+		else
+		{
 			free(out_data);
 			free(osd_data);
 			return false;
 		}
 	}
 
-	if (get_video && get_osd) {
+	if (get_video && get_osd)
+	{
 		/* alpha blend osd onto out_data (video). TODO: maybe libavcodec can do this? */
 		uint32_t *d = (uint32_t *)out_data;
 		uint32_t *pixpos = (uint32_t *) osd_data;
-		for (int count = 0; count < yres; count++) {
-			for (int count2 = 0; count2 < xres; count2++ ) {
+		for (int count = 0; count < yres; count++)
+		{
+			for (int count2 = 0; count2 < xres; count2++)
+			{
 				uint32_t pix = *pixpos;
 				if ((pix & 0xff000000) == 0xff000000)
 					*d = pix;
-				else {
+				else
+				{
 					uint8_t *in = (uint8_t *)(pixpos);
 					uint8_t *out = (uint8_t *)d;
-					int a = in[3];	/* TODO: big/little endian? */
+					int a = in[3];  /* TODO: big/little endian? */
 					*out = (*out + ((*in - *out) * a) / 256);
-					in++; out++;
+					in++;
+					out++;
 					*out = (*out + ((*in - *out) * a) / 256);
-					in++; out++;
+					in++;
+					out++;
 					*out = (*out + ((*in - *out) * a) / 256);
 				}
 				d++;
@@ -1245,7 +1471,7 @@
 	else if (get_osd) /* only get_osd, out_data is not yet populated */
 		memcpy(out_data, osd_data, xres * yres * sizeof(uint32_t));
 
-	if(osd_data)
+	if (osd_data)
 		free(osd_data);
 
 	return true;
@@ -1265,3 +1491,13 @@
 {
 	hdmi_cec::getInstance()->SetCECAutoView(state);
 }
+
+int cVideo::GetAudioDestination()
+{
+	return (int)hdmi_cec::getInstance()->GetAudioDestination();
+}
+
+void cVideo::SetAudioDestination(int audio_dest)
+{
+	hdmi_cec::getInstance()->SetAudioDestination(audio_dest);
+}
diff -Nur libstb-hal-ddt.git.orig/libmipsbox/video_lib.h libstb-hal-ddt.git/libmipsbox/video_lib.h
--- libstb-hal-ddt.git.orig/libmipsbox/video_lib.h	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libmipsbox/video_lib.h	2022-07-23 18:18:31.503773029 +0200
@@ -10,31 +10,25 @@
 	char format[16];
 } cs_vs_format_struct_t;
 
-typedef enum {
-	ANALOG_SD_RGB_CINCH = 0x00,
-	ANALOG_SD_YPRPB_CINCH,
-	ANALOG_HD_RGB_CINCH,
-	ANALOG_HD_YPRPB_CINCH,
-	ANALOG_SD_RGB_SCART = 0x10,
-	ANALOG_SD_YPRPB_SCART,
-	ANALOG_HD_RGB_SCART,
-	ANALOG_HD_YPRPB_SCART,
-	ANALOG_SCART_MASK = 0x10
-} analog_mode_t;
-
-typedef enum {
-	COLORFORMAT_RGB = 0x10, // keep compatible with analog_mode_t
-	COLORFORMAT_YUV,
-	COLORFORMAT_CVBS,
-	COLORFORMAT_SVIDEO,
-	COLORFORMAT_HDMI_AUTO,
-	COLORFORMAT_HDMI_RGB,
-	COLORFORMAT_HDMI_YCBCR444,
-	COLORFORMAT_HDMI_YCBCR422,
-	COLORFORMAT_HDMI_YCBCR420
-} COLOR_FORMAT;
+#if BOXMODEL_VUPLUS_ARM
+typedef enum
+{
+	HDMI_COLORIMETRY_AUTO,
+	HDMI_COLORIMETRY_BT709,
+	HDMI_COLORIMETRY_BT470
+} HDMI_COLORIMETRY;
+#else
+typedef enum
+{
+	HDMI_COLORIMETRY_AUTO,
+	HDMI_COLORIMETRY_BT2020NCL,
+	HDMI_COLORIMETRY_BT2020CL,
+	HDMI_COLORIMETRY_BT709
+} HDMI_COLORIMETRY;
+#endif
 
-typedef enum {
+typedef enum
+{
 	VIDEO_FORMAT_MPEG2 = 0,
 	VIDEO_FORMAT_MPEG4_H264,
 	VIDEO_FORMAT_VC1,
@@ -45,16 +39,8 @@
 	VIDEO_FORMAT_AVS = 16
 } VIDEO_FORMAT;
 
-typedef enum {
-	VIDEO_SD = 0,
-	VIDEO_HD,
-	VIDEO_120x60i,
-	VIDEO_320x240i,
-	VIDEO_1440x800i,
-	VIDEO_360x288i
-} VIDEO_DEFINITION;
-
-typedef enum {
+typedef enum
+{
 	VIDEO_FRAME_RATE_23_976 = 0,
 	VIDEO_FRAME_RATE_24,
 	VIDEO_FRAME_RATE_25,
@@ -65,29 +51,24 @@
 	VIDEO_FRAME_RATE_60
 } VIDEO_FRAME_RATE;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_1_1,
 	DISPLAY_AR_4_3,
-	DISPLAY_AR_14_9,
 	DISPLAY_AR_16_9,
 	DISPLAY_AR_20_9,
 	DISPLAY_AR_RAW
 } DISPLAY_AR;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_MODE_PANSCAN = 0,
 	DISPLAY_AR_MODE_LETTERBOX,
-	DISPLAY_AR_MODE_NONE,
-	DISPLAY_AR_MODE_PANSCAN2
+	DISPLAY_AR_MODE_NONE
 } DISPLAY_AR_MODE;
 
-typedef enum {
-	VIDEO_DB_DR_NEITHER = 0,
-	VIDEO_DB_ON,
-	VIDEO_DB_DR_BOTH
-} VIDEO_DB_DR;
-
-typedef enum {
+typedef enum
+{
 	VIDEO_PLAY_STILL = 0,
 	VIDEO_PLAY_CLIP,
 	VIDEO_PLAY_TRICK,
@@ -95,7 +76,8 @@
 	VIDEO_PLAY_MOTION_NO_SYNC
 } VIDEO_PLAY_MODE;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_STD_NTSC,
 	VIDEO_STD_SECAM,
 	VIDEO_STD_PAL,
@@ -120,7 +102,8 @@
 	VIDEO_STD_MAX = VIDEO_STD_AUTO
 } VIDEO_STD;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_HDMI_CEC_MODE_OFF = 0,
 	VIDEO_HDMI_CEC_MODE_TUNER = 3,
 	VIDEO_HDMI_CEC_MODE_RECORDER = 1
@@ -128,6 +111,13 @@
 
 typedef enum
 {
+	VIDEO_HDMI_CEC_VOL_OFF = 0,
+	VIDEO_HDMI_CEC_VOL_AUDIOSYSTEM = 1,
+	VIDEO_HDMI_CEC_VOL_TV = 2
+} VIDEO_HDMI_CEC_VOL;
+
+typedef enum
+{
 	VIDEO_CONTROL_BRIGHTNESS = 0,
 	VIDEO_CONTROL_CONTRAST,
 	VIDEO_CONTROL_SATURATION,
@@ -150,11 +140,12 @@
 
 class cVideo
 {
-	friend class cPlayback;
-	friend class cDemux;
+		friend class cPlayback;
+		friend class cDemux;
 	private:
 		/* video device */
 		int fd;
+		bool fdd;
 		unsigned int devnum;
 		/* apparently we cannot query the driver's state
 		   => remember it */
@@ -163,11 +154,9 @@
 		int /*vidOutFmt_t*/ outputformat;
 
 		VIDEO_FORMAT StreamType;
-		VIDEO_DEFINITION VideoDefinition;
 		DISPLAY_AR DisplayAR;
 		VIDEO_PLAY_MODE SyncMode;
 		DISPLAY_AR_MODE ARMode;
-		VIDEO_DB_DR eDbDr;
 		DISPLAY_AR PictureAR;
 		VIDEO_FRAME_RATE FrameRate;
 		int video_standby;
@@ -185,10 +174,10 @@
 		int dynamic_contrast;
 		int scaler_sharpness;
 		int zapping_mode;
+		int blank_mode;
 
 		/* used internally by dmx */
 		int64_t GetPTS(void);
-
 	public:
 		/* constructor & destructor */
 		cVideo(int mode, void *, void *, unsigned int unit = 0);
@@ -198,8 +187,19 @@
 		void openDevice(void);
 		void closeDevice(void);
 
-		void * GetTVEnc() { return NULL; };
-		void * GetTVEncSD() { return NULL; };
+		void open_AVInput_Device(void);
+		void close_AVInput_Device(void);
+
+		void setAVInput(int val);
+
+		void *GetTVEnc()
+		{
+			return NULL;
+		};
+		void *GetTVEncSD()
+		{
+			return NULL;
+		};
 
 		/* aspect ratio */
 		int getAspectRatio(void);
@@ -224,7 +224,7 @@
 		/* get video system infos */
 		int GetVideoSystem(void);
 		/* when system = -1 then use current video system */
-		void GetVideoSystemFormatName(cs_vs_format_t* format, int system);
+		void GetVideoSystemFormatName(cs_vs_format_t *format, int system);
 
 		/* set video_system */
 		int SetVideoSystem(int video_system, bool remember = true);
@@ -233,23 +233,40 @@
 		bool SetCECMode(VIDEO_HDMI_CEC_MODE);
 		void SetCECAutoView(bool);
 		void SetCECAutoStandby(bool);
-		void ShowPicture(const char * fname);
+		int  GetAudioDestination();
+		void SetAudioDestination(int audio_dest);
+		bool ShowPicture(const char *fname);
 		void StopPicture();
 		void Standby(unsigned int bOn);
+		void ShowPig(int _x);
 		void Pig(int x, int y, int w, int h, int osd_w = 1064, int osd_h = 600, int startx = 0, int starty = 0, int endx = 1279, int endy = 719);
 		void SetControl(int, int);
 		void setContrast(int val);
-		void SetVideoMode(analog_mode_t mode);
-		void SetDBDR(int) { return; };
-		void SetAudioHandle(void *) { return; };
-		void SetAutoModes(int [VIDEO_STD_MAX]) { return; };
-		int  OpenVBI(int) { return 0; };
-		int  CloseVBI(void) { return 0; };
-		int  StartVBI(unsigned short) { return 0; };
-		int  StopVBI(void) { return 0; };
+		void QuadPiP(bool active = false, int _x = 0, int _y = 0, int _w = 360, int _h = 288);
+
+		void SetAudioHandle(void *)
+		{
+			return;
+		};
+		int  OpenVBI(int)
+		{
+			return 0;
+		};
+		int  CloseVBI(void)
+		{
+			return 0;
+		};
+		int  StartVBI(unsigned short)
+		{
+			return 0;
+		};
+		int  StopVBI(void)
+		{
+			return 0;
+		};
 		void SetDemux(cDemux *dmx);
-		void SetColorFormat(COLOR_FORMAT color_format);
-		bool GetScreenImage(unsigned char * &data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
+		void SetHDMIColorimetry(HDMI_COLORIMETRY hdmi_colorimetry);
+		bool GetScreenImage(unsigned char*&data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
 };
 
 #endif // __VIDEO_LIB_H__
diff -Nur libstb-hal-ddt.git.orig/libraspi/audio.cpp libstb-hal-ddt.git/libraspi/audio.cpp
--- libstb-hal-ddt.git.orig/libraspi/audio.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/audio.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -27,7 +27,7 @@
 #define hal_debug(args...) _hal_debug(HAL_DEBUG_AUDIO, this, args)
 #define hal_info(args...) _hal_info(HAL_DEBUG_AUDIO, this, args)
 
-cAudio * audioDecoder = NULL;
+cAudio *audioDecoder = NULL;
 
 cAudio::cAudio(void *, void *, void *)
 {
@@ -114,12 +114,12 @@
 void cAudio::getAudioInfo(int &type, int &layer, int &freq, int &bitrate, int &mode)
 {
 	type = 0;
-	layer = 0;	/* not used */
+	layer = 0;  /* not used */
 	freq = 0;
-	bitrate = 0;	/* not used, but easy to get :-) */
-	mode = 0;	/* default: stereo */
+	bitrate = 0;    /* not used, but easy to get :-) */
+	mode = 0;   /* default: stereo */
 	hal_debug("%s t: %d l: %d f: %d b: %d m: %d\n",
-		  __func__, type, layer, freq, bitrate, mode);
+	    __func__, type, layer, freq, bitrate, mode);
 };
 
 void cAudio::SetSRS(int /*iq_enable*/, int /*nmgr_enable*/, int /*iq_mode*/, int /*iq_level*/)
diff -Nur libstb-hal-ddt.git.orig/libraspi/audio_lib.h libstb-hal-ddt.git/libraspi/audio_lib.h
--- libstb-hal-ddt.git.orig/libraspi/audio_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/audio_lib.h	2022-07-23 18:18:31.539772306 +0200
@@ -13,7 +13,8 @@
 	AUDIO_SYNC_AUDIO_MASTER
 } AUDIO_SYNC_MODE;
 
-typedef enum {
+typedef enum
+{
 	HDMI_ENCODED_OFF,
 	HDMI_ENCODED_AUTO,
 	HDMI_ENCODED_FORCED
@@ -39,7 +40,7 @@
 
 class cAudio
 {
-	friend class cPlayback;
+		friend class cPlayback;
 	private:
 		int fd;
 		bool Muted;
@@ -48,7 +49,7 @@
 		int mixer_fd;  /* if we are using the OSS mixer */
 		int mixer_num; /* oss mixer to use, if any */
 
-		AUDIO_FORMAT	StreamType;
+		AUDIO_FORMAT    StreamType;
 		AUDIO_SYNC_MODE    SyncMode;
 		bool started;
 		bool thread_started;
@@ -66,17 +67,35 @@
 		/* construct & destruct */
 		cAudio(void *, void *, void *);
 		~cAudio(void);
-		int64_t getPts() { return curr_pts; }
-
-		void *GetHandle() { return NULL; };
+		int64_t getPts()
+		{
+			return curr_pts;
+		}
+
+		void *GetHandle()
+		{
+			return NULL;
+		};
 		/* shut up */
-		int mute(bool remember = true) { return do_mute(true, remember); };
-		int unmute(bool remember = true) { return do_mute(false, remember); };
+		int mute(bool remember = true)
+		{
+			return do_mute(true, remember);
+		};
+		int unmute(bool remember = true)
+		{
+			return do_mute(false, remember);
+		};
 
 		/* volume, min = 0, max = 255 */
 		int setVolume(unsigned int left, unsigned int right);
-		int getVolume(void) { return volume;}
-		bool getMuteStatus(void) { return Muted; };
+		int getVolume(void)
+		{
+			return volume;
+		}
+		bool getMuteStatus(void)
+		{
+			return Muted;
+		};
 
 		/* start and stop audio */
 		int Start(void);
@@ -88,9 +107,9 @@
 		/* select channels */
 		int setChannel(int channel);
 		int PrepareClipPlay(int uNoOfChannels, int uSampleRate, int uBitsPerSample, int bLittleEndian);
-		int WriteClip(unsigned char * buffer, int size);
+		int WriteClip(unsigned char *buffer, int size);
 		int StopClip();
-		void getAudioInfo(int &type, int &layer, int& freq, int &bitrate, int &mode);
+		void getAudioInfo(int &type, int &layer, int &freq, int &bitrate, int &mode);
 		void SetSRS(int iq_enable, int nmgr_enable, int iq_mode, int iq_level);
 		bool IsHdmiDDSupported();
 		void SetHdmiDD(bool enable);
diff -Nur libstb-hal-ddt.git.orig/libraspi/dmx.cpp libstb-hal-ddt.git/libraspi/dmx.cpp
--- libstb-hal-ddt.git.orig/libraspi/dmx.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/dmx.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -44,15 +44,16 @@
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_DEMUX, NULL, args)
 
 #define dmx_err(_errfmt, _errstr, _revents) do { \
-	hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
-		__func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
+    hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
+        __func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
 } while(0);
 
 cDemux *videoDemux = NULL;
 cDemux *audioDemux = NULL;
 //cDemux *pcrDemux = NULL;
 
-static const char *DMX_T[] = {
+static const char *DMX_T[] =
+{
 	"DMX_INVALID",
 	"DMX_VIDEO",
 	"DMX_AUDIO",
@@ -64,7 +65,8 @@
 };
 
 /* map the device numbers. for now only demux0 is used */
-static const char *devname[] = {
+static const char *devname[] =
+{
 	"/dev/dvb/adapter0/demux0",
 	"/dev/dvb/adapter0/demux0",
 	"/dev/dvb/adapter0/demux0"
@@ -95,7 +97,7 @@
 bool cDemux::Open(DMX_CHANNEL_TYPE pes_type, void * /*hVideoBuffer*/, int uBufferSize)
 {
 	int devnum = num;
-	int flags = O_RDWR|O_CLOEXEC;
+	int flags = O_RDWR | O_CLOEXEC;
 	if (fd > -1)
 		hal_info("%s FD ALREADY OPENED? fd = %d\n", __FUNCTION__, fd);
 
@@ -110,12 +112,12 @@
 		return false;
 	}
 	hal_debug("%s #%d pes_type: %s(%d), uBufferSize: %d fd: %d\n", __func__,
-		 num, DMX_T[pes_type], pes_type, uBufferSize, fd);
+	    num, DMX_T[pes_type], pes_type, uBufferSize, fd);
 
 	if (dmx_type == DMX_VIDEO_CHANNEL)
-		uBufferSize = 0x100000;		/* 1MB */
+		uBufferSize = 0x100000;     /* 1MB */
 	if (dmx_type == DMX_AUDIO_CHANNEL)
-		uBufferSize = 0x10000;		/* 64k */
+		uBufferSize = 0x10000;      /* 64k */
 #if 0
 	if (!pesfds.empty())
 	{
@@ -190,17 +192,17 @@
 #if 0
 	if (len != 4095 && timeout != 100)
 		fprintf(stderr, "cDemux::%s #%d fd: %d type: %s len: %d timeout: %d\n",
-			__FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
+		    __FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
 #endif
 	int rc;
 	struct pollfd ufds;
 	ufds.fd = fd;
-	ufds.events = POLLIN|POLLPRI|POLLERR;
+	ufds.events = POLLIN | POLLPRI | POLLERR;
 	ufds.revents = 0;
 
 	if (timeout > 0)
 	{
- retry:
+retry:
 		rc = ::poll(&ufds, 1, timeout);
 		if (!rc)
 			return 0; // timeout
@@ -241,9 +243,9 @@
 	return rc;
 }
 
-bool cDemux::sectionFilter(unsigned short _pid, const unsigned char * const filter,
-			   const unsigned char * const mask, int len, int timeout,
-			   const unsigned char * const negmask)
+bool cDemux::sectionFilter(unsigned short _pid, const unsigned char *const filter,
+    const unsigned char *const mask, int len, int timeout,
+    const unsigned char *const negmask)
 {
 	struct dmx_sct_filter_params s_flt;
 	memset(&s_flt, 0, sizeof(s_flt));
@@ -262,79 +264,80 @@
 	if (negmask != NULL)
 		memcpy(s_flt.filter.mode, negmask, len);
 
-	s_flt.flags = DMX_IMMEDIATE_START|DMX_CHECK_CRC;
+	s_flt.flags = DMX_IMMEDIATE_START | DMX_CHECK_CRC;
 
 	int to = 0;
-	switch (filter[0]) {
-	case 0x00: /* program_association_section */
-		to = 2000;
-		break;
-	case 0x01: /* conditional_access_section */
-		to = 6000;
-		break;
-	case 0x02: /* program_map_section */
-		to = 1500;
-		break;
-	case 0x03: /* transport_stream_description_section */
-		to = 10000;
-		break;
-	/* 0x04 - 0x3F: reserved */
-	case 0x40: /* network_information_section - actual_network */
-		to = 10000;
-		break;
-	case 0x41: /* network_information_section - other_network */
-		to = 15000;
-		break;
-	case 0x42: /* service_description_section - actual_transport_stream */
-		to = 10000;
-		break;
-	/* 0x43 - 0x45: reserved for future use */
-	case 0x46: /* service_description_section - other_transport_stream */
-		to = 10000;
-		break;
-	/* 0x47 - 0x49: reserved for future use */
-	case 0x4A: /* bouquet_association_section */
-		to = 11000;
-		break;
-	/* 0x4B - 0x4D: reserved for future use */
-	case 0x4E: /* event_information_section - actual_transport_stream, present/following */
-		to = 2000;
-		break;
-	case 0x4F: /* event_information_section - other_transport_stream, present/following */
-		to = 10000;
-		break;
-	/* 0x50 - 0x5F: event_information_section - actual_transport_stream, schedule */
-	/* 0x60 - 0x6F: event_information_section - other_transport_stream, schedule */
-	case 0x70: /* time_date_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		//s_flt.pid     = 0x0014;
-		to = 30000;
-		break;
-	case 0x71: /* running_status_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		to = 0;
-		break;
-	case 0x72: /* stuffing_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		to = 0;
-		break;
-	case 0x73: /* time_offset_section */
-		//s_flt.pid     = 0x0014;
-		to = 30000;
-		break;
-	/* 0x74 - 0x7D: reserved for future use */
-	case 0x7E: /* discontinuity_information_section */
-		s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
-		to = 0;
-		break;
-	case 0x7F: /* selection_information_section */
-		to = 0;
-		break;
-	/* 0x80 - 0x8F: ca_message_section */
-	/* 0x90 - 0xFE: user defined */
-	/*        0xFF: reserved */
-	default:
-		break;
+	switch (filter[0])
+	{
+		case 0x00: /* program_association_section */
+			to = 2000;
+			break;
+		case 0x01: /* conditional_access_section */
+			to = 6000;
+			break;
+		case 0x02: /* program_map_section */
+			to = 1500;
+			break;
+		case 0x03: /* transport_stream_description_section */
+			to = 10000;
+			break;
+		/* 0x04 - 0x3F: reserved */
+		case 0x40: /* network_information_section - actual_network */
+			to = 10000;
+			break;
+		case 0x41: /* network_information_section - other_network */
+			to = 15000;
+			break;
+		case 0x42: /* service_description_section - actual_transport_stream */
+			to = 10000;
+			break;
+		/* 0x43 - 0x45: reserved for future use */
+		case 0x46: /* service_description_section - other_transport_stream */
+			to = 10000;
+			break;
+		/* 0x47 - 0x49: reserved for future use */
+		case 0x4A: /* bouquet_association_section */
+			to = 11000;
+			break;
+		/* 0x4B - 0x4D: reserved for future use */
+		case 0x4E: /* event_information_section - actual_transport_stream, present/following */
+			to = 2000;
+			break;
+		case 0x4F: /* event_information_section - other_transport_stream, present/following */
+			to = 10000;
+			break;
+		/* 0x50 - 0x5F: event_information_section - actual_transport_stream, schedule */
+		/* 0x60 - 0x6F: event_information_section - other_transport_stream, schedule */
+		case 0x70: /* time_date_section */
+			s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
+			//s_flt.pid     = 0x0014;
+			to = 30000;
+			break;
+		case 0x71: /* running_status_section */
+			s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
+			to = 0;
+			break;
+		case 0x72: /* stuffing_section */
+			s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
+			to = 0;
+			break;
+		case 0x73: /* time_offset_section */
+			//s_flt.pid     = 0x0014;
+			to = 30000;
+			break;
+		/* 0x74 - 0x7D: reserved for future use */
+		case 0x7E: /* discontinuity_information_section */
+			s_flt.flags &= ~DMX_CHECK_CRC; /* section has no CRC */
+			to = 0;
+			break;
+		case 0x7F: /* selection_information_section */
+			to = 0;
+			break;
+		/* 0x80 - 0x8F: ca_message_section */
+		/* 0x90 - 0xFE: user defined */
+		/*        0xFF: reserved */
+		default:
+			break;
 //		return -1;
 	}
 	/* the negmask == NULL is a hack: the users of negmask are PMT-update
@@ -344,13 +347,22 @@
 		s_flt.timeout = to;
 
 	hal_debug("%s #%d pid:0x%04hx fd:%d type:%s len:%d to:%d flags:%x flt[0]:%02x\n", __func__, num,
-		pid, fd, DMX_T[dmx_type], len, s_flt.timeout,s_flt.flags, s_flt.filter.filter[0]);
-#if 0
-	fprintf(stderr,"filt: ");for(int i=0;i<DMX_FILTER_SIZE;i++)fprintf(stderr,"%02hhx ",s_flt.filter.filter[i]);fprintf(stderr,"\n");
-	fprintf(stderr,"mask: ");for(int i=0;i<DMX_FILTER_SIZE;i++)fprintf(stderr,"%02hhx ",s_flt.filter.mask  [i]);fprintf(stderr,"\n");
-	fprintf(stderr,"mode: ");for(int i=0;i<DMX_FILTER_SIZE;i++)fprintf(stderr,"%02hhx ",s_flt.filter.mode  [i]);fprintf(stderr,"\n");
-#endif
-	ioctl (fd, DMX_STOP);
+	    pid, fd, DMX_T[dmx_type], len, s_flt.timeout, s_flt.flags, s_flt.filter.filter[0]);
+
+	if (debuglevel == 2)
+	{
+		fprintf(stderr, "filt: ");
+		for (int i = 0; i < DMX_FILTER_SIZE; i++)fprintf(stderr, "%02hhx ", s_flt.filter.filter[i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mask: ");
+		for (int i = 0; i < DMX_FILTER_SIZE; i++)fprintf(stderr, "%02hhx ", s_flt.filter.mask  [i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mode: ");
+		for (int i = 0; i < DMX_FILTER_SIZE; i++)fprintf(stderr, "%02hhx ", s_flt.filter.mode  [i]);
+		fprintf(stderr, "\n");
+	}
+
+	ioctl(fd, DMX_STOP);
 	if (ioctl(fd, DMX_SET_FILTER, &s_flt) < 0)
 		return false;
 
@@ -366,7 +378,7 @@
 	 * this check originally is from tuxbox cvs but I'm not sure
 	 * what it is good for...
 	if (pid <= 0x0001 && dmx_type != DMX_PCR_ONLY_CHANNEL)
-		return false;
+	    return false;
 	 */
 	if ((pid >= 0x0002 && pid <= 0x000f) || pid >= 0x1fff)
 		return false;
@@ -378,31 +390,32 @@
 	p_flt.output = DMX_OUT_DECODER;
 	p_flt.input  = DMX_IN_FRONTEND;
 
-	switch (dmx_type) {
-	case DMX_PCR_ONLY_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TAP;
-		return true;
-		break;
-	case DMX_AUDIO_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TSDEMUX_TAP;
-		break;
-	case DMX_VIDEO_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TSDEMUX_TAP;
-		break;
-	case DMX_PES_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TAP;
-		break;
-	case DMX_TP_CHANNEL:
-		p_flt.pes_type = DMX_PES_OTHER;
-		p_flt.output  = DMX_OUT_TSDEMUX_TAP;
-		break;
-	default:
-		hal_info("%s #%d invalid dmx_type %d!\n", __func__, num, dmx_type);
-		return false;
+	switch (dmx_type)
+	{
+		case DMX_PCR_ONLY_CHANNEL:
+			p_flt.pes_type = DMX_PES_OTHER;
+			p_flt.output  = DMX_OUT_TAP;
+			return true;
+			break;
+		case DMX_AUDIO_CHANNEL:
+			p_flt.pes_type = DMX_PES_OTHER;
+			p_flt.output  = DMX_OUT_TSDEMUX_TAP;
+			break;
+		case DMX_VIDEO_CHANNEL:
+			p_flt.pes_type = DMX_PES_OTHER;
+			p_flt.output  = DMX_OUT_TSDEMUX_TAP;
+			break;
+		case DMX_PES_CHANNEL:
+			p_flt.pes_type = DMX_PES_OTHER;
+			p_flt.output  = DMX_OUT_TAP;
+			break;
+		case DMX_TP_CHANNEL:
+			p_flt.pes_type = DMX_PES_OTHER;
+			p_flt.output  = DMX_OUT_TSDEMUX_TAP;
+			break;
+		default:
+			hal_info("%s #%d invalid dmx_type %d!\n", __func__, num, dmx_type);
+			return false;
 	}
 	return (ioctl(fd, DMX_SET_PES_FILTER, &p_flt) >= 0);
 }
@@ -454,7 +467,8 @@
 	}
 	for (std::vector<pes_pids>::iterator i = pesfds.begin(); i != pesfds.end(); ++i)
 	{
-		if ((*i).pid == Pid) {
+		if ((*i).pid == Pid)
+		{
 			hal_debug("removePid: removing demux fd %d pid 0x%04x\n", fd, Pid);
 			if (ioctl(fd, DMX_REMOVE_PID, Pid) < 0)
 				hal_info("%s: (DMX_REMOVE_PID, 0x%04hx): %m\n", __func__, Pid);
@@ -465,7 +479,7 @@
 	hal_info("%s pid 0x%04x not found\n", __FUNCTION__, Pid);
 }
 
-void cDemux::getSTC(int64_t * STC)
+void cDemux::getSTC(int64_t *STC)
 {
 	int64_t pts = 0;
 	if (videoDecoder)
diff -Nur libstb-hal-ddt.git.orig/libraspi/dmx_lib.h libstb-hal-ddt.git/libraspi/dmx_lib.h
--- libstb-hal-ddt.git.orig/libraspi/dmx_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/dmx_lib.h	2022-07-23 18:18:31.539772306 +0200
@@ -16,7 +16,6 @@
 	DMX_AUDIO_CHANNEL,
 	DMX_PES_CHANNEL,
 	DMX_PSI_CHANNEL,
-	DMX_PIP_CHANNEL,
 	DMX_TP_CHANNEL,
 	DMX_PCR_ONLY_CHANNEL
 } DMX_CHANNEL_TYPE;
@@ -31,31 +30,37 @@
 class cPlayback;
 class cDemux
 {
-	friend class cRecord;
-	friend class cPlayback;
+		friend class cRecord;
+		friend class cPlayback;
 	public:
-		bool Open(DMX_CHANNEL_TYPE pes_type, void * x = NULL, int y = 0);
+		bool Open(DMX_CHANNEL_TYPE pes_type, void *x = NULL, int y = 0);
 		void Close(void);
 		bool Start(bool record = false);
 		bool Stop(void);
 		int Read(unsigned char *buff, int len, int Timeout = 0);
-		bool sectionFilter(unsigned short pid, const unsigned char * const filter, const unsigned char * const mask, int len, int Timeout = 0, const unsigned char * const negmask = NULL);
+		bool sectionFilter(unsigned short pid, const unsigned char *const filter, const unsigned char *const mask, int len, int Timeout = 0, const unsigned char *const negmask = NULL);
 		bool pesFilter(const unsigned short pid);
 		void SetSyncMode(AVSYNC_TYPE mode);
-		void * getBuffer();
-		void * getChannel();
-		DMX_CHANNEL_TYPE getChannelType(void) { return dmx_type; };
+		void *getBuffer();
+		void *getChannel();
+		DMX_CHANNEL_TYPE getChannelType(void)
+		{
+			return dmx_type;
+		};
 		bool addPid(unsigned short pid);
-		void getSTC(int64_t * STC);
+		void getSTC(int64_t *STC);
 		int getUnit(void);
 		static bool SetSource(int unit, int source);
 		static int GetSource(int unit);
-		int getFD(void) { return fd; };		/* needed by cPlayback class */
+		int getFD(void)
+		{
+			return fd;
+		};     /* needed by cPlayback class */
 		cDemux(int num = 0);
 		~cDemux();
 
 	private:
-		void removePid(unsigned short Pid);	/* needed by cRecord class */
+		void removePid(unsigned short Pid); /* needed by cRecord class */
 		int num;
 		int fd;
 		int buffersize;
diff -Nur libstb-hal-ddt.git.orig/libraspi/glfb.cpp libstb-hal-ddt.git/libraspi/glfb.cpp
--- libstb-hal-ddt.git.orig/libraspi/glfb.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/glfb.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -1,21 +1,21 @@
 /*
-	Copyright 2013 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
+    Copyright 2013 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
 
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-	GNU General Public License for more details.
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+    GNU General Public License for more details.
 
-	You should have received a copy of the GNU General Public License
-	along with this program. If not, see <http://www.gnu.org/licenses/>.
+    You should have received a copy of the GNU General Public License
+    along with this program. If not, see <http://www.gnu.org/licenses/>.
 
-	The GLFB namespace is just because it's already established by the
-	generic-pc implementation.
+    The GLFB namespace is just because it's already established by the
+    generic-pc implementation.
 */
 
 #include <vector>
@@ -50,10 +50,10 @@
 static OpenThreads::Mutex blit_mutex;
 static OpenThreads::Condition blit_cond;
 
-static bool goodbye = false;	/* if set main loop is left */
-static bool ready = false;	/* condition predicate */
+static bool goodbye = false;    /* if set main loop is left */
+static bool ready = false;  /* condition predicate */
 
-static int width;		/* width and height, fixed for a framebuffer instance */
+static int width;       /* width and height, fixed for a framebuffer instance */
 static int height;
 
 GLFramebuffer::GLFramebuffer(int x, int y)
@@ -126,11 +126,12 @@
 	/* 32bit FB depth, *2 because tuxtxt uses a shadow buffer */
 	osd_buf.resize(pitch * height * 2);
 	hal_info("GLFB: Display is %d x %d, FB is %d x %d, memory size %d\n",
-		info.width, info.height, width, height, osd_buf.size());
+	    info.width, info.height, width, height, osd_buf.size());
 	image = &osd_buf[0];
 	/* initialize to half-transparent grey */
 	memset(image, 0x7f, osd_buf.size());
-	for (int i = 0; i < 2; i++) {
+	for (int i = 0; i < 2; i++)
+	{
 		res[i] = vc_dispmanx_resource_create(type, width, height, &vc_img_ptr[i]);
 		CHECK(res[i]);
 	}
@@ -142,15 +143,15 @@
 	vc_dispmanx_rect_set(&src_rect, 0, 0, width << 16, height << 16);
 	vc_dispmanx_rect_set(&dsp_rect, 0, 0, info.width, info.height);
 	element = vc_dispmanx_element_add(update,
-					  display,
-					  2000 /*layer*/,
-					  &dsp_rect,
-					  res[curr_res],
-					  &src_rect,
-					  DISPMANX_PROTECTION_NONE,
-					  &alpha,
-					  NULL,
-					  DISPMANX_NO_ROTATE);
+	        display,
+	        2000 /*layer*/,
+	        &dsp_rect,
+	        res[curr_res],
+	        &src_rect,
+	        DISPMANX_PROTECTION_NONE,
+	        &alpha,
+	        NULL,
+	        DISPMANX_NO_ROTATE);
 	ret = vc_dispmanx_update_submit_sync(update);
 	CHECK(ret == 0);
 	curr_res = !curr_res;
diff -Nur libstb-hal-ddt.git.orig/libraspi/glfb.h libstb-hal-ddt.git/libraspi/glfb.h
--- libstb-hal-ddt.git.orig/libraspi/glfb.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/glfb.h	2022-07-23 18:18:31.539772306 +0200
@@ -1,18 +1,18 @@
 /*
-	Copyright 2013 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
+    Copyright 2013 Stefan Seyfried <seife@tuxboxcvs.slipkontur.de>
 
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation; either version 2 of the License, or
-	(at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-	GNU General Public License for more details.
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+    GNU General Public License for more details.
 
-	You should have received a copy of the GNU General Public License
-	along with this program. If not, see <http://www.gnu.org/licenses/>.
+    You should have received a copy of the GNU General Public License
+    along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
 #ifndef __glthread__
@@ -23,20 +23,26 @@
 
 class GLFramebuffer : public OpenThreads::Thread
 {
-public:
-	GLFramebuffer(int x, int y);
-	~GLFramebuffer();
-	std::vector<unsigned char> *getOSDBuffer() { return &osd_buf; } /* pointer to OSD bounce buffer */
-	void blit();
-	fb_var_screeninfo getScreenInfo() { return si; }
-
-private:
-	void *pdata;	/* not yet used */
-	fb_var_screeninfo si;
-	std::vector<unsigned char> osd_buf; /* silly bounce buffer */
-	void run();	/* for OpenThreads::Thread */
+	public:
+		GLFramebuffer(int x, int y);
+		~GLFramebuffer();
+		std::vector<unsigned char> *getOSDBuffer()
+		{
+			return &osd_buf;    /* pointer to OSD bounce buffer */
+		}
+		void blit();
+		fb_var_screeninfo getScreenInfo()
+		{
+			return si;
+		}
+
+	private:
+		void *pdata;    /* not yet used */
+		fb_var_screeninfo si;
+		std::vector<unsigned char> osd_buf; /* silly bounce buffer */
+		void run(); /* for OpenThreads::Thread */
 
-	void setup();
-	void blit_osd();
+		void setup();
+		void blit_osd();
 };
 #endif
diff -Nur libstb-hal-ddt.git.orig/libraspi/hardware_caps.c libstb-hal-ddt.git/libraspi/hardware_caps.c
--- libstb-hal-ddt.git.orig/libraspi/hardware_caps.c	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/hardware_caps.c	2022-07-23 18:18:31.539772306 +0200
@@ -26,7 +26,7 @@
 	memset(&caps, 0, sizeof(hw_caps_t));
 
 	initialized = 1;
-	caps.can_shutdown = 1;	/* for testing */
+	caps.can_shutdown = 1;  /* for testing */
 	caps.display_type = HW_DISPLAY_LINE_TEXT;
 	caps.has_HDMI = 1;
 	caps.display_xres = 8;
diff -Nur libstb-hal-ddt.git.orig/libraspi/init.cpp libstb-hal-ddt.git/libraspi/init.cpp
--- libstb-hal-ddt.git.orig/libraspi/init.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/init.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -49,24 +49,24 @@
 static void init_keymap(void)
 {
 	/* same as generic-pc/glfb.cpp */
-	kmap[KEY_ENTER]	= KEY_OK;
-	kmap[KEY_ESC]	= KEY_EXIT;
-	kmap[KEY_E]	= KEY_EPG;
-	kmap[KEY_I]	= KEY_INFO;
-	kmap[KEY_M]	= KEY_MENU;
-	kmap[KEY_F12]	= KEY_VOLUMEUP;		/* different than glfb, as we */
-	kmap[KEY_F11]	= KEY_VOLUMEDOWN;	/* don't consider the keyboard */
-	kmap[KEY_F10]	= KEY_MUTE;		/* layout... */
-	kmap[KEY_H]	= KEY_HELP;
-	kmap[KEY_P]	= KEY_POWER;
-	kmap[KEY_F1]	= KEY_RED;
-	kmap[KEY_F2]	= KEY_GREEN;
-	kmap[KEY_F3]	= KEY_YELLOW;
-	kmap[KEY_F4]	= KEY_BLUE;
-	kmap[KEY_F5]	= KEY_WWW;
-	kmap[KEY_F6]	= KEY_SUBTITLE;
-	kmap[KEY_F7]	= KEY_MOVE;
-	kmap[KEY_F8]	= KEY_SLEEP;
+	kmap[KEY_ENTER] = KEY_OK;
+	kmap[KEY_ESC]   = KEY_EXIT;
+	kmap[KEY_E] = KEY_EPG;
+	kmap[KEY_I] = KEY_INFO;
+	kmap[KEY_M] = KEY_MENU;
+	kmap[KEY_F12]   = KEY_VOLUMEUP;     /* different than glfb, as we */
+	kmap[KEY_F11]   = KEY_VOLUMEDOWN;   /* don't consider the keyboard */
+	kmap[KEY_F10]   = KEY_MUTE;     /* layout... */
+	kmap[KEY_H] = KEY_HELP;
+	kmap[KEY_P] = KEY_POWER;
+	kmap[KEY_F1]    = KEY_RED;
+	kmap[KEY_F2]    = KEY_GREEN;
+	kmap[KEY_F3]    = KEY_YELLOW;
+	kmap[KEY_F4]    = KEY_BLUE;
+	kmap[KEY_F5]    = KEY_WWW;
+	kmap[KEY_F6]    = KEY_SUBTITLE;
+	kmap[KEY_F7]    = KEY_MOVE;
+	kmap[KEY_F8]    = KEY_SLEEP;
 }
 
 class Input: public OpenThreads::Thread
@@ -111,7 +111,7 @@
 	init_keymap();
 	unlink("/tmp/neutrino.input");
 	mkfifo("/tmp/neutrino.input", 0600);
-	out_fd = open("/tmp/neutrino.input", O_RDWR|O_CLOEXEC|O_NONBLOCK);
+	out_fd = open("/tmp/neutrino.input", O_RDWR | O_CLOEXEC | O_NONBLOCK);
 	if (out_fd < 0)
 		hal_info("could not create /tmp/neutrino.input. good luck. error: %m\n");
 
@@ -120,16 +120,19 @@
 		hal_info("no input devices /dev/input/eventX??\n");
 	else
 	{
-		while (n--) {
+		while (n--)
+		{
 			strcpy(inputstr + strlen("/dev/input/"), namelist[n]->d_name);
 			free(namelist[n]);
-			int fd = open(inputstr, O_RDWR|O_CLOEXEC|O_NONBLOCK);
-			if (fd < 0) {
+			int fd = open(inputstr, O_RDWR | O_CLOEXEC | O_NONBLOCK);
+			if (fd < 0)
+			{
 				hal_info("could not open %s:%m\n", inputstr);
 				continue;
 			}
 			ioctl(fd, EVIOCGBIT(0, EV_MAX), &bit);
-			if ((bit & (1 << EV_KEY)) == 0) {
+			if ((bit & (1 << EV_KEY)) == 0)
+			{
 				close(fd);
 				continue;
 			}
@@ -143,29 +146,34 @@
 
 	fd_max++;
 	running = true;
-	while (running) {
+	while (running)
+	{
 		FD_ZERO(&rfds);
 		for (std::set<int>::iterator i = in_fds.begin(); i != in_fds.end(); ++i)
 			FD_SET((*i), &rfds);
 
 		/* timeout should not be necessary, but somehow cancel / cleanup did not
-		 * work correctly with OpenThreads::Thread :-( */
+		 * work correctly with OpenThreads::Thread :-(*/
 		struct timeval timeout = { 0, 100000 }; /* 100ms */
 		int ret = select(fd_max, &rfds, NULL, NULL, &timeout);
 		if (ret == 0) /* timed out */
 			continue;
-		if (ret < 0) {
+		if (ret < 0)
+		{
 			hal_info("input: select returned %d (%m)\n", ret);
 			continue;
 		}
 
-		for (std::set<int>::iterator i = in_fds.begin(); i != in_fds.end(); ++i) {
+		for (std::set<int>::iterator i = in_fds.begin(); i != in_fds.end(); ++i)
+		{
 			if (!FD_ISSET((*i), &rfds))
 				continue;
 
 			ret = read(*i, &in, sizeof(in));
-			if (ret != sizeof(in)) {
-				if (errno == ENODEV) {
+			if (ret != sizeof(in))
+			{
+				if (errno == ENODEV)
+				{
 					close(*i);
 					hal_info("input fd %d vanished?\n", *i);
 					in_fds.erase(i);
@@ -193,7 +201,8 @@
 	if (!initialized)
 		hal_debug_init();
 	hal_info("%s begin, initialized=%d, debug=0x%02x\n", __func__, (int)initialized, debuglevel);
-	if (! glfb) {
+	if (! glfb)
+	{
 		int x = 1280, y = 720; /* default OSD FB resolution */
 		/*
 		 * export GLFB_RESOLUTION=720,576
@@ -203,7 +212,8 @@
 		const char *p = NULL;
 		if (tmp)
 			p = strchr(tmp, ',');
-		if (p) {
+		if (p)
+		{
 			x = atoi(tmp);
 			y = atoi(p + 1);
 		}
diff -Nur libstb-hal-ddt.git.orig/libraspi/playback.cpp libstb-hal-ddt.git/libraspi/playback.cpp
--- libstb-hal-ddt.git.orig/libraspi/playback.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/playback.cpp	2022-07-23 18:18:31.535772387 +0200
@@ -2,7 +2,7 @@
 
 #include "playback_lib.h"
 
-static const char * FILENAME = "playback-dummy";
+static const char *FILENAME = "playback-dummy";
 
 bool cPlayback::Open(playmode_t)
 {
@@ -15,13 +15,13 @@
 
 bool cPlayback::Start(std::string filename, std::string headers)
 {
-	return Start((char*) filename.c_str(),0,0,0,0,0, headers);
+	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers);
 }
 
 bool cPlayback::Start(char *filename, int vpid, int vtype, int apid, int ac3, int duration, std::string /*headers*/)
 {
 	printf("%s:%s - filename=%s vpid=%u vtype=%d apid=%u ac3=%d duration=%i\n",
-		FILENAME, __func__, filename, vpid, vtype, apid, ac3, duration);
+	    FILENAME, __func__, filename, vpid, vtype, apid, ac3, duration);
 	return true;
 }
 
@@ -58,7 +58,7 @@
 
 bool cPlayback::SetPosition(int position, bool)
 {
-	printf("%s:%s %d\n", FILENAME, __func__,position);
+	printf("%s:%s %d\n", FILENAME, __func__, position);
 	return true;
 }
 
diff -Nur libstb-hal-ddt.git.orig/libraspi/playback_lib.h libstb-hal-ddt.git/libraspi/playback_lib.h
--- libstb-hal-ddt.git.orig/libraspi/playback_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/playback_lib.h	2022-07-23 18:18:31.535772387 +0200
@@ -5,10 +5,11 @@
 #include <stdint.h>
 #include <vector>
 
-typedef enum {
+typedef enum
+{
 	PLAYMODE_TS = 0,
 	PLAYMODE_FILE,
-} playmode_t; 
+} playmode_t;
 
 struct AVFormatContext;
 class cPlayback
@@ -27,9 +28,15 @@
 		bool SetAPid(int pid, bool ac3);
 		bool SetSubtitlePid(int pid);
 		bool SetTeletextPid(int pid);
-		int GetAPid(void) { return mAudioStream; }
+		int GetAPid(void)
+		{
+			return mAudioStream;
+		}
 		int GetVPid(void);
-		int GetSubtitlePid(void) { return mSubtitleStream; }
+		int GetSubtitlePid(void)
+		{
+			return mSubtitleStream;
+		}
 		int GetTeletextPid(void);
 		void SuspendSubtitle(bool);
 		int GetFirstTeletextPid(void);
@@ -42,7 +49,10 @@
 		void FindAllSubtitlePids(int *pids, unsigned int *numpids, std::string *language);
 		void FindAllTeletextsubtitlePids(int *pids, unsigned int *numpidt, std::string *tlanguage, int *mags, int *pages);
 		void RequestAbort(void);
-		bool IsPlaying(void) { return false; }
+		bool IsPlaying(void)
+		{
+			return false;
+		}
 		uint64_t GetReadCount(void);
 		void FindAllSubs(uint16_t *pids, unsigned short *supported, uint16_t *numpida, std::string *language);
 		bool SelectSubtitles(int pid);
@@ -52,7 +62,10 @@
 		void GetMetadata(std::vector<std::string> &keys, std::vector<std::string> &values);
 		//
 		~cPlayback();
-		AVFormatContext *GetAVFormatContext(){ return NULL; }
+		AVFormatContext *GetAVFormatContext()
+		{
+			return NULL;
+		}
 		void ReleaseAVFormatContext() {}
 };
 
diff -Nur libstb-hal-ddt.git.orig/libraspi/record.cpp libstb-hal-ddt.git/libraspi/record.cpp
--- libstb-hal-ddt.git.orig/libraspi/record.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/record.cpp	2022-07-23 18:18:31.543772226 +0200
@@ -134,17 +134,21 @@
 	bool found;
 	unsigned short pid;
 	hal_info("%s\n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
 	/* the first PID is the video pid, so start with the second PID... */
-	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+	{
 		found = false;
 		pid = (*i).pid;
-		for (j = 0; j < numapids; j++) {
-			if (pid == apids[j]) {
+		for (j = 0; j < numapids; j++)
+		{
+			if (pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -152,10 +156,13 @@
 		if (!found)
 			dmx->removePid(pid);
 	}
-	for (j = 0; j < numapids; j++) {
+	for (j = 0; j < numapids; j++)
+	{
 		found = false;
-		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
-			if ((*i).pid == apids[j]) {
+		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+		{
+			if ((*i).pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -170,12 +177,14 @@
 {
 	std::vector<pes_pids> pids;
 	hal_info("%s: \n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
-	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i)
+	{
 		if ((*i).pid == pid)
 			return true; /* or is it an error to try to add the same PID twice? */
 	}
@@ -187,14 +196,16 @@
 	char threadname[17];
 	strncpy(threadname, "WriterThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	unsigned int chunk = 0;
-	while (!sem_wait(&sem)) {
+	while (!sem_wait(&sem))
+	{
 		if (!io_len[chunk]) // empty, assume end of recording
 			return;
 		unsigned char *p_buf = io_buf[chunk];
 		size_t p_len = io_len[chunk];
-		while (p_len) {
+		while (p_len)
+		{
 			ssize_t written = write(file_fd, p_buf, p_len);
 			if (written < 0)
 				break;
@@ -214,7 +225,7 @@
 	char threadname[17];
 	strncpy(threadname, "RecordThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	int readsize = bufsize / 16;
 	int buf_pos = 0;
 	int count = 0;
@@ -235,7 +246,7 @@
 	}
 
 	int val = fcntl(file_fd, F_GETFL);
-	if (fcntl(file_fd, F_SETFL, val|O_APPEND))
+	if (fcntl(file_fd, F_SETFL, val | O_APPEND))
 		hal_info("%s: O_APPEND? (%m)\n", __func__);
 
 	memset(&a, 0, sizeof(a));
@@ -250,7 +261,8 @@
 	{
 		if (buf_pos < bufsize)
 		{
-			if (overflow_count) {
+			if (overflow_count)
+			{
 				hal_info("%s: Overflow cleared after %d iterations\n", __func__, overflow_count);
 				overflow_count = 0;
 			}
@@ -259,7 +271,7 @@
 				toread = readsize;
 			ssize_t s = dmx->Read(buf + buf_pos, toread, 50);
 			hal_debug("%s: buf_pos %6d s %6d / %6d\n", __func__,
-				buf_pos, (int)s, bufsize - buf_pos);
+			    buf_pos, (int)s, bufsize - buf_pos);
 			if (s < 0)
 			{
 				if (errno != EAGAIN && (errno != EOVERFLOW || !overflow))
@@ -362,9 +374,9 @@
 	eventServer.registerEvent2(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, "/tmp/neutrino.sock");
 	stream2file_status2_t s;
 	s.status = exit_flag;
-	strncpy(s.filename,basename(myfilename),512);
+	strncpy(s.filename, basename(myfilename), 512);
 	s.filename[511] = '\0';
-	strncpy(s.dir,dirname(myfilename),100);
+	strncpy(s.dir, dirname(myfilename), 100);
 	s.dir[99] = '\0';
 	eventServer.sendEvent(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, &s, sizeof(s));
 	printf("[stream2file]: pthreads exit code: %i, dir: '%s', filename: '%s' myfilename: '%s'\n", exit_flag, s.dir, s.filename, myfilename);
diff -Nur libstb-hal-ddt.git.orig/libraspi/record_lib.h libstb-hal-ddt.git/libraspi/record_lib.h
--- libstb-hal-ddt.git.orig/libraspi/record_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/record_lib.h	2022-07-23 18:18:31.543772226 +0200
@@ -9,13 +9,14 @@
 #define REC_STATUS_OVERFLOW 2
 #define REC_STATUS_STOPPED 4
 
-typedef enum {
+typedef enum
+{
 	RECORD_RUNNING,
 	RECORD_STOPPED,
-	RECORD_FAILED_READ,	/* failed to read from DMX */
-	RECORD_FAILED_OVERFLOW,	/* cannot write fast enough */
-	RECORD_FAILED_FILE,	/* cannot write to file */
-	RECORD_FAILED_MEMORY	/* out of memory */
+	RECORD_FAILED_READ, /* failed to read from DMX */
+	RECORD_FAILED_OVERFLOW, /* cannot write fast enough */
+	RECORD_FAILED_FILE, /* cannot write to file */
+	RECORD_FAILED_MEMORY    /* out of memory */
 } record_state_t;
 
 class cRecord
@@ -38,8 +39,12 @@
 		unsigned char *io_buf[RECORD_WRITER_CHUNKS];
 		size_t io_len[RECORD_WRITER_CHUNKS];
 	public:
-		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024); 
-		void setFailureCallback(void (*f)(void *), void *d) { failureCallback = f; failureData = d; }
+		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024);
+		void setFailureCallback(void (*f)(void *), void *d)
+		{
+			failureCallback = f;
+			failureData = d;
+		}
 		~cRecord();
 
 		bool Open();
diff -Nur libstb-hal-ddt.git.orig/libraspi/video.cpp libstb-hal-ddt.git/libraspi/video.cpp
--- libstb-hal-ddt.git.orig/libraspi/video.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/video.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -81,7 +81,7 @@
 int cVideo::SetVideoSystem(int system, bool)
 {
 	int h;
-	switch(system)
+	switch (system)
 	{
 		case VIDEO_STD_NTSC:
 		case VIDEO_STD_480P:
@@ -101,7 +101,7 @@
 			break;
 		case VIDEO_STD_AUTO:
 			hal_info("%s: VIDEO_STD_AUTO not implemented\n", __func__);
-			// fallthrough
+		// fallthrough
 		case VIDEO_STD_SECAM:
 		case VIDEO_STD_PAL:
 		case VIDEO_STD_576P:
@@ -125,11 +125,11 @@
 {
 }
 
-void cVideo::ShowPicture(const char *fname)
+bool cVideo::ShowPicture(const char *fname)
 {
 	hal_info("%s(%s)\n", __func__, fname);
 	if (access(fname, R_OK))
-		return;
+		return true;
 }
 
 void cVideo::StopPicture()
@@ -170,10 +170,10 @@
 	return 0;
 }
 
-bool cVideo::GetScreenImage(unsigned char * &data, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
+bool cVideo::GetScreenImage(unsigned char*&data, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
 {
 	hal_info("%s: data 0x%p xres %d yres %d vid %d osd %d scale %d\n",
-		__func__, data, xres, yres, get_video, get_osd, scale_to_video);
+	    __func__, data, xres, yres, get_video, get_osd, scale_to_video);
 	return false;
 }
 
diff -Nur libstb-hal-ddt.git.orig/libraspi/video_lib.h libstb-hal-ddt.git/libraspi/video_lib.h
--- libstb-hal-ddt.git.orig/libraspi/video_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libraspi/video_lib.h	2022-07-23 18:18:31.539772306 +0200
@@ -10,7 +10,8 @@
 #include <libavutil/rational.h>
 }
 
-typedef enum {
+typedef enum
+{
 	ANALOG_SD_RGB_CINCH = 0x00,
 	ANALOG_SD_YPRPB_CINCH,
 	ANALOG_HD_RGB_CINCH,
@@ -23,7 +24,8 @@
 } analog_mode_t;
 
 
-typedef enum {
+typedef enum
+{
 	VIDEO_FORMAT_MPEG2 = 0,
 	VIDEO_FORMAT_MPEG4,
 	VIDEO_FORMAT_VC1,
@@ -32,7 +34,8 @@
 	VIDEO_FORMAT_PNG
 } VIDEO_FORMAT;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_SD = 0,
 	VIDEO_HD,
 	VIDEO_120x60i,
@@ -41,7 +44,8 @@
 	VIDEO_360x288i
 } VIDEO_DEFINITION;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_FRAME_RATE_23_976 = 0,
 	VIDEO_FRAME_RATE_24,
 	VIDEO_FRAME_RATE_25,
@@ -52,29 +56,31 @@
 	VIDEO_FRAME_RATE_60
 } VIDEO_FRAME_RATE;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_1_1,
 	DISPLAY_AR_4_3,
-	DISPLAY_AR_14_9,
 	DISPLAY_AR_16_9,
 	DISPLAY_AR_20_9,
 	DISPLAY_AR_RAW
 } DISPLAY_AR;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_MODE_PANSCAN = 0,
 	DISPLAY_AR_MODE_LETTERBOX,
-	DISPLAY_AR_MODE_NONE,
-	DISPLAY_AR_MODE_PANSCAN2
+	DISPLAY_AR_MODE_NONE
 } DISPLAY_AR_MODE;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_DB_DR_NEITHER = 0,
 	VIDEO_DB_ON,
 	VIDEO_DB_DR_BOTH
 } VIDEO_DB_DR;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_PLAY_STILL = 0,
 	VIDEO_PLAY_CLIP,
 	VIDEO_PLAY_TRICK,
@@ -82,7 +88,8 @@
 	VIDEO_PLAY_MOTION_NO_SYNC
 } VIDEO_PLAY_MODE;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_STD_NTSC,
 	VIDEO_STD_SECAM,
 	VIDEO_STD_PAL,
@@ -96,12 +103,13 @@
 	VIDEO_STD_1080P24,
 	VIDEO_STD_1080P25,
 	VIDEO_STD_AUTO,
-	VIDEO_STD_1080P50,	/* SPARK only */
+	VIDEO_STD_1080P50,  /* SPARK only */
 	VIDEO_STD_MAX
 } VIDEO_STD;
 
 /* not used, for dummy functions */
-typedef enum {
+typedef enum
+{
 	VIDEO_HDMI_CEC_MODE_OFF = 0,
 	VIDEO_HDMI_CEC_MODE_TUNER,
 	VIDEO_HDMI_CEC_MODE_RECORDER
@@ -121,27 +129,51 @@
 #define VDEC_MAXBUFS 0x30
 class cVideo
 {
-	friend class GLFramebuffer;
-	friend class cDemux;
+		friend class GLFramebuffer;
+		friend class cDemux;
 	private:
 		/* called from GL thread */
 		class SWFramebuffer : public std::vector<unsigned char>
 		{
-		public:
-			SWFramebuffer() : mWidth(0), mHeight(0) {}
-			void width(int w) { mWidth = w; }
-			void height(int h) { mHeight = h; }
-			void pts(uint64_t p) { mPts = p; }
-			void AR(AVRational a) { mAR = a; }
-			int width() const { return mWidth; }
-			int height() const { return mHeight; }
-			int64_t pts() const { return mPts; }
-			AVRational AR() const { return mAR; }
-		private:
-			int mWidth;
-			int mHeight;
-			int64_t mPts;
-			AVRational mAR;
+			public:
+				SWFramebuffer() : mWidth(0), mHeight(0) {}
+				void width(int w)
+				{
+					mWidth = w;
+				}
+				void height(int h)
+				{
+					mHeight = h;
+				}
+				void pts(uint64_t p)
+				{
+					mPts = p;
+				}
+				void AR(AVRational a)
+				{
+					mAR = a;
+				}
+				int width() const
+				{
+					return mWidth;
+				}
+				int height() const
+				{
+					return mHeight;
+				}
+				int64_t pts() const
+				{
+					return mPts;
+				}
+				AVRational AR() const
+				{
+					return mAR;
+				}
+			private:
+				int mWidth;
+				int mHeight;
+				int64_t mPts;
+				AVRational mAR;
 		};
 		int buf_in, buf_out, buf_num;
 		int64_t GetPTS(void);
@@ -150,8 +182,14 @@
 		cVideo(int mode, void *, void *, unsigned int unit = 0);
 		~cVideo(void);
 
-		void * GetTVEnc() { return NULL; };
-		void * GetTVEncSD() { return NULL; };
+		void *GetTVEnc()
+		{
+			return NULL;
+		};
+		void *GetTVEncSD()
+		{
+			return NULL;
+		};
 
 		/* aspect ratio */
 		int getAspectRatio(void);
@@ -177,25 +215,54 @@
 		int SetVideoSystem(int video_system, bool remember = true);
 		int SetStreamType(VIDEO_FORMAT type);
 		void SetSyncMode(AVSYNC_TYPE mode);
-		bool SetCECMode(VIDEO_HDMI_CEC_MODE) { return true; };
-		void SetCECAutoView(bool) { return; };
-		void SetCECAutoStandby(bool) { return; };
-		void ShowPicture(const char * fname);
+		bool SetCECMode(VIDEO_HDMI_CEC_MODE)
+		{
+			return true;
+		};
+		void SetCECAutoView(bool)
+		{
+			return;
+		};
+		void SetCECAutoStandby(bool)
+		{
+			return;
+		};
+		bool ShowPicture(const char *fname);
 		void StopPicture();
 		void Standby(unsigned int bOn);
 		void Pig(int x, int y, int w, int h, int osd_w = 1064, int osd_h = 600);
-		void SetControl(int, int) { return; };
+		void SetControl(int, int)
+		{
+			return;
+		};
 		void setContrast(int val);
 		void SetVideoMode(analog_mode_t mode);
-		void SetDBDR(int) { return; };
-		void SetAudioHandle(void *) { return; };
-		void SetAutoModes(int [VIDEO_STD_MAX]) { return; };
-		int  OpenVBI(int) { return 0; };
-		int  CloseVBI(void) { return 0; };
-		int  StartVBI(unsigned short) { return 0; };
-		int  StopVBI(void) { return 0; };
+		void SetDBDR(int)
+		{
+			return;
+		};
+		void SetAudioHandle(void *)
+		{
+			return;
+		};
+		int  OpenVBI(int)
+		{
+			return 0;
+		};
+		int  CloseVBI(void)
+		{
+			return 0;
+		};
+		int  StartVBI(unsigned short)
+		{
+			return 0;
+		};
+		int  StopVBI(void)
+		{
+			return 0;
+		};
 		void SetDemux(cDemux *dmx);
-		bool GetScreenImage(unsigned char * &data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
+		bool GetScreenImage(unsigned char*&data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
 	private:
 		SWFramebuffer buffers[VDEC_MAXBUFS];
 		int dec_w, dec_h;
diff -Nur libstb-hal-ddt.git.orig/libspark/audio.cpp libstb-hal-ddt.git/libspark/audio.cpp
--- libstb-hal-ddt.git.orig/libspark/audio.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libspark/audio.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -8,22 +8,45 @@
 
 #include <linux/dvb/audio.h>
 
+#include <hardware_caps.h>
 #include <proc_tools.h>
 
 #include "audio_lib.h"
 #include "audio_mixer.h"
 #include "hal_debug.h"
 
-#define AUDIO_DEVICE	"/dev/dvb/adapter0/audio0"
 #define hal_debug(args...) _hal_debug(HAL_DEBUG_AUDIO, this, args)
 #define hal_info(args...) _hal_info(HAL_DEBUG_AUDIO, this, args)
 
 #include <linux/soundcard.h>
 
-cAudio * audioDecoder = NULL;
+enum
+{
+	ENCODER,
+	AUX
+};
+
+cAudio *audioDecoder = NULL;
+cAudio *pipAudioDecoder[3] = { NULL, NULL, NULL };
+
+static const char *ADEV[] =
+{
+	"/dev/dvb/adapter0/audio0",
+	"/dev/dvb/adapter0/audio1",
+	"/dev/dvb/adapter0/audio2",
+	"/dev/dvb/adapter0/audio3"
+};
 
-cAudio::cAudio(void *, void *, void *)
+cAudio::cAudio(void *, void *, void *, unsigned int unit)
 {
+	hw_caps_t *hwcaps = get_hwcaps();
+	if (unit > (unsigned int) hwcaps->pip_devs)
+	{
+		hal_info("%s: unit %d out of range, setting to 0\n", __func__, unit);
+		devnum = 0;
+	}
+	else
+		devnum = unit;
 	fd = -1;
 	clipfd = -1;
 	mixer_fd = -1;
@@ -48,7 +71,7 @@
 
 	if (fd < 0)
 	{
-		if ((fd = open(AUDIO_DEVICE, O_RDWR)) < 0)
+		if ((fd = open(ADEV[devnum], O_RDWR)) < 0)
 			hal_info("openDevice: open failed (%m)\n");
 		fcntl(fd, F_SETFD, FD_CLOEXEC);
 		do_mute(true, false);
@@ -61,20 +84,28 @@
 {
 	closeMixers();
 
-	if (fd > -1) {
+	if (fd > -1)
+	{
 		close(fd);
 		fd = -1;
 	}
-	if (clipfd > -1) {
+	if (clipfd > -1)
+	{
 		close(clipfd);
 		clipfd = -1;
 	}
-	if (mixer_fd > -1) {
+	if (mixer_fd > -1)
+	{
 		close(mixer_fd);
 		mixer_fd = -1;
 	}
 }
 
+void cAudio::setAVInput(int val)
+{
+	hal_info("%s not implemented yet - switching to: %s\n", __func__, val == AUX ? "AUX" : "ENCODER");
+}
+
 int cAudio::do_mute(bool enable, bool remember)
 {
 	hal_debug("%s(%d, %d)\n", __FUNCTION__, enable, remember);
@@ -114,7 +145,8 @@
 	volume = (left + right) / 2;
 	int v = map_volume(volume);
 #if 0
-	if (clipfd != -1 && mixer_fd != -1) {
+	if (clipfd != -1 && mixer_fd != -1)
+	{
 		int tmp = 0;
 		/* not sure if left / right is correct here, but it is always the same anyways ;-) */
 		if (! Muted)
@@ -157,41 +189,12 @@
 	ioctl(fd, AUDIO_SET_AV_SYNC, Mode);
 }
 
-// E2 streamtype values. These correspond to
-//  player2/linux/drivers/media/dvb/stm/dvb/dvb_audio.c:AudioIoctlSetBypassMode
-#define AUDIO_STREAMTYPE_AC3	0
-#define AUDIO_STREAMTYPE_MPEG	1
-#define AUDIO_STREAMTYPE_DTS	2
-#define AUDIO_STREAMTYPE_AAC	8
-#define AUDIO_STREAMTYPE_AACHE	9
-
-void cAudio::SetStreamType(AUDIO_FORMAT type)
-{
-	int bypass = AUDIO_STREAMTYPE_MPEG;
-	hal_debug("%s %d\n", __FUNCTION__, type);
-	StreamType = type;
+void cAudio::SetStreamType(int bypass)
+{
+	StreamType = bypass;
 
-	switch (type)
-	{
-		case AUDIO_FMT_DD_PLUS:
-		case AUDIO_FMT_DOLBY_DIGITAL:
-			bypass = AUDIO_STREAMTYPE_AC3;
-			break;
-		case AUDIO_FMT_AAC:
-			bypass = AUDIO_STREAMTYPE_AAC;
-			break;
-		case AUDIO_FMT_AAC_PLUS:
-			bypass = AUDIO_STREAMTYPE_AACHE;
-			break;
-		case AUDIO_FMT_DTS:
-			bypass = AUDIO_STREAMTYPE_DTS;
-			break;
-		default:
-			break;
-	}
+	hal_info("%s %d (0x%x)\n", __FUNCTION__, bypass, bypass);
 
-	// Normaly the encoding should be set using AUDIO_SET_ENCODING
-	// But as we implemented the behavior to bypass (cause of e2) this is correct here
 	if (ioctl(fd, AUDIO_SET_BYPASS_MODE, bypass) < 0)
 		hal_info("%s: AUDIO_SET_BYPASS_MODE failed (%m)\n", __func__);
 }
@@ -209,7 +212,8 @@
 	const char *dsp_dev = getenv("DSP_DEVICE");
 	const char *mix_dev = getenv("MIX_DEVICE");
 	hal_debug("%s ch %d srate %d bits %d le %d\n", __FUNCTION__, ch, srate, bits, little_endian);
-	if (clipfd > -1) {
+	if (clipfd > -1)
+	{
 		hal_info("%s: clipfd already opened (%d)\n", __FUNCTION__, clipfd);
 		return -1;
 	}
@@ -222,16 +226,18 @@
 	 *   export MIX_DEVICE=/dev/sound/mixer2
 	 *   neutrino
 	 */
-	if ((!dsp_dev) || (access(dsp_dev, W_OK))) {
+	if ((!dsp_dev) || (access(dsp_dev, W_OK)))
+	{
 		if (dsp_dev)
 			hal_info("%s: DSP_DEVICE is set (%s) but cannot be opened,"
-				" fall back to /dev/dsp1\n", __func__, dsp_dev);
+			    " fall back to /dev/dsp1\n", __func__, dsp_dev);
 		dsp_dev = "/dev/dsp1";
 	}
 	hal_info("%s: dsp_dev %s mix_dev %s\n", __func__, dsp_dev, mix_dev); /* NULL mix_dev is ok */
 	/* the tdoss dsp driver seems to work only on the second open(). really. */
 	clipfd = open(dsp_dev, O_WRONLY);
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s open %s: %m\n", dsp_dev, __FUNCTION__);
 		return -1;
 	}
@@ -254,42 +260,50 @@
 		return 0;
 
 	mixer_fd = open(mix_dev, O_RDWR);
-	if (mixer_fd < 0) {
+	if (mixer_fd < 0)
+	{
 		hal_info("%s: open mixer %s failed (%m)\n", __func__, mix_dev);
 		/* not a real error */
 		return 0;
 	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_DEVMASK, &devmask) == -1) {
+	if (ioctl(mixer_fd, SOUND_MIXER_READ_DEVMASK, &devmask) == -1)
+	{
 		hal_info("%s: SOUND_MIXER_READ_DEVMASK %m\n", __func__);
 		devmask = 0;
 	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_STEREODEVS, &stereo) == -1) {
+	if (ioctl(mixer_fd, SOUND_MIXER_READ_STEREODEVS, &stereo) == -1)
+	{
 		hal_info("%s: SOUND_MIXER_READ_STEREODEVS %m\n", __func__);
 		stereo = 0;
 	}
 	usable = devmask & stereo;
-	if (usable == 0) {
+	if (usable == 0)
+	{
 		hal_info("%s: devmask: %08x stereo: %08x, no usable dev :-(\n",
-			__func__, devmask, stereo);
+		    __func__, devmask, stereo);
 		close(mixer_fd);
 		mixer_fd = -1;
 		return 0; /* TODO: should we treat this as error? */
 	}
 	/* __builtin_popcount needs GCC, it counts the set bits... */
-	if (__builtin_popcount (usable) != 1) {
+	if (__builtin_popcount(usable) != 1)
+	{
 		/* TODO: this code is not yet tested as I have only single-mixer devices... */
 		hal_info("%s: more than one mixer control: devmask %08x stereo %08x\n"
-			"%s: querying MIX_NUMBER environment variable...\n",
-			__func__, devmask, stereo, __func__);
+		    "%s: querying MIX_NUMBER environment variable...\n",
+		    __func__, devmask, stereo, __func__);
 		const char *tmp = getenv("MIX_NUMBER");
 		if (tmp)
 			mixer_num = atoi(tmp);
 		hal_info("%s: mixer_num is %d -> device %08x\n",
-			__func__, mixer_num, (mixer_num >= 0) ? (1 << mixer_num) : 0);
+		    __func__, mixer_num, (mixer_num >= 0) ? (1 << mixer_num) : 0);
 		/* no error checking, you'd better know what you are doing... */
-	} else {
+	}
+	else
+	{
 		mixer_num = 0;
-		while (!(usable & 0x01)) {
+		while (!(usable & 0x01))
+		{
 			mixer_num++;
 			usable >>= 1;
 		}
@@ -303,7 +317,8 @@
 {
 	int ret;
 	// hal_debug("cAudio::%s\n", __FUNCTION__);
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
 		return -1;
 	}
@@ -316,13 +331,15 @@
 int cAudio::StopClip()
 {
 	hal_debug("%s\n", __FUNCTION__);
-	if (clipfd < 0) {
+	if (clipfd < 0)
+	{
 		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
 		return -1;
 	}
 	close(clipfd);
 	clipfd = -1;
-	if (mixer_fd > -1) {
+	if (mixer_fd > -1)
+	{
 		close(mixer_fd);
 		mixer_fd = -1;
 	}
@@ -350,24 +367,24 @@
 
 	type = atype;
 #if 0
-/* this does not work, some of the values are negative?? */
+	/* this does not work, some of the values are negative?? */
 	AMPEGStatus A;
 	memcpy(&A, &i.word00, sizeof(i.word00));
 	layer   = A.audio_mpeg_layer;
 	mode    = A.audio_mpeg_mode;
 	bitrate = A.audio_mpeg_bitrate;
-	switch(A.audio_mpeg_frequency)
+	switch (A.audio_mpeg_frequency)
 #endif
-	/* layer and bitrate are not used anyway... */
-	layer   = 0; //(i.word00 >> 17) & 3;
+		/* layer and bitrate are not used anyway... */
+		layer   = 0; //(i.word00 >> 17) & 3;
 	bitrate = 0; //(i.word00 >> 12) & 3;
 	switch (type)
 	{
-		case 0:	/* MPEG */
+		case 0: /* MPEG */
 			mode = (i.word00 >> 6) & 3;
 			freq = freq_mpg[(i.word00 >> 10) & 3];
 			break;
-		case 1:	/* AC3 */
+		case 1: /* AC3 */
 			mode = (i.word00 >> 28) & 7;
 			freq = freq_ac3[(i.word00 >> 16) & 3];
 			break;
@@ -436,17 +453,20 @@
 
 void cAudio::setMixerVolume(const char *name, long value, bool remember)
 {
-	if (!strcmp(name, "Analog")) {
+	if (!strcmp(name, "Analog"))
+	{
 		mixerAnalog->setVolume(value);
 		if (remember)
 			volumeAnalog = value;
 	}
-	if (!strcmp(name, "HDMI")) {
+	if (!strcmp(name, "HDMI"))
+	{
 		mixerHDMI->setVolume(value);
 		if (remember)
 			volumeHDMI = value;
 	}
-	if (!strcmp(name, "SPDIF")) {
+	if (!strcmp(name, "SPDIF"))
+	{
 		mixerSPDIF->setVolume(value);
 		if (remember)
 			volumeSPDIF = value;
@@ -455,12 +475,15 @@
 
 void cAudio::muteMixers(bool m)
 {
-	if (m && !mixersMuted) {
+	if (m && !mixersMuted)
+	{
 		mixersMuted = true;
 		setMixerVolume("Analog", 0, false);
 		setMixerVolume("HDMI", 0, false);
 		setMixerVolume("SPDIF", 0, false);
-	} else if (!m && mixersMuted) {
+	}
+	else if (!m && mixersMuted)
+	{
 		mixersMuted = false;
 		setMixerVolume("Analog", volumeAnalog, false);
 		setMixerVolume("HDMI", volumeHDMI, false);
diff -Nur libstb-hal-ddt.git.orig/libspark/audio_lib.h libstb-hal-ddt.git/libspark/audio_lib.h
--- libstb-hal-ddt.git.orig/libspark/audio_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/audio_lib.h	2022-07-23 18:18:31.539772306 +0200
@@ -12,44 +12,28 @@
 	AUDIO_SYNC_AUDIO_MASTER
 } AUDIO_SYNC_MODE;
 
-typedef enum {
+typedef enum
+{
 	HDMI_ENCODED_OFF,
 	HDMI_ENCODED_AUTO,
 	HDMI_ENCODED_FORCED
 } HDMI_ENCODED_MODE;
 
-typedef enum
-{
-	AUDIO_FMT_AUTO = 0,
-	AUDIO_FMT_MPEG,
-	AUDIO_FMT_MP3,
-	AUDIO_FMT_DOLBY_DIGITAL,
-	AUDIO_FMT_BASIC = AUDIO_FMT_DOLBY_DIGITAL,
-	AUDIO_FMT_AAC,
-	AUDIO_FMT_AAC_PLUS,
-	AUDIO_FMT_DD_PLUS,
-	AUDIO_FMT_DTS,
-	AUDIO_FMT_AVS,
-	AUDIO_FMT_MLP,
-	AUDIO_FMT_WMA,
-	AUDIO_FMT_MPG1, // TD only. For Movieplayer / cPlayback
-	AUDIO_FMT_ADVANCED = AUDIO_FMT_MLP
-} AUDIO_FORMAT;
-
 class mixerVolume;
 
 class cAudio
 {
-	friend class cPlayback;
+		friend class cPlayback;
 	private:
 		int fd;
+		unsigned int devnum;
 		bool Muted;
 
 		int clipfd; /* for pcm playback */
 		int mixer_fd;  /* if we are using the OSS mixer */
 		int mixer_num; /* oss mixer to use, if any */
 
-		AUDIO_FORMAT	StreamType;
+		int StreamType;
 		AUDIO_SYNC_MODE    SyncMode;
 		bool started;
 
@@ -67,35 +51,67 @@
 
 	public:
 		/* construct & destruct */
-		cAudio(void *, void *, void *);
+		cAudio(void *, void *, void *, unsigned int unit = 0);
 		~cAudio(void);
 
-		void *GetHandle() { return NULL; };
+		void open_AVInput_Device(void)
+		{
+			return;
+		};
+		void close_AVInput_Device(void)
+		{
+			return;
+		};
+
+		void setAVInput(int val);
+
+		void *GetHandle()
+		{
+			return NULL;
+		};
 		/* shut up */
-		int mute(bool remember = true) { return do_mute(true, remember); };
-		int unmute(bool remember = true) { return do_mute(false, remember); };
+		int mute(bool remember = true)
+		{
+			return do_mute(true, remember);
+		};
+		int unmute(bool remember = true)
+		{
+			return do_mute(false, remember);
+		};
 
 		/* volume, min = 0, max = 255 */
 		int setVolume(unsigned int left, unsigned int right);
-		int getVolume(void) { return volume;}
-		bool getMuteStatus(void) { return Muted; };
+		int getVolume(void)
+		{
+			return volume;
+		}
+		bool getMuteStatus(void)
+		{
+			return Muted;
+		};
 
 		/* start and stop audio */
 		int Start(void);
 		int Stop(void);
 		bool Pause(bool Pcm = true);
-		void SetStreamType(AUDIO_FORMAT type);
-		AUDIO_FORMAT GetStreamType(void) { return StreamType; }
+		void SetStreamType(int bypass);
+		int GetStreamType(void)
+		{
+			return StreamType;
+		}
 		void SetSyncMode(AVSYNC_TYPE Mode);
 
 		/* select channels */
 		int setChannel(int channel);
 		int PrepareClipPlay(int uNoOfChannels, int uSampleRate, int uBitsPerSample, int bLittleEndian);
-		int WriteClip(unsigned char * buffer, int size);
+		int WriteClip(unsigned char *buffer, int size);
 		int StopClip();
-		void getAudioInfo(int &type, int &layer, int& freq, int &bitrate, int &mode);
+		void getAudioInfo(int &type, int &layer, int &freq, int &bitrate, int &mode);
 		void SetSRS(int iq_enable, int nmgr_enable, int iq_mode, int iq_level);
-		bool IsHdmiDDSupported() { return true; };
+		bool IsHdmiDDSupported()
+		{
+			return true;
+		};
 		void SetHdmiDD(bool enable);
 		void SetSpdifDD(bool enable);
 		void ScheduleMute(bool On);
diff -Nur libstb-hal-ddt.git.orig/libspark/audio_mixer.cpp libstb-hal-ddt.git/libspark/audio_mixer.cpp
--- libstb-hal-ddt.git.orig/libspark/audio_mixer.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/audio_mixer.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -19,7 +19,8 @@
 
 #include <audio_mixer.h>
 
-mixerVolume::mixerVolume(const char *name, const char *card, long volume) {
+mixerVolume::mixerVolume(const char *name, const char *card, long volume)
+{
 	snd_mixer_selem_id_t *sid = NULL;
 	elem = NULL;
 	handle = NULL;
@@ -49,7 +50,8 @@
 	snd_mixer_selem_id_set_index(sid, 0);
 	snd_mixer_selem_id_set_name(sid, name);
 	elem = snd_mixer_find_selem(handle, sid);
-	if (elem) {
+	if (elem)
+	{
 		snd_mixer_selem_get_playback_volume_range(elem, &min, &max);
 		setVolume(volume);
 	}
@@ -60,9 +62,10 @@
 		snd_mixer_close(handle);
 }
 
-bool mixerVolume::setVolume(long volume) {
+bool mixerVolume::setVolume(long volume)
+{
 	return elem
-		&& (volume > -1)
-		&& (volume < 101)
-		&& !snd_mixer_selem_set_playback_volume_all(elem, min + volume * (max - min)/100);
+	    && (volume > -1)
+	    && (volume < 101)
+	    && !snd_mixer_selem_set_playback_volume_all(elem, min + volume * (max - min) / 100);
 }
diff -Nur libstb-hal-ddt.git.orig/libspark/audio_mixer.h libstb-hal-ddt.git/libspark/audio_mixer.h
--- libstb-hal-ddt.git.orig/libspark/audio_mixer.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/audio_mixer.h	2022-07-23 18:18:31.539772306 +0200
@@ -27,7 +27,7 @@
 	private:
 		long min, max;
 		snd_mixer_t *handle;
-		snd_mixer_elem_t* elem;
+		snd_mixer_elem_t *elem;
 	public:
 		mixerVolume(const char *selem_name, const char *Card, long volume = -1);
 		~mixerVolume(void);
diff -Nur libstb-hal-ddt.git.orig/libspark/dmx.cpp libstb-hal-ddt.git/libspark/dmx.cpp
--- libstb-hal-ddt.git.orig/libspark/dmx.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libspark/dmx.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -26,19 +26,19 @@
  *
  * the sh4 pti driver, driving the /dev/dvb/adapter0/dmxN devices, can
  * apparently only map one input to on demux device at a time, so e.g.
- * 	DMX_SOURCE_FRONT1 -> demux0
- * 	DMX_SOURCE_FRONT2 -> demux0
- * 	DMX_SOURCE_FRONT1 -> demux1
+ *  DMX_SOURCE_FRONT1 -> demux0
+ *  DMX_SOURCE_FRONT2 -> demux0
+ *  DMX_SOURCE_FRONT1 -> demux1
  * does not work. The driver makes sure that a one-to-one mapping of
  * DMX_SOURCE_FRONTn to demuxM is maintained, and it does by e.g changing
  * the default of
- * 	FRONT0 -> demux0
- * 	FRONT1 -> demux1
- * 	FRONT2 -> demux2
+ *  FRONT0 -> demux0
+ *  FRONT1 -> demux1
+ *  FRONT2 -> demux2
  * to
- * 	FRONT1 -> demux0
- * 	FRONT0 -> demux1
- * 	FRONT2 -> demux2
+ *  FRONT1 -> demux0
+ *  FRONT0 -> demux1
+ *  FRONT2 -> demux2
  * if you do a DMX_SET_SOURCE(FRONT1) ioctl on demux0.
  * This means, it also changes demux1's source on the SET_SOURCE ioctl on
  * demux0, potentially disturbing any operation on demux1 (e.g. recording).
@@ -84,15 +84,16 @@
 #define hal_debug_z(args...) _hal_debug(HAL_DEBUG_DEMUX, thiz, args)
 
 #define dmx_err(_errfmt, _errstr, _revents) do { \
-	hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
-		__func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
+    hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
+        __func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
 } while(0);
 
 cDemux *videoDemux = NULL;
 cDemux *audioDemux = NULL;
 //cDemux *pcrDemux = NULL;
 
-static const char *DMX_T[] = {
+static const char *DMX_T[] =
+{
 	"DMX_INVALID",
 	"DMX_VIDEO",
 	"DMX_AUDIO",
@@ -109,17 +110,21 @@
 /* the current source of each cDemux unit */
 static int dmx_source[NUM_DEMUX] = { 0, 0, 0, 0 };
 
+char dmxdev[32];
+static char *devname(int adapter, int demux)
+{
+	snprintf(dmxdev, sizeof(dmxdev), "/dev/dvb/adapter%d/demux%d", adapter, demux);
+	return dmxdev;
+}
+
 /* map the device numbers. */
 #define NUM_DEMUXDEV 3
-static const char *devname[NUM_DEMUXDEV] = {
-	"/dev/dvb/adapter0/demux0",
-	"/dev/dvb/adapter0/demux1",
-	"/dev/dvb/adapter0/demux2"
-};
+
 /* did we already DMX_SET_SOURCE on that demux device? */
 static bool init[NUM_DEMUXDEV] = { false, false, false };
 
-typedef struct dmx_pdata {
+typedef struct dmx_pdata
+{
 	int last_source;
 	OpenThreads::Mutex *mutex;
 } dmx_pdata;
@@ -167,31 +172,33 @@
 
 static bool _open(cDemux *thiz, int num, int &fd, int &last_source, DMX_CHANNEL_TYPE dmx_type, int buffersize)
 {
-	int flags = O_RDWR|O_CLOEXEC;
+	int flags = O_RDWR | O_CLOEXEC;
 	int devnum = dmx_source[num];
-	if (last_source == devnum) {
+	if (last_source == devnum)
+	{
 		hal_debug_z("%s #%d: source (%d) did not change\n", __func__, num, last_source);
 		if (fd > -1)
 			return true;
 	}
-	if (fd > -1) {
+	if (fd > -1)
+	{
 		/* we changed source -> close and reopen the fd */
 		hal_debug_z("%s #%d: FD ALREADY OPENED fd = %d lastsource %d devnum %d\n",
-				__func__, num, fd, last_source, devnum);
+		    __func__, num, fd, last_source, devnum);
 		close(fd);
 	}
 
 	if (dmx_type != DMX_PSI_CHANNEL)
 		flags |= O_NONBLOCK;
 
-	fd = open(devname[devnum], flags);
+	fd = open(devname(0, devnum), flags);
 	if (fd < 0)
 	{
-		hal_info_z("%s %s: %m\n", __FUNCTION__, devname[devnum]);
+		hal_info_z("%s %s: %m\n", __FUNCTION__, devname(0, devnum));
 		return false;
 	}
 	hal_debug_z("%s #%d pes_type: %s(%d), uBufferSize: %d fd: %d\n", __func__,
-		 num, DMX_T[dmx_type], dmx_type, buffersize, fd);
+	    num, DMX_T[dmx_type], dmx_type, buffersize, fd);
 
 	/* this would actually need locking, but the worst that weill happen is, that
 	 * we'll DMX_SET_SOURCE twice per device, so don't bother... */
@@ -199,7 +206,7 @@
 	{
 		/* this should not change anything... */
 		int n = DMX_SOURCE_FRONT0 + devnum;
-		hal_info_z("%s: setting %s to source %d\n", __func__, devname[devnum], n);
+		hal_info_z("%s: setting %s to source %d\n", __func__, devname(0, devnum), n);
 		if (ioctl(fd, DMX_SET_SOURCE, &n) < 0)
 			hal_info_z("%s DMX_SET_SOURCE failed!\n", __func__);
 		else
@@ -262,7 +269,7 @@
 #if 0
 	if (len != 4095 && timeout != 10)
 		fprintf(stderr, "cDemux::%s #%d fd: %d type: %s len: %d timeout: %d\n",
-			__FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
+		    __FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
 #endif
 	if (fd < 0)
 	{
@@ -275,7 +282,7 @@
 	int to = timeout;
 	struct pollfd ufds;
 	ufds.fd = fd;
-	ufds.events = POLLIN|POLLPRI|POLLERR;
+	ufds.events = POLLIN | POLLPRI | POLLERR;
 	ufds.revents = 0;
 
 	/* hack: if the frontend loses and regains lock, the demuxer often will not
@@ -286,7 +293,7 @@
 
 	if (to > 0)
 	{
- retry:
+retry:
 		rc = ::poll(&ufds, 1, to);
 		if (ufds.fd != fd)
 		{
@@ -331,8 +338,9 @@
 			return 0;
 		}
 	}
-	if (ufds.fd != fd)	/* does this ever happen? and if, is it harmful? */
-	{			/* read(-1,...) will just return EBADF anyway... */
+	if (ufds.fd != fd)  /* does this ever happen? and if, is it harmful? */
+	{
+		/* read(-1,...) will just return EBADF anyway... */
 		hal_info("%s:2 ========== fd has changed, %d->%d ==========\n", __func__, ufds.fd, fd);
 		return -1;
 	}
@@ -345,9 +353,9 @@
 	return rc;
 }
 
-bool cDemux::sectionFilter(unsigned short _pid, const unsigned char * const filter,
-			   const unsigned char * const mask, int len, int timeout,
-			   const unsigned char * const negmask)
+bool cDemux::sectionFilter(unsigned short _pid, const unsigned char *const filter,
+    const unsigned char *const mask, int len, int timeout,
+    const unsigned char *const negmask)
 {
 	struct dmx_sct_filter_params s_flt;
 	memset(&s_flt, 0, sizeof(s_flt));
@@ -368,7 +376,7 @@
 	if (negmask != NULL)
 		memcpy(s_flt.filter.mode, negmask, len);
 
-	s_flt.flags = DMX_IMMEDIATE_START|DMX_CHECK_CRC;
+	s_flt.flags = DMX_IMMEDIATE_START | DMX_CHECK_CRC;
 
 	int to = 0;
 	switch (filter[0])
@@ -453,13 +461,22 @@
 		s_flt.timeout = to;
 
 	hal_debug("%s #%d pid:0x%04hx fd:%d type:%s len:%d to:%d flags:%x flt[0]:%02x\n", __func__, num,
-		pid, fd, DMX_T[dmx_type], len, s_flt.timeout, s_flt.flags, s_flt.filter.filter[0]);
-#if 0
-	fprintf(stderr,"filt: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.filter[i]); fprintf(stderr, "\n");
-	fprintf(stderr,"mask: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mask  [i]); fprintf(stderr, "\n");
-	fprintf(stderr,"mode: "); for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mode  [i]); fprintf(stderr, "\n");
-#endif
-	ioctl (fd, DMX_STOP);
+	    pid, fd, DMX_T[dmx_type], len, s_flt.timeout, s_flt.flags, s_flt.filter.filter[0]);
+
+	if (debuglevel == 2)
+	{
+		fprintf(stderr, "filt: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.filter[i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mask: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mask  [i]);
+		fprintf(stderr, "\n");
+		fprintf(stderr, "mode: ");
+		for (int i = 0; i < len; i++) fprintf(stderr, "%02hhx ", s_flt.filter.mode  [i]);
+		fprintf(stderr, "\n");
+	}
+
+	ioctl(fd, DMX_STOP);
 	if (ioctl(fd, DMX_SET_FILTER, &s_flt) < 0)
 		return false;
 
@@ -475,7 +492,7 @@
 	 * this check originally is from tuxbox cvs but I'm not sure
 	 * what it is good for...
 	if (pid <= 0x0001 && dmx_type != DMX_PCR_ONLY_CHANNEL)
-		return false;
+	    return false;
 	 */
 	if ((pid >= 0x0002 && pid <= 0x000f) || pid >= 0x1fff)
 		return false;
@@ -486,31 +503,50 @@
 
 	memset(&p_flt, 0, sizeof(p_flt));
 	p_flt.pid    = pid;
-	p_flt.output = DMX_OUT_DECODER;
 	p_flt.input  = DMX_IN_FRONTEND;
+	p_flt.output = DMX_OUT_DECODER;
 	p_flt.flags  = DMX_IMMEDIATE_START;
 
 	switch (dmx_type)
 	{
-		case DMX_PCR_ONLY_CHANNEL:
-			p_flt.pes_type = DMX_PES_PCR;
-			break;
-		case DMX_AUDIO_CHANNEL:
-			p_flt.pes_type = DMX_PES_AUDIO;
-			break;
 		case DMX_VIDEO_CHANNEL:
-			p_flt.pes_type = DMX_PES_VIDEO;
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_VIDEO0; break;
+				case 1: p_flt.pes_type = DMX_PES_VIDEO1; break;
+				case 2: p_flt.pes_type = DMX_PES_VIDEO2; break;
+				case 3: p_flt.pes_type = DMX_PES_VIDEO3; break;
+			}
 			break;
-		case DMX_PIP_CHANNEL: /* PIP is a special version of DMX_VIDEO_CHANNEL */
-			p_flt.pes_type = DMX_PES_VIDEO1;
+		case DMX_AUDIO_CHANNEL:
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_AUDIO0; break;
+				case 1: p_flt.pes_type = DMX_PES_AUDIO1; break;
+				case 2: p_flt.pes_type = DMX_PES_AUDIO2; break;
+				case 3: p_flt.pes_type = DMX_PES_AUDIO3; break;
+			}
 			break;
 		case DMX_PES_CHANNEL:
 			p_flt.pes_type = DMX_PES_OTHER;
-			p_flt.output  = DMX_OUT_TAP;
+			p_flt.output   = DMX_OUT_TAP;
 			break;
+#if 0
+		case DMX_PSI_CHANNEL:
+			break;
+#endif
 		case DMX_TP_CHANNEL:
 			p_flt.pes_type = DMX_PES_OTHER;
-			p_flt.output  = DMX_OUT_TSDEMUX_TAP;
+			p_flt.output   = DMX_OUT_TSDEMUX_TAP;
+			break;
+		case DMX_PCR_ONLY_CHANNEL:
+			switch (num)
+			{
+				case 0: p_flt.pes_type = DMX_PES_PCR0; break;
+				case 1: p_flt.pes_type = DMX_PES_PCR1; break;
+				case 2: p_flt.pes_type = DMX_PES_PCR2; break;
+				case 3: p_flt.pes_type = DMX_PES_PCR3; break;
+			}
 			break;
 		default:
 			hal_info("%s #%d invalid dmx_type %d!\n", __func__, num, dmx_type);
@@ -567,7 +603,8 @@
 	}
 	for (std::vector<pes_pids>::iterator i = pesfds.begin(); i != pesfds.end(); ++i)
 	{
-		if ((*i).pid == Pid) {
+		if ((*i).pid == Pid)
+		{
 			hal_debug("removePid: removing demux fd %d pid 0x%04x\n", fd, Pid);
 			if (ioctl(fd, DMX_REMOVE_PID, Pid) < 0)
 				hal_info("%s: (DMX_REMOVE_PID, 0x%04hx): %m\n", __func__, Pid);
@@ -578,7 +615,7 @@
 	hal_info("%s pid 0x%04x not found\n", __FUNCTION__, Pid);
 }
 
-void cDemux::getSTC(int64_t * STC)
+void cDemux::getSTC(int64_t *STC)
 {
 	/* apparently I can only get the PTS of the video decoder,
 	 * but that's good enough for dvbsub */
@@ -600,7 +637,8 @@
 
 bool cDemux::SetSource(int unit, int source)
 {
-	if (unit >= NUM_DEMUX || unit < 0) {
+	if (unit >= NUM_DEMUX || unit < 0)
+	{
 		hal_info_c("%s: unit (%d) out of range, NUM_DEMUX %d\n", __func__, unit, NUM_DEMUX);
 		return false;
 	}
@@ -614,7 +652,8 @@
 
 int cDemux::GetSource(int unit)
 {
-	if (unit >= NUM_DEMUX || unit < 0) {
+	if (unit >= NUM_DEMUX || unit < 0)
+	{
 		hal_info_c("%s: unit (%d) out of range, NUM_DEMUX %d\n", __func__, unit, NUM_DEMUX);
 		return -1;
 	}
diff -Nur libstb-hal-ddt.git.orig/libspark/hardware_caps.c libstb-hal-ddt.git/libspark/hardware_caps.c
--- libstb-hal-ddt.git.orig/libspark/hardware_caps.c	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/hardware_caps.c	2022-07-23 18:18:31.539772306 +0200
@@ -29,6 +29,12 @@
 
 	memset(&caps, 0, sizeof(hw_caps_t));
 
+	caps.pip_devs = 0;
+	if (access("/dev/dvb/adapter0/video1", F_OK) != -1) caps.pip_devs = 1;
+	if (access("/dev/dvb/adapter0/video2", F_OK) != -1) caps.pip_devs = 2;
+	if (access("/dev/dvb/adapter0/video3", F_OK) != -1) caps.pip_devs = 3;
+	if (caps.pip_devs > 0) caps.can_pip = 1;
+
 	initialized = 1;
 	caps.has_CI = 0;
 	caps.can_cec = 1;
@@ -44,12 +50,14 @@
 	const char *tmp;
 	char buf[1024];
 	int len = -1, ret, val;
-	int fd = open (FP_DEV, O_RDWR);
-	if (fd != -1) {
+	int fd = open(FP_DEV, O_RDWR);
+	if (fd != -1)
+	{
 		ret = ioctl(fd, VFDGETVERSION, &val);
 		if (ret < 0)
 			fprintf(stderr, "[hardware_caps] %s: VFDGETVERSION %m\n", __func__);
-		else if (val & 1) { /* VFD = 1, DVFD = 3 */
+		else if (val & 1)   /* VFD = 1, DVFD = 3 */
+		{
 			caps.display_type = HW_DISPLAY_LINE_TEXT;
 			caps.display_xres = 8;
 			caps.display_can_set_brightness = 1;
@@ -57,17 +65,21 @@
 		close(fd);
 	}
 	fd = open("/proc/cmdline", O_RDONLY);
-	if (fd != -1) {
+	if (fd != -1)
+	{
 		len = read(fd, buf, sizeof(buf) - 1);
 		close(fd);
 	}
-	if (len > 0) {
+	if (len > 0)
+	{
 		buf[len] = 0;
 		char *p = strstr(buf, "STB_ID=");
 		int h0, h1, h2;
-		if (p && sscanf(p, "STB_ID=%x:%x:%x:", &h0, &h1, &h2) == 3) {
+		if (p && sscanf(p, "STB_ID=%x:%x:%x:", &h0, &h1, &h2) == 3)
+		{
 			int sys_id = (h0 << 16) | (h1 << 8) | h2;
-			switch (sys_id) {
+			switch (sys_id)
+			{
 				case 0x090003:
 					tmp = "Truman Premier 1+";
 					break;
@@ -151,14 +163,17 @@
 				default:
 					tmp = p;
 			}
-			if ((sys_id & 0xff0000) == 0x090000)
+			if ((sys_id & 0xff0000) == 0x090000) {
 				caps.boxtype = 7111;
-			else
+				strcpy(caps.boxarch, "STX7111");
+			} else {
 				caps.boxtype = 7162;
-		} else
+				strcpy(caps.boxarch, "STX7105");
+			}
+		}
+		else
 			tmp = "(NO STB_ID FOUND)";
 		strcpy(caps.boxname, tmp);
 	}
-	strcpy(caps.boxarch,caps.boxname);
 	return &caps;
 }
diff -Nur libstb-hal-ddt.git.orig/libspark/init.cpp libstb-hal-ddt.git/libspark/init.cpp
--- libstb-hal-ddt.git.orig/libspark/init.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/init.cpp	2022-07-23 18:18:31.539772306 +0200
@@ -36,7 +36,8 @@
 #define VIRTUALINPUT "/sys/devices/virtual/input"
 #define DEVINPUT "/dev/input"
 
-typedef struct {
+typedef struct
+{
 	const char *name;
 	const char *desc;
 	int fd;
@@ -45,68 +46,80 @@
 	time_t next_discovery;
 } input_device_t;
 
-static input_device_t input_device[] = {
-	{ "/dev/input/nevis_ir",	"lircd",			-1, 0, 0, 0 },
-	{ "/dev/input/tdt_rc",		"TDT RC event driver",		-1, 0, 0, 0 },
-	{ "/dev/input/fulan_fp",	"fulan front panel buttons",	-1, 0, 0, 0 },
-	{ "/dev/input/event0",		NULL,				-1, 0, 0, 0 },
-	{ "/dev/input/event1",		NULL,				-1, 0, 0, 0 },
-	{ "/dev/input/event2",		NULL,				-1, 0, 0, 0 },
-	{ "/dev/input/event3",		NULL,				-1, 0, 0, 0 },
-	{ "/dev/input/event4",		NULL,				-1, 0, 0, 0 },
-	{ "/dev/input/event5",		NULL,				-1, 0, 0, 0 },
-	{ "/dev/input/event6",		NULL,				-1, 0, 0, 0 },
-	{ "/dev/input/event7",		NULL,				-1, 0, 0, 0 },
-	{ NULL,				NULL,				-1, 0, 0, 0 }
+static input_device_t input_device[] =
+{
+	{ "/dev/input/nevis_ir",    "lircd",            -1, 0, 0, 0 },
+	{ "/dev/input/tdt_rc",      "TDT RC event driver",      -1, 0, 0, 0 },
+	{ "/dev/input/fulan_fp",    "fulan front panel buttons",    -1, 0, 0, 0 },
+	{ "/dev/input/event0",      NULL,               -1, 0, 0, 0 },
+	{ "/dev/input/event1",      NULL,               -1, 0, 0, 0 },
+	{ "/dev/input/event2",      NULL,               -1, 0, 0, 0 },
+	{ "/dev/input/event3",      NULL,               -1, 0, 0, 0 },
+	{ "/dev/input/event4",      NULL,               -1, 0, 0, 0 },
+	{ "/dev/input/event5",      NULL,               -1, 0, 0, 0 },
+	{ "/dev/input/event6",      NULL,               -1, 0, 0, 0 },
+	{ "/dev/input/event7",      NULL,               -1, 0, 0, 0 },
+	{ NULL,             NULL,               -1, 0, 0, 0 }
 };
 
 #define number_of_input_devices (sizeof(input_device)/sizeof(input_device_t) - 1)
 
-static void do_mknod(int i, char *d_name) {
+static void do_mknod(int i, char *d_name)
+{
 	char name[255];
 	int dev = -1;
 	// I've no idea how the event device number is actually calculated. Just loop.  --martii
 
-	for (int j = 0; j < 99 && dev < 0; j++) {
+	for (int j = 0; j < 99 && dev < 0; j++)
+	{
 		snprintf(name, sizeof(name), VIRTUALINPUT "/%s/event%d/dev", d_name, j);
-		dev = open (name, O_RDONLY);
+		dev = open(name, O_RDONLY);
 	}
 
-	if (dev > -1) {
+	if (dev > -1)
+	{
 		char buf[255];
 		int l = read(dev, buf, sizeof(buf) - 1);
 		close(dev);
-		if (l > -1) {
+		if (l > -1)
+		{
 			buf[l] = 0;
-			if (2 == sscanf(buf, "%d:%d", &input_device[i].major, &input_device[i].minor)) {
+			if (2 == sscanf(buf, "%d:%d", &input_device[i].major, &input_device[i].minor))
+			{
 				mknod(input_device[i].name, 0666 | S_IFCHR,
-					gnu_dev_makedev(input_device[i].major, input_device[i].minor));
+				    gnu_dev_makedev(input_device[i].major, input_device[i].minor));
 			}
 		}
 	}
 }
 
-static void create_input_devices (void) {
-	DIR *d = opendir (VIRTUALINPUT);
-	if (d) {
+static void create_input_devices(void)
+{
+	DIR *d = opendir(VIRTUALINPUT);
+	if (d)
+	{
 		struct dirent *e;
-		while ((e = readdir(d))) {
+		while ((e = readdir(d)))
+		{
 			char name[255];
 			if (e->d_name[0] == '.')
 				continue;
 			snprintf(name, sizeof(name), VIRTUALINPUT "/%s/name", e->d_name);
 			int n = open(name, O_RDONLY);
-			if (n > -1) {
+			if (n > -1)
+			{
 				char buf[255];
 				int l = read(n, buf, sizeof(buf) - 1);
 				close(n);
-				if (l > 1) {
+				if (l > 1)
+				{
 					do
 						buf[l--] = 0;
 					while (l > 1 && buf[l] == '\n');
 
 					for (unsigned int i = 0; i < number_of_input_devices; i++)
-						if (input_device[i].desc && !strcmp(buf, input_device[i].desc)) {
+						if (input_device[i].desc && !strcmp(buf, input_device[i].desc))
+						{
 							do_mknod(i, e->d_name);
 							break;
 						}
@@ -116,10 +129,12 @@
 		closedir(d);
 	}
 	// remove any event* files left that point to our "well-known" inputs
-	d = opendir (DEVINPUT);
-	if (d) {
+	d = opendir(DEVINPUT);
+	if (d)
+	{
 		struct dirent *e;
-		while ((e = readdir(d))) {
+		while ((e = readdir(d)))
+		{
 			char name[255];
 			if (strncmp(e->d_name, "event", 5))
 				continue;
@@ -140,49 +155,63 @@
 static pthread_t inmux_task = 0;
 static int inmux_thread_running = 0;
 
-static void open_input_devices(void) {
+static void open_input_devices(void)
+{
 	time_t now = time(NULL);
 	for (unsigned int i = 0; i < number_of_input_devices; i++)
-		if ((input_device[i].fd < 0) && (input_device[i].next_discovery <= now)) {
+		if ((input_device[i].fd < 0) && (input_device[i].next_discovery <= now))
+		{
 			input_device[i].next_discovery = now + 60;
 			input_device[i].fd = open(input_device[i].name, O_RDWR | O_NONBLOCK);
 		}
 }
 
-static void reopen_input_devices(void) {
+static void reopen_input_devices(void)
+{
 	create_input_devices();
 	time_t now = time(NULL);
-	for (unsigned int i = 0; i < number_of_input_devices; i++) {
+	for (unsigned int i = 0; i < number_of_input_devices; i++)
+	{
 		input_device[i].next_discovery = now + 60;
 		int fd = open(input_device[i].name, O_RDWR | O_NONBLOCK);
-		if (fd > -1) {
-			if (input_device[i].fd > -1) {
+		if (fd > -1)
+		{
+			if (input_device[i].fd > -1)
+			{
 				dup2(fd, input_device[i].fd);
-				close (fd);
-			} else {
+				close(fd);
+			}
+			else
+			{
 				input_device[i].fd = fd;
 			}
-		} else if (input_device[i].fd > -1) {
-			close (input_device[i].fd);
+		}
+		else if (input_device[i].fd > -1)
+		{
+			close(input_device[i].fd);
 			input_device[i].fd = -1;
 		}
 	}
 }
 
-static void close_input_devices(void) {
+static void close_input_devices(void)
+{
 	for (unsigned int i = 0; i < number_of_input_devices; i++)
-		if (input_device[i].fd > -1) {
+		if (input_device[i].fd > -1)
+		{
 			close(input_device[i].fd);
 			input_device[i].fd = -1;
 		}
 }
 
-static void poll_input_devices(void) {
+static void poll_input_devices(void)
+{
 	struct pollfd fds[number_of_input_devices];
 	input_device_t *inputs[number_of_input_devices];
 	int nfds = 0;
 	for (unsigned int i = 1; i < number_of_input_devices; i++)
-		if (input_device[i].fd > -1) {
+		if (input_device[i].fd > -1)
+		{
 			fds[nfds].fd = input_device[i].fd;
 			fds[nfds].events = POLLIN | POLLHUP | POLLERR;
 			fds[nfds].revents = 0;
@@ -190,7 +219,8 @@
 			nfds++;
 		}
 
-	if (nfds == 0) {
+	if (nfds == 0)
+	{
 		// Only a single input device, which happens to be our master. poll() to avoid looping too fast.
 		fds[0].fd = input_device[0].fd;
 		fds[0].events = POLLIN | POLLHUP | POLLERR;
@@ -200,23 +230,29 @@
 	}
 
 	int r = poll(fds, nfds, 60000 /* ms */);
-	if (r < 0) {
-		if (errno != EAGAIN) {
+	if (r < 0)
+	{
+		if (errno != EAGAIN)
+		{
 			hal_info("%s: poll(): %m\n", __func__);
 			inmux_thread_running = 0;
 		}
 		return;
 	}
-	for (int i = 0; i < nfds && r > 0; i++) {
-		if (fds[i].revents & POLLIN) {
+	for (int i = 0; i < nfds && r > 0; i++)
+	{
+		if (fds[i].revents & POLLIN)
+		{
 //fprintf(stderr, "### input from fd %d (%s)\n", fds[i].fd, inputs[i]->name);
 			struct input_event ev;
 			while (sizeof(ev) == read(fds[i].fd, &ev, sizeof(ev)))
 				write(input_device[0].fd, &ev, sizeof(ev));
 			r--;
-		} else if (fds[i].revents & (POLLHUP | POLLERR | POLLNVAL)) {
+		}
+		else if (fds[i].revents & (POLLHUP | POLLERR | POLLNVAL))
+		{
 //fprintf(stderr, "### error on %d (%s)\n", fds[i].fd, inputs[i]->name);
-			close (fds[i].fd);
+			close(fds[i].fd);
 			inputs[i]->fd = -1;
 			r--;
 		}
@@ -228,10 +264,11 @@
 	char threadname[17];
 	strncpy(threadname, __func__, sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 
 	inmux_thread_running = 1;
-	while (inmux_thread_running) {
+	while (inmux_thread_running)
+	{
 		open_input_devices();
 		poll_input_devices();
 	}
@@ -242,7 +279,8 @@
 void start_inmux_thread(void)
 {
 	input_device[0].fd = open(input_device[0].name, O_RDWR | O_NONBLOCK); // nevis_ir. This is mandatory.
-	if (input_device[0].fd < 0){
+	if (input_device[0].fd < 0)
+	{
 		hal_info("%s: open(%s): %m\n", __func__, input_device[0].name);
 		return;
 	}
@@ -269,15 +307,13 @@
 	hal_info("%s begin, initialized=%d, debug=0x%02x\n", __FUNCTION__, (int)initialized, debuglevel);
 	if (!initialized)
 	{
-		cCpuFreqManager f;
-		f.SetCpuFreq(0);	/* CPUFREQ == 0 is the trigger for leaving standby */
 		create_input_devices();
 		start_inmux_thread();
 
 		/* this is a strange hack: the drivers seem to only work correctly after
 		 * demux0 has been used once. After that, we can use demux1,2,... */
 		struct dmx_pes_filter_params p;
-		int dmx = open("/dev/dvb/adapter0/demux0", O_RDWR|O_CLOEXEC);
+		int dmx = open("/dev/dvb/adapter0/demux0", O_RDWR | O_CLOEXEC);
 		if (dmx < 0)
 			hal_info("%s: ERROR open /dev/dvb/adapter0/demux0 (%m)\n", __func__);
 		else
@@ -301,7 +337,8 @@
 void hal_api_exit()
 {
 	hal_info("%s, initialized = %d\n", __FUNCTION__, (int)initialized);
-	if (initialized) {
+	if (initialized)
+	{
 		stop_inmux_thread();
 		close_input_devices();
 	}
diff -Nur libstb-hal-ddt.git.orig/libspark/irmp.c libstb-hal-ddt.git/libspark/irmp.c
--- libstb-hal-ddt.git.orig/libspark/irmp.c	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/irmp.c	2022-07-23 18:18:31.543772226 +0200
@@ -1,4284 +1,4474 @@
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * irmp.c - infrared multi-protocol decoder, supports several remote control protocols
- *
- * Copyright (c) 2009-2011 Frank Meyer - frank(at)fli4l.de
- *
- * $Id: irmp.c,v 1.115 2012/02/21 08:41:46 fm Exp $
- *
- * ATMEGA88 @ 8 MHz
- *
- * Supported mikrocontrollers:
- *
- * ATtiny45,  ATtiny85
- * ATtiny84
- * ATmega8,   ATmega16,  ATmega32
- * ATmega162
- * ATmega164, ATmega324, ATmega644,  ATmega644P, ATmega1284
- * ATmega88,  ATmega88P, ATmega168,  ATmega168P, ATmega328P
- *
- * Typical manufacturers of remote controls:
- *
- * SIRCS        - Sony
- * NEC          - NEC, Yamaha, Canon, Tevion, Harman/Kardon, Hitachi, JVC, Pioneer, Toshiba, Xoro, Orion, and many other Japanese manufacturers
- * SAMSUNG      - Samsung
- * SAMSUNG32    - Samsung
- * MATSUSHITA   - Matsushita
- * KASEIKYO     - Panasonic, Denon & other Japanese manufacturers (members of "Japan's Association for Electric Home Application")
- * RECS80       - Philips, Nokia, Thomson, Nordmende, Telefunken, Saba
- * RC5          - Philips and other European manufacturers
- * DENON        - Denon, Sharp
- * RC6          - Philips and other European manufacturers
- * APPLE        - Apple
- * NUBERT       - Nubert Subwoofer System
- * B&O          - Bang & Olufsen
- * PANASONIC    - Panasonic (older, yet not implemented)
- * GRUNDIG      - Grundig
- * NOKIA        - Nokia
- * SIEMENS      - Siemens, e.g. Gigaset M740AV
- * FDC          - FDC IR keyboard
- * RCCAR        - IR remote control for RC cars
- * JVC          - JVC
- * THOMSON      - Thomson
- * NIKON        - Nikon cameras
- * RUWIDO       - T-Home
- * KATHREIN     - Kathrein
- * LEGO         - Lego Power Functions RC
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   SIRCS
- *   -----
- *
- *   frame: 1 start bit + 12-20 data bits + no stop bit
- *   data:  7 command bits + 5 address bits + 0 to 8 additional bits
- *
- *   start bit:                           data "0":                 data "1":                 stop bit:
- *   -----------------_________           ------_____               ------------______
- *       2400us         600us             600us 600us               1200us      600 us        no stop bit
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   NEC + extended NEC
- *   -------------------------
- *
- *   frame: 1 start bit + 32 data bits + 1 stop bit
- *   data NEC:          8 address bits + 8 inverted address bits + 8 command bits + 8 inverted command bits
- *   data extended NEC: 16 address bits + 8 command bits + 8 inverted command bits
- *
- *   start bit:                           data "0":                 data "1":                 stop bit:
- *   -----------------_________           ------______              ------________________    ------______....
- *       9000us        4500us             560us  560us              560us    1690 us          560us
- *
- *
- *   Repetition frame:
- *
- *   -----------------_________------______  .... ~100ms Pause, then repeat
- *       9000us        2250us   560us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   SAMSUNG
- *   -------
- *
- *   frame: 1 start bit + 16 data(1) bits + 1 sync bit + additional 20 data(2) bits + 1 stop bit
- *   data(1): 16 address bits
- *   data(2): 4 ID bits + 8 command bits + 8 inverted command bits
- *
- *   start bit:                           data "0":                 data "1":                 sync bit:               stop bit:
- *   ----------______________             ------______              ------________________    ------______________    ------______....
- *    4500us       4500us                 550us  450us              550us    1450us           550us    4500us         550us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   SAMSUNG32
- *   ----------
- *
- *   frame: 1 start bit + 32 data bits + 1 stop bit
- *   data: 16 address bits + 16 command bits
- *
- *   start bit:                           data "0":                 data "1":                 stop bit:
- *   ----------______________             ------______              ------________________    ------______....
- *    4500us       4500us                 550us  450us              550us    1450us           550us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   MATSUSHITA
- *   ----------
- *
- *   frame: 1 start bit + 24 data bits + 1 stop bit
- *   data:  6 custom bits + 6 command bits + 12 address bits
- *
- *   start bit:                           data "0":                 data "1":                 stop bit:
- *   ----------_________                  ------______              ------________________    ------______....
- *    3488us     3488us                   872us  872us              872us    2616us           872us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   KASEIKYO
- *   --------
- *
- *   frame: 1 start bit + 48 data bits + 1 stop bit
- *   data:  16 manufacturer bits + 4 parity bits + 4 genre1 bits + 4 genre2 bits + 10 command bits + 2 id bits + 8 parity bits
- *
- *   start bit:                           data "0":                 data "1":                 stop bit:
- *   ----------______                     ------______              ------________________    ------______....
- *    3380us   1690us                     423us  423us              423us    1269us           423us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   RECS80
- *   ------
- *
- *   frame: 2 start bits + 10 data bits + 1 stop bit
- *   data:  1 toggle bit + 3 address bits + 6 command bits
- *
- *   start bit:                           data "0":                 data "1":                 stop bit:
- *   -----_____________________           -----____________         -----______________       ------_______....
- *   158us       7432us                   158us   4902us            158us    7432us           158us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   RECS80EXT
- *   ---------
- *
- *   frame: 2 start bits + 11 data bits + 1 stop bit
- *   data:  1 toggle bit + 4 address bits + 6 command bits
- *
- *   start bit:                           data "0":                 data "1":                 stop bit:
- *   -----_____________________           -----____________         -----______________       ------_______....
- *   158us       3637us                   158us   4902us            158us    7432us           158us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   RC5 + RC5X
- *   ----------
- *
- *   RC5 frame:  2 start bits + 12 data bits + no stop bit
- *   RC5 data:   1 toggle bit + 5 address bits + 6 command bits
- *   RC5X frame: 1 start bit +  13 data bits + no stop bit
- *   RC5X data:  1 inverted command bit + 1 toggle bit + 5 address bits + 6 command bits
- *
- *   start bit:              data "0":                data "1":
- *   ______-----             ------______             ______------
- *   889us 889us             889us 889us              889us 889us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   DENON
- *   -----
- *
- *   frame: 0 start bits + 16 data bits + stop bit + 65ms pause + 16 inverted data bits + stop bit
- *   data:  5 address bits + 10 command bits
- *
- *   Theory:
- *
- *   data "0":                 data "1":
- *   ------________________    ------______________
- *   275us       775us         275us   1900us
- *
- *   Practice:
- *
- *   data "0":                 data "1":
- *   ------________________    ------______________
- *   310us       745us         310us   1780us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   RC6
- *   ---
- *
- *   RC6 frame:  1 start bit + 1 bit "1" + 3 mode bits + 1 toggle bit + 16 data bits + 2666 us pause
- *   RC6 data:   8 address bits + 8 command bits
- *
- *   start  bit               toggle bit "0":      toggle bit "1":     data/mode "0":      data/mode "1":
- *   ____________-------      _______-------       -------_______      _______-------      -------_______
- *      2666us    889us        889us  889us         889us  889us        444us  444us        444us  444us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   APPLE
- *   -----
- *
- *   frame: 1 start bit + 32 data bits + 1 stop bit
- *   data:  16 address bits + 11100000 + 8 command bits
- *
- *   start bit:                           data "0":                 data "1":                 stop bit:
- *   -----------------_________           ------______              ------________________    ------______....
- *       9000us        4500us             560us  560us              560us    1690 us          560us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   NUBERT (subwoofer system)
- *   -------------------------
- *
- *   frame: 1 start bit + 10 data bits + 1 stop bit
- *   data:  0 address bits + 10 command bits ?
- *
- *   start bit:                       data "0":                 data "1":                 stop bit:
- *   ----------_____                  ------______              ------________________    ------______....
- *    1340us   340us                  500us 1300us              1340us 340us              500us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   BANG_OLUFSEN
- *   ------------
- *
- *   frame: 4 start bits + 16 data bits + 1 trailer bit + 1 stop bit
- *   data:  0 address bits + 16 command bits
- *
- *   1st start bit:  2nd start bit:      3rd start bit:       4th start bit:
- *   -----________   -----________       -----_____________   -----________
- *   210us 3000us    210us 3000us        210us   15000us      210us 3000us
- *
- *   data "0":       data "1":           data "repeat bit":   trailer bit:         stop bit:
- *   -----________   -----_____________  -----___________     -----_____________   -----____...
- *   210us 3000us    210us   9000us      210us   6000us       210us   12000us      210us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   GRUNDIG
- *   -------
- *
- *   packet:  1 start frame + 19,968ms pause + N info frames + 117,76ms pause + 1 stop frame
- *   frame: 1 pre bit + 1 start bit + 9 data bits + no stop bit
- *   pause between info frames: 117,76ms
- *
- *   data of start frame:   9 x 1
- *   data of info  frame:   9 command bits
- *   data of stop  frame:   9 x 1
- *
- *   pre bit:              start bit           data "0":            data "1":
- *   ------____________    ------______        ______------         ------______             
- *   528us  2639us         528us  528us        528us  528us         528us  528us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   NOKIA:
- *   ------
- *
- *   Timing similar to Grundig, but 16 data bits:
- *   frame: 1 pre bit + 1 start bit + 8 command bits + 8 address bits + no stop bit
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   SIEMENS or RUWIDO:
- *   ------------------
- *
- *   SIEMENS frame:  1 start bit + 22 data bits + no stop bit
- *   SIEMENS data:   13 address bits + 1 repeat bit + 7 data bits + 1 unknown bit
- *
- *   start  bit           data "0":            data "1":
- *   -------_______       _______-------       -------_______
- *    250us  250us         250us  250us         250us  250us
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- *   PANASONIC (older protocol, yet not implemented, see also MATSUSHITA, timing very similar)
- *   -----------------------------------------------------------------------------------------
- *
- *   frame: 1 start bit + 22 data bits + 1 stop bit
- *   22 data bits = 5 custom bits + 6 data bits + 5 inverted custom bits + 6 inverted data bits
- *
- *   European version:      T = 456us
- *   USA & Canada version:  T = 422us
- *
- *   start bit:                           data "0":                 data "1":                 stop bit:
- *        8T            8T                 2T   2T                   2T      6T                2T
- *   -------------____________            ------_____               ------_____________       ------_______....
- *      3648us        3648us              912us 912us               912us    2736us           912us                (Europe)
- *      3376us        3376us              844us 844us               844us    2532us           844us                (US)
- *
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-
-#if defined(__18CXX)
-#define PIC_C18                                                             // Microchip C18 Compiler
-#endif
-
-#if defined(__PCM__) || defined(__PCB__) || defined(__PCH__)                // CCS PIC Compiler instead of AVR
-#define PIC_CCS_COMPILER
-#endif
-
-#ifdef unix                                                                 // test on linux/unix
-#include <stdio.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-
-/* for crazy lirc stuff... */
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <errno.h>
-
-#define ANALYZE
-#define PROGMEM
-#define memcpy_P        memcpy
-
-#else // not unix:
-
-#ifdef WIN32
-#include <stdio.h>
-#include <string.h>
-typedef unsigned char   uint8_t;
-typedef unsigned short  uint16_t;
-#define ANALYZE
-#define PROGMEM
-#define memcpy_P        memcpy
-
-#else
-
-#if defined (PIC_CCS_COMPILER) || defined(PIC_C18)
-
-#include <string.h>
-#define PROGMEM
-#define memcpy_P        memcpy
-
-#if defined (PIC_CCS_COMPILER)
-typedef unsigned int8   uint8_t;
-typedef unsigned int16  uint16_t;
-#endif
-
-#else // AVR:
-
-#include <inttypes.h>
-#include <stdio.h>
-#include <string.h>
-#include <avr/io.h>
-#include <util/delay.h>
-#include <avr/pgmspace.h>
-
-#endif  // PIC_CCS_COMPILER or PIC_C18
-
-#endif // windows
-#endif // unix
-
-#ifndef IRMP_USE_AS_LIB
-#include "irmpconfig.h"
-#endif
-#include "irmp.h"
-
-#if IRMP_SUPPORT_GRUNDIG_PROTOCOL == 1 || IRMP_SUPPORT_NOKIA_PROTOCOL == 1 || IRMP_SUPPORT_IR60_PROTOCOL == 1
-#define IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL  1
-#else
-#define IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL  0
-#endif
-
-#if IRMP_SUPPORT_SIEMENS_PROTOCOL == 1 || IRMP_SUPPORT_RUWIDO_PROTOCOL == 1
-#define IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL 1
-#else
-#define IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL 0
-#endif
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 ||                   \
-    IRMP_SUPPORT_RC6_PROTOCOL == 1 ||                   \
-    IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1 ||    \
-    IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1 ||     \
-    IRMP_SUPPORT_GRUNDIG2_PROTOCOL == 1 ||              \
-    IRMP_SUPPORT_IR60_PROTOCOL
-#define IRMP_SUPPORT_MANCHESTER                 1
-#else
-#define IRMP_SUPPORT_MANCHESTER                 0
-#endif
-
-#if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
-#define IRMP_SUPPORT_SERIAL                     1
-#else
-#define IRMP_SUPPORT_SERIAL                     0
-#endif
-
-#define IRMP_KEY_REPETITION_LEN                 (uint16_t)(F_INTERRUPTS * 150.0e-3 + 0.5)           // autodetect key repetition within 150 msec
-
-#define MIN_TOLERANCE_00                        1.0                           // -0%
-#define MAX_TOLERANCE_00                        1.0                           // +0%
-
-#define MIN_TOLERANCE_05                        0.95                          // -5%
-#define MAX_TOLERANCE_05                        1.05                          // +5%
-
-#define MIN_TOLERANCE_10                        0.9                           // -10%
-#define MAX_TOLERANCE_10                        1.1                           // +10%
-
-#define MIN_TOLERANCE_15                        0.85                          // -15%
-#define MAX_TOLERANCE_15                        1.15                          // +15%
-
-#define MIN_TOLERANCE_20                        0.8                           // -20%
-#define MAX_TOLERANCE_20                        1.2                           // +20%
-
-#define MIN_TOLERANCE_30                        0.7                           // -30%
-#define MAX_TOLERANCE_30                        1.3                           // +30%
-
-#define MIN_TOLERANCE_40                        0.6                           // -40%
-#define MAX_TOLERANCE_40                        1.4                           // +40%
-
-#define MIN_TOLERANCE_50                        0.5                           // -50%
-#define MAX_TOLERANCE_50                        1.5                           // +50%
-
-#define MIN_TOLERANCE_60                        0.4                           // -60%
-#define MAX_TOLERANCE_60                        1.6                           // +60%
-
-#define MIN_TOLERANCE_70                        0.3                           // -70%
-#define MAX_TOLERANCE_70                        1.7                           // +70%
-
-#define SIRCS_START_BIT_PULSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define SIRCS_START_BIT_PULSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define SIRCS_START_BIT_PAUSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#if IRMP_SUPPORT_NETBOX_PROTOCOL                // only 5% to avoid conflict with NETBOX:
-#define SIRCS_START_BIT_PAUSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUSE_TIME * MAX_TOLERANCE_05 + 0.5))
-#else                                           // only 5% + 1 to avoid conflict with RC6:
-#define SIRCS_START_BIT_PAUSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUSE_TIME * MAX_TOLERANCE_05 + 0.5) + 1)
-#endif
-#define SIRCS_1_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * SIRCS_1_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define SIRCS_1_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * SIRCS_1_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define SIRCS_0_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * SIRCS_0_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define SIRCS_0_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * SIRCS_0_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define SIRCS_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * SIRCS_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define SIRCS_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * SIRCS_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define NEC_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PULSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define NEC_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PULSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-#define NEC_START_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define NEC_START_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-#define NEC_REPEAT_START_BIT_PAUSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * NEC_REPEAT_START_BIT_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define NEC_REPEAT_START_BIT_PAUSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * NEC_REPEAT_START_BIT_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-#define NEC_PULSE_LEN_MIN                       ((uint8_t)(F_INTERRUPTS * NEC_PULSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define NEC_PULSE_LEN_MAX                       ((uint8_t)(F_INTERRUPTS * NEC_PULSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-#define NEC_1_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * NEC_1_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define NEC_1_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * NEC_1_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-#define NEC_0_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * NEC_0_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define NEC_0_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * NEC_0_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-// autodetect nec repetition frame within 50 msec:
-// NEC seems to send the first repetition frame after 40ms, further repetition frames after 100 ms
-#if 0
-#define NEC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint16_t)(F_INTERRUPTS * NEC_FRAME_REPEAT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5)
-#else
-#define NEC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint16_t)(F_INTERRUPTS * 100.0e-3 * MAX_TOLERANCE_20 + 0.5)
-#endif
-
-#define SAMSUNG_START_BIT_PULSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define SAMSUNG_START_BIT_PULSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define SAMSUNG_START_BIT_PAUSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define SAMSUNG_START_BIT_PAUSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define SAMSUNG_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * SAMSUNG_PULSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define SAMSUNG_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * SAMSUNG_PULSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-#define SAMSUNG_1_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_1_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define SAMSUNG_1_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_1_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-#define SAMSUNG_0_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_0_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define SAMSUNG_0_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_0_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-
-#define MATSUSHITA_START_BIT_PULSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define MATSUSHITA_START_BIT_PULSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define MATSUSHITA_START_BIT_PAUSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define MATSUSHITA_START_BIT_PAUSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define MATSUSHITA_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * MATSUSHITA_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define MATSUSHITA_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * MATSUSHITA_PULSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-#define MATSUSHITA_1_PAUSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_1_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define MATSUSHITA_1_PAUSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_1_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-#define MATSUSHITA_0_PAUSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_0_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define MATSUSHITA_0_PAUSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_0_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-
-#define KASEIKYO_START_BIT_PULSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define KASEIKYO_START_BIT_PULSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define KASEIKYO_START_BIT_PAUSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define KASEIKYO_START_BIT_PAUSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define KASEIKYO_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * KASEIKYO_PULSE_TIME * MIN_TOLERANCE_50 + 0.5) - 1)
-#define KASEIKYO_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * KASEIKYO_PULSE_TIME * MAX_TOLERANCE_50 + 0.5) + 1)
-#define KASEIKYO_1_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KASEIKYO_1_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define KASEIKYO_1_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KASEIKYO_1_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-#define KASEIKYO_0_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KASEIKYO_0_PAUSE_TIME * MIN_TOLERANCE_50 + 0.5) - 1)
-#define KASEIKYO_0_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KASEIKYO_0_PAUSE_TIME * MAX_TOLERANCE_50 + 0.5) + 1)
-
-#define RECS80_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PULSE_TIME * MIN_TOLERANCE_00 + 0.5) - 1)
-#define RECS80_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RECS80_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RECS80_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RECS80_PULSE_LEN_MIN                    ((uint8_t)(F_INTERRUPTS * RECS80_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RECS80_PULSE_LEN_MAX                    ((uint8_t)(F_INTERRUPTS * RECS80_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RECS80_1_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RECS80_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RECS80_1_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RECS80_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RECS80_0_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RECS80_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RECS80_0_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RECS80_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define RC5_START_BIT_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RC5_START_BIT_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define RC5_BIT_LEN_MIN                         ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RC5_BIT_LEN_MAX                         ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define DENON_PULSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * DENON_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define DENON_PULSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * DENON_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define DENON_1_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * DENON_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define DENON_1_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * DENON_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
-#define DENON_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * DENON_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5))     // no -1, avoid conflict with RUWIDO
-#else
-#define DENON_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * DENON_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1) // be more tolerant
-#endif
-#define DENON_0_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * DENON_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define THOMSON_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * THOMSON_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define THOMSON_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * THOMSON_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define THOMSON_1_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * THOMSON_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define THOMSON_1_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * THOMSON_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define THOMSON_0_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * THOMSON_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define THOMSON_0_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * THOMSON_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define RC6_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RC6_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RC6_START_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RC6_START_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RC6_TOGGLE_BIT_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RC6_TOGGLE_BIT_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RC6_TOGGLE_BIT_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RC6_TOGGLE_BIT_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RC6_BIT_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RC6_BIT_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MAX_TOLERANCE_60 + 0.5) + 1)       // pulses: 300 - 800
-#define RC6_BIT_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RC6_BIT_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MAX_TOLERANCE_20 + 0.5) + 1)       // pauses: 300 - 600
-
-#define RECS80EXT_START_BIT_PULSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PULSE_TIME * MIN_TOLERANCE_00 + 0.5) - 1)
-#define RECS80EXT_START_BIT_PULSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PULSE_TIME * MAX_TOLERANCE_00 + 0.5) + 1)
-#define RECS80EXT_START_BIT_PAUSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PAUSE_TIME * MIN_TOLERANCE_05 + 0.5) - 1)
-#define RECS80EXT_START_BIT_PAUSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PAUSE_TIME * MAX_TOLERANCE_05 + 0.5) + 1)
-#define RECS80EXT_PULSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * RECS80EXT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RECS80EXT_PULSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * RECS80EXT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RECS80EXT_1_PAUSE_LEN_MIN               ((uint8_t)(F_INTERRUPTS * RECS80EXT_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RECS80EXT_1_PAUSE_LEN_MAX               ((uint8_t)(F_INTERRUPTS * RECS80EXT_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RECS80EXT_0_PAUSE_LEN_MIN               ((uint8_t)(F_INTERRUPTS * RECS80EXT_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RECS80EXT_0_PAUSE_LEN_MAX               ((uint8_t)(F_INTERRUPTS * RECS80EXT_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define NUBERT_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NUBERT_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NUBERT_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NUBERT_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NUBERT_1_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NUBERT_1_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NUBERT_1_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NUBERT_1_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NUBERT_0_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NUBERT_0_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NUBERT_0_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NUBERT_0_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-
-#define BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_START_BIT1_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_START_BIT2_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_START_BIT2_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_START_BIT3_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_START_BIT3_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MAX   ((PAUSE_LEN)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_PAUSE_TIME * MAX_TOLERANCE_05 + 0.5) + 1) // value must be below IRMP_TIMEOUT
-#define BANG_OLUFSEN_START_BIT4_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_START_BIT4_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_PULSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_PULSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_1_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_1_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_0_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_0_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_R_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_R_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_R_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_R_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MIN  ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_TRAILER_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MAX  ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_TRAILER_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define IR60_TIMEOUT_LEN                        ((uint8_t)(F_INTERRUPTS * IR60_TIMEOUT_TIME * 0.5))
-#define GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define GRUNDIG_NOKIA_IR60_START_BIT_LEN_MAX    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define GRUNDIG_NOKIA_IR60_BIT_LEN_MIN          ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define GRUNDIG_NOKIA_IR60_BIT_LEN_MAX          ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_PRE_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) + 1)
-#define GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MAX    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_PRE_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-
-#define SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define GRUNDIG2_START_BIT_PULSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * GRUNDIG2_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define GRUNDIG2_START_BIT_PULSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * GRUNDIG2_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define GRUNDIG2_START_BIT_PAUSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * GRUNDIG2_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define GRUNDIG2_START_BIT_PAUSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * GRUNDIG2_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define GRUNDIG2_BIT_PULSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * GRUNDIG2_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define GRUNDIG2_BIT_PULSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * GRUNDIG2_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define GRUNDIG2_BIT_PAUSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * GRUNDIG2_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define GRUNDIG2_BIT_PAUSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * GRUNDIG2_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define FDC_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PULSE_TIME * MIN_TOLERANCE_05 + 0.5) - 1)   // 5%: avoid conflict with NETBOX
-#define FDC_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PULSE_TIME * MAX_TOLERANCE_05 + 0.5))
-#define FDC_START_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PAUSE_TIME * MIN_TOLERANCE_05 + 0.5) - 1)
-#define FDC_START_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PAUSE_TIME * MAX_TOLERANCE_05 + 0.5))
-#define FDC_PULSE_LEN_MIN                       ((uint8_t)(F_INTERRUPTS * FDC_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define FDC_PULSE_LEN_MAX                       ((uint8_t)(F_INTERRUPTS * FDC_PULSE_TIME * MAX_TOLERANCE_50 + 0.5) + 1)
-#define FDC_1_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * FDC_1_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define FDC_1_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * FDC_1_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#if 0
-#define FDC_0_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * FDC_0_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)   // could be negative: 255
-#else
-#define FDC_0_PAUSE_LEN_MIN                     (1)                                                                         // simply use 1
-#endif
-#define FDC_0_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * FDC_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define RCCAR_START_BIT_PULSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RCCAR_START_BIT_PULSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RCCAR_START_BIT_PAUSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define RCCAR_START_BIT_PAUSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define RCCAR_PULSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * RCCAR_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define RCCAR_PULSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * RCCAR_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define RCCAR_1_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RCCAR_1_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define RCCAR_1_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RCCAR_1_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-#define RCCAR_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RCCAR_0_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
-#define RCCAR_0_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RCCAR_0_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
-
-#define JVC_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define JVC_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-#define JVC_REPEAT_START_BIT_PAUSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * (JVC_FRAME_REPEAT_PAUSE_TIME - IRMP_TIMEOUT_TIME) * MIN_TOLERANCE_40 + 0.5) - 1)  // HACK!
-#define JVC_REPEAT_START_BIT_PAUSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * (JVC_FRAME_REPEAT_PAUSE_TIME - IRMP_TIMEOUT_TIME) * MAX_TOLERANCE_70 + 0.5) - 1)  // HACK!
-#define JVC_PULSE_LEN_MIN                       ((uint8_t)(F_INTERRUPTS * JVC_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define JVC_PULSE_LEN_MAX                       ((uint8_t)(F_INTERRUPTS * JVC_PULSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-#define JVC_1_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * JVC_1_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define JVC_1_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * JVC_1_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-#define JVC_0_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * JVC_0_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define JVC_0_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * JVC_0_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-// autodetect JVC repetition frame within 50 msec:
-#define JVC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint16_t)(F_INTERRUPTS * JVC_FRAME_REPEAT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5)
-
-#define NIKON_START_BIT_PULSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * NIKON_START_BIT_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NIKON_START_BIT_PULSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * NIKON_START_BIT_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NIKON_START_BIT_PAUSE_LEN_MIN           ((uint16_t)(F_INTERRUPTS * NIKON_START_BIT_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NIKON_START_BIT_PAUSE_LEN_MAX           ((uint16_t)(F_INTERRUPTS * NIKON_START_BIT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NIKON_REPEAT_START_BIT_PAUSE_LEN_MIN    ((uint8_t)(F_INTERRUPTS * NIKON_REPEAT_START_BIT_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NIKON_REPEAT_START_BIT_PAUSE_LEN_MAX    ((uint8_t)(F_INTERRUPTS * NIKON_REPEAT_START_BIT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NIKON_PULSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * NIKON_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NIKON_PULSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * NIKON_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NIKON_1_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * NIKON_1_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NIKON_1_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * NIKON_1_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NIKON_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * NIKON_0_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
-#define NIKON_0_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * NIKON_0_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
-#define NIKON_FRAME_REPEAT_PAUSE_LEN_MAX        (uint16_t)(F_INTERRUPTS * NIKON_FRAME_REPEAT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5)
-
-#define KATHREIN_START_BIT_PULSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define KATHREIN_START_BIT_PULSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define KATHREIN_START_BIT_PAUSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define KATHREIN_START_BIT_PAUSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define KATHREIN_1_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define KATHREIN_1_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define KATHREIN_1_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define KATHREIN_1_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define KATHREIN_0_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define KATHREIN_0_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define KATHREIN_0_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define KATHREIN_0_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define KATHREIN_SYNC_BIT_PAUSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * KATHREIN_SYNC_BIT_PAUSE_LEN_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define KATHREIN_SYNC_BIT_PAUSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * KATHREIN_SYNC_BIT_PAUSE_LEN_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-
-#define NETBOX_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define NETBOX_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define NETBOX_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
-#define NETBOX_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
-#define NETBOX_PULSE_LEN                        ((uint8_t)(F_INTERRUPTS * NETBOX_PULSE_TIME))
-#define NETBOX_PAUSE_LEN                        ((uint8_t)(F_INTERRUPTS * NETBOX_PAUSE_TIME))
-#define NETBOX_PULSE_REST_LEN                   ((uint8_t)(F_INTERRUPTS * NETBOX_PULSE_TIME / 4))
-#define NETBOX_PAUSE_REST_LEN                   ((uint8_t)(F_INTERRUPTS * NETBOX_PAUSE_TIME / 4))
-
-#define LEGO_START_BIT_PULSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define LEGO_START_BIT_PULSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PULSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-#define LEGO_START_BIT_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define LEGO_START_BIT_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-#define LEGO_PULSE_LEN_MIN                      ((uint8_t)(F_INTERRUPTS * LEGO_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define LEGO_PULSE_LEN_MAX                      ((uint8_t)(F_INTERRUPTS * LEGO_PULSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-#define LEGO_1_PAUSE_LEN_MIN                    ((uint8_t)(F_INTERRUPTS * LEGO_1_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define LEGO_1_PAUSE_LEN_MAX                    ((uint8_t)(F_INTERRUPTS * LEGO_1_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-#define LEGO_0_PAUSE_LEN_MIN                    ((uint8_t)(F_INTERRUPTS * LEGO_0_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
-#define LEGO_0_PAUSE_LEN_MAX                    ((uint8_t)(F_INTERRUPTS * LEGO_0_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
-
-#define AUTO_FRAME_REPETITION_LEN               (uint16_t)(F_INTERRUPTS * AUTO_FRAME_REPETITION_TIME + 0.5)       // use uint16_t!
-
-#ifdef ANALYZE
-#define ANALYZE_PUTCHAR(a)                      { if (! silent)             { putchar (a);          } }
-#ifndef LIRC_IRMP
-#define ANALYZE_ONLY_NORMAL_PUTCHAR(a)          { if (! silent && !verbose) { putchar (a);          } }
-#else
-#define ANALYZE_ONLY_NORMAL_PUTCHAR(a)
-#endif
-#define ANALYZE_PRINTF(...)                     { if (verbose)              { printf (__VA_ARGS__); } }
-#define ANALYZE_NEWLINE()                       { if (verbose)              { putchar ('\n');       } }
-static int                                      silent = TRUE;
-static int                                      time_counter;
-static int                                      verbose;
-#else
-#define ANALYZE_PUTCHAR(a)
-#define ANALYZE_ONLY_NORMAL_PUTCHAR(a)
-#define ANALYZE_PRINTF(...)
-#define ANALYZE_NEWLINE()
-#endif
-
-#if IRMP_USE_CALLBACK == 1
-static void                                     (*irmp_callback_ptr) (uint8_t);
-#endif // IRMP_USE_CALLBACK == 1
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- *  Protocol names
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#if IRMP_PROTOCOL_NAMES == 1
-char *
-irmp_protocol_names[IRMP_N_PROTOCOLS + 1] =
-{
-    "UNKNOWN",
-    "SIRCS",
-    "NEC",
-    "SAMSUNG",
-    "MATSUSH",
-    "KASEIKYO",
-    "RECS80",
-    "RC5",
-    "DENON",
-    "RC6",
-    "SAMSG32",
-    "APPLE",
-    "RECS80EX",
-    "NUBERT",
-    "BANG OLU",
-    "GRUNDIG",
-    "NOKIA",
-    "SIEMENS",
-    "FDC",
-    "RCCAR",
-    "JVC",
-    "RC6A",
-    "NIKON",
-    "RUWIDO",
-    "IR60",
-    "KATHREIN",
-    "NETBOX",
-    "NEC16",
-    "NEC42",
-    "LEGO",
-    "THOMSON"
-};
-#endif
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- *  Logging
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#if IRMP_LOGGING == 1                                               // logging via UART
-
-#if IRMP_EXT_LOGGING == 1                                           // use external logging
-#include "irmpextlog.h"
-#else                                                               // normal UART log (IRMP_EXT_LOGGING == 0)
-#define BAUD                                    9600L
-#include <util/setbaud.h>
-
-#ifdef UBRR0H
-
-#define UART0_UBRRH                             UBRR0H
-#define UART0_UBRRL                             UBRR0L
-#define UART0_UCSRA                             UCSR0A
-#define UART0_UCSRB                             UCSR0B
-#define UART0_UCSRC                             UCSR0C
-#define UART0_UDRE_BIT_VALUE                    (1<<UDRE0)
-#define UART0_UCSZ1_BIT_VALUE                   (1<<UCSZ01)
-#define UART0_UCSZ0_BIT_VALUE                   (1<<UCSZ00)
-#ifdef URSEL0
-#define UART0_URSEL_BIT_VALUE                   (1<<URSEL0)
-#else
-#define UART0_URSEL_BIT_VALUE                   (0)
-#endif
-#define UART0_TXEN_BIT_VALUE                    (1<<TXEN0)
-#define UART0_UDR                               UDR0
-#define UART0_U2X                               U2X0
-        
-#else
-
-#define UART0_UBRRH                             UBRRH
-#define UART0_UBRRL                             UBRRL
-#define UART0_UCSRA                             UCSRA
-#define UART0_UCSRB                             UCSRB
-#define UART0_UCSRC                             UCSRC
-#define UART0_UDRE_BIT_VALUE                    (1<<UDRE)
-#define UART0_UCSZ1_BIT_VALUE                   (1<<UCSZ1)
-#define UART0_UCSZ0_BIT_VALUE                   (1<<UCSZ0)
-#ifdef URSEL
-#define UART0_URSEL_BIT_VALUE                   (1<<URSEL)
-#else
-#define UART0_URSEL_BIT_VALUE                   (0)
-#endif
-#define UART0_TXEN_BIT_VALUE                    (1<<TXEN)
-#define UART0_UDR                               UDR
-#define UART0_U2X                               U2X
-
-#endif //UBRR0H
-#endif //IRMP_EXT_LOGGING
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- *  Initialize  UART
- *  @details  Initializes UART
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-void
-irmp_uart_init (void)
-{
-#if (IRMP_EXT_LOGGING == 0)                                                                         // use UART
-    UART0_UBRRH = UBRRH_VALUE;                                                                      // set baud rate
-    UART0_UBRRL = UBRRL_VALUE;
-
-#if USE_2X
-    UART0_UCSRA |= (1<<UART0_U2X);
-#else
-    UART0_UCSRA &= ~(1<<UART0_U2X);
-#endif
-
-    UART0_UCSRC = UART0_UCSZ1_BIT_VALUE | UART0_UCSZ0_BIT_VALUE | UART0_URSEL_BIT_VALUE;
-    UART0_UCSRB |= UART0_TXEN_BIT_VALUE;                                                            // enable UART TX
-#else                                                                                               // other log method
-        initextlog();                                                         
-#endif //IRMP_EXT_LOGGING
-}
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- *  Send character
- *  @details  Sends character
- *  @param    ch character to be transmitted
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-void
-irmp_uart_putc (unsigned char ch)
-{
-#if (IRMP_EXT_LOGGING == 0)
-    while (!(UART0_UCSRA & UART0_UDRE_BIT_VALUE))
-    {
-        ;
-    }
-
-    UART0_UDR = ch;
-#else
-    sendextlog(ch); //Use external log
-#endif
-}
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- *  Log IR signal
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-
-#define STARTCYCLES                       2                                 // min count of zeros before start of logging
-#define ENDBITS                        1000                                 // number of sequenced highbits to detect end
-#define DATALEN                         700                                 // log buffer size
-
-static void
-irmp_log (uint8_t val)
-{
-    static uint8_t  buf[DATALEN];                                           // logging buffer
-    static uint16_t buf_idx;                                                // number of written bits
-    static uint8_t  startcycles;                                            // current number of start-zeros
-    static uint16_t cnt;                                                    // counts sequenced highbits - to detect end
-
-    if (! val && (startcycles < STARTCYCLES) && !buf_idx)                   // prevent that single random zeros init logging
-    {
-        startcycles++;
-    }
-    else
-    {
-        startcycles = 0;
-
-        if (! val || (val && buf_idx != 0))                                 // start or continue logging on "0", "1" cannot init logging
-        {
-            if (buf_idx < DATALEN * 8)                                      // index in range?
-            {                                                               // yes
-                if (val)
-                {
-                    buf[(buf_idx / 8)] |=  (1<<(buf_idx % 8));              // set bit
-                }
-                else
-                {
-                    buf[(buf_idx / 8)] &= ~(1<<(buf_idx % 8));              // reset bit
-                }
-
-                buf_idx++;
-            }
-
-            if (val)
-            {                                                               // if high received then look at log-stop condition
-                cnt++;
-
-                if (cnt > ENDBITS)
-                {                                                           // if stop condition is true, output on uart
-                    uint16_t i;
-
-                    for (i = 0; i < STARTCYCLES; i++)
-                    {
-                        irmp_uart_putc ('0');                               // the ignored starting zeros
-                    }
-
-                    for (i = 0; i < (buf_idx - ENDBITS + 20) / 8; i++)      // transform bitset into uart chars
-                    {
-                        uint8_t d = buf[i];
-                        uint8_t j;
-
-                        for (j = 0; j < 8; j++)
-                        {
-                            irmp_uart_putc ((d & 1) + '0');
-                            d >>= 1;
-                        }
-                    }
-
-                    irmp_uart_putc ('\n');
-                    buf_idx = 0;
-                }
-            }
-            else
-            {
-                cnt = 0;
-            }
-        }
-    }
-}
-
-#else
-#define irmp_log(val)
-#endif //IRMP_LOGGING
-
-typedef struct
-{
-    uint8_t    protocol;                                                // ir protocol
-    uint8_t    pulse_1_len_min;                                         // minimum length of pulse with bit value 1
-    uint8_t    pulse_1_len_max;                                         // maximum length of pulse with bit value 1
-    uint8_t    pause_1_len_min;                                         // minimum length of pause with bit value 1
-    uint8_t    pause_1_len_max;                                         // maximum length of pause with bit value 1
-    uint8_t    pulse_0_len_min;                                         // minimum length of pulse with bit value 0
-    uint8_t    pulse_0_len_max;                                         // maximum length of pulse with bit value 0
-    uint8_t    pause_0_len_min;                                         // minimum length of pause with bit value 0
-    uint8_t    pause_0_len_max;                                         // maximum length of pause with bit value 0
-    uint8_t    address_offset;                                          // address offset
-    uint8_t    address_end;                                             // end of address
-    uint8_t    command_offset;                                          // command offset
-    uint8_t    command_end;                                             // end of command
-    uint8_t    complete_len;                                            // complete length of frame
-    uint8_t    stop_bit;                                                // flag: frame has stop bit
-    uint8_t    lsb_first;                                               // flag: LSB first
-    uint8_t    flags;                                                   // some flags
-} IRMP_PARAMETER;
-
-#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER sircs_param =
-{
-    IRMP_SIRCS_PROTOCOL,                                                // protocol:        ir protocol
-    SIRCS_1_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum length of pulse with bit value 1
-    SIRCS_1_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum length of pulse with bit value 1
-    SIRCS_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum length of pause with bit value 1
-    SIRCS_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum length of pause with bit value 1
-    SIRCS_0_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum length of pulse with bit value 0
-    SIRCS_0_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum length of pulse with bit value 0
-    SIRCS_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum length of pause with bit value 0
-    SIRCS_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum length of pause with bit value 0
-    SIRCS_ADDRESS_OFFSET,                                               // address_offset:  address offset
-    SIRCS_ADDRESS_OFFSET + SIRCS_ADDRESS_LEN,                           // address_end:     end of address
-    SIRCS_COMMAND_OFFSET,                                               // command_offset:  command offset
-    SIRCS_COMMAND_OFFSET + SIRCS_COMMAND_LEN,                           // command_end:     end of command
-    SIRCS_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame
-    SIRCS_STOP_BIT,                                                     // stop_bit:        flag: frame has stop bit
-    SIRCS_LSB,                                                          // lsb_first:       flag: LSB first
-    SIRCS_FLAGS                                                         // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_NEC_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER nec_param =
-{
-    IRMP_NEC_PROTOCOL,                                                  // protocol:        ir protocol
-    NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum length of pulse with bit value 1
-    NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum length of pulse with bit value 1
-    NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum length of pause with bit value 1
-    NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum length of pause with bit value 1
-    NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum length of pulse with bit value 0
-    NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum length of pulse with bit value 0
-    NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum length of pause with bit value 0
-    NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum length of pause with bit value 0
-    NEC_ADDRESS_OFFSET,                                                 // address_offset:  address offset
-    NEC_ADDRESS_OFFSET + NEC_ADDRESS_LEN,                               // address_end:     end of address
-    NEC_COMMAND_OFFSET,                                                 // command_offset:  command offset
-    NEC_COMMAND_OFFSET + NEC_COMMAND_LEN,                               // command_end:     end of command
-    NEC_COMPLETE_DATA_LEN,                                              // complete_len:    complete length of frame
-    NEC_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
-    NEC_LSB,                                                            // lsb_first:       flag: LSB first
-    NEC_FLAGS                                                           // flags:           some flags
-};
-
-static const PROGMEM IRMP_PARAMETER nec_rep_param =
-{
-    IRMP_NEC_PROTOCOL,                                                  // protocol:        ir protocol
-    NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum length of pulse with bit value 1
-    NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum length of pulse with bit value 1
-    NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum length of pause with bit value 1
-    NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum length of pause with bit value 1
-    NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum length of pulse with bit value 0
-    NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum length of pulse with bit value 0
-    NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum length of pause with bit value 0
-    NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum length of pause with bit value 0
-    0,                                                                  // address_offset:  address offset
-    0,                                                                  // address_end:     end of address
-    0,                                                                  // command_offset:  command offset
-    0,                                                                  // command_end:     end of command
-    0,                                                                  // complete_len:    complete length of frame
-    NEC_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
-    NEC_LSB,                                                            // lsb_first:       flag: LSB first
-    NEC_FLAGS                                                           // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_NEC42_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER nec42_param =
-{
-    IRMP_NEC42_PROTOCOL,                                                // protocol:        ir protocol
-    NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum length of pulse with bit value 1
-    NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum length of pulse with bit value 1
-    NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum length of pause with bit value 1
-    NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum length of pause with bit value 1
-    NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum length of pulse with bit value 0
-    NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum length of pulse with bit value 0
-    NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum length of pause with bit value 0
-    NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum length of pause with bit value 0
-    NEC42_ADDRESS_OFFSET,                                               // address_offset:  address offset
-    NEC42_ADDRESS_OFFSET + NEC42_ADDRESS_LEN,                           // address_end:     end of address
-    NEC42_COMMAND_OFFSET,                                               // command_offset:  command offset
-    NEC42_COMMAND_OFFSET + NEC42_COMMAND_LEN,                           // command_end:     end of command
-    NEC42_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame
-    NEC_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
-    NEC_LSB,                                                            // lsb_first:       flag: LSB first
-    NEC_FLAGS                                                           // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER samsung_param =
-{
-    IRMP_SAMSUNG_PROTOCOL,                                              // protocol:        ir protocol
-    SAMSUNG_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum length of pulse with bit value 1
-    SAMSUNG_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum length of pulse with bit value 1
-    SAMSUNG_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum length of pause with bit value 1
-    SAMSUNG_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum length of pause with bit value 1
-    SAMSUNG_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum length of pulse with bit value 0
-    SAMSUNG_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum length of pulse with bit value 0
-    SAMSUNG_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum length of pause with bit value 0
-    SAMSUNG_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum length of pause with bit value 0
-    SAMSUNG_ADDRESS_OFFSET,                                             // address_offset:  address offset
-    SAMSUNG_ADDRESS_OFFSET + SAMSUNG_ADDRESS_LEN,                       // address_end:     end of address
-    SAMSUNG_COMMAND_OFFSET,                                             // command_offset:  command offset
-    SAMSUNG_COMMAND_OFFSET + SAMSUNG_COMMAND_LEN,                       // command_end:     end of command
-    SAMSUNG_COMPLETE_DATA_LEN,                                          // complete_len:    complete length of frame
-    SAMSUNG_STOP_BIT,                                                   // stop_bit:        flag: frame has stop bit
-    SAMSUNG_LSB,                                                        // lsb_first:       flag: LSB first
-    SAMSUNG_FLAGS                                                       // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER matsushita_param =
-{
-    IRMP_MATSUSHITA_PROTOCOL,                                           // protocol:        ir protocol
-    MATSUSHITA_PULSE_LEN_MIN,                                           // pulse_1_len_min: minimum length of pulse with bit value 1
-    MATSUSHITA_PULSE_LEN_MAX,                                           // pulse_1_len_max: maximum length of pulse with bit value 1
-    MATSUSHITA_1_PAUSE_LEN_MIN,                                         // pause_1_len_min: minimum length of pause with bit value 1
-    MATSUSHITA_1_PAUSE_LEN_MAX,                                         // pause_1_len_max: maximum length of pause with bit value 1
-    MATSUSHITA_PULSE_LEN_MIN,                                           // pulse_0_len_min: minimum length of pulse with bit value 0
-    MATSUSHITA_PULSE_LEN_MAX,                                           // pulse_0_len_max: maximum length of pulse with bit value 0
-    MATSUSHITA_0_PAUSE_LEN_MIN,                                         // pause_0_len_min: minimum length of pause with bit value 0
-    MATSUSHITA_0_PAUSE_LEN_MAX,                                         // pause_0_len_max: maximum length of pause with bit value 0
-    MATSUSHITA_ADDRESS_OFFSET,                                          // address_offset:  address offset
-    MATSUSHITA_ADDRESS_OFFSET + MATSUSHITA_ADDRESS_LEN,                 // address_end:     end of address
-    MATSUSHITA_COMMAND_OFFSET,                                          // command_offset:  command offset
-    MATSUSHITA_COMMAND_OFFSET + MATSUSHITA_COMMAND_LEN,                 // command_end:     end of command
-    MATSUSHITA_COMPLETE_DATA_LEN,                                       // complete_len:    complete length of frame
-    MATSUSHITA_STOP_BIT,                                                // stop_bit:        flag: frame has stop bit
-    MATSUSHITA_LSB,                                                     // lsb_first:       flag: LSB first
-    MATSUSHITA_FLAGS                                                    // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER kaseikyo_param =
-{
-    IRMP_KASEIKYO_PROTOCOL,                                             // protocol:        ir protocol
-    KASEIKYO_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum length of pulse with bit value 1
-    KASEIKYO_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum length of pulse with bit value 1
-    KASEIKYO_1_PAUSE_LEN_MIN,                                           // pause_1_len_min: minimum length of pause with bit value 1
-    KASEIKYO_1_PAUSE_LEN_MAX,                                           // pause_1_len_max: maximum length of pause with bit value 1
-    KASEIKYO_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum length of pulse with bit value 0
-    KASEIKYO_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum length of pulse with bit value 0
-    KASEIKYO_0_PAUSE_LEN_MIN,                                           // pause_0_len_min: minimum length of pause with bit value 0
-    KASEIKYO_0_PAUSE_LEN_MAX,                                           // pause_0_len_max: maximum length of pause with bit value 0
-    KASEIKYO_ADDRESS_OFFSET,                                            // address_offset:  address offset
-    KASEIKYO_ADDRESS_OFFSET + KASEIKYO_ADDRESS_LEN,                     // address_end:     end of address
-    KASEIKYO_COMMAND_OFFSET,                                            // command_offset:  command offset
-    KASEIKYO_COMMAND_OFFSET + KASEIKYO_COMMAND_LEN,                     // command_end:     end of command
-    KASEIKYO_COMPLETE_DATA_LEN,                                         // complete_len:    complete length of frame
-    KASEIKYO_STOP_BIT,                                                  // stop_bit:        flag: frame has stop bit
-    KASEIKYO_LSB,                                                       // lsb_first:       flag: LSB first
-    KASEIKYO_FLAGS                                                      // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_RECS80_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER recs80_param =
-{
-    IRMP_RECS80_PROTOCOL,                                               // protocol:        ir protocol
-    RECS80_PULSE_LEN_MIN,                                               // pulse_1_len_min: minimum length of pulse with bit value 1
-    RECS80_PULSE_LEN_MAX,                                               // pulse_1_len_max: maximum length of pulse with bit value 1
-    RECS80_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum length of pause with bit value 1
-    RECS80_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum length of pause with bit value 1
-    RECS80_PULSE_LEN_MIN,                                               // pulse_0_len_min: minimum length of pulse with bit value 0
-    RECS80_PULSE_LEN_MAX,                                               // pulse_0_len_max: maximum length of pulse with bit value 0
-    RECS80_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum length of pause with bit value 0
-    RECS80_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum length of pause with bit value 0
-    RECS80_ADDRESS_OFFSET,                                              // address_offset:  address offset
-    RECS80_ADDRESS_OFFSET + RECS80_ADDRESS_LEN,                         // address_end:     end of address
-    RECS80_COMMAND_OFFSET,                                              // command_offset:  command offset
-    RECS80_COMMAND_OFFSET + RECS80_COMMAND_LEN,                         // command_end:     end of command
-    RECS80_COMPLETE_DATA_LEN,                                           // complete_len:    complete length of frame
-    RECS80_STOP_BIT,                                                    // stop_bit:        flag: frame has stop bit
-    RECS80_LSB,                                                         // lsb_first:       flag: LSB first
-    RECS80_FLAGS                                                        // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER rc5_param =
-{
-    IRMP_RC5_PROTOCOL,                                                  // protocol:        ir protocol
-    RC5_BIT_LEN_MIN,                                                    // pulse_1_len_min: here: minimum length of short pulse
-    RC5_BIT_LEN_MAX,                                                    // pulse_1_len_max: here: maximum length of short pulse
-    RC5_BIT_LEN_MIN,                                                    // pause_1_len_min: here: minimum length of short pause
-    RC5_BIT_LEN_MAX,                                                    // pause_1_len_max: here: maximum length of short pause
-    0,                                                                  // pulse_0_len_min: here: not used
-    0,                                                                  // pulse_0_len_max: here: not used
-    0,                                                                  // pause_0_len_min: here: not used
-    0,                                                                  // pause_0_len_max: here: not used
-    RC5_ADDRESS_OFFSET,                                                 // address_offset:  address offset
-    RC5_ADDRESS_OFFSET + RC5_ADDRESS_LEN,                               // address_end:     end of address
-    RC5_COMMAND_OFFSET,                                                 // command_offset:  command offset
-    RC5_COMMAND_OFFSET + RC5_COMMAND_LEN,                               // command_end:     end of command
-    RC5_COMPLETE_DATA_LEN,                                              // complete_len:    complete length of frame
-    RC5_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
-    RC5_LSB,                                                            // lsb_first:       flag: LSB first
-    RC5_FLAGS                                                           // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_DENON_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER denon_param =
-{
-    IRMP_DENON_PROTOCOL,                                                // protocol:        ir protocol
-    DENON_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum length of pulse with bit value 1
-    DENON_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum length of pulse with bit value 1
-    DENON_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum length of pause with bit value 1
-    DENON_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum length of pause with bit value 1
-    DENON_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum length of pulse with bit value 0
-    DENON_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum length of pulse with bit value 0
-    DENON_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum length of pause with bit value 0
-    DENON_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum length of pause with bit value 0
-    DENON_ADDRESS_OFFSET,                                               // address_offset:  address offset
-    DENON_ADDRESS_OFFSET + DENON_ADDRESS_LEN,                           // address_end:     end of address
-    DENON_COMMAND_OFFSET,                                               // command_offset:  command offset
-    DENON_COMMAND_OFFSET + DENON_COMMAND_LEN,                           // command_end:     end of command
-    DENON_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame
-    DENON_STOP_BIT,                                                     // stop_bit:        flag: frame has stop bit
-    DENON_LSB,                                                          // lsb_first:       flag: LSB first
-    DENON_FLAGS                                                         // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_RC6_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER rc6_param =
-{
-    IRMP_RC6_PROTOCOL,                                                  // protocol:        ir protocol
-
-    RC6_BIT_PULSE_LEN_MIN,                                              // pulse_1_len_min: here: minimum length of short pulse
-    RC6_BIT_PULSE_LEN_MAX,                                              // pulse_1_len_max: here: maximum length of short pulse
-    RC6_BIT_PAUSE_LEN_MIN,                                              // pause_1_len_min: here: minimum length of short pause
-    RC6_BIT_PAUSE_LEN_MAX,                                              // pause_1_len_max: here: maximum length of short pause
-    0,                                                                  // pulse_0_len_min: here: not used
-    0,                                                                  // pulse_0_len_max: here: not used
-    0,                                                                  // pause_0_len_min: here: not used
-    0,                                                                  // pause_0_len_max: here: not used
-    RC6_ADDRESS_OFFSET,                                                 // address_offset:  address offset
-    RC6_ADDRESS_OFFSET + RC6_ADDRESS_LEN,                               // address_end:     end of address
-    RC6_COMMAND_OFFSET,                                                 // command_offset:  command offset
-    RC6_COMMAND_OFFSET + RC6_COMMAND_LEN,                               // command_end:     end of command
-    RC6_COMPLETE_DATA_LEN_SHORT,                                        // complete_len:    complete length of frame
-    RC6_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
-    RC6_LSB,                                                            // lsb_first:       flag: LSB first
-    RC6_FLAGS                                                           // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER recs80ext_param =
-{
-    IRMP_RECS80EXT_PROTOCOL,                                            // protocol:        ir protocol
-    RECS80EXT_PULSE_LEN_MIN,                                            // pulse_1_len_min: minimum length of pulse with bit value 1
-    RECS80EXT_PULSE_LEN_MAX,                                            // pulse_1_len_max: maximum length of pulse with bit value 1
-    RECS80EXT_1_PAUSE_LEN_MIN,                                          // pause_1_len_min: minimum length of pause with bit value 1
-    RECS80EXT_1_PAUSE_LEN_MAX,                                          // pause_1_len_max: maximum length of pause with bit value 1
-    RECS80EXT_PULSE_LEN_MIN,                                            // pulse_0_len_min: minimum length of pulse with bit value 0
-    RECS80EXT_PULSE_LEN_MAX,                                            // pulse_0_len_max: maximum length of pulse with bit value 0
-    RECS80EXT_0_PAUSE_LEN_MIN,                                          // pause_0_len_min: minimum length of pause with bit value 0
-    RECS80EXT_0_PAUSE_LEN_MAX,                                          // pause_0_len_max: maximum length of pause with bit value 0
-    RECS80EXT_ADDRESS_OFFSET,                                           // address_offset:  address offset
-    RECS80EXT_ADDRESS_OFFSET + RECS80EXT_ADDRESS_LEN,                   // address_end:     end of address
-    RECS80EXT_COMMAND_OFFSET,                                           // command_offset:  command offset
-    RECS80EXT_COMMAND_OFFSET + RECS80EXT_COMMAND_LEN,                   // command_end:     end of command
-    RECS80EXT_COMPLETE_DATA_LEN,                                        // complete_len:    complete length of frame
-    RECS80EXT_STOP_BIT,                                                 // stop_bit:        flag: frame has stop bit
-    RECS80EXT_LSB,                                                      // lsb_first:       flag: LSB first
-    RECS80EXT_FLAGS                                                     // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER nubert_param =
-{
-    IRMP_NUBERT_PROTOCOL,                                               // protocol:        ir protocol
-    NUBERT_1_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum length of pulse with bit value 1
-    NUBERT_1_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum length of pulse with bit value 1
-    NUBERT_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum length of pause with bit value 1
-    NUBERT_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum length of pause with bit value 1
-    NUBERT_0_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum length of pulse with bit value 0
-    NUBERT_0_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum length of pulse with bit value 0
-    NUBERT_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum length of pause with bit value 0
-    NUBERT_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum length of pause with bit value 0
-    NUBERT_ADDRESS_OFFSET,                                              // address_offset:  address offset
-    NUBERT_ADDRESS_OFFSET + NUBERT_ADDRESS_LEN,                         // address_end:     end of address
-    NUBERT_COMMAND_OFFSET,                                              // command_offset:  command offset
-    NUBERT_COMMAND_OFFSET + NUBERT_COMMAND_LEN,                         // command_end:     end of command
-    NUBERT_COMPLETE_DATA_LEN,                                           // complete_len:    complete length of frame
-    NUBERT_STOP_BIT,                                                    // stop_bit:        flag: frame has stop bit
-    NUBERT_LSB,                                                         // lsb_first:       flag: LSB first
-    NUBERT_FLAGS                                                        // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER bang_olufsen_param =
-{
-    IRMP_BANG_OLUFSEN_PROTOCOL,                                         // protocol:        ir protocol
-    BANG_OLUFSEN_PULSE_LEN_MIN,                                         // pulse_1_len_min: minimum length of pulse with bit value 1
-    BANG_OLUFSEN_PULSE_LEN_MAX,                                         // pulse_1_len_max: maximum length of pulse with bit value 1
-    BANG_OLUFSEN_1_PAUSE_LEN_MIN,                                       // pause_1_len_min: minimum length of pause with bit value 1
-    BANG_OLUFSEN_1_PAUSE_LEN_MAX,                                       // pause_1_len_max: maximum length of pause with bit value 1
-    BANG_OLUFSEN_PULSE_LEN_MIN,                                         // pulse_0_len_min: minimum length of pulse with bit value 0
-    BANG_OLUFSEN_PULSE_LEN_MAX,                                         // pulse_0_len_max: maximum length of pulse with bit value 0
-    BANG_OLUFSEN_0_PAUSE_LEN_MIN,                                       // pause_0_len_min: minimum length of pause with bit value 0
-    BANG_OLUFSEN_0_PAUSE_LEN_MAX,                                       // pause_0_len_max: maximum length of pause with bit value 0
-    BANG_OLUFSEN_ADDRESS_OFFSET,                                        // address_offset:  address offset
-    BANG_OLUFSEN_ADDRESS_OFFSET + BANG_OLUFSEN_ADDRESS_LEN,             // address_end:     end of address
-    BANG_OLUFSEN_COMMAND_OFFSET,                                        // command_offset:  command offset
-    BANG_OLUFSEN_COMMAND_OFFSET + BANG_OLUFSEN_COMMAND_LEN,             // command_end:     end of command
-    BANG_OLUFSEN_COMPLETE_DATA_LEN,                                     // complete_len:    complete length of frame
-    BANG_OLUFSEN_STOP_BIT,                                              // stop_bit:        flag: frame has stop bit
-    BANG_OLUFSEN_LSB,                                                   // lsb_first:       flag: LSB first
-    BANG_OLUFSEN_FLAGS                                                  // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
-
-static uint8_t first_bit;
-
-static const PROGMEM IRMP_PARAMETER grundig_param =
-{
-    IRMP_GRUNDIG_PROTOCOL,                                              // protocol:        ir protocol
-
-    GRUNDIG_NOKIA_IR60_BIT_LEN_MIN,                                     // pulse_1_len_min: here: minimum length of short pulse
-    GRUNDIG_NOKIA_IR60_BIT_LEN_MAX,                                     // pulse_1_len_max: here: maximum length of short pulse
-    GRUNDIG_NOKIA_IR60_BIT_LEN_MIN,                                     // pause_1_len_min: here: minimum length of short pause
-    GRUNDIG_NOKIA_IR60_BIT_LEN_MAX,                                     // pause_1_len_max: here: maximum length of short pause
-    0,                                                                  // pulse_0_len_min: here: not used
-    0,                                                                  // pulse_0_len_max: here: not used
-    0,                                                                  // pause_0_len_min: here: not used
-    0,                                                                  // pause_0_len_max: here: not used
-    GRUNDIG_ADDRESS_OFFSET,                                             // address_offset:  address offset
-    GRUNDIG_ADDRESS_OFFSET + GRUNDIG_ADDRESS_LEN,                       // address_end:     end of address
-    GRUNDIG_COMMAND_OFFSET,                                             // command_offset:  command offset
-    GRUNDIG_COMMAND_OFFSET + GRUNDIG_COMMAND_LEN + 1,                   // command_end:     end of command (USE 1 bit MORE to STORE NOKIA DATA!)
-    NOKIA_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame, here: NOKIA instead of GRUNDIG!
-    GRUNDIG_NOKIA_IR60_STOP_BIT,                                        // stop_bit:        flag: frame has stop bit
-    GRUNDIG_NOKIA_IR60_LSB,                                             // lsb_first:       flag: LSB first
-    GRUNDIG_NOKIA_IR60_FLAGS                                            // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER ruwido_param =
-{
-    IRMP_RUWIDO_PROTOCOL,                                               // protocol:        ir protocol
-    SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN,                                // pulse_1_len_min: here: minimum length of short pulse
-    SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX,                                // pulse_1_len_max: here: maximum length of short pulse
-    SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN,                                // pause_1_len_min: here: minimum length of short pause
-    SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX,                                // pause_1_len_max: here: maximum length of short pause
-    0,                                                                  // pulse_0_len_min: here: not used
-    0,                                                                  // pulse_0_len_max: here: not used
-    0,                                                                  // pause_0_len_min: here: not used
-    0,                                                                  // pause_0_len_max: here: not used
-    RUWIDO_ADDRESS_OFFSET,                                              // address_offset:  address offset
-    RUWIDO_ADDRESS_OFFSET + RUWIDO_ADDRESS_LEN,                         // address_end:     end of address
-    RUWIDO_COMMAND_OFFSET,                                              // command_offset:  command offset
-    RUWIDO_COMMAND_OFFSET + RUWIDO_COMMAND_LEN,                         // command_end:     end of command
-    SIEMENS_COMPLETE_DATA_LEN,                                          // complete_len:    complete length of frame, here: SIEMENS instead of RUWIDO!
-    SIEMENS_OR_RUWIDO_STOP_BIT,                                         // stop_bit:        flag: frame has stop bit
-    SIEMENS_OR_RUWIDO_LSB,                                              // lsb_first:       flag: LSB first
-    SIEMENS_OR_RUWIDO_FLAGS                                             // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_GRUNDIG2_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER grundig2_param =
-{
-    IRMP_GRUNDIG2_PROTOCOL,                                             // protocol:        ir protocol
-    GRUNDIG2_BIT_PULSE_LEN_MIN,                                         // pulse_1_len_min: here: minimum length of short pulse
-    GRUNDIG2_BIT_PULSE_LEN_MAX,                                         // pulse_1_len_max: here: maximum length of short pulse
-    GRUNDIG2_BIT_PAUSE_LEN_MIN,                                         // pause_1_len_min: here: minimum length of short pause
-    GRUNDIG2_BIT_PAUSE_LEN_MAX,                                         // pause_1_len_max: here: maximum length of short pause
-    0,                                                                  // pulse_0_len_min: here: not used
-    0,                                                                  // pulse_0_len_max: here: not used
-    0,                                                                  // pause_0_len_min: here: not used
-    0,                                                                  // pause_0_len_max: here: not used
-    GRUNDIG2_ADDRESS_OFFSET,                                            // address_offset:  address offset
-    GRUNDIG2_ADDRESS_OFFSET + GRUNDIG2_ADDRESS_LEN,                     // address_end:     end of address
-    GRUNDIG2_COMMAND_OFFSET,                                            // command_offset:  command offset
-    GRUNDIG2_COMMAND_OFFSET + GRUNDIG2_COMMAND_LEN,                     // command_end:     end of command
-    GRUNDIG2_COMPLETE_DATA_LEN,                                         // complete_len:    complete length of frame
-    GRUNDIG2_STOP_BIT,                                                  // stop_bit:        flag: frame has stop bit
-    GRUNDIG2_LSB,                                                       // lsb_first:       flag: LSB first
-    GRUNDIG2_FLAGS                                                      // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_FDC_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER fdc_param =
-{
-    IRMP_FDC_PROTOCOL,                                                  // protocol:        ir protocol
-    FDC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum length of pulse with bit value 1
-    FDC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum length of pulse with bit value 1
-    FDC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum length of pause with bit value 1
-    FDC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum length of pause with bit value 1
-    FDC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum length of pulse with bit value 0
-    FDC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum length of pulse with bit value 0
-    FDC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum length of pause with bit value 0
-    FDC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum length of pause with bit value 0
-    FDC_ADDRESS_OFFSET,                                                 // address_offset:  address offset
-    FDC_ADDRESS_OFFSET + FDC_ADDRESS_LEN,                               // address_end:     end of address
-    FDC_COMMAND_OFFSET,                                                 // command_offset:  command offset
-    FDC_COMMAND_OFFSET + FDC_COMMAND_LEN,                               // command_end:     end of command
-    FDC_COMPLETE_DATA_LEN,                                              // complete_len:    complete length of frame
-    FDC_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
-    FDC_LSB,                                                            // lsb_first:       flag: LSB first
-    FDC_FLAGS                                                           // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER rccar_param =
-{
-    IRMP_RCCAR_PROTOCOL,                                                // protocol:        ir protocol
-    RCCAR_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum length of pulse with bit value 1
-    RCCAR_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum length of pulse with bit value 1
-    RCCAR_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum length of pause with bit value 1
-    RCCAR_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum length of pause with bit value 1
-    RCCAR_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum length of pulse with bit value 0
-    RCCAR_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum length of pulse with bit value 0
-    RCCAR_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum length of pause with bit value 0
-    RCCAR_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum length of pause with bit value 0
-    RCCAR_ADDRESS_OFFSET,                                               // address_offset:  address offset
-    RCCAR_ADDRESS_OFFSET + RCCAR_ADDRESS_LEN,                           // address_end:     end of address
-    RCCAR_COMMAND_OFFSET,                                               // command_offset:  command offset
-    RCCAR_COMMAND_OFFSET + RCCAR_COMMAND_LEN,                           // command_end:     end of command
-    RCCAR_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame
-    RCCAR_STOP_BIT,                                                     // stop_bit:        flag: frame has stop bit
-    RCCAR_LSB,                                                          // lsb_first:       flag: LSB first
-    RCCAR_FLAGS                                                         // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_NIKON_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER nikon_param =
-{
-    IRMP_NIKON_PROTOCOL,                                                // protocol:        ir protocol
-    NIKON_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum length of pulse with bit value 1
-    NIKON_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum length of pulse with bit value 1
-    NIKON_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum length of pause with bit value 1
-    NIKON_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum length of pause with bit value 1
-    NIKON_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum length of pulse with bit value 0
-    NIKON_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum length of pulse with bit value 0
-    NIKON_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum length of pause with bit value 0
-    NIKON_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum length of pause with bit value 0
-    NIKON_ADDRESS_OFFSET,                                               // address_offset:  address offset
-    NIKON_ADDRESS_OFFSET + NIKON_ADDRESS_LEN,                           // address_end:     end of address
-    NIKON_COMMAND_OFFSET,                                               // command_offset:  command offset
-    NIKON_COMMAND_OFFSET + NIKON_COMMAND_LEN,                           // command_end:     end of command
-    NIKON_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame
-    NIKON_STOP_BIT,                                                     // stop_bit:        flag: frame has stop bit
-    NIKON_LSB,                                                          // lsb_first:       flag: LSB first
-    NIKON_FLAGS                                                         // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER kathrein_param =
-{
-    IRMP_KATHREIN_PROTOCOL,                                             // protocol:        ir protocol
-    KATHREIN_1_PULSE_LEN_MIN,                                           // pulse_1_len_min: minimum length of pulse with bit value 1
-    KATHREIN_1_PULSE_LEN_MAX,                                           // pulse_1_len_max: maximum length of pulse with bit value 1
-    KATHREIN_1_PAUSE_LEN_MIN,                                           // pause_1_len_min: minimum length of pause with bit value 1
-    KATHREIN_1_PAUSE_LEN_MAX,                                           // pause_1_len_max: maximum length of pause with bit value 1
-    KATHREIN_0_PULSE_LEN_MIN,                                           // pulse_0_len_min: minimum length of pulse with bit value 0
-    KATHREIN_0_PULSE_LEN_MAX,                                           // pulse_0_len_max: maximum length of pulse with bit value 0
-    KATHREIN_0_PAUSE_LEN_MIN,                                           // pause_0_len_min: minimum length of pause with bit value 0
-    KATHREIN_0_PAUSE_LEN_MAX,                                           // pause_0_len_max: maximum length of pause with bit value 0
-    KATHREIN_ADDRESS_OFFSET,                                            // address_offset:  address offset
-    KATHREIN_ADDRESS_OFFSET + KATHREIN_ADDRESS_LEN,                     // address_end:     end of address
-    KATHREIN_COMMAND_OFFSET,                                            // command_offset:  command offset
-    KATHREIN_COMMAND_OFFSET + KATHREIN_COMMAND_LEN,                     // command_end:     end of command
-    KATHREIN_COMPLETE_DATA_LEN,                                         // complete_len:    complete length of frame
-    KATHREIN_STOP_BIT,                                                  // stop_bit:        flag: frame has stop bit
-    KATHREIN_LSB,                                                       // lsb_first:       flag: LSB first
-    KATHREIN_FLAGS                                                      // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER netbox_param =
-{
-    IRMP_NETBOX_PROTOCOL,                                               // protocol:        ir protocol
-    NETBOX_PULSE_LEN,                                                   // pulse_1_len_min: minimum length of pulse with bit value 1, here: exact value
-    NETBOX_PULSE_REST_LEN,                                              // pulse_1_len_max: maximum length of pulse with bit value 1, here: rest value
-    NETBOX_PAUSE_LEN,                                                   // pause_1_len_min: minimum length of pause with bit value 1, here: exact value
-    NETBOX_PAUSE_REST_LEN,                                              // pause_1_len_max: maximum length of pause with bit value 1, here: rest value
-    NETBOX_PULSE_LEN,                                                   // pulse_0_len_min: minimum length of pulse with bit value 0, here: exact value
-    NETBOX_PULSE_REST_LEN,                                              // pulse_0_len_max: maximum length of pulse with bit value 0, here: rest value
-    NETBOX_PAUSE_LEN,                                                   // pause_0_len_min: minimum length of pause with bit value 0, here: exact value
-    NETBOX_PAUSE_REST_LEN,                                              // pause_0_len_max: maximum length of pause with bit value 0, here: rest value
-    NETBOX_ADDRESS_OFFSET,                                              // address_offset:  address offset
-    NETBOX_ADDRESS_OFFSET + NETBOX_ADDRESS_LEN,                         // address_end:     end of address
-    NETBOX_COMMAND_OFFSET,                                              // command_offset:  command offset
-    NETBOX_COMMAND_OFFSET + NETBOX_COMMAND_LEN,                         // command_end:     end of command
-    NETBOX_COMPLETE_DATA_LEN,                                           // complete_len:    complete length of frame
-    NETBOX_STOP_BIT,                                                    // stop_bit:        flag: frame has stop bit
-    NETBOX_LSB,                                                         // lsb_first:       flag: LSB first
-    NETBOX_FLAGS                                                        // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_LEGO_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER lego_param =
-{
-    IRMP_LEGO_PROTOCOL,                                                 // protocol:        ir protocol
-    LEGO_PULSE_LEN_MIN,                                                 // pulse_1_len_min: minimum length of pulse with bit value 1
-    LEGO_PULSE_LEN_MAX,                                                 // pulse_1_len_max: maximum length of pulse with bit value 1
-    LEGO_1_PAUSE_LEN_MIN,                                               // pause_1_len_min: minimum length of pause with bit value 1
-    LEGO_1_PAUSE_LEN_MAX,                                               // pause_1_len_max: maximum length of pause with bit value 1
-    LEGO_PULSE_LEN_MIN,                                                 // pulse_0_len_min: minimum length of pulse with bit value 0
-    LEGO_PULSE_LEN_MAX,                                                 // pulse_0_len_max: maximum length of pulse with bit value 0
-    LEGO_0_PAUSE_LEN_MIN,                                               // pause_0_len_min: minimum length of pause with bit value 0
-    LEGO_0_PAUSE_LEN_MAX,                                               // pause_0_len_max: maximum length of pause with bit value 0
-    LEGO_ADDRESS_OFFSET,                                                // address_offset:  address offset
-    LEGO_ADDRESS_OFFSET + LEGO_ADDRESS_LEN,                             // address_end:     end of address
-    LEGO_COMMAND_OFFSET,                                                // command_offset:  command offset
-    LEGO_COMMAND_OFFSET + LEGO_COMMAND_LEN,                             // command_end:     end of command
-    LEGO_COMPLETE_DATA_LEN,                                             // complete_len:    complete length of frame
-    LEGO_STOP_BIT,                                                      // stop_bit:        flag: frame has stop bit
-    LEGO_LSB,                                                           // lsb_first:       flag: LSB first
-    LEGO_FLAGS                                                          // flags:           some flags
-};
-
-#endif
-
-#if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
-
-static const PROGMEM IRMP_PARAMETER thomson_param =
-{
-    IRMP_THOMSON_PROTOCOL,                                              // protocol:        ir protocol
-    THOMSON_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum length of pulse with bit value 1
-    THOMSON_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum length of pulse with bit value 1
-    THOMSON_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum length of pause with bit value 1
-    THOMSON_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum length of pause with bit value 1
-    THOMSON_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum length of pulse with bit value 0
-    THOMSON_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum length of pulse with bit value 0
-    THOMSON_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum length of pause with bit value 0
-    THOMSON_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum length of pause with bit value 0
-    THOMSON_ADDRESS_OFFSET,                                             // address_offset:  address offset
-    THOMSON_ADDRESS_OFFSET + THOMSON_ADDRESS_LEN,                       // address_end:     end of address
-    THOMSON_COMMAND_OFFSET,                                             // command_offset:  command offset
-    THOMSON_COMMAND_OFFSET + THOMSON_COMMAND_LEN,                       // command_end:     end of command
-    THOMSON_COMPLETE_DATA_LEN,                                          // complete_len:    complete length of frame
-    THOMSON_STOP_BIT,                                                   // stop_bit:        flag: frame has stop bit
-    THOMSON_LSB,                                                        // lsb_first:       flag: LSB first
-    THOMSON_FLAGS                                                       // flags:           some flags
-};
-
-#endif
-
-static uint8_t                              irmp_bit;                   // current bit position
-static IRMP_PARAMETER                       irmp_param;
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
-static IRMP_PARAMETER                       irmp_param2;
-#endif
-
-static volatile uint8_t                     irmp_ir_detected;
-static volatile uint8_t                     irmp_protocol;
-static volatile uint16_t                    irmp_address;
-static volatile uint16_t                    irmp_command;
-static volatile uint16_t                    irmp_id;                    // only used for SAMSUNG protocol
-static volatile uint8_t                     irmp_flags;
-// static volatile uint8_t                     irmp_busy_flag;
-
-#ifdef ANALYZE
-static uint8_t                              IRMP_PIN;
-#endif
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- *  Initialize IRMP decoder
- *  @details  Configures IRMP input pin
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#ifndef ANALYZE
-void
-irmp_init (void)
-{
-#ifndef ARDUINO
-#if !defined(PIC_CCS_COMPILER) && !defined(PIC_C18)                     // only AVR
-    IRMP_PORT &= ~(1<<IRMP_BIT);                                        // deactivate pullup
-    IRMP_DDR &= ~(1<<IRMP_BIT);                                         // set pin to input
-#endif
-
-#if IRMP_LOGGING == 1
-    irmp_uart_init ();
-#endif
-#endif //ARDUINO
-}
-#endif
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- *  Get IRMP data
- *  @details  gets decoded IRMP data
- *  @param    pointer in order to store IRMP data
- *  @return    TRUE: successful, FALSE: failed
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-uint8_t
-irmp_get_data (IRMP_DATA * irmp_data_p)
-{
-    uint8_t   rtc = FALSE;
-
-    if (irmp_ir_detected)
-    {
-        switch (irmp_protocol)
-        {
-#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
-            case IRMP_SAMSUNG_PROTOCOL:
-                if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
-                {
-                    irmp_command &= 0xff;
-                    irmp_command |= irmp_id << 8;
-                    rtc = TRUE;
-                }
-                break;
-#endif
-#if IRMP_SUPPORT_NEC_PROTOCOL == 1
-            case IRMP_NEC_PROTOCOL:
-                if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
-                {
-                    irmp_command &= 0xff;
-                    rtc = TRUE;
-                }
-                else if (irmp_address == 0x87EE)
-                {
-                    ANALYZE_PRINTF ("Switching to APPLE protocol\n");
-                    irmp_protocol = IRMP_APPLE_PROTOCOL;
-                    irmp_address = (irmp_command & 0xFF00) >> 8;
-                    irmp_command &= 0x00FF;
-                    rtc = TRUE;
-                }
-                break;
-#endif
-#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
-            case IRMP_SIEMENS_PROTOCOL:
-            case IRMP_RUWIDO_PROTOCOL:
-                if (((irmp_command >> 1) & 0x0001) == (~irmp_command & 0x0001))
-                {
-                    irmp_command >>= 1;
-                    rtc = TRUE;
-                }
-                break;
-#endif
-#if IRMP_SUPPORT_GRUNDIG2_PROTOCOL == 1
-            case IRMP_GRUNDIG2_PROTOCOL:
-                if (irmp_command & 0x0001)
-                {
-                    irmp_command >>= 1;
-                    rtc = TRUE;
-                }
-                break;
-#endif
-#if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
-            case IRMP_KATHREIN_PROTOCOL:
-                if (irmp_command != 0x0000)
-                {
-                    rtc = TRUE;
-                }
-                break;
-#endif
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1
-            case IRMP_RC5_PROTOCOL:
-                irmp_address &= ~0x20;                              // clear toggle bit
-                rtc = TRUE;
-                break;
-#endif
-#if IRMP_SUPPORT_IR60_PROTOCOL == 1
-            case IRMP_IR60_PROTOCOL:
-                if (irmp_command != 0x007d)                         // 0x007d (== 62<<1 + 1) is start instruction frame
-                {
-                    rtc = TRUE;
-                }
-                break;
-#endif
-#if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
-            case IRMP_RCCAR_PROTOCOL:
-                // frame in irmp_data:
-                // Bit 12 11 10 9  8  7  6  5  4  3  2  1  0
-                //     V  D7 D6 D5 D4 D3 D2 D1 D0 A1 A0 C1 C0   //         10 9  8  7  6  5  4  3  2  1  0
-                irmp_address = (irmp_command & 0x000C) >> 2;    // addr:   0  0  0  0  0  0  0  0  0  A1 A0
-                irmp_command = ((irmp_command & 0x1000) >> 2) | // V-Bit:  V  0  0  0  0  0  0  0  0  0  0
-                               ((irmp_command & 0x0003) << 8) | // C-Bits: 0  C1 C0 0  0  0  0  0  0  0  0
-                               ((irmp_command & 0x0FF0) >> 4);  // D-Bits:          D7 D6 D5 D4 D3 D2 D1 D0
-                rtc = TRUE;                                     // Summe:  V  C1 C0 D7 D6 D5 D4 D3 D2 D1 D0
-                break;
-#endif
-
-#if IRMP_SUPPORT_NETBOX_PROTOCOL == 1                           // squeeze code to 8 bit, upper bit indicates release-key
-            case IRMP_NETBOX_PROTOCOL:
-                if (irmp_command & 0x1000)                      // last bit set?
-                {
-                    if ((irmp_command & 0x1f) == 0x15)          // key pressed: 101 01 (LSB)
-                    {
-                        irmp_command >>= 5;
-                        irmp_command &= 0x7F;
-                        rtc = TRUE;
-                    }
-                    else if ((irmp_command & 0x1f) == 0x10)     // key released: 000 01 (LSB)
-                    {
-                        irmp_command >>= 5;
-                        irmp_command |= 0x80;
-                        rtc = TRUE;
-                    }
-                    else
-                    {
-                        ANALYZE_PRINTF("error NETBOX: bit6/7 must be 0/1\n");
-                    }
-                }
-                else
-                {
-                    ANALYZE_PRINTF("error NETBOX: last bit not set\n");
-                }
-                break;
-#endif
-#if IRMP_SUPPORT_LEGO_PROTOCOL == 1
-            case IRMP_LEGO_PROTOCOL:
-            {
-                uint8_t crc = 0x0F ^ ((irmp_command & 0xF000) >> 12) ^ ((irmp_command & 0x0F00) >> 8) ^ ((irmp_command & 0x00F0) >> 4);
-
-                if ((irmp_command & 0x000F) == crc)
-                {
-                    irmp_command >>= 4;
-                    rtc = TRUE;
-                }
-                else
-                {
-                    ANALYZE_PRINTF ("CRC error in LEGO protocol\n");
-                    rtc = TRUE;
-                }
-                break;
-            }
-#endif
-            default:
-                rtc = TRUE;
-        }
-
-        if (rtc)
-        {
-            irmp_data_p->protocol = irmp_protocol;
-            irmp_data_p->address = irmp_address;
-            irmp_data_p->command = irmp_command;
-            irmp_data_p->flags   = irmp_flags;
-            irmp_command = 0;
-            irmp_address = 0;
-            irmp_flags   = 0;
-        }
-
-        irmp_ir_detected = FALSE;
-    }
-
-    return rtc;
-}
-
-// uint8_t
-// irmp_is_busy (void)
-// {
-//     return irmp_busy_flag;
-// }
-
-#if IRMP_USE_CALLBACK == 1
-void
-irmp_set_callback_ptr (void (*cb)(uint8_t))
-{
-    irmp_callback_ptr = cb;
-}
-#endif // IRMP_USE_CALLBACK == 1
-
-// these statics must not be volatile, because they are only used by irmp_store_bit(), which is called by irmp_ISR()
-static uint16_t irmp_tmp_address;                                                       // ir address
-static uint16_t irmp_tmp_command;                                                       // ir command
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1) || IRMP_SUPPORT_NEC42_PROTOCOL == 1
-static uint16_t irmp_tmp_address2;                                                      // ir address
-static uint16_t irmp_tmp_command2;                                                      // ir command
-#endif
-
-#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
-static uint16_t irmp_tmp_id;                                                            // ir id (only SAMSUNG)
-#endif
-#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
-static uint8_t  xor_check[6];                                                           // check kaseikyo "parity" bits
-static uint8_t  genre2;                                                                 // save genre2 bits here, later copied to MSB in flags
-#endif
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- *  store bit
- *  @details  store bit in temp address or temp command
- *  @param    value to store: 0 or 1
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-// verhindert, dass irmp_store_bit() inline compiliert wird:
-// static void irmp_store_bit (uint8_t) __attribute__ ((noinline));
-
-static void
-irmp_store_bit (uint8_t value)
-{
-#if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
-    if (irmp_bit == 0 && irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL)
-    {
-        first_bit = value;
-    }
-    else
-#endif
-
-    if (irmp_bit >= irmp_param.address_offset && irmp_bit < irmp_param.address_end)
-    {
-        if (irmp_param.lsb_first)
-        {
-            irmp_tmp_address |= (((uint16_t) (value)) << (irmp_bit - irmp_param.address_offset));   // CV wants cast
-        }
-        else
-        {
-            irmp_tmp_address <<= 1;
-            irmp_tmp_address |= value;
-        }
-    }
-    else if (irmp_bit >= irmp_param.command_offset && irmp_bit < irmp_param.command_end)
-    {
-        if (irmp_param.lsb_first)
-        {
-            irmp_tmp_command |= (((uint16_t) (value)) << (irmp_bit - irmp_param.command_offset));   // CV wants cast
-        }
-        else
-        {
-            irmp_tmp_command <<= 1;
-            irmp_tmp_command |= value;
-        }
-    }
-
-#if IRMP_SUPPORT_NEC42_PROTOCOL == 1
-    else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && irmp_bit >= 13 && irmp_bit < 26)
-    {
-        irmp_tmp_address2 |= (((uint16_t) (value)) << (irmp_bit - 13));                             // CV wants cast
-    }
-#endif
-
-#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
-    else if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit >= SAMSUNG_ID_OFFSET && irmp_bit < SAMSUNG_ID_OFFSET + SAMSUNG_ID_LEN)
-    {
-        irmp_tmp_id |= (((uint16_t) (value)) << (irmp_bit - SAMSUNG_ID_OFFSET));                    // store with LSB first
-    }
-#endif
-
-#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
-    else if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
-    {
-        if (irmp_bit >= 20 && irmp_bit < 24)
-        {
-            irmp_tmp_command |= (((uint16_t) (value)) << (irmp_bit - 8));       // store 4 system bits (genre 1) in upper nibble with LSB first
-        }
-        else if (irmp_bit >= 24 && irmp_bit < 28)
-        {
-            genre2 |= (((uint8_t) (value)) << (irmp_bit - 20));                 // store 4 system bits (genre 2) in upper nibble with LSB first
-        }
-
-        if (irmp_bit < KASEIKYO_COMPLETE_DATA_LEN)
-        {
-            if (value)
-            {
-                xor_check[irmp_bit / 8] |= 1 << (irmp_bit % 8);
-            }
-            else
-            {
-                xor_check[irmp_bit / 8] &= ~(1 << (irmp_bit % 8));
-            }
-        }
-    }
-#endif
-
-    irmp_bit++;
-}
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- *  store bit
- *  @details  store bit in temp address or temp command
- *  @param    value to store: 0 or 1
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
-static void
-irmp_store_bit2 (uint8_t value)
-{
-    uint8_t irmp_bit2;
-
-    if (irmp_param.protocol)
-    {
-        irmp_bit2 = irmp_bit - 2;
-    }
-    else
-    {
-        irmp_bit2 = irmp_bit - 1;
-    }
-
-    if (irmp_bit2 >= irmp_param2.address_offset && irmp_bit2 < irmp_param2.address_end)
-    {
-        irmp_tmp_address2 |= (((uint16_t) (value)) << (irmp_bit2 - irmp_param2.address_offset));   // CV wants cast
-    }
-    else if (irmp_bit2 >= irmp_param2.command_offset && irmp_bit2 < irmp_param2.command_end)
-    {
-        irmp_tmp_command2 |= (((uint16_t) (value)) << (irmp_bit2 - irmp_param2.command_offset));   // CV wants cast
-    }
-}
-#endif // IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- *  ISR routine
- *  @details  ISR routine, called 10000 times per second
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-uint8_t
-irmp_ISR (uint8_t x42)
-{
-    static uint8_t      irmp_start_bit_detected;                                // flag: start bit detected
-    static uint8_t      wait_for_space;                                         // flag: wait for data bit space
-    static uint8_t      wait_for_start_space;                                   // flag: wait for start bit space
-    static uint8_t      irmp_pulse_time;                                        // count bit time for pulse
-    static PAUSE_LEN    irmp_pause_time;                                        // count bit time for pause
-    static uint16_t     last_irmp_address = 0xFFFF;                             // save last irmp address to recognize key repetition
-    static uint16_t     last_irmp_command = 0xFFFF;                             // save last irmp command to recognize key repetition
-    static uint16_t     repetition_len;                                         // SIRCS repeats frame 2-5 times with 45 ms pause
-    static uint8_t      repetition_frame_number;
-#if IRMP_SUPPORT_DENON_PROTOCOL == 1
-    static uint16_t     last_irmp_denon_command;                                // save last irmp command to recognize DENON frame repetition
-#endif
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1
-    static uint8_t      rc5_cmd_bit6;                                           // bit 6 of RC5 command is the inverted 2nd start bit
-#endif
-#if IRMP_SUPPORT_MANCHESTER == 1
-    static PAUSE_LEN    last_pause;                                             // last pause value
-#endif
-#if IRMP_SUPPORT_MANCHESTER == 1 || IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
-    static uint8_t      last_value;                                             // last bit value
-#endif
-    uint8_t             irmp_input;                                             // input value
-
-#ifdef ANALYZE
-    time_counter++;
-#endif
-
-    irmp_input = input(x42);
-
-#if IRMP_USE_CALLBACK == 1
-    if (irmp_callback_ptr)
-    {
-        static uint8_t last_inverted_input;
-
-        if (last_inverted_input != !irmp_input)
-        {
-            (*irmp_callback_ptr) (! irmp_input);
-            last_inverted_input = !irmp_input;
-        }
-    }
-#endif // IRMP_USE_CALLBACK == 1
-
-    irmp_log(irmp_input);                                                       // log ir signal, if IRMP_LOGGING defined
-
-    if (! irmp_ir_detected)                                                     // ir code already detected?
-    {                                                                           // no...
-        if (! irmp_start_bit_detected)                                          // start bit detected?
-        {                                                                       // no...
-            if (! irmp_input)                                                   // receiving burst?
-            {                                                                   // yes...
-//              irmp_busy_flag = TRUE;
-#ifdef ANALYZE
-                if (! irmp_pulse_time)
-                {
-                    ANALYZE_PRINTF("%8.3fms [starting pulse]\n", (double) (time_counter * 1000) / F_INTERRUPTS);
-                }
-#endif
-                irmp_pulse_time++;                                              // increment counter
-            }
-            else
-            {                                                                   // no...
-                if (irmp_pulse_time)                                            // it's dark....
-                {                                                               // set flags for counting the time of darkness...
-                    irmp_start_bit_detected = 1;
-                    wait_for_start_space    = 1;
-                    wait_for_space          = 0;
-                    irmp_tmp_command        = 0;
-                    irmp_tmp_address        = 0;
-#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
-                    genre2                  = 0;
-#endif
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1) || IRMP_SUPPORT_NEC42_PROTOCOL == 1
-                    irmp_tmp_command2       = 0;
-                    irmp_tmp_address2       = 0;
-#endif
-
-                    irmp_bit                = 0xff;
-                    irmp_pause_time         = 1;                                // 1st pause: set to 1, not to 0!
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1
-                    rc5_cmd_bit6            = 0;                                // fm 2010-03-07: bugfix: reset it after incomplete RC5 frame!
-#endif
-                }
-                else
-                {
-                    if (repetition_len < 0xFFFF)                                // avoid overflow of counter
-                    {
-                        repetition_len++;
-                    }
-                }
-            }
-        }
-        else
-        {
-            if (wait_for_start_space)                                           // we have received start bit...
-            {                                                                   // ...and are counting the time of darkness
-                if (irmp_input)                                                 // still dark?
-                {                                                               // yes
-                    irmp_pause_time++;                                          // increment counter
-
-#if IRMP_SUPPORT_NIKON_PROTOCOL == 1
-                    if (((irmp_pulse_time < NIKON_START_BIT_PULSE_LEN_MIN || irmp_pulse_time > NIKON_START_BIT_PULSE_LEN_MAX) && irmp_pause_time > IRMP_TIMEOUT_LEN) ||
-                         irmp_pause_time > IRMP_TIMEOUT_NIKON_LEN)
-#else
-                    if (irmp_pause_time > IRMP_TIMEOUT_LEN)                     // timeout?
-#endif
-                    {                                                           // yes...
-#if IRMP_SUPPORT_JVC_PROTOCOL == 1
-                        if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // don't show eror if JVC protocol, irmp_pulse_time has been set below!
-                        {
-                            ;
-                        }
-                        else
-#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
-                        {
-                            ANALYZE_PRINTF ("%8.3fms error 1: pause after start bit pulse %d too long: %d\n", (double) (time_counter * 1000) / F_INTERRUPTS, irmp_pulse_time, irmp_pause_time);
-                            ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
-                        }
-//                      irmp_busy_flag = FALSE;
-                        irmp_start_bit_detected = 0;                            // reset flags, let's wait for another start bit
-                        irmp_pulse_time         = 0;
-                        irmp_pause_time         = 0;
-                    }
-                }
-                else
-                {                                                               // receiving first data pulse!
-                    IRMP_PARAMETER * irmp_param_p = (IRMP_PARAMETER *) 0;
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
-                    irmp_param2.protocol = 0;
-#endif
-
-                    ANALYZE_PRINTF ("%8.3fms [start-bit: pulse = %2d, pause = %2d]\n", (double) (time_counter * 1000) / F_INTERRUPTS, irmp_pulse_time, irmp_pause_time);
-
-#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
-                    if (irmp_pulse_time >= SIRCS_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SIRCS_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= SIRCS_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SIRCS_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's SIRCS
-                        ANALYZE_PRINTF ("protocol = SIRCS, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        SIRCS_START_BIT_PULSE_LEN_MIN, SIRCS_START_BIT_PULSE_LEN_MAX,
-                                        SIRCS_START_BIT_PAUSE_LEN_MIN, SIRCS_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) (IRMP_PARAMETER *) &sircs_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_SIRCS_PROTOCOL == 1
-
-#if IRMP_SUPPORT_JVC_PROTOCOL == 1
-                    if (irmp_protocol == IRMP_JVC_PROTOCOL &&                                                       // last protocol was JVC, awaiting repeat frame
-                        irmp_pulse_time >= JVC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= JVC_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= JVC_REPEAT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= JVC_REPEAT_START_BIT_PAUSE_LEN_MAX)
-                    {
-                        ANALYZE_PRINTF ("protocol = NEC or JVC (type 1) repeat frame, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        JVC_START_BIT_PULSE_LEN_MIN, JVC_START_BIT_PULSE_LEN_MAX,
-                                        JVC_REPEAT_START_BIT_PAUSE_LEN_MIN, JVC_REPEAT_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &nec_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
-
-#if IRMP_SUPPORT_NEC_PROTOCOL == 1
-                    if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_START_BIT_PAUSE_LEN_MAX)
-                    {
-#if IRMP_SUPPORT_NEC42_PROTOCOL == 1
-                        ANALYZE_PRINTF ("protocol = NEC42, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
-                                        NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &nec42_param;
-#else
-                        ANALYZE_PRINTF ("protocol = NEC, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
-                                        NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &nec_param;
-#endif
-
-                    }
-                    else if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN        && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
-                             irmp_pause_time >= NEC_REPEAT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_REPEAT_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's NEC
-#if IRMP_SUPPORT_JVC_PROTOCOL == 1
-                        if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // last protocol was JVC, awaiting repeat frame
-                        {                                                       // some jvc remote controls use nec repetition frame for jvc repetition frame
-                            ANALYZE_PRINTF ("protocol = JVC repeat frame type 2, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                            NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
-                                            NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BIT_PAUSE_LEN_MAX);
-                            irmp_param_p = (IRMP_PARAMETER *) &nec_param;
-                        }
-                        else
-#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
-                        {
-                            ANALYZE_PRINTF ("protocol = NEC (repetition frame), start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                            NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
-                                            NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BIT_PAUSE_LEN_MAX);
-
-                            irmp_param_p = (IRMP_PARAMETER *) &nec_rep_param;
-                        }
-                    }
-                    else
-
-#if IRMP_SUPPORT_JVC_PROTOCOL == 1
-                    if (irmp_protocol == IRMP_JVC_PROTOCOL &&                   // last protocol was JVC, awaiting repeat frame
-                        irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= NEC_0_PAUSE_LEN_MIN         && irmp_pause_time <= NEC_0_PAUSE_LEN_MAX)
-                    {                                                           // it's JVC repetition type 3
-                        ANALYZE_PRINTF ("protocol = JVC repeat frame type 3, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
-                                        NEC_0_PAUSE_LEN_MIN, NEC_0_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &nec_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
-
-#endif // IRMP_SUPPORT_NEC_PROTOCOL == 1
-
-#if IRMP_SUPPORT_NIKON_PROTOCOL == 1
-                    if (irmp_pulse_time >= NIKON_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NIKON_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= NIKON_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NIKON_START_BIT_PAUSE_LEN_MAX)
-                    {
-                        ANALYZE_PRINTF ("protocol = NIKON, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        NIKON_START_BIT_PULSE_LEN_MIN, NIKON_START_BIT_PULSE_LEN_MAX,
-                                        NIKON_START_BIT_PAUSE_LEN_MIN, NIKON_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &nikon_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_NIKON_PROTOCOL == 1
-
-#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
-                    if (irmp_pulse_time >= SAMSUNG_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's SAMSUNG
-                        ANALYZE_PRINTF ("protocol = SAMSUNG, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        SAMSUNG_START_BIT_PULSE_LEN_MIN, SAMSUNG_START_BIT_PULSE_LEN_MAX,
-                                        SAMSUNG_START_BIT_PAUSE_LEN_MIN, SAMSUNG_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &samsung_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
-
-#if IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
-                    if (irmp_pulse_time >= MATSUSHITA_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= MATSUSHITA_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= MATSUSHITA_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= MATSUSHITA_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's MATSUSHITA
-                        ANALYZE_PRINTF ("protocol = MATSUSHITA, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        MATSUSHITA_START_BIT_PULSE_LEN_MIN, MATSUSHITA_START_BIT_PULSE_LEN_MAX,
-                                        MATSUSHITA_START_BIT_PAUSE_LEN_MIN, MATSUSHITA_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &matsushita_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
-
-#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
-                    if (irmp_pulse_time >= KASEIKYO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= KASEIKYO_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= KASEIKYO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= KASEIKYO_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's KASEIKYO
-                        ANALYZE_PRINTF ("protocol = KASEIKYO, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        KASEIKYO_START_BIT_PULSE_LEN_MIN, KASEIKYO_START_BIT_PULSE_LEN_MAX,
-                                        KASEIKYO_START_BIT_PAUSE_LEN_MIN, KASEIKYO_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &kaseikyo_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
-
-#if IRMP_SUPPORT_RECS80_PROTOCOL == 1
-                    if (irmp_pulse_time >= RECS80_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RECS80_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= RECS80_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RECS80_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's RECS80
-                        ANALYZE_PRINTF ("protocol = RECS80, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        RECS80_START_BIT_PULSE_LEN_MIN, RECS80_START_BIT_PULSE_LEN_MAX,
-                                        RECS80_START_BIT_PAUSE_LEN_MIN, RECS80_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &recs80_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_RECS80_PROTOCOL == 1
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1
-                    if (((irmp_pulse_time >= RC5_START_BIT_LEN_MIN     && irmp_pulse_time <= RC5_START_BIT_LEN_MAX) ||
-                         (irmp_pulse_time >= 2 * RC5_START_BIT_LEN_MIN && irmp_pulse_time <= 2 * RC5_START_BIT_LEN_MAX)) &&
-                        ((irmp_pause_time >= RC5_START_BIT_LEN_MIN     && irmp_pause_time <= RC5_START_BIT_LEN_MAX) ||
-                         (irmp_pause_time >= 2 * RC5_START_BIT_LEN_MIN && irmp_pause_time <= 2 * RC5_START_BIT_LEN_MAX)))
-                    {                                                           // it's RC5
-#if IRMP_SUPPORT_FDC_PROTOCOL == 1
-                        if (irmp_pulse_time >= FDC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= FDC_START_BIT_PULSE_LEN_MAX &&
-                            irmp_pause_time >= FDC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= FDC_START_BIT_PAUSE_LEN_MAX)
-                        {
-                            ANALYZE_PRINTF ("protocol = RC5 or FDC\n");
-                            ANALYZE_PRINTF ("FDC start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                            FDC_START_BIT_PULSE_LEN_MIN, FDC_START_BIT_PULSE_LEN_MAX,
-                                            FDC_START_BIT_PAUSE_LEN_MIN, FDC_START_BIT_PAUSE_LEN_MAX);
-                            ANALYZE_PRINTF ("RC5 start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                            RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
-                                            RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX);
-                            memcpy_P (&irmp_param2, &fdc_param, sizeof (IRMP_PARAMETER));
-                        }
-                        else
-#endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
-
-#if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
-                        if (irmp_pulse_time >= RCCAR_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RCCAR_START_BIT_PULSE_LEN_MAX &&
-                            irmp_pause_time >= RCCAR_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_START_BIT_PAUSE_LEN_MAX)
-                        {
-                            ANALYZE_PRINTF ("protocol = RC5 or RCCAR\n");
-                            ANALYZE_PRINTF ("RCCAR start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                            RCCAR_START_BIT_PULSE_LEN_MIN, RCCAR_START_BIT_PULSE_LEN_MAX,
-                                            RCCAR_START_BIT_PAUSE_LEN_MIN, RCCAR_START_BIT_PAUSE_LEN_MAX);
-                            ANALYZE_PRINTF ("RC5 start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                            RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
-                                            RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX);
-                            memcpy_P (&irmp_param2, &rccar_param, sizeof (IRMP_PARAMETER));
-                        }
-                        else
-#endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
-                        {
-                            ANALYZE_PRINTF ("protocol = RC5, start bit timings: pulse: %3d - %3d, pause: %3d - %3d or pulse: %3d - %3d, pause: %3d - %3d\n",
-                                            RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
-                                            2 * RC5_START_BIT_LEN_MIN, 2 * RC5_START_BIT_LEN_MAX,
-                                            RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
-                                            2 * RC5_START_BIT_LEN_MIN, 2 * RC5_START_BIT_LEN_MAX);
-                        }
-
-                        irmp_param_p = (IRMP_PARAMETER *) &rc5_param;
-                        last_pause = irmp_pause_time;
-
-                        if ((irmp_pulse_time > RC5_START_BIT_LEN_MAX && irmp_pulse_time <= 2 * RC5_START_BIT_LEN_MAX) ||
-                            (irmp_pause_time > RC5_START_BIT_LEN_MAX && irmp_pause_time <= 2 * RC5_START_BIT_LEN_MAX))
-                        {
-                          last_value  = 0;
-                          rc5_cmd_bit6 = 1<<6;
-                        }
-                        else
-                        {
-                          last_value  = 1;
-                        }
-                    }
-                    else
-#endif // IRMP_SUPPORT_RC5_PROTOCOL == 1
-
-#if IRMP_SUPPORT_DENON_PROTOCOL == 1
-                    if ( (irmp_pulse_time >= DENON_PULSE_LEN_MIN && irmp_pulse_time <= DENON_PULSE_LEN_MAX) &&
-                        ((irmp_pause_time >= DENON_1_PAUSE_LEN_MIN && irmp_pause_time <= DENON_1_PAUSE_LEN_MAX) ||
-                         (irmp_pause_time >= DENON_0_PAUSE_LEN_MIN && irmp_pause_time <= DENON_0_PAUSE_LEN_MAX)))
-                    {                                                           // it's DENON
-                        ANALYZE_PRINTF ("protocol = DENON, start bit timings: pulse: %3d - %3d, pause: %3d - %3d or %3d - %3d\n",
-                                        DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX,
-                                        DENON_1_PAUSE_LEN_MIN, DENON_1_PAUSE_LEN_MAX,
-                                        DENON_0_PAUSE_LEN_MIN, DENON_0_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &denon_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_DENON_PROTOCOL == 1
-
-#if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
-                    if ( (irmp_pulse_time >= THOMSON_PULSE_LEN_MIN && irmp_pulse_time <= THOMSON_PULSE_LEN_MAX) &&
-                        ((irmp_pause_time >= THOMSON_1_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_1_PAUSE_LEN_MAX) ||
-                         (irmp_pause_time >= THOMSON_0_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_0_PAUSE_LEN_MAX)))
-                    {                                                           // it's THOMSON
-                        ANALYZE_PRINTF ("protocol = THOMSON, start bit timings: pulse: %3d - %3d, pause: %3d - %3d or %3d - %3d\n",
-                                        THOMSON_PULSE_LEN_MIN, THOMSON_PULSE_LEN_MAX,
-                                        THOMSON_1_PAUSE_LEN_MIN, THOMSON_1_PAUSE_LEN_MAX,
-                                        THOMSON_0_PAUSE_LEN_MIN, THOMSON_0_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &thomson_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_THOMSON_PROTOCOL == 1
-
-#if IRMP_SUPPORT_RC6_PROTOCOL == 1
-                    if (irmp_pulse_time >= RC6_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RC6_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= RC6_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RC6_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's RC6
-                        ANALYZE_PRINTF ("protocol = RC6, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        RC6_START_BIT_PULSE_LEN_MIN, RC6_START_BIT_PULSE_LEN_MAX,
-                                        RC6_START_BIT_PAUSE_LEN_MIN, RC6_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &rc6_param;
-                        last_pause = 0;
-                        last_value = 1;
-                    }
-                    else
-#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
-
-#if IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
-                    if (irmp_pulse_time >= RECS80EXT_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RECS80EXT_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= RECS80EXT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RECS80EXT_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's RECS80EXT
-                        ANALYZE_PRINTF ("protocol = RECS80EXT, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        RECS80EXT_START_BIT_PULSE_LEN_MIN, RECS80EXT_START_BIT_PULSE_LEN_MAX,
-                                        RECS80EXT_START_BIT_PAUSE_LEN_MIN, RECS80EXT_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &recs80ext_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
-
-#if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
-                    if (irmp_pulse_time >= NUBERT_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NUBERT_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= NUBERT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NUBERT_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's NUBERT
-                        ANALYZE_PRINTF ("protocol = NUBERT, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        NUBERT_START_BIT_PULSE_LEN_MIN, NUBERT_START_BIT_PULSE_LEN_MAX,
-                                        NUBERT_START_BIT_PAUSE_LEN_MIN, NUBERT_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &nubert_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_NUBERT_PROTOCOL == 1
-
-#if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
-                    if (irmp_pulse_time >= BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN && irmp_pulse_time <= BANG_OLUFSEN_START_BIT1_PULSE_LEN_MAX &&
-                        irmp_pause_time >= BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MAX)
-                    {                                                           // it's BANG_OLUFSEN
-                        ANALYZE_PRINTF ("protocol = BANG_OLUFSEN\n");
-                        ANALYZE_PRINTF ("start bit 1 timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT1_PULSE_LEN_MAX,
-                                        BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MAX);
-                        ANALYZE_PRINTF ("start bit 2 timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        BANG_OLUFSEN_START_BIT2_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT2_PULSE_LEN_MAX,
-                                        BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MAX);
-                        ANALYZE_PRINTF ("start bit 3 timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        BANG_OLUFSEN_START_BIT3_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT3_PULSE_LEN_MAX,
-                                        BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MAX);
-                        ANALYZE_PRINTF ("start bit 4 timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        BANG_OLUFSEN_START_BIT4_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT4_PULSE_LEN_MAX,
-                                        BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &bang_olufsen_param;
-                        last_value = 0;
-                    }
-                    else
-#endif // IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
-
-#if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
-                    if (irmp_pulse_time >= GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN && irmp_pulse_time <= GRUNDIG_NOKIA_IR60_START_BIT_LEN_MAX &&
-                        irmp_pause_time >= GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN && irmp_pause_time <= GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MAX)
-                    {                                                           // it's GRUNDIG
-                        ANALYZE_PRINTF ("protocol = GRUNDIG, pre bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN, GRUNDIG_NOKIA_IR60_START_BIT_LEN_MAX,
-                                        GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN, GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &grundig_param;
-                        last_pause = irmp_pause_time;
-                        last_value  = 1;
-                    }
-                    else
-#endif // IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
-
-#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
-                    if (((irmp_pulse_time >= SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX) ||
-                         (irmp_pulse_time >= 2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= 2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX)) &&
-                        ((irmp_pause_time >= SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX) || 
-                         (irmp_pause_time >= 2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= 2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX)))
-                    {                                                           // it's RUWIDO or SIEMENS
-                        ANALYZE_PRINTF ("protocol = RUWIDO, start bit timings: pulse: %3d - %3d or %3d - %3d, pause: %3d - %3d or %3d - %3d\n",
-                                        SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN,   SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX,
-                                        2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN, 2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX,
-                                        SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN,   SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX,
-                                        2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN, 2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &ruwido_param;
-                        last_pause = irmp_pause_time;
-                        last_value  = 1;
-                    }
-                    else
-#endif // IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
-
-#if IRMP_SUPPORT_GRUNDIG2_PROTOCOL == 1
-                    if ((irmp_pulse_time >= GRUNDIG2_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= GRUNDIG2_START_BIT_PULSE_LEN_MAX) &&
-                        (irmp_pause_time >= GRUNDIG2_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= GRUNDIG2_START_BIT_PAUSE_LEN_MAX))
-                    {                                                           // it's GRUNDIG2
-                        ANALYZE_PRINTF ("protocol = GRUNDIG2, start bit timings: pulse: %3d - %3d or %3d - %3d, pause: %3d - %3d or %3d - %3d\n",
-                                        GRUNDIG2_START_BIT_PULSE_LEN_MIN,   GRUNDIG2_START_BIT_PULSE_LEN_MAX,
-                                        2 * GRUNDIG2_START_BIT_PULSE_LEN_MIN, 2 * GRUNDIG2_START_BIT_PULSE_LEN_MAX,
-                                        GRUNDIG2_START_BIT_PAUSE_LEN_MIN,   GRUNDIG2_START_BIT_PAUSE_LEN_MAX,
-                                        2 * GRUNDIG2_START_BIT_PAUSE_LEN_MIN, 2 * GRUNDIG2_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &grundig2_param;
-                        last_pause = irmp_pause_time;
-                        last_value  = 1;
-                    }
-                    else
-#endif // IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
-
-#if IRMP_SUPPORT_FDC_PROTOCOL == 1
-                    if (irmp_pulse_time >= FDC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= FDC_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= FDC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= FDC_START_BIT_PAUSE_LEN_MAX)
-                    {
-                        ANALYZE_PRINTF ("protocol = FDC, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        FDC_START_BIT_PULSE_LEN_MIN, FDC_START_BIT_PULSE_LEN_MAX,
-                                        FDC_START_BIT_PAUSE_LEN_MIN, FDC_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &fdc_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
-
-#if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
-                    if (irmp_pulse_time >= RCCAR_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RCCAR_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= RCCAR_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_START_BIT_PAUSE_LEN_MAX)
-                    {
-                        ANALYZE_PRINTF ("protocol = RCCAR, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        RCCAR_START_BIT_PULSE_LEN_MIN, RCCAR_START_BIT_PULSE_LEN_MAX,
-                                        RCCAR_START_BIT_PAUSE_LEN_MIN, RCCAR_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &rccar_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
-
-#if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
-                    if (irmp_pulse_time >= KATHREIN_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= KATHREIN_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= KATHREIN_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= KATHREIN_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's KATHREIN
-                        ANALYZE_PRINTF ("protocol = KATHREIN, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        KATHREIN_START_BIT_PULSE_LEN_MIN, KATHREIN_START_BIT_PULSE_LEN_MAX,
-                                        KATHREIN_START_BIT_PAUSE_LEN_MIN, KATHREIN_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &kathrein_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
-
-#if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
-                    if (irmp_pulse_time >= NETBOX_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NETBOX_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= NETBOX_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NETBOX_START_BIT_PAUSE_LEN_MAX)
-                    {                                                           // it's NETBOX
-                        ANALYZE_PRINTF ("protocol = NETBOX, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        NETBOX_START_BIT_PULSE_LEN_MIN, NETBOX_START_BIT_PULSE_LEN_MAX,
-                                        NETBOX_START_BIT_PAUSE_LEN_MIN, NETBOX_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &netbox_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_NETBOX_PROTOCOL == 1
-
-#if IRMP_SUPPORT_LEGO_PROTOCOL == 1
-                    if (irmp_pulse_time >= LEGO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= LEGO_START_BIT_PULSE_LEN_MAX &&
-                        irmp_pause_time >= LEGO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= LEGO_START_BIT_PAUSE_LEN_MAX)
-                    {
-                        ANALYZE_PRINTF ("protocol = LEGO, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
-                                        LEGO_START_BIT_PULSE_LEN_MIN, LEGO_START_BIT_PULSE_LEN_MAX,
-                                        LEGO_START_BIT_PAUSE_LEN_MIN, LEGO_START_BIT_PAUSE_LEN_MAX);
-                        irmp_param_p = (IRMP_PARAMETER *) &lego_param;
-                    }
-                    else
-#endif // IRMP_SUPPORT_LEGO_PROTOCOL == 1
-
-                    {
-                        ANALYZE_PRINTF ("protocol = UNKNOWN\n");
-//                      irmp_busy_flag = FALSE;
-                        irmp_start_bit_detected = 0;                            // wait for another start bit...
-                    }
-
-                    if (irmp_start_bit_detected)
-                    {
-                        memcpy_P (&irmp_param, irmp_param_p, sizeof (IRMP_PARAMETER));
-
-#ifdef ANALYZE
-                        if (! (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
-                        {
-                            ANALYZE_PRINTF ("pulse_1: %3d - %3d\n", irmp_param.pulse_1_len_min, irmp_param.pulse_1_len_max);
-                            ANALYZE_PRINTF ("pause_1: %3d - %3d\n", irmp_param.pause_1_len_min, irmp_param.pause_1_len_max);
-                        }
-                        else
-                        {
-                            ANALYZE_PRINTF ("pulse: %3d - %3d or %3d - %3d\n", irmp_param.pulse_1_len_min, irmp_param.pulse_1_len_max,
-                                            2 * irmp_param.pulse_1_len_min, 2 * irmp_param.pulse_1_len_max);
-                            ANALYZE_PRINTF ("pause: %3d - %3d or %3d - %3d\n", irmp_param.pause_1_len_min, irmp_param.pause_1_len_max,
-                                            2 * irmp_param.pause_1_len_min, 2 * irmp_param.pause_1_len_max);
-                        }
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
-                        if (irmp_param2.protocol)
-                        {
-                            ANALYZE_PRINTF ("pulse_0: %3d - %3d\n", irmp_param2.pulse_0_len_min, irmp_param2.pulse_0_len_max);
-                            ANALYZE_PRINTF ("pause_0: %3d - %3d\n", irmp_param2.pause_0_len_min, irmp_param2.pause_0_len_max);
-                            ANALYZE_PRINTF ("pulse_1: %3d - %3d\n", irmp_param2.pulse_1_len_min, irmp_param2.pulse_1_len_max);
-                            ANALYZE_PRINTF ("pause_1: %3d - %3d\n", irmp_param2.pause_1_len_min, irmp_param2.pause_1_len_max);
-                        }
-#endif
-
-
-#if IRMP_SUPPORT_RC6_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_RC6_PROTOCOL)
-                        {
-                            ANALYZE_PRINTF ("pulse_toggle: %3d - %3d\n", RC6_TOGGLE_BIT_LEN_MIN, RC6_TOGGLE_BIT_LEN_MAX);
-                        }
-#endif
-
-                        if (! (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
-                        {
-                            ANALYZE_PRINTF ("pulse_0: %3d - %3d\n", irmp_param.pulse_0_len_min, irmp_param.pulse_0_len_max);
-                            ANALYZE_PRINTF ("pause_0: %3d - %3d\n", irmp_param.pause_0_len_min, irmp_param.pause_0_len_max);
-                        }
-                        else
-                        {
-                            ANALYZE_PRINTF ("pulse: %3d - %3d or %3d - %3d\n", irmp_param.pulse_0_len_min, irmp_param.pulse_0_len_max,
-                                            2 * irmp_param.pulse_0_len_min, 2 * irmp_param.pulse_0_len_max);
-                            ANALYZE_PRINTF ("pause: %3d - %3d or %3d - %3d\n", irmp_param.pause_0_len_min, irmp_param.pause_0_len_max,
-                                            2 * irmp_param.pause_0_len_min, 2 * irmp_param.pause_0_len_max);
-                        }
-
-#if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_BANG_OLUFSEN_PROTOCOL)
-                        {
-                            ANALYZE_PRINTF ("pulse_r: %3d - %3d\n", irmp_param.pulse_0_len_min, irmp_param.pulse_0_len_max);
-                            ANALYZE_PRINTF ("pause_r: %3d - %3d\n", BANG_OLUFSEN_R_PAUSE_LEN_MIN, BANG_OLUFSEN_R_PAUSE_LEN_MAX);
-                        }
-#endif
-
-                        ANALYZE_PRINTF ("command_offset: %2d\n", irmp_param.command_offset);
-                        ANALYZE_PRINTF ("command_len:    %3d\n", irmp_param.command_end - irmp_param.command_offset);
-                        ANALYZE_PRINTF ("complete_len:   %3d\n", irmp_param.complete_len);
-                        ANALYZE_PRINTF ("stop_bit:       %3d\n", irmp_param.stop_bit);
-#endif // ANALYZE
-                    }
-
-                    irmp_bit = 0;
-
-#if IRMP_SUPPORT_MANCHESTER == 1
-                    if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
-                         irmp_param.protocol != IRMP_RUWIDO_PROTOCOL && // Manchester, but not RUWIDO
-                         irmp_param.protocol != IRMP_RC6_PROTOCOL)      // Manchester, but not RC6
-                    {
-                        if (irmp_pause_time > irmp_param.pulse_1_len_max && irmp_pause_time <= 2 * irmp_param.pulse_1_len_max)
-                        {
-                            ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (time_counter * 1000) / F_INTERRUPTS, irmp_bit, irmp_pulse_time, irmp_pause_time);
-                            ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '0' : '1');
-                            ANALYZE_NEWLINE ();
-                            irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 0 : 1);
-                        }
-                        else if (! last_value)  // && irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_param.pause_1_len_max)
-                        {
-                            ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (time_counter * 1000) / F_INTERRUPTS, irmp_bit, irmp_pulse_time, irmp_pause_time);
-
-                            ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '1' : '0');
-                            ANALYZE_NEWLINE ();
-                            irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 : 0);
-                        }
-                    }
-                    else
-#endif // IRMP_SUPPORT_MANCHESTER == 1
-
-#if IRMP_SUPPORT_SERIAL == 1
-                    if (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL)
-                    {
-                        ; // do nothing
-                    }
-                    else
-#endif // IRMP_SUPPORT_SERIAL == 1
-
-
-#if IRMP_SUPPORT_DENON_PROTOCOL == 1
-                    if (irmp_param.protocol == IRMP_DENON_PROTOCOL)
-                    {
-                        ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (time_counter * 1000) / F_INTERRUPTS, irmp_bit, irmp_pulse_time, irmp_pause_time);
-
-                        if (irmp_pause_time >= DENON_1_PAUSE_LEN_MIN && irmp_pause_time <= DENON_1_PAUSE_LEN_MAX)
-                        {                                                       // pause timings correct for "1"?
-                          ANALYZE_PUTCHAR ('1');                                  // yes, store 1
-                          ANALYZE_NEWLINE ();
-                          irmp_store_bit (1);
-                        }
-                        else // if (irmp_pause_time >= DENON_0_PAUSE_LEN_MIN && irmp_pause_time <= DENON_0_PAUSE_LEN_MAX)
-                        {                                                       // pause timings correct for "0"?
-                          ANALYZE_PUTCHAR ('0');                                  // yes, store 0
-                          ANALYZE_NEWLINE ();
-                          irmp_store_bit (0);
-                        }
-                    }
-                    else
-#endif // IRMP_SUPPORT_DENON_PROTOCOL == 1
-#if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
-                    if (irmp_param.protocol == IRMP_THOMSON_PROTOCOL)
-                    {
-                        ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (time_counter * 1000) / F_INTERRUPTS, irmp_bit, irmp_pulse_time, irmp_pause_time);
-
-                        if (irmp_pause_time >= THOMSON_1_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_1_PAUSE_LEN_MAX)
-                        {                                                       // pause timings correct for "1"?
-                          ANALYZE_PUTCHAR ('1');                                  // yes, store 1
-                          ANALYZE_NEWLINE ();
-                          irmp_store_bit (1);
-                        }
-                        else // if (irmp_pause_time >= THOMSON_0_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_0_PAUSE_LEN_MAX)
-                        {                                                       // pause timings correct for "0"?
-                          ANALYZE_PUTCHAR ('0');                                  // yes, store 0
-                          ANALYZE_NEWLINE ();
-                          irmp_store_bit (0);
-                        }
-                    }
-                    else
-#endif // IRMP_SUPPORT_THOMSON_PROTOCOL == 1
-                    {
-                        ;                                                       // else do nothing
-                    }
-
-                    irmp_pulse_time = 1;                                        // set counter to 1, not 0
-                    irmp_pause_time = 0;
-                    wait_for_start_space = 0;
-                }
-            }
-            else if (wait_for_space)                                            // the data section....
-            {                                                                   // counting the time of darkness....
-                uint8_t got_light = FALSE;
-
-                if (irmp_input)                                                 // still dark?
-                {                                                               // yes...
-                    if (irmp_bit == irmp_param.complete_len && irmp_param.stop_bit == 1)
-                    {
-                        if (
-#if IRMP_SUPPORT_MANCHESTER == 1
-                            (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) ||
-#endif
-#if IRMP_SUPPORT_SERIAL == 1
-                            (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL) ||
-#endif
-                            (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= irmp_param.pulse_0_len_max))
-                        {
-#ifdef ANALYZE
-                            if (! (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
-                            {
-                                ANALYZE_PRINTF ("stop bit detected\n");
-                            }
-#endif
-                            irmp_param.stop_bit = 0;
-                        }
-                        else
-                        {
-                            ANALYZE_PRINTF ("error: stop bit timing wrong, irmp_bit = %d, irmp_pulse_time = %d, pulse_0_len_min = %d, pulse_0_len_max = %d\n",
-                                            irmp_bit, irmp_pulse_time, irmp_param.pulse_0_len_min, irmp_param.pulse_0_len_max);
-
-//                          irmp_busy_flag = FALSE;
-                            irmp_start_bit_detected = 0;                        // wait for another start bit...
-                            irmp_pulse_time         = 0;
-                            irmp_pause_time         = 0;
-                        }
-                    }
-                    else
-                    {
-                        irmp_pause_time++;                                                          // increment counter
-
-#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL &&                           // Sony has a variable number of bits:
-                            irmp_pause_time > SIRCS_PAUSE_LEN_MAX &&                                // minimum is 12
-                            irmp_bit >= 12 - 1)                                                     // pause too long?
-                        {                                                                           // yes, break and close this frame
-                            irmp_param.complete_len = irmp_bit + 1;                                 // set new complete length
-                            got_light = TRUE;                                                       // this is a lie, but helps (generates stop bit)
-                            irmp_tmp_address |= (irmp_bit - SIRCS_MINIMUM_DATA_LEN + 1) << 8;       // new: store number of additional bits in upper byte of address!
-                            irmp_param.command_end = irmp_param.command_offset + irmp_bit + 1;      // correct command length
-                            irmp_pause_time = SIRCS_PAUSE_LEN_MAX - 1;                              // correct pause length
-                        }
-                        else
-#endif
-#if IRMP_SUPPORT_SERIAL == 1
-                        // NETBOX generates no stop bit, here is the timeout condition:
-                        if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL) && irmp_param.protocol == IRMP_NETBOX_PROTOCOL &&
-                            irmp_pause_time >= NETBOX_PULSE_LEN * (NETBOX_COMPLETE_DATA_LEN - irmp_bit))
-                        {
-                            got_light = TRUE;                                                       // this is a lie, but helps (generates stop bit)
-                        }
-                        else
-#endif
-#if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL && !irmp_param.stop_bit)
-                        {
-                            if (irmp_pause_time > IR60_TIMEOUT_LEN && irmp_bit == 6)
-                            {
-                                ANALYZE_PRINTF ("Switching to IR60 protocol\n");
-                                got_light = TRUE;                                       // this is a lie, but generates a stop bit ;-)
-                                irmp_param.stop_bit = TRUE;                             // set flag
-
-                                irmp_param.protocol         = IRMP_IR60_PROTOCOL;       // change protocol
-                                irmp_param.complete_len     = IR60_COMPLETE_DATA_LEN;   // correct complete len
-                                irmp_param.address_offset   = IR60_ADDRESS_OFFSET;
-                                irmp_param.address_end      = IR60_ADDRESS_OFFSET + IR60_ADDRESS_LEN;
-                                irmp_param.command_offset   = IR60_COMMAND_OFFSET;
-                                irmp_param.command_end      = IR60_COMMAND_OFFSET + IR60_COMMAND_LEN;
-
-                                irmp_tmp_command <<= 1;
-                                irmp_tmp_command |= first_bit;
-                            }
-                            else if (irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= GRUNDIG_COMPLETE_DATA_LEN - 2)
-                            {                                                           // special manchester decoder
-                                irmp_param.complete_len = GRUNDIG_COMPLETE_DATA_LEN;    // correct complete len
-                                got_light = TRUE;                                       // this is a lie, but generates a stop bit ;-)
-                                irmp_param.stop_bit = TRUE;                             // set flag
-                            }
-                            else if (irmp_bit >= GRUNDIG_COMPLETE_DATA_LEN)
-                            {
-                                ANALYZE_PRINTF ("Switching to NOKIA protocol\n");
-                                irmp_param.protocol         = IRMP_NOKIA_PROTOCOL;      // change protocol
-                                irmp_param.address_offset   = NOKIA_ADDRESS_OFFSET;
-                                irmp_param.address_end      = NOKIA_ADDRESS_OFFSET + NOKIA_ADDRESS_LEN;
-                                irmp_param.command_offset   = NOKIA_COMMAND_OFFSET;
-                                irmp_param.command_end      = NOKIA_COMMAND_OFFSET + NOKIA_COMMAND_LEN;
-
-                                if (irmp_tmp_command & 0x300)
-                                {
-                                    irmp_tmp_address = (irmp_tmp_command >> 8);
-                                    irmp_tmp_command &= 0xFF;
-                                }
-                            }
-                        }
-                        else
-#endif
-#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_RUWIDO_PROTOCOL && !irmp_param.stop_bit)
-                        {
-                            if (irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= RUWIDO_COMPLETE_DATA_LEN - 2)
-                            {                                                           // special manchester decoder
-                                irmp_param.complete_len = RUWIDO_COMPLETE_DATA_LEN;     // correct complete len
-                                got_light = TRUE;                                       // this is a lie, but generates a stop bit ;-)
-                                irmp_param.stop_bit = TRUE;                             // set flag
-                            }
-                            else if (irmp_bit >= RUWIDO_COMPLETE_DATA_LEN)
-                            {
-                                ANALYZE_PRINTF ("Switching to SIEMENS protocol\n");
-                                irmp_param.protocol         = IRMP_SIEMENS_PROTOCOL;    // change protocol
-                                irmp_param.address_offset   = SIEMENS_ADDRESS_OFFSET;
-                                irmp_param.address_end      = SIEMENS_ADDRESS_OFFSET + SIEMENS_ADDRESS_LEN;
-                                irmp_param.command_offset   = SIEMENS_COMMAND_OFFSET;
-                                irmp_param.command_end      = SIEMENS_COMMAND_OFFSET + SIEMENS_COMMAND_LEN;
-
-                                //                   76543210
-                                // RUWIDO:  AAAAAAAAACCCCCCCp
-                                // SIEMENS: AAAAAAAAAAACCCCCCCCCCp
-                                irmp_tmp_address <<= 2;
-                                irmp_tmp_address |= (irmp_tmp_command >> 6);
-                                irmp_tmp_command &= 0x003F;
-                                irmp_tmp_command <<= 4;
-                                irmp_tmp_command |= last_value;
-                            }
-                        }
-                        else
-#endif
-#if IRMP_SUPPORT_MANCHESTER == 1
-                        if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
-                            irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= irmp_param.complete_len - 2 && !irmp_param.stop_bit)
-                        {                                                       // special manchester decoder
-                            got_light = TRUE;                                   // this is a lie, but generates a stop bit ;-)
-                            irmp_param.stop_bit = TRUE;                         // set flag
-                        }
-                        else
-#endif // IRMP_SUPPORT_MANCHESTER == 1
-                        if (irmp_pause_time > IRMP_TIMEOUT_LEN)                 // timeout?
-                        {                                                       // yes...
-                            if (irmp_bit == irmp_param.complete_len - 1 && irmp_param.stop_bit == 0)
-                            {
-                                irmp_bit++;
-                            }
-#if IRMP_SUPPORT_JVC_PROTOCOL == 1
-                            else if (irmp_param.protocol == IRMP_NEC_PROTOCOL && (irmp_bit == 16 || irmp_bit == 17))      // it was a JVC stop bit
-                            {
-                                ANALYZE_PRINTF ("Switching to JVC protocol, irmp_bit = %d\n", irmp_bit);
-                                irmp_param.stop_bit     = TRUE;                                     // set flag
-                                irmp_param.protocol     = IRMP_JVC_PROTOCOL;                        // switch protocol
-                                irmp_param.complete_len = irmp_bit;                                 // patch length: 16 or 17
-                                irmp_tmp_command        = (irmp_tmp_address >> 4);                  // set command: upper 12 bits are command bits
-                                irmp_tmp_address        = irmp_tmp_address & 0x000F;                // lower 4 bits are address bits
-                                irmp_start_bit_detected = 1;                                        // tricky: don't wait for another start bit...
-                            }
-#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
-
-#if IRMP_SUPPORT_NEC42_PROTOCOL == 1
-#if IRMP_SUPPORT_NEC_PROTOCOL == 1
-                            else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && irmp_bit == 32)  // it was a NEC stop bit
-                            {
-                                ANALYZE_PRINTF ("Switching to NEC protocol\n");
-                                irmp_param.stop_bit     = TRUE;                                     // set flag
-                                irmp_param.protocol     = IRMP_NEC_PROTOCOL;                        // switch protocol
-                                irmp_param.complete_len = irmp_bit;                                 // patch length: 16 or 17
-
-                                //        0123456789ABC0123456789ABC0123456701234567
-                                // NEC42: AAAAAAAAAAAAAaaaaaaaaaaaaaCCCCCCCCcccccccc
-                                // NEC:   AAAAAAAAaaaaaaaaCCCCCCCCcccccccc
-                                irmp_tmp_address        |= (irmp_tmp_address2 & 0x0007) << 13;      // fm 2012-02-13: 12 -> 13
-                                irmp_tmp_command        = (irmp_tmp_address2 >> 3) | (irmp_tmp_command << 10);
-                            }
-#endif // IRMP_SUPPORT_NEC_PROTOCOL == 1
-#if IRMP_SUPPORT_JVC_PROTOCOL == 1
-                            else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && (irmp_bit == 16 || irmp_bit == 17))  // it was a JVC stop bit
-                            {
-                                ANALYZE_PRINTF ("Switching to JVC protocol, irmp_bit = %d\n", irmp_bit);
-                                irmp_param.stop_bit     = TRUE;                                     // set flag
-                                irmp_param.protocol     = IRMP_JVC_PROTOCOL;                        // switch protocol
-                                irmp_param.complete_len = irmp_bit;                                 // patch length: 16 or 17
-
-                                //        0123456789ABC0123456789ABC0123456701234567
-                                // NEC42: AAAAAAAAAAAAAaaaaaaaaaaaaaCCCCCCCCcccccccc
-                                // JVC:   AAAACCCCCCCCCCCC
-                                irmp_tmp_command        = (irmp_tmp_address >> 4) | (irmp_tmp_address2 << 9);   // set command: upper 12 bits are command bits
-                                irmp_tmp_address        = irmp_tmp_address & 0x000F;                            // lower 4 bits are address bits
-                            }
-#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
-#endif // IRMP_SUPPORT_NEC42_PROTOCOL == 1
-                            else
-                            {
-                                ANALYZE_PRINTF ("error 2: pause %d after data bit %d too long\n", irmp_pause_time, irmp_bit);
-                                ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
-
-//                              irmp_busy_flag = FALSE;
-                                irmp_start_bit_detected = 0;                    // wait for another start bit...
-                                irmp_pulse_time         = 0;
-                                irmp_pause_time         = 0;
-                            }
-                        }
-                    }
-                }
-                else
-                {                                                               // got light now!
-                    got_light = TRUE;
-                }
-
-                if (got_light)
-                {
-                    ANALYZE_PRINTF ("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double) (time_counter * 1000) / F_INTERRUPTS, irmp_bit, irmp_pulse_time, irmp_pause_time);
-
-#if IRMP_SUPPORT_MANCHESTER == 1
-                    if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))                                     // Manchester
-                    {
-#if 1
-                        if (irmp_pulse_time > irmp_param.pulse_1_len_max /* && irmp_pulse_time <= 2 * irmp_param.pulse_1_len_max */)
-#else // better, but some IR-RCs use asymmetric timings :-/
-                        if (irmp_pulse_time > irmp_param.pulse_1_len_max && irmp_pulse_time <= 2 * irmp_param.pulse_1_len_max &&
-                            irmp_pause_time <= 2 * irmp_param.pause_1_len_max)
-#endif
-                        {
-#if IRMP_SUPPORT_RC6_PROTOCOL == 1
-                            if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 4 && irmp_pulse_time > RC6_TOGGLE_BIT_LEN_MIN)         // RC6 toggle bit
-                            {
-                                ANALYZE_PUTCHAR ('T');
-                                if (irmp_param.complete_len == RC6_COMPLETE_DATA_LEN_LONG)                      // RC6 mode 6A
-                                {
-                                    irmp_store_bit (1);
-                                    last_value = 1;
-                                }
-                                else                                                                            // RC6 mode 0
-                                {
-                                    irmp_store_bit (0);
-                                    last_value = 0;
-                                }
-                                ANALYZE_NEWLINE ();
-                            }
-                            else
-#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
-                            {
-                                ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '0' : '1');
-                                irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 0  :  1 );
-
-#if IRMP_SUPPORT_RC6_PROTOCOL == 1
-                                if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 4 && irmp_pulse_time > RC6_TOGGLE_BIT_LEN_MIN)      // RC6 toggle bit
-                                {
-                                    ANALYZE_PUTCHAR ('T');
-                                    irmp_store_bit (1);
-
-                                    if (irmp_pause_time > 2 * irmp_param.pause_1_len_max)
-                                    {
-                                        last_value = 0;
-                                    }
-                                    else
-                                    {
-                                        last_value = 1;
-                                    }
-                                    ANALYZE_NEWLINE ();
-                                }
-                                else
-#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
-                                {
-                                    ANALYZE_PUTCHAR ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '1' : '0');
-                                    irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 :   0 );
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
-                                    if (! irmp_param2.protocol)
-#endif
-                                    {
-                                        ANALYZE_NEWLINE ();
-                                    }
-                                    last_value = (irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 : 0;
-                                }
-                            }
-                        }
-                        else if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_param.pulse_1_len_max
-                                 /* && irmp_pause_time <= 2 * irmp_param.pause_1_len_max */)
-                        {
-                            uint8_t manchester_value;
-
-                            if (last_pause > irmp_param.pause_1_len_max && last_pause <= 2 * irmp_param.pause_1_len_max)
-                            {
-                                manchester_value = last_value ? 0 : 1;
-                                last_value  = manchester_value;
-                            }
-                            else
-                            {
-                                manchester_value = last_value;
-                            }
-
-                            ANALYZE_PUTCHAR (manchester_value + '0');
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
-                            if (! irmp_param2.protocol)
-#endif
-                            {
-                                ANALYZE_NEWLINE ();
-                            }
-
-#if IRMP_SUPPORT_RC6_PROTOCOL == 1
-                            if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 1 && manchester_value == 1)     // RC6 mode != 0 ???
-                            {
-                                ANALYZE_PRINTF ("Switching to RC6A protocol\n");
-                                irmp_param.complete_len = RC6_COMPLETE_DATA_LEN_LONG;
-                                irmp_param.address_offset = 5;
-                                irmp_param.address_end = irmp_param.address_offset + 15;
-                                irmp_param.command_offset = irmp_param.address_end + 1;                                 // skip 1 system bit, changes like a toggle bit
-                                irmp_param.command_end = irmp_param.command_offset + 16 - 1;
-                                irmp_tmp_address = 0;
-                            }
-#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
-
-                            irmp_store_bit (manchester_value);
-                        }
-                        else
-                        {
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_FDC_PROTOCOL == 1
-                            if (irmp_param2.protocol == IRMP_FDC_PROTOCOL &&
-                                irmp_pulse_time >= FDC_PULSE_LEN_MIN && irmp_pulse_time <= FDC_PULSE_LEN_MAX &&
-                                ((irmp_pause_time >= FDC_1_PAUSE_LEN_MIN && irmp_pause_time <= FDC_1_PAUSE_LEN_MAX) ||
-                                 (irmp_pause_time >= FDC_0_PAUSE_LEN_MIN && irmp_pause_time <= FDC_0_PAUSE_LEN_MAX)))
-                            {
-                                ANALYZE_PUTCHAR ('?');
-                                irmp_param.protocol = 0;                // switch to FDC, see below
-                            }
-                            else
-#endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_RCCAR_PROTOCOL == 1
-                            if (irmp_param2.protocol == IRMP_RCCAR_PROTOCOL &&
-                                irmp_pulse_time >= RCCAR_PULSE_LEN_MIN && irmp_pulse_time <= RCCAR_PULSE_LEN_MAX &&
-                                ((irmp_pause_time >= RCCAR_1_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_1_PAUSE_LEN_MAX) ||
-                                 (irmp_pause_time >= RCCAR_0_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_0_PAUSE_LEN_MAX)))
-                            {
-                                ANALYZE_PUTCHAR ('?');
-                                irmp_param.protocol = 0;                // switch to RCCAR, see below
-                            }
-                            else
-#endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
-                            {
-                                ANALYZE_PUTCHAR ('?');
-                                ANALYZE_NEWLINE ();
-                                ANALYZE_PRINTF ("error 3 manchester: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
-                                ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
-//                              irmp_busy_flag = FALSE;
-                                irmp_start_bit_detected = 0;                            // reset flags and wait for next start bit
-                                irmp_pause_time         = 0;
-                            }
-                        }
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_FDC_PROTOCOL == 1
-                        if (irmp_param2.protocol == IRMP_FDC_PROTOCOL && irmp_pulse_time >= FDC_PULSE_LEN_MIN && irmp_pulse_time <= FDC_PULSE_LEN_MAX)
-                        {
-                            if (irmp_pause_time >= FDC_1_PAUSE_LEN_MIN && irmp_pause_time <= FDC_1_PAUSE_LEN_MAX)
-                            {
-                                ANALYZE_PRINTF ("   1 (FDC)\n");
-                                irmp_store_bit2 (1);
-                            }
-                            else if (irmp_pause_time >= FDC_0_PAUSE_LEN_MIN && irmp_pause_time <= FDC_0_PAUSE_LEN_MAX)
-                            {
-                                ANALYZE_PRINTF ("   0 (FDC)\n");
-                                irmp_store_bit2 (0);
-                            }
-
-                            if (! irmp_param.protocol)
-                            {
-                                ANALYZE_PRINTF ("Switching to FDC protocol\n");
-                                memcpy (&irmp_param, &irmp_param2, sizeof (IRMP_PARAMETER));
-                                irmp_param2.protocol = 0;
-                                irmp_tmp_address = irmp_tmp_address2;
-                                irmp_tmp_command = irmp_tmp_command2;
-                            }
-                        }
-#endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_RCCAR_PROTOCOL == 1
-                        if (irmp_param2.protocol == IRMP_RCCAR_PROTOCOL && irmp_pulse_time >= RCCAR_PULSE_LEN_MIN && irmp_pulse_time <= RCCAR_PULSE_LEN_MAX)
-                        {
-                            if (irmp_pause_time >= RCCAR_1_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_1_PAUSE_LEN_MAX)
-                            {
-                                ANALYZE_PRINTF ("   1 (RCCAR)\n");
-                                irmp_store_bit2 (1);
-                            }
-                            else if (irmp_pause_time >= RCCAR_0_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_0_PAUSE_LEN_MAX)
-                            {
-                                ANALYZE_PRINTF ("   0 (RCCAR)\n");
-                                irmp_store_bit2 (0);
-                            }
-
-                            if (! irmp_param.protocol)
-                            {
-                                ANALYZE_PRINTF ("Switching to RCCAR protocol\n");
-                                memcpy (&irmp_param, &irmp_param2, sizeof (IRMP_PARAMETER));
-                                irmp_param2.protocol = 0;
-                                irmp_tmp_address = irmp_tmp_address2;
-                                irmp_tmp_command = irmp_tmp_command2;
-                            }
-                        }
-#endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
-
-                        last_pause      = irmp_pause_time;
-                        wait_for_space  = 0;
-                    }
-                    else
-#endif // IRMP_SUPPORT_MANCHESTER == 1
-
-#if IRMP_SUPPORT_SERIAL == 1
-                    if (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL)
-                    {
-                        while (irmp_bit < irmp_param.complete_len && irmp_pulse_time > irmp_param.pulse_1_len_max)
-                        {
-                            ANALYZE_PUTCHAR ('1');
-                            irmp_store_bit (1);
-
-                            if (irmp_pulse_time >= irmp_param.pulse_1_len_min)
-                            {
-                                irmp_pulse_time -= irmp_param.pulse_1_len_min;
-                            }
-                            else
-                            {
-                                irmp_pulse_time = 0;
-                            }
-                        }
-
-                        while (irmp_bit < irmp_param.complete_len && irmp_pause_time > irmp_param.pause_1_len_max)
-                        {
-                            ANALYZE_PUTCHAR ('0');
-                            irmp_store_bit (0);
-
-                            if (irmp_pause_time >= irmp_param.pause_1_len_min)
-                            {
-                                irmp_pause_time -= irmp_param.pause_1_len_min;
-                            }
-                            else
-                            {
-                                irmp_pause_time = 0;
-                            }
-                        }
-                        ANALYZE_NEWLINE ();
-                        wait_for_space = 0;
-                    }
-                    else
-#endif // IRMP_SUPPORT_SERIAL == 1
-
-#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
-                    if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit == 16)       // Samsung: 16th bit
-                    {
-                        if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_PULSE_LEN_MAX &&
-                            irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_START_BIT_PAUSE_LEN_MAX)
-                        {
-                            ANALYZE_PRINTF ("SYNC\n");
-                            wait_for_space = 0;
-                            irmp_tmp_id = 0;
-                            irmp_bit++;
-                        }
-                        else  if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_PULSE_LEN_MAX)
-                        {
-                            irmp_param.protocol         = IRMP_SAMSUNG32_PROTOCOL;
-                            irmp_param.command_offset   = SAMSUNG32_COMMAND_OFFSET;
-                            irmp_param.command_end      = SAMSUNG32_COMMAND_OFFSET + SAMSUNG32_COMMAND_LEN;
-                            irmp_param.complete_len     = SAMSUNG32_COMPLETE_DATA_LEN;
-
-                            if (irmp_pause_time >= SAMSUNG_1_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_1_PAUSE_LEN_MAX)
-                            {
-                                ANALYZE_PUTCHAR ('1');
-                                ANALYZE_NEWLINE ();
-                                irmp_store_bit (1);
-                                wait_for_space = 0;
-                            }
-                            else
-                            {
-                                ANALYZE_PUTCHAR ('0');
-                                ANALYZE_NEWLINE ();
-                                irmp_store_bit (0);
-                                wait_for_space = 0;
-                            }
-
-                            ANALYZE_PRINTF ("Switching to SAMSUNG32 protocol\n");
-                        }
-                        else
-                        {                                                           // timing incorrect!
-                            ANALYZE_PRINTF ("error 3 Samsung: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
-                            ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
-//                          irmp_busy_flag = FALSE;
-                            irmp_start_bit_detected = 0;                            // reset flags and wait for next start bit
-                            irmp_pause_time         = 0;
-                        }
-                    }
-                    else
-#endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL
-
-#if IRMP_SUPPORT_NEC16_PROTOCOL
-#if IRMP_SUPPORT_NEC42_PROTOCOL == 1
-                    if (irmp_param.protocol == IRMP_NEC42_PROTOCOL &&
-#else // IRMP_SUPPORT_NEC_PROTOCOL instead
-                    if (irmp_param.protocol == IRMP_NEC_PROTOCOL &&
-#endif // IRMP_SUPPORT_NEC42_PROTOCOL == 1
-                        irmp_bit == 8 && irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_START_BIT_PAUSE_LEN_MAX)
-                    {
-                        ANALYZE_PRINTF ("Switching to NEC16 protocol\n");
-                        irmp_param.protocol         = IRMP_NEC16_PROTOCOL;
-                        irmp_param.address_offset   = NEC16_ADDRESS_OFFSET;
-                        irmp_param.address_end      = NEC16_ADDRESS_OFFSET + NEC16_ADDRESS_LEN;
-                        irmp_param.command_offset   = NEC16_COMMAND_OFFSET;
-                        irmp_param.command_end      = NEC16_COMMAND_OFFSET + NEC16_COMMAND_LEN;
-                        irmp_param.complete_len     = NEC16_COMPLETE_DATA_LEN;
-                        wait_for_space = 0;
-                    }
-                    else
-#endif // IRMP_SUPPORT_NEC16_PROTOCOL
-
-#if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
-                    if (irmp_param.protocol == IRMP_BANG_OLUFSEN_PROTOCOL)
-                    {
-                        if (irmp_pulse_time >= BANG_OLUFSEN_PULSE_LEN_MIN && irmp_pulse_time <= BANG_OLUFSEN_PULSE_LEN_MAX)
-                        {
-                            if (irmp_bit == 1)                                      // Bang & Olufsen: 3rd bit
-                            {
-                                if (irmp_pause_time >= BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MAX)
-                                {
-                                    ANALYZE_PRINTF ("3rd start bit\n");
-                                    wait_for_space = 0;
-                                    irmp_bit++;
-                                }
-                                else
-                                {                                                   // timing incorrect!
-                                    ANALYZE_PRINTF ("error 3a B&O: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
-                                    ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
-//                                  irmp_busy_flag = FALSE;
-                                    irmp_start_bit_detected = 0;                    // reset flags and wait for next start bit
-                                    irmp_pause_time         = 0;
-                                }
-                            }
-                            else if (irmp_bit == 19)                                // Bang & Olufsen: trailer bit
-                            {
-                                if (irmp_pause_time >= BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MAX)
-                                {
-                                    ANALYZE_PRINTF ("trailer bit\n");
-                                    wait_for_space = 0;
-                                    irmp_bit++;
-                                }
-                                else
-                                {                                                   // timing incorrect!
-                                    ANALYZE_PRINTF ("error 3b B&O: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
-                                    ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
-//                                  irmp_busy_flag = FALSE;
-                                    irmp_start_bit_detected = 0;                    // reset flags and wait for next start bit
-                                    irmp_pause_time         = 0;
-                                }
-                            }
-                            else
-                            {
-                                if (irmp_pause_time >= BANG_OLUFSEN_1_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_1_PAUSE_LEN_MAX)
-                                {                                                   // pulse & pause timings correct for "1"?
-                                    ANALYZE_PUTCHAR ('1');
-                                    ANALYZE_NEWLINE ();
-                                    irmp_store_bit (1);
-                                    last_value = 1;
-                                    wait_for_space = 0;
-                                }
-                                else if (irmp_pause_time >= BANG_OLUFSEN_0_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_0_PAUSE_LEN_MAX)
-                                {                                                   // pulse & pause timings correct for "0"?
-                                    ANALYZE_PUTCHAR ('0');
-                                    ANALYZE_NEWLINE ();
-                                    irmp_store_bit (0);
-                                    last_value = 0;
-                                    wait_for_space = 0;
-                                }
-                                else if (irmp_pause_time >= BANG_OLUFSEN_R_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_R_PAUSE_LEN_MAX)
-                                {
-                                    ANALYZE_PUTCHAR (last_value + '0');
-                                    ANALYZE_NEWLINE ();
-                                    irmp_store_bit (last_value);
-                                    wait_for_space = 0;
-                                }
-                                else
-                                {                                                   // timing incorrect!
-                                    ANALYZE_PRINTF ("error 3c B&O: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
-                                    ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
-//                                  irmp_busy_flag = FALSE;
-                                    irmp_start_bit_detected = 0;                    // reset flags and wait for next start bit
-                                    irmp_pause_time         = 0;
-                                }
-                            }
-                        }
-                        else
-                        {                                                           // timing incorrect!
-                            ANALYZE_PRINTF ("error 3d B&O: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
-                            ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
-//                          irmp_busy_flag = FALSE;
-                            irmp_start_bit_detected = 0;                            // reset flags and wait for next start bit
-                            irmp_pause_time         = 0;
-                        }
-                    }
-                    else
-#endif // IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL
-
-                    if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_param.pulse_1_len_max &&
-                        irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_param.pause_1_len_max)
-                    {                                                               // pulse & pause timings correct for "1"?
-                        ANALYZE_PUTCHAR ('1');
-                        ANALYZE_NEWLINE ();
-                        irmp_store_bit (1);
-                        wait_for_space = 0;
-                    }
-                    else if (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= irmp_param.pulse_0_len_max &&
-                             irmp_pause_time >= irmp_param.pause_0_len_min && irmp_pause_time <= irmp_param.pause_0_len_max)
-                    {                                                               // pulse & pause timings correct for "0"?
-                        ANALYZE_PUTCHAR ('0');
-                        ANALYZE_NEWLINE ();
-                        irmp_store_bit (0);
-                        wait_for_space = 0;
-                    }
-                    else
-#if IRMP_SUPPORT_KATHREIN_PROTOCOL
-
-                    if (irmp_param.protocol == IRMP_KATHREIN_PROTOCOL &&
-                        irmp_pulse_time >= KATHREIN_1_PULSE_LEN_MIN && irmp_pulse_time <= KATHREIN_1_PULSE_LEN_MAX &&
-                        (((irmp_bit == 8 || irmp_bit == 6) &&
-                                irmp_pause_time >= KATHREIN_SYNC_BIT_PAUSE_LEN_MIN && irmp_pause_time <= KATHREIN_SYNC_BIT_PAUSE_LEN_MAX) ||
-                         (irmp_bit == 12 &&
-                                irmp_pause_time >= KATHREIN_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= KATHREIN_START_BIT_PAUSE_LEN_MAX)))
-
-                    {
-                        if (irmp_bit == 8)
-                        {
-                            irmp_bit++;
-                            ANALYZE_PUTCHAR ('S');
-                            ANALYZE_NEWLINE ();
-                            irmp_tmp_command <<= 1;
-                        }
-                        else
-                        {
-                            ANALYZE_PUTCHAR ('S');
-                            ANALYZE_NEWLINE ();
-                            irmp_store_bit (1);
-                        }
-                        wait_for_space = 0;
-                    }
-                    else
-#endif // IRMP_SUPPORT_KATHREIN_PROTOCOL
-                    {                                                               // timing incorrect!
-                        ANALYZE_PRINTF ("error 3: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
-                        ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
-//                      irmp_busy_flag = FALSE;
-                        irmp_start_bit_detected = 0;                                // reset flags and wait for next start bit
-                        irmp_pause_time         = 0;
-                    }
-
-                    irmp_pulse_time = 1;                                            // set counter to 1, not 0
-                }
-            }
-            else
-            {                                                                       // counting the pulse length ...
-                if (! irmp_input)                                                   // still light?
-                {                                                                   // yes...
-                    irmp_pulse_time++;                                              // increment counter
-                }
-                else
-                {                                                                   // now it's dark!
-                    wait_for_space  = 1;                                            // let's count the time (see above)
-                    irmp_pause_time = 1;                                            // set pause counter to 1, not 0
-                }
-            }
-
-            if (irmp_start_bit_detected && irmp_bit == irmp_param.complete_len && irmp_param.stop_bit == 0)    // enough bits received?
-            {
-                if (last_irmp_command == irmp_tmp_command && repetition_len < AUTO_FRAME_REPETITION_LEN)
-                {
-                    repetition_frame_number++;
-                }
-                else
-                {
-                    repetition_frame_number = 0;
-                }
-
-#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
-                // if SIRCS protocol and the code will be repeated within 50 ms, we will ignore 2nd and 3rd repetition frame
-                if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL && (repetition_frame_number == 1 || repetition_frame_number == 2))
-                {
-                    ANALYZE_PRINTF ("code skipped: SIRCS auto repetition frame #%d, counter = %d, auto repetition len = %d\n",
-                                    repetition_frame_number + 1, repetition_len, AUTO_FRAME_REPETITION_LEN);
-                    repetition_len = 0;
-                }
-                else
-#endif
-
-#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
-                // if KASEIKYO protocol and the code will be repeated within 50 ms, we will ignore 2nd repetition frame
-                if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL && repetition_frame_number == 1)
-                {
-                    ANALYZE_PRINTF ("code skipped: KASEIKYO auto repetition frame #%d, counter = %d, auto repetition len = %d\n",
-                                    repetition_frame_number + 1, repetition_len, AUTO_FRAME_REPETITION_LEN);
-                    repetition_len = 0;
-                }
-                else
-#endif
-
-#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
-                // if SAMSUNG32 protocol and the code will be repeated within 50 ms, we will ignore every 2nd frame
-                if (irmp_param.protocol == IRMP_SAMSUNG32_PROTOCOL && (repetition_frame_number & 0x01))
-                {
-                    ANALYZE_PRINTF ("code skipped: SAMSUNG32 auto repetition frame #%d, counter = %d, auto repetition len = %d\n",
-                                    repetition_frame_number + 1, repetition_len, AUTO_FRAME_REPETITION_LEN);
-                    repetition_len = 0;
-                }
-                else
-#endif
-
-#if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
-                // if NUBERT protocol and the code will be repeated within 50 ms, we will ignore every 2nd frame
-                if (irmp_param.protocol == IRMP_NUBERT_PROTOCOL && (repetition_frame_number & 0x01))
-                {
-                    ANALYZE_PRINTF ("code skipped: NUBERT auto repetition frame #%d, counter = %d, auto repetition len = %d\n",
-                                    repetition_frame_number + 1, repetition_len, AUTO_FRAME_REPETITION_LEN);
-                    repetition_len = 0;
-                }
-                else
-#endif
-
-                {
-                    ANALYZE_PRINTF ("%8.3fms code detected, length = %d\n", (double) (time_counter * 1000) / F_INTERRUPTS, irmp_bit);
-                    irmp_ir_detected = TRUE;
-
-#if IRMP_SUPPORT_DENON_PROTOCOL == 1
-                    if (irmp_param.protocol == IRMP_DENON_PROTOCOL)
-                    {                                                               // check for repetition frame
-                        if ((~irmp_tmp_command & 0x3FF) == last_irmp_denon_command) // command bits must be inverted
-                        {
-                            irmp_tmp_command = last_irmp_denon_command;             // use command received before!
-
-                            irmp_protocol = irmp_param.protocol;                    // store protocol
-                            irmp_address = irmp_tmp_address;                        // store address
-                            irmp_command = irmp_tmp_command ;                       // store command
-                        }
-                        else
-                        {
-                            ANALYZE_PRINTF ("waiting for inverted command repetition\n");
-                            irmp_ir_detected = FALSE;
-                            last_irmp_denon_command = irmp_tmp_command;
-                        }
-                    }
-                    else
-#endif // IRMP_SUPPORT_DENON_PROTOCOL
-
-#if IRMP_SUPPORT_GRUNDIG_PROTOCOL == 1
-                    if (irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL && irmp_tmp_command == 0x01ff)
-                    {                                                               // Grundig start frame?
-                        ANALYZE_PRINTF ("Detected GRUNDIG start frame, ignoring it\n");
-                        irmp_ir_detected = FALSE;
-                    }
-                    else
-#endif // IRMP_SUPPORT_GRUNDIG_PROTOCOL
-
-#if IRMP_SUPPORT_NOKIA_PROTOCOL == 1
-                    if (irmp_param.protocol == IRMP_NOKIA_PROTOCOL && irmp_tmp_address == 0x00ff && irmp_tmp_command == 0x00fe)
-                    {                                                               // Nokia start frame?
-                        ANALYZE_PRINTF ("Detected NOKIA start frame, ignoring it\n");
-                        irmp_ir_detected = FALSE;
-                    }
-                    else
-#endif // IRMP_SUPPORT_NOKIA_PROTOCOL
-                    {
-#if IRMP_SUPPORT_NEC_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_NEC_PROTOCOL && irmp_bit == 0)  // repetition frame
-                        {
-                            if (repetition_len < NEC_FRAME_REPEAT_PAUSE_LEN_MAX)
-                            {
-                                ANALYZE_PRINTF ("Detected NEC repetition frame, repetition_len = %d\n", repetition_len);
-                                irmp_tmp_address = last_irmp_address;                   // address is last address
-                                irmp_tmp_command = last_irmp_command;                   // command is last command
-                                irmp_flags |= IRMP_FLAG_REPETITION;
-                                repetition_len = 0;
-                            }
-                            else
-                            {
-                                ANALYZE_PRINTF ("Detected NEC repetition frame, ignoring it: timeout occured, repetition_len = %d > %d\n",
-                                                repetition_len, NEC_FRAME_REPEAT_PAUSE_LEN_MAX);
-                                irmp_ir_detected = FALSE;
-                            }
-                        }
-#endif // IRMP_SUPPORT_NEC_PROTOCOL
-
-#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
-                        {
-                            uint8_t xor;
-                            // ANALYZE_PRINTF ("0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
-                            //                 xor_check[0], xor_check[1], xor_check[2], xor_check[3], xor_check[4], xor_check[5]);
-
-                            xor = (xor_check[0] & 0x0F) ^ ((xor_check[0] & 0xF0) >> 4) ^ (xor_check[1] & 0x0F) ^ ((xor_check[1] & 0xF0) >> 4);
-
-                            if (xor != (xor_check[2] & 0x0F))
-                            {
-                                ANALYZE_PRINTF ("error 4: wrong XOR check for customer id: 0x%1x 0x%1x\n", xor, xor_check[2] & 0x0F);
-                                irmp_ir_detected = FALSE;
-                            }
-
-                            xor = xor_check[2] ^ xor_check[3] ^ xor_check[4];
-
-                            if (xor != xor_check[5])
-                            {
-                                ANALYZE_PRINTF ("error 4: wrong XOR check for data bits: 0x%02x 0x%02x\n", xor, xor_check[5]);
-                                irmp_ir_detected = FALSE;
-                            }
-
-                            irmp_flags |= genre2;       // write the genre2 bits into MSB of the flag byte
-                        }
-#endif // IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
-
-#if IRMP_SUPPORT_RC6_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_param.complete_len == RC6_COMPLETE_DATA_LEN_LONG)     // RC6 mode = 6?
-                        {
-                            irmp_protocol = IRMP_RC6A_PROTOCOL;
-                        }
-                        else
-#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
-
-                        irmp_protocol = irmp_param.protocol;
-
-#if IRMP_SUPPORT_FDC_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_FDC_PROTOCOL)
-                        {
-                            if (irmp_tmp_command & 0x000F)                          // released key?
-                            {
-                                irmp_tmp_command = (irmp_tmp_command >> 4) | 0x80;  // yes, set bit 7
-                            }
-                            else
-                            {
-                                irmp_tmp_command >>= 4;                             // no, it's a pressed key
-                            }
-                            irmp_tmp_command |= (irmp_tmp_address << 2) & 0x0F00;   // 000000CCCCAAAAAA -> 0000CCCC00000000
-                            irmp_tmp_address &= 0x003F;
-                        }
-#endif
-
-                        irmp_address = irmp_tmp_address;                            // store address
-#if IRMP_SUPPORT_NEC_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_NEC_PROTOCOL)
-                        {
-                            last_irmp_address = irmp_tmp_address;                   // store as last address, too
-                        }
-#endif
-
-#if IRMP_SUPPORT_RC5_PROTOCOL == 1
-                        if (irmp_param.protocol == IRMP_RC5_PROTOCOL)
-                        {
-                            irmp_tmp_command |= rc5_cmd_bit6;                       // store bit 6
-                        }
-#endif
-                        irmp_command = irmp_tmp_command;                            // store command
-
-#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
-                        irmp_id = irmp_tmp_id;
-#endif
-                    }
-                }
-
-                if (irmp_ir_detected)
-                {
-                    if (last_irmp_command == irmp_tmp_command &&
-                        last_irmp_address == irmp_tmp_address &&
-                        repetition_len < IRMP_KEY_REPETITION_LEN)
-                    {
-                        irmp_flags |= IRMP_FLAG_REPETITION;
-                    }
-
-                    last_irmp_address = irmp_tmp_address;                           // store as last address, too
-                    last_irmp_command = irmp_tmp_command;                           // store as last command, too
-
-                    repetition_len = 0;
-                }
-                else
-                {
-                    ANALYZE_ONLY_NORMAL_PUTCHAR ('\n');
-                }
-
-//              irmp_busy_flag          = FALSE;
-                irmp_start_bit_detected = 0;                                        // and wait for next start bit
-                irmp_tmp_command        = 0;
-                irmp_pulse_time         = 0;
-                irmp_pause_time         = 0;
-
-#if IRMP_SUPPORT_JVC_PROTOCOL == 1
-                if (irmp_protocol == IRMP_JVC_PROTOCOL)                             // the stop bit of JVC frame is also start bit of next frame
-                {                                                                   // set pulse time here!
-                    irmp_pulse_time = ((uint8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME));
-                }
-#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
-            }
-        }
-    }
-    return (irmp_ir_detected);
-}
-
-#ifdef ANALYZE
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * main functions - for Unix/Linux + Windows only!
- *
- * AVR: see main.c!
- *
- * Compile it under linux with:
- * cc irmp.c -o irmp
- *
- * usage: ./irmp [-v|-s|-a|-l|-p] < file
- *
- * options:
- *   -v verbose
- *   -s silent
- *   -a analyze
- *   -l list pulse/pauses
- *   -p print timings
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-
-#ifndef IRMP_EMBED
-static void
-print_timings (void)
-{
-    printf ("IRMP_TIMEOUT_LEN:        %d [%d byte(s)]\n", IRMP_TIMEOUT_LEN, sizeof (PAUSE_LEN));
-    printf ("IRMP_KEY_REPETITION_LEN  %d\n", IRMP_KEY_REPETITION_LEN);
-    puts ("");
-    printf ("PROTOCOL       S  S-PULSE    S-PAUSE    PULSE-0    PAUSE-0    PULSE-1    PAUSE-1\n");
-    printf ("====================================================================================\n");
-    printf ("SIRCS          1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            SIRCS_START_BIT_PULSE_LEN_MIN, SIRCS_START_BIT_PULSE_LEN_MAX, SIRCS_START_BIT_PAUSE_LEN_MIN, SIRCS_START_BIT_PAUSE_LEN_MAX,
-            SIRCS_0_PULSE_LEN_MIN, SIRCS_0_PULSE_LEN_MAX, SIRCS_PAUSE_LEN_MIN, SIRCS_PAUSE_LEN_MAX,
-            SIRCS_1_PULSE_LEN_MIN, SIRCS_1_PULSE_LEN_MAX, SIRCS_PAUSE_LEN_MIN, SIRCS_PAUSE_LEN_MAX);
-
-    printf ("NEC            1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX, NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX,
-            NEC_PULSE_LEN_MIN, NEC_PULSE_LEN_MAX, NEC_0_PAUSE_LEN_MIN, NEC_0_PAUSE_LEN_MAX,
-            NEC_PULSE_LEN_MIN, NEC_PULSE_LEN_MAX, NEC_1_PAUSE_LEN_MIN, NEC_1_PAUSE_LEN_MAX);
-
-    printf ("NEC (rep)      1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX, NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BIT_PAUSE_LEN_MAX,
-            NEC_PULSE_LEN_MIN, NEC_PULSE_LEN_MAX, NEC_0_PAUSE_LEN_MIN, NEC_0_PAUSE_LEN_MAX,
-            NEC_PULSE_LEN_MIN, NEC_PULSE_LEN_MAX, NEC_1_PAUSE_LEN_MIN, NEC_1_PAUSE_LEN_MAX);
-
-    printf ("SAMSUNG        1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            SAMSUNG_START_BIT_PULSE_LEN_MIN, SAMSUNG_START_BIT_PULSE_LEN_MAX, SAMSUNG_START_BIT_PAUSE_LEN_MIN, SAMSUNG_START_BIT_PAUSE_LEN_MAX,
-            SAMSUNG_PULSE_LEN_MIN, SAMSUNG_PULSE_LEN_MAX, SAMSUNG_0_PAUSE_LEN_MIN, SAMSUNG_0_PAUSE_LEN_MAX,
-            SAMSUNG_PULSE_LEN_MIN, SAMSUNG_PULSE_LEN_MAX, SAMSUNG_1_PAUSE_LEN_MIN, SAMSUNG_1_PAUSE_LEN_MAX);
-
-    printf ("MATSUSHITA     1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            MATSUSHITA_START_BIT_PULSE_LEN_MIN, MATSUSHITA_START_BIT_PULSE_LEN_MAX, MATSUSHITA_START_BIT_PAUSE_LEN_MIN, MATSUSHITA_START_BIT_PAUSE_LEN_MAX,
-            MATSUSHITA_PULSE_LEN_MIN, MATSUSHITA_PULSE_LEN_MAX, MATSUSHITA_0_PAUSE_LEN_MIN, MATSUSHITA_0_PAUSE_LEN_MAX,
-            MATSUSHITA_PULSE_LEN_MIN, MATSUSHITA_PULSE_LEN_MAX, MATSUSHITA_1_PAUSE_LEN_MIN, MATSUSHITA_1_PAUSE_LEN_MAX);
-
-    printf ("KASEIKYO       1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            KASEIKYO_START_BIT_PULSE_LEN_MIN, KASEIKYO_START_BIT_PULSE_LEN_MAX, KASEIKYO_START_BIT_PAUSE_LEN_MIN, KASEIKYO_START_BIT_PAUSE_LEN_MAX,
-            KASEIKYO_PULSE_LEN_MIN, KASEIKYO_PULSE_LEN_MAX, KASEIKYO_0_PAUSE_LEN_MIN, KASEIKYO_0_PAUSE_LEN_MAX,
-            KASEIKYO_PULSE_LEN_MIN, KASEIKYO_PULSE_LEN_MAX, KASEIKYO_1_PAUSE_LEN_MIN, KASEIKYO_1_PAUSE_LEN_MAX);
-
-    printf ("RECS80         1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            RECS80_START_BIT_PULSE_LEN_MIN, RECS80_START_BIT_PULSE_LEN_MAX, RECS80_START_BIT_PAUSE_LEN_MIN, RECS80_START_BIT_PAUSE_LEN_MAX,
-            RECS80_PULSE_LEN_MIN, RECS80_PULSE_LEN_MAX, RECS80_0_PAUSE_LEN_MIN, RECS80_0_PAUSE_LEN_MAX,
-            RECS80_PULSE_LEN_MIN, RECS80_PULSE_LEN_MAX, RECS80_1_PAUSE_LEN_MIN, RECS80_1_PAUSE_LEN_MAX);
-
-    printf ("RC5            1  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX, RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
-            RC5_BIT_LEN_MIN, RC5_BIT_LEN_MAX);
-
-    printf ("DENON          1  %3d - %3d             %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX,
-            DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX, DENON_0_PAUSE_LEN_MIN, DENON_0_PAUSE_LEN_MAX,
-            DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX, DENON_1_PAUSE_LEN_MIN, DENON_1_PAUSE_LEN_MAX);
-
-    printf ("THOMSON        1  %3d - %3d             %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            THOMSON_PULSE_LEN_MIN, THOMSON_PULSE_LEN_MAX,
-            THOMSON_PULSE_LEN_MIN, THOMSON_PULSE_LEN_MAX, THOMSON_0_PAUSE_LEN_MIN, THOMSON_0_PAUSE_LEN_MAX,
-            THOMSON_PULSE_LEN_MIN, THOMSON_PULSE_LEN_MAX, THOMSON_1_PAUSE_LEN_MIN, THOMSON_1_PAUSE_LEN_MAX);
-
-    printf ("RC6            1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            RC6_START_BIT_PULSE_LEN_MIN, RC6_START_BIT_PULSE_LEN_MAX, RC6_START_BIT_PAUSE_LEN_MIN, RC6_START_BIT_PAUSE_LEN_MAX,
-            RC6_BIT_PULSE_LEN_MIN, RC6_BIT_PULSE_LEN_MAX, RC6_BIT_PAUSE_LEN_MIN, RC6_BIT_PAUSE_LEN_MAX);
-
-    printf ("RECS80EXT      1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            RECS80EXT_START_BIT_PULSE_LEN_MIN, RECS80EXT_START_BIT_PULSE_LEN_MAX, RECS80EXT_START_BIT_PAUSE_LEN_MIN, RECS80EXT_START_BIT_PAUSE_LEN_MAX,
-            RECS80EXT_PULSE_LEN_MIN, RECS80EXT_PULSE_LEN_MAX, RECS80EXT_0_PAUSE_LEN_MIN, RECS80EXT_0_PAUSE_LEN_MAX,
-            RECS80EXT_PULSE_LEN_MIN, RECS80EXT_PULSE_LEN_MAX, RECS80EXT_1_PAUSE_LEN_MIN, RECS80EXT_1_PAUSE_LEN_MAX);
-
-    printf ("NUBERT         1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            NUBERT_START_BIT_PULSE_LEN_MIN, NUBERT_START_BIT_PULSE_LEN_MAX, NUBERT_START_BIT_PAUSE_LEN_MIN, NUBERT_START_BIT_PAUSE_LEN_MAX,
-            NUBERT_0_PULSE_LEN_MIN, NUBERT_0_PULSE_LEN_MAX, NUBERT_0_PAUSE_LEN_MIN, NUBERT_0_PAUSE_LEN_MAX,
-            NUBERT_1_PULSE_LEN_MIN, NUBERT_1_PULSE_LEN_MAX, NUBERT_1_PAUSE_LEN_MIN, NUBERT_1_PAUSE_LEN_MAX);
-
-    printf ("BANG_OLUFSEN   1  %3d - %3d  %3d - %3d\n",
-            BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT1_PULSE_LEN_MAX,
-            BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MAX);
-
-    printf ("BANG_OLUFSEN   2  %3d - %3d  %3d - %3d\n",
-            BANG_OLUFSEN_START_BIT2_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT2_PULSE_LEN_MAX,
-            BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MAX);
-
-    printf ("BANG_OLUFSEN   3  %3d - %3d  %3d - %3d\n",
-            BANG_OLUFSEN_START_BIT3_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT3_PULSE_LEN_MAX,
-            BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MAX);
-
-    printf ("BANG_OLUFSEN   4  %3d - %3d  %3d - %3d\n",
-            BANG_OLUFSEN_START_BIT4_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT4_PULSE_LEN_MAX,
-            BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MAX);
-
-    printf ("BANG_OLUFSEN   -                        %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            BANG_OLUFSEN_PULSE_LEN_MIN, BANG_OLUFSEN_PULSE_LEN_MAX, BANG_OLUFSEN_0_PAUSE_LEN_MIN, BANG_OLUFSEN_0_PAUSE_LEN_MAX,
-            BANG_OLUFSEN_PULSE_LEN_MIN, BANG_OLUFSEN_PULSE_LEN_MAX, BANG_OLUFSEN_1_PAUSE_LEN_MIN, BANG_OLUFSEN_1_PAUSE_LEN_MAX);
-
-    printf ("GRUNDIG/NOKIA  1  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN, GRUNDIG_NOKIA_IR60_START_BIT_LEN_MAX,
-            GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN, GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MAX,
-            GRUNDIG_NOKIA_IR60_BIT_LEN_MIN, GRUNDIG_NOKIA_IR60_BIT_LEN_MAX);
-
-    printf ("SIEMENS/RUWIDO 1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN, SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX,
-            SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN, SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX,
-            SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN, SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX,
-            SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN, SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX,
-            2 * SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN, 2 * SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX,
-            2 * SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN, 2 * SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX);
-
-    printf ("GRUNDIG2       1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            GRUNDIG2_START_BIT_PULSE_LEN_MIN, GRUNDIG2_START_BIT_PULSE_LEN_MAX,
-            GRUNDIG2_START_BIT_PAUSE_LEN_MIN, GRUNDIG2_START_BIT_PAUSE_LEN_MAX,
-            GRUNDIG2_BIT_PULSE_LEN_MIN, GRUNDIG2_BIT_PULSE_LEN_MAX,
-            GRUNDIG2_BIT_PAUSE_LEN_MIN, GRUNDIG2_BIT_PAUSE_LEN_MAX,
-            2 * GRUNDIG2_BIT_PULSE_LEN_MIN, 2 * GRUNDIG2_BIT_PULSE_LEN_MAX,
-            2 * GRUNDIG2_BIT_PAUSE_LEN_MIN, 2 * GRUNDIG2_BIT_PAUSE_LEN_MAX);
-
-    printf ("FDC            1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            FDC_START_BIT_PULSE_LEN_MIN, FDC_START_BIT_PULSE_LEN_MAX, FDC_START_BIT_PAUSE_LEN_MIN, FDC_START_BIT_PAUSE_LEN_MAX,
-            FDC_PULSE_LEN_MIN, FDC_PULSE_LEN_MAX, FDC_0_PAUSE_LEN_MIN, FDC_0_PAUSE_LEN_MAX,
-            FDC_PULSE_LEN_MIN, FDC_PULSE_LEN_MAX, FDC_1_PAUSE_LEN_MIN, FDC_1_PAUSE_LEN_MAX);
-
-    printf ("RCCAR          1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            RCCAR_START_BIT_PULSE_LEN_MIN, RCCAR_START_BIT_PULSE_LEN_MAX, RCCAR_START_BIT_PAUSE_LEN_MIN, RCCAR_START_BIT_PAUSE_LEN_MAX,
-            RCCAR_PULSE_LEN_MIN, RCCAR_PULSE_LEN_MAX, RCCAR_0_PAUSE_LEN_MIN, RCCAR_0_PAUSE_LEN_MAX,
-            RCCAR_PULSE_LEN_MIN, RCCAR_PULSE_LEN_MAX, RCCAR_1_PAUSE_LEN_MIN, RCCAR_1_PAUSE_LEN_MAX);
-
-    printf ("NIKON          1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            NIKON_START_BIT_PULSE_LEN_MIN, NIKON_START_BIT_PULSE_LEN_MAX, NIKON_START_BIT_PAUSE_LEN_MIN, NIKON_START_BIT_PAUSE_LEN_MAX,
-            NIKON_PULSE_LEN_MIN, NIKON_PULSE_LEN_MAX, NIKON_0_PAUSE_LEN_MIN, NIKON_0_PAUSE_LEN_MAX,
-            NIKON_PULSE_LEN_MIN, NIKON_PULSE_LEN_MAX, NIKON_1_PAUSE_LEN_MIN, NIKON_1_PAUSE_LEN_MAX);
-
-    printf ("LEGO           1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
-            LEGO_START_BIT_PULSE_LEN_MIN, LEGO_START_BIT_PULSE_LEN_MAX, LEGO_START_BIT_PAUSE_LEN_MIN, LEGO_START_BIT_PAUSE_LEN_MAX,
-            LEGO_PULSE_LEN_MIN, LEGO_PULSE_LEN_MAX, LEGO_0_PAUSE_LEN_MIN, LEGO_0_PAUSE_LEN_MAX,
-            LEGO_PULSE_LEN_MIN, LEGO_PULSE_LEN_MAX, LEGO_1_PAUSE_LEN_MIN, LEGO_1_PAUSE_LEN_MAX);
-
-}
-
-void
-print_spectrum (char * text, int * buf, int is_pulse)
-{
-    int     i;
-    int     j;
-    int     min;
-    int     max;
-    int     max_value = 0;
-    int     value;
-    int     sum = 0;
-    int     counter = 0;
-    double  average = 0;
-    double  tolerance;
-
-    puts ("-------------------------------------------------------------------------------");
-    printf ("%s:\n", text);
-
-    for (i = 0; i < 256; i++)
-    {
-        if (buf[i] > max_value)
-        {
-            max_value = buf[i];
-        }
-    }
-
-    for (i = 1; i < 100; i++)
-    {
-        if (buf[i] > 0)
-        {
-            printf ("%3d ", i);
-            value = (buf[i] * 60) / max_value;
-
-            for (j = 0; j < value; j++)
-            {
-                putchar ('o');
-            }
-            printf (" %d\n", buf[i]);
-
-            sum += i * buf[i];
-            counter += buf[i];
-        }
-        else
-        {
-            max = i - 1;
-
-            if (counter > 0)
-            {
-                average = (float) sum / (float) counter;
-
-                if (is_pulse)
-                {
-                    printf ("pulse ");
-                }
-                else
-                {
-                    printf ("pause ");
-                }
-
-                printf ("avg: %4.1f=%6.1f us, ", average, (1000000. * average) / (float) F_INTERRUPTS);
-                printf ("min: %2d=%6.1f us, ", min, (1000000. * min) / (float) F_INTERRUPTS);
-                printf ("max: %2d=%6.1f us, ", max, (1000000. * max) / (float) F_INTERRUPTS);
-
-                tolerance = (max - average);
-
-                if (average - min > tolerance)
-                {
-                    tolerance = average - min;
-                }
-
-                tolerance = tolerance * 100 / average;
-                printf ("tol: %4.1f%%\n", tolerance);
-            }
-
-            counter = 0;
-            sum = 0;
-            min = i + 1;
-        }
-    }
-}
-#endif
-
-#define STATE_LEFT_SHIFT    0x01
-#define STATE_RIGHT_SHIFT   0x02
-#define STATE_LEFT_CTRL     0x04
-#define STATE_LEFT_ALT      0x08
-#define STATE_RIGHT_ALT     0x10
-
-#define KEY_ESCAPE          0x1B            // keycode = 0x006e
-#define KEY_MENUE           0x80            // keycode = 0x0070
-#define KEY_BACK            0x81            // keycode = 0x0071
-#define KEY_FORWARD         0x82            // keycode = 0x0072
-#define KEY_ADDRESS         0x83            // keycode = 0x0073
-#define KEY_WINDOW          0x84            // keycode = 0x0074
-#define KEY_1ST_PAGE        0x85            // keycode = 0x0075
-#define KEY_STOP            0x86            // keycode = 0x0076
-#define KEY_MAIL            0x87            // keycode = 0x0077
-#define KEY_FAVORITES       0x88            // keycode = 0x0078
-#define KEY_NEW_PAGE        0x89            // keycode = 0x0079
-#define KEY_SETUP           0x8A            // keycode = 0x007a
-#define KEY_FONT            0x8B            // keycode = 0x007b
-#define KEY_PRINT           0x8C            // keycode = 0x007c
-#define KEY_ON_OFF          0x8E            // keycode = 0x007c
-
-#define KEY_INSERT          0x90            // keycode = 0x004b
-#define KEY_DELETE          0x91            // keycode = 0x004c
-#define KEY_LEFT            0x92            // keycode = 0x004f
-#define KEY_HOME            0x93            // keycode = 0x0050
-#define KEY_END             0x94            // keycode = 0x0051
-#define KEY_UP              0x95            // keycode = 0x0053
-#define KEY_DOWN            0x96            // keycode = 0x0054
-#define KEY_PAGE_UP         0x97            // keycode = 0x0055
-#define KEY_PAGE_DOWN       0x98            // keycode = 0x0056
-#define KEY_RIGHT           0x99            // keycode = 0x0059
-#define KEY_MOUSE_1         0x9E            // keycode = 0x0400
-#define KEY_MOUSE_2         0x9F            // keycode = 0x0800
-
-#ifndef LIRC_IRMP
-static uint8_t
-get_fdc_key (uint16_t cmd)
-{
-    static uint8_t key_table[128] =
-    {
-     // 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
-        0,  '^', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'ß', '´',  0,  '\b',
-       '\t','q', 'w', 'e', 'r', 't', 'z', 'u', 'i', 'o', 'p', 'ü', '+',  0,   0,  'a',
-       's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'ö', 'ä', '#',  '\r', 0,  '<', 'y', 'x',
-       'c', 'v', 'b', 'n', 'm', ',', '.', '-',  0,   0,   0,   0,   0,  ' ',  0,   0,
-
-        0,  '°', '!', '"', '§', '$', '%', '&', '/', '(', ')', '=', '?', '`',  0,  '\b',
-       '\t','Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I', 'O', 'P', 'Ü', '*',  0,   0,  'A',
-       'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'Ö', 'Ä', '\'','\r', 0,  '>', 'Y', 'X',
-       'C', 'V', 'B', 'N', 'M', ';', ':', '_',  0,   0,   0,   0,   0,  ' ',  0,   0
-    };
-    static uint8_t state;
-
-    uint8_t key = 0;
-
-    switch (cmd)
-    {
-        case 0x002C: state |=  STATE_LEFT_SHIFT;    break;              // pressed left shift
-        case 0x00AC: state &= ~STATE_LEFT_SHIFT;    break;              // released left shift
-        case 0x0039: state |=  STATE_RIGHT_SHIFT;   break;              // pressed right shift
-        case 0x00B9: state &= ~STATE_RIGHT_SHIFT;   break;              // released right shift
-        case 0x003A: state |=  STATE_LEFT_CTRL;     break;              // pressed left ctrl
-        case 0x00BA: state &= ~STATE_LEFT_CTRL;     break;              // released left ctrl
-        case 0x003C: state |=  STATE_LEFT_ALT;      break;              // pressed left alt
-        case 0x00BC: state &= ~STATE_LEFT_ALT;      break;              // released left alt
-        case 0x003E: state |=  STATE_RIGHT_ALT;     break;              // pressed left alt
-        case 0x00BE: state &= ~STATE_RIGHT_ALT;     break;              // released left alt
-
-        case 0x006e: key = KEY_ESCAPE;              break;
-        case 0x004b: key = KEY_INSERT;              break;
-        case 0x004c: key = KEY_DELETE;              break;
-        case 0x004f: key = KEY_LEFT;                break;
-        case 0x0050: key = KEY_HOME;                break;
-        case 0x0051: key = KEY_END;                 break;
-        case 0x0053: key = KEY_UP;                  break;
-        case 0x0054: key = KEY_DOWN;                break;
-        case 0x0055: key = KEY_PAGE_UP;             break;
-        case 0x0056: key = KEY_PAGE_DOWN;           break;
-        case 0x0059: key = KEY_RIGHT;               break;
-        case 0x0400: key = KEY_MOUSE_1;             break;
-        case 0x0800: key = KEY_MOUSE_2;             break;
-
-        default:
-        {
-            if (!(cmd & 0x80))                      // pressed key
-            {
-                if (cmd >= 0x70 && cmd <= 0x7F)     // function keys
-                {
-                    key = cmd + 0x10;               // 7x -> 8x
-                }
-                else if (cmd < 64)                  // key listed in key_table
-                {
-                    if (state & (STATE_LEFT_ALT | STATE_RIGHT_ALT))
-                    {
-                        switch (cmd)
-                        {
-                            case 0x0003: key = '²';     break;
-                            case 0x0008: key = '{';     break;
-                            case 0x0009: key = '[';     break;
-                            case 0x000A: key = ']';     break;
-                            case 0x000B: key = '}';     break;
-                            case 0x000C: key = '\\';    break;
-                            case 0x001C: key = '~';     break;
-                            case 0x002D: key = '|';     break;
-                            case 0x0034: key = 0xB5;    break; // Mu
-                        }
-                    }
-                    else if (state & (STATE_LEFT_CTRL))
-                    {
-                        if (key_table[cmd] >= 'a' && key_table[cmd] <= 'z')
-                        {
-                            key = key_table[cmd] - 'a' + 1;
-                        }
-                        else
-                        {
-                            key = key_table[cmd];
-                        }
-                    }
-                    else
-                    {
-                        int idx = cmd + ((state & (STATE_LEFT_SHIFT | STATE_RIGHT_SHIFT)) ? 64 : 0);
-
-                        if (key_table[idx])
-                        {
-                            key = key_table[idx];
-                        }
-                    }
-                }
-            }
-            break;
-        }
-    }
-
-    return (key);
-}
-
-static int         analyze = FALSE;
-static int         list = FALSE;
-static IRMP_DATA   irmp_data;
-
-static void
-next_tick (void)
-{
-    if (! analyze && ! list)
-    {
-        (void) irmp_ISR ();
-
-        if (irmp_get_data (&irmp_data))
-        {
-            uint8_t key;
-
-            ANALYZE_ONLY_NORMAL_PUTCHAR (' ');
-
-            if (verbose)
-            {
-                printf ("%8.3fms ", (double) (time_counter * 1000) / F_INTERRUPTS);
-            }
-
-            if (irmp_data.protocol == IRMP_FDC_PROTOCOL && (key = get_fdc_key (irmp_data.command)) != 0)
-            {
-                if ((key >= 0x20 && key < 0x7F) || key >= 0xA0)
-                {
-                    printf ("p = %2d, a = 0x%04x, c = 0x%04x, f = 0x%02x, asc = 0x%02x, key = '%c'\n",
-                            irmp_data.protocol, irmp_data.address, irmp_data.command, irmp_data.flags, key, key);
-                }
-                else if (key == '\r' || key == '\t' || key == KEY_ESCAPE || (key >= 0x80 && key <= 0x9F))                 // function keys
-                {
-                    char * p = (char *) NULL;
-
-                    switch (key)
-                    {
-                        case '\t'                : p = "TAB";           break;
-                        case '\r'                : p = "CR";            break;
-                        case KEY_ESCAPE          : p = "ESCAPE";        break;
-                        case KEY_MENUE           : p = "MENUE";         break;
-                        case KEY_BACK            : p = "BACK";          break;
-                        case KEY_FORWARD         : p = "FORWARD";       break;
-                        case KEY_ADDRESS         : p = "ADDRESS";       break;
-                        case KEY_WINDOW          : p = "WINDOW";        break;
-                        case KEY_1ST_PAGE        : p = "1ST_PAGE";      break;
-                        case KEY_STOP            : p = "STOP";          break;
-                        case KEY_MAIL            : p = "MAIL";          break;
-                        case KEY_FAVORITES       : p = "FAVORITES";     break;
-                        case KEY_NEW_PAGE        : p = "NEW_PAGE";      break;
-                        case KEY_SETUP           : p = "SETUP";         break;
-                        case KEY_FONT            : p = "FONT";          break;
-                        case KEY_PRINT           : p = "PRINT";         break;
-                        case KEY_ON_OFF          : p = "ON_OFF";        break;
-
-                        case KEY_INSERT          : p = "INSERT";        break;
-                        case KEY_DELETE          : p = "DELETE";        break;
-                        case KEY_LEFT            : p = "LEFT";          break;
-                        case KEY_HOME            : p = "HOME";          break;
-                        case KEY_END             : p = "END";           break;
-                        case KEY_UP              : p = "UP";            break;
-                        case KEY_DOWN            : p = "DOWN";          break;
-                        case KEY_PAGE_UP         : p = "PAGE_UP";       break;
-                        case KEY_PAGE_DOWN       : p = "PAGE_DOWN";     break;
-                        case KEY_RIGHT           : p = "RIGHT";         break;
-                        case KEY_MOUSE_1         : p = "KEY_MOUSE_1";   break;
-                        case KEY_MOUSE_2         : p = "KEY_MOUSE_2";   break;
-                        default                  : p = "<UNKNWON>";     break;
-                    }
-
-                    printf ("p = %2d, a = 0x%04x, c = 0x%04x, f = 0x%02x, asc = 0x%02x, key = %s\n",
-                            irmp_data.protocol, irmp_data.address, irmp_data.command, irmp_data.flags, key, p);
-                }
-                else
-                {
-                    printf ("p = %2d, a = 0x%04x, c = 0x%04x, f = 0x%02x, asc = 0x%02x\n",
-                            irmp_data.protocol, irmp_data.address, irmp_data.command, irmp_data.flags, key);
-                }
-            }
-            else
-            {
-                printf ("p = %2d, a = 0x%04x, c = 0x%04x, f = 0x%02x\n",
-                        irmp_data.protocol, irmp_data.address, irmp_data.command, irmp_data.flags);
-            }
-        }
-    }
-}
-#endif
-
-#ifndef LIRC_IRMP
-int
-main (int argc, char ** argv)
-{
-    int         i;
-    int         ch;
-    int         last_ch = 0;
-    int         pulse = 0;
-    int         pause = 0;
-
-    int         start_pulses[256];
-    int         start_pauses[256];
-    int         pulses[256];
-    int         pauses[256];
-
-    int         first_pulse = TRUE;
-    int         first_pause = TRUE;
-
-    if (argc == 2)
-    {
-        if (! strcmp (argv[1], "-v"))
-        {
-            verbose = TRUE;
-        }
-        else if (! strcmp (argv[1], "-l"))
-        {
-            list = TRUE;
-        }
-        else if (! strcmp (argv[1], "-a"))
-        {
-            analyze = TRUE;
-        }
-        else if (! strcmp (argv[1], "-s"))
-        {
-            silent = TRUE;
-        }
-        else if (! strcmp (argv[1], "-p"))
-        {
-            print_timings ();
-            return (0);
-        }
-    }
-
-    for (i = 0; i < 256; i++)
-    {
-        start_pulses[i] = 0;
-        start_pauses[i] = 0;
-        pulses[i] = 0;
-        pauses[i] = 0;
-    }
-
-    IRMP_PIN = 0xFF;
-
-    while ((ch = getchar ()) != EOF)
-    {
-        if (ch == '_' || ch == '0')
-        {
-            if (last_ch != ch)
-            {
-                if (pause > 0)
-                {
-                    if (list)
-                    {
-                        printf ("pause: %d\n", pause);
-                    }
-
-                    if (analyze)
-                    {
-                        if (first_pause)
-                        {
-                            if (pause < 256)
-                            {
-                                start_pauses[pause]++;
-                            }
-                            first_pause = FALSE;
-                        }
-                        else
-                        {
-                            if (pause < 256)
-                            {
-                                pauses[pause]++;
-                            }
-                        }
-                    }
-                }
-                pause = 0;
-            }
-            pulse++;
-            IRMP_PIN = 0x00;
-        }
-        else if (ch == 0xaf || ch == '-' || ch == '1')
-        {
-            if (last_ch != ch)
-            {
-                if (list)
-                {
-                    printf ("pulse: %d ", pulse);
-                }
-
-                if (analyze)
-                {
-                    if (first_pulse)
-                    {
-                        if (pulse < 256)
-                        {
-                            start_pulses[pulse]++;
-                        }
-                        first_pulse = FALSE;
-                    }
-                    else
-                    {
-                        if (pulse < 256)
-                        {
-                            pulses[pulse]++;
-                        }
-                    }
-                }
-                pulse = 0;
-            }
-
-            pause++;
-            IRMP_PIN = 0xff;
-        }
-        else if (ch == '\n')
-        {
-            IRMP_PIN = 0xff;
-
-            if (list && pause > 0)
-            {
-                printf ("pause: %d\n", pause);
-            }
-            pause = 0;
-
-            if (! analyze)
-            {
-                for (i = 0; i < (int) ((8000.0 * F_INTERRUPTS) / 10000); i++)               // newline: long pause of 800 msec
-                {
-                    next_tick ();
-                }
-            }
-            first_pulse = TRUE;
-            first_pause = TRUE;
-        }
-        else if (ch == '#')
-        {
-            if (analyze)
-            {
-                while ((ch = getchar()) != '\n' && ch != EOF)
-                {
-                    ;
-                }
-            }
-            else
-            {
-                puts ("-------------------------------------------------------------------");
-                putchar (ch);
-
-                while ((ch = getchar()) != '\n' && ch != EOF)
-                {
-                    if (ch != '\r')                                                         // ignore CR in DOS/Windows files
-                    {
-                        putchar (ch);
-                    }
-                }
-                putchar ('\n');
-            }
-
-        }
-
-        last_ch = ch;
-
-        next_tick ();
-    }
-
-    if (analyze)
-    {
-        print_spectrum ("START PULSES", start_pulses, TRUE);
-        print_spectrum ("START PAUSES", start_pauses, FALSE);
-        print_spectrum ("PULSES", pulses, TRUE);
-        print_spectrum ("PAUSES", pauses, FALSE);
-        puts ("-------------------------------------------------------------------------------");
-    }
-    return 0;
-}
-#else
-#ifndef IRMP_EMBED
-/* 50 ms. This should be longer than the longest light pulse */
-#define POLL_MS		(50 * 1000)
-#define LIRC_PULSE	0x01000000
-#define LIRC_PULSE_MASK	0x00FFFFFF
-
-int main (int argc, char ** argv)
-{
-	int fd;
-	int pulse;
-	int last_pulse = 1;
-	uint32_t lircdata;	/* lirc_t to be correct... */
-	unsigned int count = 0;	/* how many timeouts? */
-	IRMP_DATA d;
-
-	silent = TRUE;
-
-	if (argc == 2)
-	{
-		if (! strcmp (argv[1], "-v"))
-		{
-			verbose = TRUE;
-			silent = FALSE;
-		}
-		else if (! strcmp (argv[1], "-p"))
-		{
-			print_timings ();
-			return (0);
-		}
-	}
-
-	IRMP_PIN = 0xFF;
-	fd = open("/dev/lirc", O_RDONLY);
-	if (fd < 0)
-	{
-		perror ("open /dev/lirc");
-		return 1;
-	}
-	/* TODO: ioctl to find out if we have a compatible LIRC_MODE2 device */
-
-	while(1)
-	{
-		fd_set fds;
-		struct timeval tv;
-		int ret;
-
-		FD_ZERO(&fds);
-		FD_SET(fd, &fds);
-		tv.tv_sec = 0;
-		tv.tv_usec = POLL_MS;
-		/* any singal can interrupt select. we rely on the linux-only feature
-		 * that the timeout is automatcally recalculated in this case! */
-		do {
-			ret = select(fd + 1, &fds, NULL, NULL, &tv);
-		} while (ret == -1 && errno == EINTR);
-
-		if (ret == -1) {
-			/* errno != EINTR... */
-			perror("lirmp: select");
-			break;
-		}
-
-		if (ret == 0)
-		{
-			count++;
-			lircdata = POLL_MS;	/* timeout */
-			pulse = !last_pulse;	/* lirc sends data on signal change */
-		}
-		else
-		{
-			if (read(fd, &lircdata, sizeof(lircdata)) != sizeof(lircdata))
-			{
-				perror("read");
-				break;
-			}
-			pulse = (lircdata & LIRC_PULSE);	/* we got light... */
-			last_pulse = pulse;
-			lircdata &= LIRC_PULSE_MASK;		/* how long the pulse was in microseconds */
-		}
-
-		if (ret && count)
-		{
-			if (count * POLL_MS > lircdata)
-				lircdata = 0;
-			else
-				lircdata -= count * POLL_MS;
-			count = 0;
-		}
-		//printf("lircdata: ret:%d c:%d %d\n", ret, ch - '0', lircdata);
-		lircdata /= (1000000 / F_INTERRUPTS);
-
-		if (pulse)
-			IRMP_PIN = 0x00;
-		else
-			IRMP_PIN = 0xff;
-
-		do {
-			(void) irmp_ISR ();
-			if (irmp_get_data (&d))
-			{
-				printf("protocol: %2d address: 0x%04x command: 0x%04x flags: %d\n",
-					d.protocol, d.address, d.command, d.flags);
-
-				/* do something else here... */
-
-				/* todo: do we need to complete the loop if we already
-				 * detected the singal in this pulse? */
-			}
-		} while (lircdata-- > 0);
-	}
-	return 0;
-}
-#endif // IRMP_EMBED
-#endif // LIRC_IRMP
-#endif // ANALYZE
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * irmp.c - infrared multi-protocol decoder, supports several remote control protocols
+ *
+ * Copyright (c) 2009-2011 Frank Meyer - frank(at)fli4l.de
+ *
+ * $Id: irmp.c,v 1.115 2012/02/21 08:41:46 fm Exp $
+ *
+ * ATMEGA88 @ 8 MHz
+ *
+ * Supported mikrocontrollers:
+ *
+ * ATtiny45,  ATtiny85
+ * ATtiny84
+ * ATmega8,   ATmega16,  ATmega32
+ * ATmega162
+ * ATmega164, ATmega324, ATmega644,  ATmega644P, ATmega1284
+ * ATmega88,  ATmega88P, ATmega168,  ATmega168P, ATmega328P
+ *
+ * Typical manufacturers of remote controls:
+ *
+ * SIRCS        - Sony
+ * NEC          - NEC, Yamaha, Canon, Tevion, Harman/Kardon, Hitachi, JVC, Pioneer, Toshiba, Xoro, Orion, and many other Japanese manufacturers
+ * SAMSUNG      - Samsung
+ * SAMSUNG32    - Samsung
+ * MATSUSHITA   - Matsushita
+ * KASEIKYO     - Panasonic, Denon & other Japanese manufacturers (members of "Japan's Association for Electric Home Application")
+ * RECS80       - Philips, Nokia, Thomson, Nordmende, Telefunken, Saba
+ * RC5          - Philips and other European manufacturers
+ * DENON        - Denon, Sharp
+ * RC6          - Philips and other European manufacturers
+ * APPLE        - Apple
+ * NUBERT       - Nubert Subwoofer System
+ * B&O          - Bang & Olufsen
+ * PANASONIC    - Panasonic (older, yet not implemented)
+ * GRUNDIG      - Grundig
+ * NOKIA        - Nokia
+ * SIEMENS      - Siemens, e.g. Gigaset M740AV
+ * FDC          - FDC IR keyboard
+ * RCCAR        - IR remote control for RC cars
+ * JVC          - JVC
+ * THOMSON      - Thomson
+ * NIKON        - Nikon cameras
+ * RUWIDO       - T-Home
+ * KATHREIN     - Kathrein
+ * LEGO         - Lego Power Functions RC
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   SIRCS
+ *   -----
+ *
+ *   frame: 1 start bit + 12-20 data bits + no stop bit
+ *   data:  7 command bits + 5 address bits + 0 to 8 additional bits
+ *
+ *   start bit:                           data "0":                 data "1":                 stop bit:
+ *   -----------------_________           ------_____               ------------______
+ *       2400us         600us             600us 600us               1200us      600 us        no stop bit
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   NEC + extended NEC
+ *   -------------------------
+ *
+ *   frame: 1 start bit + 32 data bits + 1 stop bit
+ *   data NEC:          8 address bits + 8 inverted address bits + 8 command bits + 8 inverted command bits
+ *   data extended NEC: 16 address bits + 8 command bits + 8 inverted command bits
+ *
+ *   start bit:                           data "0":                 data "1":                 stop bit:
+ *   -----------------_________           ------______              ------________________    ------______....
+ *       9000us        4500us             560us  560us              560us    1690 us          560us
+ *
+ *
+ *   Repetition frame:
+ *
+ *   -----------------_________------______  .... ~100ms Pause, then repeat
+ *       9000us        2250us   560us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   SAMSUNG
+ *   -------
+ *
+ *   frame: 1 start bit + 16 data(1) bits + 1 sync bit + additional 20 data(2) bits + 1 stop bit
+ *   data(1): 16 address bits
+ *   data(2): 4 ID bits + 8 command bits + 8 inverted command bits
+ *
+ *   start bit:                           data "0":                 data "1":                 sync bit:               stop bit:
+ *   ----------______________             ------______              ------________________    ------______________    ------______....
+ *    4500us       4500us                 550us  450us              550us    1450us           550us    4500us         550us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   SAMSUNG32
+ *   ----------
+ *
+ *   frame: 1 start bit + 32 data bits + 1 stop bit
+ *   data: 16 address bits + 16 command bits
+ *
+ *   start bit:                           data "0":                 data "1":                 stop bit:
+ *   ----------______________             ------______              ------________________    ------______....
+ *    4500us       4500us                 550us  450us              550us    1450us           550us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   MATSUSHITA
+ *   ----------
+ *
+ *   frame: 1 start bit + 24 data bits + 1 stop bit
+ *   data:  6 custom bits + 6 command bits + 12 address bits
+ *
+ *   start bit:                           data "0":                 data "1":                 stop bit:
+ *   ----------_________                  ------______              ------________________    ------______....
+ *    3488us     3488us                   872us  872us              872us    2616us           872us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   KASEIKYO
+ *   --------
+ *
+ *   frame: 1 start bit + 48 data bits + 1 stop bit
+ *   data:  16 manufacturer bits + 4 parity bits + 4 genre1 bits + 4 genre2 bits + 10 command bits + 2 id bits + 8 parity bits
+ *
+ *   start bit:                           data "0":                 data "1":                 stop bit:
+ *   ----------______                     ------______              ------________________    ------______....
+ *    3380us   1690us                     423us  423us              423us    1269us           423us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   RECS80
+ *   ------
+ *
+ *   frame: 2 start bits + 10 data bits + 1 stop bit
+ *   data:  1 toggle bit + 3 address bits + 6 command bits
+ *
+ *   start bit:                           data "0":                 data "1":                 stop bit:
+ *   -----_____________________           -----____________         -----______________       ------_______....
+ *   158us       7432us                   158us   4902us            158us    7432us           158us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   RECS80EXT
+ *   ---------
+ *
+ *   frame: 2 start bits + 11 data bits + 1 stop bit
+ *   data:  1 toggle bit + 4 address bits + 6 command bits
+ *
+ *   start bit:                           data "0":                 data "1":                 stop bit:
+ *   -----_____________________           -----____________         -----______________       ------_______....
+ *   158us       3637us                   158us   4902us            158us    7432us           158us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   RC5 + RC5X
+ *   ----------
+ *
+ *   RC5 frame:  2 start bits + 12 data bits + no stop bit
+ *   RC5 data:   1 toggle bit + 5 address bits + 6 command bits
+ *   RC5X frame: 1 start bit +  13 data bits + no stop bit
+ *   RC5X data:  1 inverted command bit + 1 toggle bit + 5 address bits + 6 command bits
+ *
+ *   start bit:              data "0":                data "1":
+ *   ______-----             ------______             ______------
+ *   889us 889us             889us 889us              889us 889us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   DENON
+ *   -----
+ *
+ *   frame: 0 start bits + 16 data bits + stop bit + 65ms pause + 16 inverted data bits + stop bit
+ *   data:  5 address bits + 10 command bits
+ *
+ *   Theory:
+ *
+ *   data "0":                 data "1":
+ *   ------________________    ------______________
+ *   275us       775us         275us   1900us
+ *
+ *   Practice:
+ *
+ *   data "0":                 data "1":
+ *   ------________________    ------______________
+ *   310us       745us         310us   1780us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   RC6
+ *   ---
+ *
+ *   RC6 frame:  1 start bit + 1 bit "1" + 3 mode bits + 1 toggle bit + 16 data bits + 2666 us pause
+ *   RC6 data:   8 address bits + 8 command bits
+ *
+ *   start  bit               toggle bit "0":      toggle bit "1":     data/mode "0":      data/mode "1":
+ *   ____________-------      _______-------       -------_______      _______-------      -------_______
+ *      2666us    889us        889us  889us         889us  889us        444us  444us        444us  444us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   APPLE
+ *   -----
+ *
+ *   frame: 1 start bit + 32 data bits + 1 stop bit
+ *   data:  16 address bits + 11100000 + 8 command bits
+ *
+ *   start bit:                           data "0":                 data "1":                 stop bit:
+ *   -----------------_________           ------______              ------________________    ------______....
+ *       9000us        4500us             560us  560us              560us    1690 us          560us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   NUBERT (subwoofer system)
+ *   -------------------------
+ *
+ *   frame: 1 start bit + 10 data bits + 1 stop bit
+ *   data:  0 address bits + 10 command bits ?
+ *
+ *   start bit:                       data "0":                 data "1":                 stop bit:
+ *   ----------_____                  ------______              ------________________    ------______....
+ *    1340us   340us                  500us 1300us              1340us 340us              500us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   BANG_OLUFSEN
+ *   ------------
+ *
+ *   frame: 4 start bits + 16 data bits + 1 trailer bit + 1 stop bit
+ *   data:  0 address bits + 16 command bits
+ *
+ *   1st start bit:  2nd start bit:      3rd start bit:       4th start bit:
+ *   -----________   -----________       -----_____________   -----________
+ *   210us 3000us    210us 3000us        210us   15000us      210us 3000us
+ *
+ *   data "0":       data "1":           data "repeat bit":   trailer bit:         stop bit:
+ *   -----________   -----_____________  -----___________     -----_____________   -----____...
+ *   210us 3000us    210us   9000us      210us   6000us       210us   12000us      210us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   GRUNDIG
+ *   -------
+ *
+ *   packet:  1 start frame + 19,968ms pause + N info frames + 117,76ms pause + 1 stop frame
+ *   frame: 1 pre bit + 1 start bit + 9 data bits + no stop bit
+ *   pause between info frames: 117,76ms
+ *
+ *   data of start frame:   9 x 1
+ *   data of info  frame:   9 command bits
+ *   data of stop  frame:   9 x 1
+ *
+ *   pre bit:              start bit           data "0":            data "1":
+ *   ------____________    ------______        ______------         ------______
+ *   528us  2639us         528us  528us        528us  528us         528us  528us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   NOKIA:
+ *   ------
+ *
+ *   Timing similar to Grundig, but 16 data bits:
+ *   frame: 1 pre bit + 1 start bit + 8 command bits + 8 address bits + no stop bit
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   SIEMENS or RUWIDO:
+ *   ------------------
+ *
+ *   SIEMENS frame:  1 start bit + 22 data bits + no stop bit
+ *   SIEMENS data:   13 address bits + 1 repeat bit + 7 data bits + 1 unknown bit
+ *
+ *   start  bit           data "0":            data "1":
+ *   -------_______       _______-------       -------_______
+ *    250us  250us         250us  250us         250us  250us
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ *   PANASONIC (older protocol, yet not implemented, see also MATSUSHITA, timing very similar)
+ *   -----------------------------------------------------------------------------------------
+ *
+ *   frame: 1 start bit + 22 data bits + 1 stop bit
+ *   22 data bits = 5 custom bits + 6 data bits + 5 inverted custom bits + 6 inverted data bits
+ *
+ *   European version:      T = 456us
+ *   USA & Canada version:  T = 422us
+ *
+ *   start bit:                           data "0":                 data "1":                 stop bit:
+ *        8T            8T                 2T   2T                   2T      6T                2T
+ *   -------------____________            ------_____               ------_____________       ------_______....
+ *      3648us        3648us              912us 912us               912us    2736us           912us                (Europe)
+ *      3376us        3376us              844us 844us               844us    2532us           844us                (US)
+ *
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+
+#if defined(__18CXX)
+#define PIC_C18                                                             // Microchip C18 Compiler
+#endif
+
+#if defined(__PCM__) || defined(__PCB__) || defined(__PCH__)                // CCS PIC Compiler instead of AVR
+#define PIC_CCS_COMPILER
+#endif
+
+#ifdef unix                                                                 // test on linux/unix
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+
+/* for crazy lirc stuff... */
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#define ANALYZE
+#define PROGMEM
+#define memcpy_P        memcpy
+
+#else // not unix:
+
+#ifdef WIN32
+#include <stdio.h>
+#include <string.h>
+typedef unsigned char   uint8_t;
+typedef unsigned short  uint16_t;
+#define ANALYZE
+#define PROGMEM
+#define memcpy_P        memcpy
+
+#else
+
+#if defined (PIC_CCS_COMPILER) || defined(PIC_C18)
+
+#include <string.h>
+#define PROGMEM
+#define memcpy_P        memcpy
+
+#if defined (PIC_CCS_COMPILER)
+typedef unsigned int8   uint8_t;
+typedef unsigned int16  uint16_t;
+#endif
+
+#else // AVR:
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+#include <avr/io.h>
+#include <util/delay.h>
+#include <avr/pgmspace.h>
+
+#endif  // PIC_CCS_COMPILER or PIC_C18
+
+#endif // windows
+#endif // unix
+
+#ifndef IRMP_USE_AS_LIB
+#include "irmpconfig.h"
+#endif
+#include "irmp.h"
+
+#if IRMP_SUPPORT_GRUNDIG_PROTOCOL == 1 || IRMP_SUPPORT_NOKIA_PROTOCOL == 1 || IRMP_SUPPORT_IR60_PROTOCOL == 1
+#define IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL  1
+#else
+#define IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL  0
+#endif
+
+#if IRMP_SUPPORT_SIEMENS_PROTOCOL == 1 || IRMP_SUPPORT_RUWIDO_PROTOCOL == 1
+#define IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL 1
+#else
+#define IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL 0
+#endif
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 ||                   \
+    IRMP_SUPPORT_RC6_PROTOCOL == 1 ||                   \
+    IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1 ||    \
+    IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1 ||     \
+    IRMP_SUPPORT_GRUNDIG2_PROTOCOL == 1 ||              \
+    IRMP_SUPPORT_IR60_PROTOCOL
+#define IRMP_SUPPORT_MANCHESTER                 1
+#else
+#define IRMP_SUPPORT_MANCHESTER                 0
+#endif
+
+#if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
+#define IRMP_SUPPORT_SERIAL                     1
+#else
+#define IRMP_SUPPORT_SERIAL                     0
+#endif
+
+#define IRMP_KEY_REPETITION_LEN                 (uint16_t)(F_INTERRUPTS * 150.0e-3 + 0.5)           // autodetect key repetition within 150 msec
+
+#define MIN_TOLERANCE_00                        1.0                           // -0%
+#define MAX_TOLERANCE_00                        1.0                           // +0%
+
+#define MIN_TOLERANCE_05                        0.95                          // -5%
+#define MAX_TOLERANCE_05                        1.05                          // +5%
+
+#define MIN_TOLERANCE_10                        0.9                           // -10%
+#define MAX_TOLERANCE_10                        1.1                           // +10%
+
+#define MIN_TOLERANCE_15                        0.85                          // -15%
+#define MAX_TOLERANCE_15                        1.15                          // +15%
+
+#define MIN_TOLERANCE_20                        0.8                           // -20%
+#define MAX_TOLERANCE_20                        1.2                           // +20%
+
+#define MIN_TOLERANCE_30                        0.7                           // -30%
+#define MAX_TOLERANCE_30                        1.3                           // +30%
+
+#define MIN_TOLERANCE_40                        0.6                           // -40%
+#define MAX_TOLERANCE_40                        1.4                           // +40%
+
+#define MIN_TOLERANCE_50                        0.5                           // -50%
+#define MAX_TOLERANCE_50                        1.5                           // +50%
+
+#define MIN_TOLERANCE_60                        0.4                           // -60%
+#define MAX_TOLERANCE_60                        1.6                           // +60%
+
+#define MIN_TOLERANCE_70                        0.3                           // -70%
+#define MAX_TOLERANCE_70                        1.7                           // +70%
+
+#define SIRCS_START_BIT_PULSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define SIRCS_START_BIT_PULSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define SIRCS_START_BIT_PAUSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#if IRMP_SUPPORT_NETBOX_PROTOCOL                // only 5% to avoid conflict with NETBOX:
+#define SIRCS_START_BIT_PAUSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUSE_TIME * MAX_TOLERANCE_05 + 0.5))
+#else                                           // only 5% + 1 to avoid conflict with RC6:
+#define SIRCS_START_BIT_PAUSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * SIRCS_START_BIT_PAUSE_TIME * MAX_TOLERANCE_05 + 0.5) + 1)
+#endif
+#define SIRCS_1_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * SIRCS_1_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define SIRCS_1_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * SIRCS_1_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define SIRCS_0_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * SIRCS_0_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define SIRCS_0_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * SIRCS_0_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define SIRCS_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * SIRCS_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define SIRCS_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * SIRCS_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define NEC_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PULSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define NEC_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PULSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+#define NEC_START_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define NEC_START_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * NEC_START_BIT_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+#define NEC_REPEAT_START_BIT_PAUSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * NEC_REPEAT_START_BIT_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define NEC_REPEAT_START_BIT_PAUSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * NEC_REPEAT_START_BIT_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+#define NEC_PULSE_LEN_MIN                       ((uint8_t)(F_INTERRUPTS * NEC_PULSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define NEC_PULSE_LEN_MAX                       ((uint8_t)(F_INTERRUPTS * NEC_PULSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+#define NEC_1_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * NEC_1_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define NEC_1_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * NEC_1_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+#define NEC_0_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * NEC_0_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define NEC_0_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * NEC_0_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+// autodetect nec repetition frame within 50 msec:
+// NEC seems to send the first repetition frame after 40ms, further repetition frames after 100 ms
+#if 0
+#define NEC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint16_t)(F_INTERRUPTS * NEC_FRAME_REPEAT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5)
+#else
+#define NEC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint16_t)(F_INTERRUPTS * 100.0e-3 * MAX_TOLERANCE_20 + 0.5)
+#endif
+
+#define SAMSUNG_START_BIT_PULSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define SAMSUNG_START_BIT_PULSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define SAMSUNG_START_BIT_PAUSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define SAMSUNG_START_BIT_PAUSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * SAMSUNG_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define SAMSUNG_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * SAMSUNG_PULSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define SAMSUNG_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * SAMSUNG_PULSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+#define SAMSUNG_1_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_1_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define SAMSUNG_1_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_1_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+#define SAMSUNG_0_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_0_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define SAMSUNG_0_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * SAMSUNG_0_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+
+#define MATSUSHITA_START_BIT_PULSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define MATSUSHITA_START_BIT_PULSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define MATSUSHITA_START_BIT_PAUSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define MATSUSHITA_START_BIT_PAUSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * MATSUSHITA_START_BIT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define MATSUSHITA_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * MATSUSHITA_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define MATSUSHITA_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * MATSUSHITA_PULSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+#define MATSUSHITA_1_PAUSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_1_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define MATSUSHITA_1_PAUSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_1_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+#define MATSUSHITA_0_PAUSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_0_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define MATSUSHITA_0_PAUSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * MATSUSHITA_0_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+
+#define KASEIKYO_START_BIT_PULSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define KASEIKYO_START_BIT_PULSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define KASEIKYO_START_BIT_PAUSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define KASEIKYO_START_BIT_PAUSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KASEIKYO_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define KASEIKYO_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * KASEIKYO_PULSE_TIME * MIN_TOLERANCE_50 + 0.5) - 1)
+#define KASEIKYO_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * KASEIKYO_PULSE_TIME * MAX_TOLERANCE_50 + 0.5) + 1)
+#define KASEIKYO_1_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KASEIKYO_1_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define KASEIKYO_1_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KASEIKYO_1_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+#define KASEIKYO_0_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KASEIKYO_0_PAUSE_TIME * MIN_TOLERANCE_50 + 0.5) - 1)
+#define KASEIKYO_0_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KASEIKYO_0_PAUSE_TIME * MAX_TOLERANCE_50 + 0.5) + 1)
+
+#define RECS80_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PULSE_TIME * MIN_TOLERANCE_00 + 0.5) - 1)
+#define RECS80_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RECS80_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RECS80_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * RECS80_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RECS80_PULSE_LEN_MIN                    ((uint8_t)(F_INTERRUPTS * RECS80_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RECS80_PULSE_LEN_MAX                    ((uint8_t)(F_INTERRUPTS * RECS80_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RECS80_1_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RECS80_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RECS80_1_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RECS80_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RECS80_0_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RECS80_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RECS80_0_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RECS80_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define RC5_START_BIT_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RC5_START_BIT_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define RC5_BIT_LEN_MIN                         ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RC5_BIT_LEN_MAX                         ((uint8_t)(F_INTERRUPTS * RC5_BIT_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define DENON_PULSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * DENON_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define DENON_PULSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * DENON_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define DENON_1_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * DENON_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define DENON_1_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * DENON_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
+#define DENON_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * DENON_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5))     // no -1, avoid conflict with RUWIDO
+#else
+#define DENON_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * DENON_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1) // be more tolerant
+#endif
+#define DENON_0_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * DENON_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define THOMSON_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * THOMSON_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define THOMSON_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * THOMSON_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define THOMSON_1_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * THOMSON_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define THOMSON_1_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * THOMSON_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define THOMSON_0_PAUSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * THOMSON_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define THOMSON_0_PAUSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * THOMSON_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define RC6_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RC6_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RC6_START_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RC6_START_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * RC6_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RC6_TOGGLE_BIT_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * RC6_TOGGLE_BIT_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RC6_TOGGLE_BIT_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * RC6_TOGGLE_BIT_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RC6_BIT_PULSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RC6_BIT_PULSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MAX_TOLERANCE_60 + 0.5) + 1)       // pulses: 300 - 800
+#define RC6_BIT_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RC6_BIT_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RC6_BIT_TIME * MAX_TOLERANCE_20 + 0.5) + 1)       // pauses: 300 - 600
+
+#define RECS80EXT_START_BIT_PULSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PULSE_TIME * MIN_TOLERANCE_00 + 0.5) - 1)
+#define RECS80EXT_START_BIT_PULSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PULSE_TIME * MAX_TOLERANCE_00 + 0.5) + 1)
+#define RECS80EXT_START_BIT_PAUSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PAUSE_TIME * MIN_TOLERANCE_05 + 0.5) - 1)
+#define RECS80EXT_START_BIT_PAUSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * RECS80EXT_START_BIT_PAUSE_TIME * MAX_TOLERANCE_05 + 0.5) + 1)
+#define RECS80EXT_PULSE_LEN_MIN                 ((uint8_t)(F_INTERRUPTS * RECS80EXT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RECS80EXT_PULSE_LEN_MAX                 ((uint8_t)(F_INTERRUPTS * RECS80EXT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RECS80EXT_1_PAUSE_LEN_MIN               ((uint8_t)(F_INTERRUPTS * RECS80EXT_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RECS80EXT_1_PAUSE_LEN_MAX               ((uint8_t)(F_INTERRUPTS * RECS80EXT_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RECS80EXT_0_PAUSE_LEN_MIN               ((uint8_t)(F_INTERRUPTS * RECS80EXT_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RECS80EXT_0_PAUSE_LEN_MAX               ((uint8_t)(F_INTERRUPTS * RECS80EXT_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define NUBERT_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NUBERT_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NUBERT_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NUBERT_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NUBERT_START_BIT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NUBERT_1_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NUBERT_1_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NUBERT_1_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NUBERT_1_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_1_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NUBERT_0_PULSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NUBERT_0_PULSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NUBERT_0_PAUSE_LEN_MIN                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NUBERT_0_PAUSE_LEN_MAX                  ((uint8_t)(F_INTERRUPTS * NUBERT_0_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+
+#define BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_START_BIT1_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_START_BIT2_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_START_BIT2_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT2_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_START_BIT3_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_START_BIT3_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MAX   ((PAUSE_LEN)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT3_PAUSE_TIME * MAX_TOLERANCE_05 + 0.5) + 1) // value must be below IRMP_TIMEOUT
+#define BANG_OLUFSEN_START_BIT4_PULSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_START_BIT4_PULSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MIN   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MAX   ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_START_BIT4_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_PULSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_PULSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_1_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_1_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_0_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_0_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_R_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_R_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_R_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_R_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MIN  ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_TRAILER_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MAX  ((uint8_t)(F_INTERRUPTS * BANG_OLUFSEN_TRAILER_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define IR60_TIMEOUT_LEN                        ((uint8_t)(F_INTERRUPTS * IR60_TIMEOUT_TIME * 0.5))
+#define GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define GRUNDIG_NOKIA_IR60_START_BIT_LEN_MAX    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define GRUNDIG_NOKIA_IR60_BIT_LEN_MIN          ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define GRUNDIG_NOKIA_IR60_BIT_LEN_MAX          ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_BIT_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_PRE_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) + 1)
+#define GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MAX    ((uint8_t)(F_INTERRUPTS * GRUNDIG_NOKIA_IR60_PRE_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+
+#define SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX       ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * SIEMENS_OR_RUWIDO_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define GRUNDIG2_START_BIT_PULSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * GRUNDIG2_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define GRUNDIG2_START_BIT_PULSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * GRUNDIG2_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define GRUNDIG2_START_BIT_PAUSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * GRUNDIG2_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define GRUNDIG2_START_BIT_PAUSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * GRUNDIG2_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define GRUNDIG2_BIT_PULSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * GRUNDIG2_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define GRUNDIG2_BIT_PULSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * GRUNDIG2_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define GRUNDIG2_BIT_PAUSE_LEN_MIN              ((uint8_t)(F_INTERRUPTS * GRUNDIG2_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define GRUNDIG2_BIT_PAUSE_LEN_MAX              ((uint8_t)(F_INTERRUPTS * GRUNDIG2_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define FDC_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PULSE_TIME * MIN_TOLERANCE_05 + 0.5) - 1)   // 5%: avoid conflict with NETBOX
+#define FDC_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PULSE_TIME * MAX_TOLERANCE_05 + 0.5))
+#define FDC_START_BIT_PAUSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PAUSE_TIME * MIN_TOLERANCE_05 + 0.5) - 1)
+#define FDC_START_BIT_PAUSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * FDC_START_BIT_PAUSE_TIME * MAX_TOLERANCE_05 + 0.5))
+#define FDC_PULSE_LEN_MIN                       ((uint8_t)(F_INTERRUPTS * FDC_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define FDC_PULSE_LEN_MAX                       ((uint8_t)(F_INTERRUPTS * FDC_PULSE_TIME * MAX_TOLERANCE_50 + 0.5) + 1)
+#define FDC_1_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * FDC_1_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define FDC_1_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * FDC_1_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#if 0
+#define FDC_0_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * FDC_0_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)   // could be negative: 255
+#else
+#define FDC_0_PAUSE_LEN_MIN                     (1)                                                                         // simply use 1
+#endif
+#define FDC_0_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * FDC_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define RCCAR_START_BIT_PULSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RCCAR_START_BIT_PULSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RCCAR_START_BIT_PAUSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define RCCAR_START_BIT_PAUSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * RCCAR_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define RCCAR_PULSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * RCCAR_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define RCCAR_PULSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * RCCAR_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define RCCAR_1_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RCCAR_1_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define RCCAR_1_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RCCAR_1_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+#define RCCAR_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * RCCAR_0_PAUSE_TIME * MIN_TOLERANCE_30 + 0.5) - 1)
+#define RCCAR_0_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * RCCAR_0_PAUSE_TIME * MAX_TOLERANCE_30 + 0.5) + 1)
+
+#define JVC_START_BIT_PULSE_LEN_MIN             ((uint8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define JVC_START_BIT_PULSE_LEN_MAX             ((uint8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+#define JVC_REPEAT_START_BIT_PAUSE_LEN_MIN      ((uint8_t)(F_INTERRUPTS * (JVC_FRAME_REPEAT_PAUSE_TIME - IRMP_TIMEOUT_TIME) * MIN_TOLERANCE_40 + 0.5) - 1)  // HACK!
+#define JVC_REPEAT_START_BIT_PAUSE_LEN_MAX      ((uint8_t)(F_INTERRUPTS * (JVC_FRAME_REPEAT_PAUSE_TIME - IRMP_TIMEOUT_TIME) * MAX_TOLERANCE_70 + 0.5) - 1)  // HACK!
+#define JVC_PULSE_LEN_MIN                       ((uint8_t)(F_INTERRUPTS * JVC_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define JVC_PULSE_LEN_MAX                       ((uint8_t)(F_INTERRUPTS * JVC_PULSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+#define JVC_1_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * JVC_1_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define JVC_1_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * JVC_1_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+#define JVC_0_PAUSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * JVC_0_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define JVC_0_PAUSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * JVC_0_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+// autodetect JVC repetition frame within 50 msec:
+#define JVC_FRAME_REPEAT_PAUSE_LEN_MAX          (uint16_t)(F_INTERRUPTS * JVC_FRAME_REPEAT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5)
+
+#define NIKON_START_BIT_PULSE_LEN_MIN           ((uint8_t)(F_INTERRUPTS * NIKON_START_BIT_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NIKON_START_BIT_PULSE_LEN_MAX           ((uint8_t)(F_INTERRUPTS * NIKON_START_BIT_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NIKON_START_BIT_PAUSE_LEN_MIN           ((uint16_t)(F_INTERRUPTS * NIKON_START_BIT_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NIKON_START_BIT_PAUSE_LEN_MAX           ((uint16_t)(F_INTERRUPTS * NIKON_START_BIT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NIKON_REPEAT_START_BIT_PAUSE_LEN_MIN    ((uint8_t)(F_INTERRUPTS * NIKON_REPEAT_START_BIT_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NIKON_REPEAT_START_BIT_PAUSE_LEN_MAX    ((uint8_t)(F_INTERRUPTS * NIKON_REPEAT_START_BIT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NIKON_PULSE_LEN_MIN                     ((uint8_t)(F_INTERRUPTS * NIKON_PULSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NIKON_PULSE_LEN_MAX                     ((uint8_t)(F_INTERRUPTS * NIKON_PULSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NIKON_1_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * NIKON_1_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NIKON_1_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * NIKON_1_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NIKON_0_PAUSE_LEN_MIN                   ((uint8_t)(F_INTERRUPTS * NIKON_0_PAUSE_TIME * MIN_TOLERANCE_20 + 0.5) - 1)
+#define NIKON_0_PAUSE_LEN_MAX                   ((uint8_t)(F_INTERRUPTS * NIKON_0_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5) + 1)
+#define NIKON_FRAME_REPEAT_PAUSE_LEN_MAX        (uint16_t)(F_INTERRUPTS * NIKON_FRAME_REPEAT_PAUSE_TIME * MAX_TOLERANCE_20 + 0.5)
+
+#define KATHREIN_START_BIT_PULSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define KATHREIN_START_BIT_PULSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define KATHREIN_START_BIT_PAUSE_LEN_MIN        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define KATHREIN_START_BIT_PAUSE_LEN_MAX        ((uint8_t)(F_INTERRUPTS * KATHREIN_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define KATHREIN_1_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define KATHREIN_1_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define KATHREIN_1_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define KATHREIN_1_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_1_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define KATHREIN_0_PULSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define KATHREIN_0_PULSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define KATHREIN_0_PAUSE_LEN_MIN                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define KATHREIN_0_PAUSE_LEN_MAX                ((uint8_t)(F_INTERRUPTS * KATHREIN_0_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define KATHREIN_SYNC_BIT_PAUSE_LEN_MIN         ((uint8_t)(F_INTERRUPTS * KATHREIN_SYNC_BIT_PAUSE_LEN_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define KATHREIN_SYNC_BIT_PAUSE_LEN_MAX         ((uint8_t)(F_INTERRUPTS * KATHREIN_SYNC_BIT_PAUSE_LEN_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+
+#define NETBOX_START_BIT_PULSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PULSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define NETBOX_START_BIT_PULSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PULSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define NETBOX_START_BIT_PAUSE_LEN_MIN          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PAUSE_TIME * MIN_TOLERANCE_10 + 0.5) - 1)
+#define NETBOX_START_BIT_PAUSE_LEN_MAX          ((uint8_t)(F_INTERRUPTS * NETBOX_START_BIT_PAUSE_TIME * MAX_TOLERANCE_10 + 0.5) + 1)
+#define NETBOX_PULSE_LEN                        ((uint8_t)(F_INTERRUPTS * NETBOX_PULSE_TIME))
+#define NETBOX_PAUSE_LEN                        ((uint8_t)(F_INTERRUPTS * NETBOX_PAUSE_TIME))
+#define NETBOX_PULSE_REST_LEN                   ((uint8_t)(F_INTERRUPTS * NETBOX_PULSE_TIME / 4))
+#define NETBOX_PAUSE_REST_LEN                   ((uint8_t)(F_INTERRUPTS * NETBOX_PAUSE_TIME / 4))
+
+#define LEGO_START_BIT_PULSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define LEGO_START_BIT_PULSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PULSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+#define LEGO_START_BIT_PAUSE_LEN_MIN            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define LEGO_START_BIT_PAUSE_LEN_MAX            ((uint8_t)(F_INTERRUPTS * LEGO_START_BIT_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+#define LEGO_PULSE_LEN_MIN                      ((uint8_t)(F_INTERRUPTS * LEGO_PULSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define LEGO_PULSE_LEN_MAX                      ((uint8_t)(F_INTERRUPTS * LEGO_PULSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+#define LEGO_1_PAUSE_LEN_MIN                    ((uint8_t)(F_INTERRUPTS * LEGO_1_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define LEGO_1_PAUSE_LEN_MAX                    ((uint8_t)(F_INTERRUPTS * LEGO_1_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+#define LEGO_0_PAUSE_LEN_MIN                    ((uint8_t)(F_INTERRUPTS * LEGO_0_PAUSE_TIME * MIN_TOLERANCE_40 + 0.5) - 1)
+#define LEGO_0_PAUSE_LEN_MAX                    ((uint8_t)(F_INTERRUPTS * LEGO_0_PAUSE_TIME * MAX_TOLERANCE_40 + 0.5) + 1)
+
+#define AUTO_FRAME_REPETITION_LEN               (uint16_t)(F_INTERRUPTS * AUTO_FRAME_REPETITION_TIME + 0.5)       // use uint16_t!
+
+#ifdef ANALYZE
+#define ANALYZE_PUTCHAR(a)                      { if (! silent)             { putchar (a);          } }
+#ifndef LIRC_IRMP
+#define ANALYZE_ONLY_NORMAL_PUTCHAR(a)          { if (! silent && !verbose) { putchar (a);          } }
+#else
+#define ANALYZE_ONLY_NORMAL_PUTCHAR(a)
+#endif
+#define ANALYZE_PRINTF(...)                     { if (verbose)              { printf (__VA_ARGS__); } }
+#define ANALYZE_NEWLINE()                       { if (verbose)              { putchar ('\n');       } }
+static int                                      silent = TRUE;
+static int                                      time_counter;
+static int                                      verbose;
+#else
+#define ANALYZE_PUTCHAR(a)
+#define ANALYZE_ONLY_NORMAL_PUTCHAR(a)
+#define ANALYZE_PRINTF(...)
+#define ANALYZE_NEWLINE()
+#endif
+
+#if IRMP_USE_CALLBACK == 1
+static void (*irmp_callback_ptr)(uint8_t);
+#endif // IRMP_USE_CALLBACK == 1
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ *  Protocol names
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#if IRMP_PROTOCOL_NAMES == 1
+char *
+irmp_protocol_names[IRMP_N_PROTOCOLS + 1] =
+{
+	"UNKNOWN",
+	"SIRCS",
+	"NEC",
+	"SAMSUNG",
+	"MATSUSH",
+	"KASEIKYO",
+	"RECS80",
+	"RC5",
+	"DENON",
+	"RC6",
+	"SAMSG32",
+	"APPLE",
+	"RECS80EX",
+	"NUBERT",
+	"BANG OLU",
+	"GRUNDIG",
+	"NOKIA",
+	"SIEMENS",
+	"FDC",
+	"RCCAR",
+	"JVC",
+	"RC6A",
+	"NIKON",
+	"RUWIDO",
+	"IR60",
+	"KATHREIN",
+	"NETBOX",
+	"NEC16",
+	"NEC42",
+	"LEGO",
+	"THOMSON"
+};
+#endif
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ *  Logging
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#if IRMP_LOGGING == 1                                               // logging via UART
+
+#if IRMP_EXT_LOGGING == 1                                           // use external logging
+#include "irmpextlog.h"
+#else                                                               // normal UART log (IRMP_EXT_LOGGING == 0)
+#define BAUD                                    9600L
+#include <util/setbaud.h>
+
+#ifdef UBRR0H
+
+#define UART0_UBRRH                             UBRR0H
+#define UART0_UBRRL                             UBRR0L
+#define UART0_UCSRA                             UCSR0A
+#define UART0_UCSRB                             UCSR0B
+#define UART0_UCSRC                             UCSR0C
+#define UART0_UDRE_BIT_VALUE                    (1<<UDRE0)
+#define UART0_UCSZ1_BIT_VALUE                   (1<<UCSZ01)
+#define UART0_UCSZ0_BIT_VALUE                   (1<<UCSZ00)
+#ifdef URSEL0
+#define UART0_URSEL_BIT_VALUE                   (1<<URSEL0)
+#else
+#define UART0_URSEL_BIT_VALUE                   (0)
+#endif
+#define UART0_TXEN_BIT_VALUE                    (1<<TXEN0)
+#define UART0_UDR                               UDR0
+#define UART0_U2X                               U2X0
+
+#else
+
+#define UART0_UBRRH                             UBRRH
+#define UART0_UBRRL                             UBRRL
+#define UART0_UCSRA                             UCSRA
+#define UART0_UCSRB                             UCSRB
+#define UART0_UCSRC                             UCSRC
+#define UART0_UDRE_BIT_VALUE                    (1<<UDRE)
+#define UART0_UCSZ1_BIT_VALUE                   (1<<UCSZ1)
+#define UART0_UCSZ0_BIT_VALUE                   (1<<UCSZ0)
+#ifdef URSEL
+#define UART0_URSEL_BIT_VALUE                   (1<<URSEL)
+#else
+#define UART0_URSEL_BIT_VALUE                   (0)
+#endif
+#define UART0_TXEN_BIT_VALUE                    (1<<TXEN)
+#define UART0_UDR                               UDR
+#define UART0_U2X                               U2X
+
+#endif //UBRR0H
+#endif //IRMP_EXT_LOGGING
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ *  Initialize  UART
+ *  @details  Initializes UART
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+void
+irmp_uart_init(void)
+{
+#if (IRMP_EXT_LOGGING == 0)                                                                         // use UART
+	UART0_UBRRH = UBRRH_VALUE;                                                                      // set baud rate
+	UART0_UBRRL = UBRRL_VALUE;
+
+#if USE_2X
+	UART0_UCSRA |= (1 << UART0_U2X);
+#else
+	UART0_UCSRA &= ~(1 << UART0_U2X);
+#endif
+
+	UART0_UCSRC = UART0_UCSZ1_BIT_VALUE | UART0_UCSZ0_BIT_VALUE | UART0_URSEL_BIT_VALUE;
+	UART0_UCSRB |= UART0_TXEN_BIT_VALUE;                                                            // enable UART TX
+#else                                                                                               // other log method
+	initextlog();
+#endif //IRMP_EXT_LOGGING
+}
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ *  Send character
+ *  @details  Sends character
+ *  @param    ch character to be transmitted
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+void
+irmp_uart_putc(unsigned char ch)
+{
+#if (IRMP_EXT_LOGGING == 0)
+	while (!(UART0_UCSRA & UART0_UDRE_BIT_VALUE))
+	{
+		;
+	}
+
+	UART0_UDR = ch;
+#else
+	sendextlog(ch); //Use external log
+#endif
+}
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ *  Log IR signal
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+
+#define STARTCYCLES                       2                                 // min count of zeros before start of logging
+#define ENDBITS                        1000                                 // number of sequenced highbits to detect end
+#define DATALEN                         700                                 // log buffer size
+
+static void
+irmp_log(uint8_t val)
+{
+	static uint8_t  buf[DATALEN];                                           // logging buffer
+	static uint16_t buf_idx;                                                // number of written bits
+	static uint8_t  startcycles;                                            // current number of start-zeros
+	static uint16_t cnt;                                                    // counts sequenced highbits - to detect end
+
+	if (! val && (startcycles < STARTCYCLES) && !buf_idx)                   // prevent that single random zeros init logging
+	{
+		startcycles++;
+	}
+	else
+	{
+		startcycles = 0;
+
+		if (! val || (val && buf_idx != 0))                                 // start or continue logging on "0", "1" cannot init logging
+		{
+			if (buf_idx < DATALEN * 8)                                      // index in range?
+			{
+				// yes
+				if (val)
+				{
+					buf[(buf_idx / 8)] |= (1 << (buf_idx % 8));             // set bit
+				}
+				else
+				{
+					buf[(buf_idx / 8)] &= ~(1 << (buf_idx % 8));            // reset bit
+				}
+
+				buf_idx++;
+			}
+
+			if (val)
+			{
+				// if high received then look at log-stop condition
+				cnt++;
+
+				if (cnt > ENDBITS)
+				{
+					// if stop condition is true, output on uart
+					uint16_t i;
+
+					for (i = 0; i < STARTCYCLES; i++)
+					{
+						irmp_uart_putc('0');                                // the ignored starting zeros
+					}
+
+					for (i = 0; i < (buf_idx - ENDBITS + 20) / 8; i++)      // transform bitset into uart chars
+					{
+						uint8_t d = buf[i];
+						uint8_t j;
+
+						for (j = 0; j < 8; j++)
+						{
+							irmp_uart_putc((d & 1) + '0');
+							d >>= 1;
+						}
+					}
+
+					irmp_uart_putc('\n');
+					buf_idx = 0;
+				}
+			}
+			else
+			{
+				cnt = 0;
+			}
+		}
+	}
+}
+
+#else
+#define irmp_log(val)
+#endif //IRMP_LOGGING
+
+typedef struct
+{
+	uint8_t    protocol;                                                // ir protocol
+	uint8_t    pulse_1_len_min;                                         // minimum length of pulse with bit value 1
+	uint8_t    pulse_1_len_max;                                         // maximum length of pulse with bit value 1
+	uint8_t    pause_1_len_min;                                         // minimum length of pause with bit value 1
+	uint8_t    pause_1_len_max;                                         // maximum length of pause with bit value 1
+	uint8_t    pulse_0_len_min;                                         // minimum length of pulse with bit value 0
+	uint8_t    pulse_0_len_max;                                         // maximum length of pulse with bit value 0
+	uint8_t    pause_0_len_min;                                         // minimum length of pause with bit value 0
+	uint8_t    pause_0_len_max;                                         // maximum length of pause with bit value 0
+	uint8_t    address_offset;                                          // address offset
+	uint8_t    address_end;                                             // end of address
+	uint8_t    command_offset;                                          // command offset
+	uint8_t    command_end;                                             // end of command
+	uint8_t    complete_len;                                            // complete length of frame
+	uint8_t    stop_bit;                                                // flag: frame has stop bit
+	uint8_t    lsb_first;                                               // flag: LSB first
+	uint8_t    flags;                                                   // some flags
+} IRMP_PARAMETER;
+
+#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER sircs_param =
+{
+	IRMP_SIRCS_PROTOCOL,                                                // protocol:        ir protocol
+	SIRCS_1_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum length of pulse with bit value 1
+	SIRCS_1_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum length of pulse with bit value 1
+	SIRCS_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum length of pause with bit value 1
+	SIRCS_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum length of pause with bit value 1
+	SIRCS_0_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum length of pulse with bit value 0
+	SIRCS_0_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum length of pulse with bit value 0
+	SIRCS_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum length of pause with bit value 0
+	SIRCS_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum length of pause with bit value 0
+	SIRCS_ADDRESS_OFFSET,                                               // address_offset:  address offset
+	SIRCS_ADDRESS_OFFSET + SIRCS_ADDRESS_LEN,                           // address_end:     end of address
+	SIRCS_COMMAND_OFFSET,                                               // command_offset:  command offset
+	SIRCS_COMMAND_OFFSET + SIRCS_COMMAND_LEN,                           // command_end:     end of command
+	SIRCS_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame
+	SIRCS_STOP_BIT,                                                     // stop_bit:        flag: frame has stop bit
+	SIRCS_LSB,                                                          // lsb_first:       flag: LSB first
+	SIRCS_FLAGS                                                         // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_NEC_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER nec_param =
+{
+	IRMP_NEC_PROTOCOL,                                                  // protocol:        ir protocol
+	NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum length of pulse with bit value 1
+	NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum length of pulse with bit value 1
+	NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum length of pause with bit value 1
+	NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum length of pause with bit value 1
+	NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum length of pulse with bit value 0
+	NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum length of pulse with bit value 0
+	NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum length of pause with bit value 0
+	NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum length of pause with bit value 0
+	NEC_ADDRESS_OFFSET,                                                 // address_offset:  address offset
+	NEC_ADDRESS_OFFSET + NEC_ADDRESS_LEN,                               // address_end:     end of address
+	NEC_COMMAND_OFFSET,                                                 // command_offset:  command offset
+	NEC_COMMAND_OFFSET + NEC_COMMAND_LEN,                               // command_end:     end of command
+	NEC_COMPLETE_DATA_LEN,                                              // complete_len:    complete length of frame
+	NEC_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
+	NEC_LSB,                                                            // lsb_first:       flag: LSB first
+	NEC_FLAGS                                                           // flags:           some flags
+};
+
+static const PROGMEM IRMP_PARAMETER nec_rep_param =
+{
+	IRMP_NEC_PROTOCOL,                                                  // protocol:        ir protocol
+	NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum length of pulse with bit value 1
+	NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum length of pulse with bit value 1
+	NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum length of pause with bit value 1
+	NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum length of pause with bit value 1
+	NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum length of pulse with bit value 0
+	NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum length of pulse with bit value 0
+	NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum length of pause with bit value 0
+	NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum length of pause with bit value 0
+	0,                                                                  // address_offset:  address offset
+	0,                                                                  // address_end:     end of address
+	0,                                                                  // command_offset:  command offset
+	0,                                                                  // command_end:     end of command
+	0,                                                                  // complete_len:    complete length of frame
+	NEC_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
+	NEC_LSB,                                                            // lsb_first:       flag: LSB first
+	NEC_FLAGS                                                           // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_NEC42_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER nec42_param =
+{
+	IRMP_NEC42_PROTOCOL,                                                // protocol:        ir protocol
+	NEC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum length of pulse with bit value 1
+	NEC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum length of pulse with bit value 1
+	NEC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum length of pause with bit value 1
+	NEC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum length of pause with bit value 1
+	NEC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum length of pulse with bit value 0
+	NEC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum length of pulse with bit value 0
+	NEC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum length of pause with bit value 0
+	NEC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum length of pause with bit value 0
+	NEC42_ADDRESS_OFFSET,                                               // address_offset:  address offset
+	NEC42_ADDRESS_OFFSET + NEC42_ADDRESS_LEN,                           // address_end:     end of address
+	NEC42_COMMAND_OFFSET,                                               // command_offset:  command offset
+	NEC42_COMMAND_OFFSET + NEC42_COMMAND_LEN,                           // command_end:     end of command
+	NEC42_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame
+	NEC_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
+	NEC_LSB,                                                            // lsb_first:       flag: LSB first
+	NEC_FLAGS                                                           // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER samsung_param =
+{
+	IRMP_SAMSUNG_PROTOCOL,                                              // protocol:        ir protocol
+	SAMSUNG_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum length of pulse with bit value 1
+	SAMSUNG_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum length of pulse with bit value 1
+	SAMSUNG_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum length of pause with bit value 1
+	SAMSUNG_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum length of pause with bit value 1
+	SAMSUNG_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum length of pulse with bit value 0
+	SAMSUNG_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum length of pulse with bit value 0
+	SAMSUNG_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum length of pause with bit value 0
+	SAMSUNG_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum length of pause with bit value 0
+	SAMSUNG_ADDRESS_OFFSET,                                             // address_offset:  address offset
+	SAMSUNG_ADDRESS_OFFSET + SAMSUNG_ADDRESS_LEN,                       // address_end:     end of address
+	SAMSUNG_COMMAND_OFFSET,                                             // command_offset:  command offset
+	SAMSUNG_COMMAND_OFFSET + SAMSUNG_COMMAND_LEN,                       // command_end:     end of command
+	SAMSUNG_COMPLETE_DATA_LEN,                                          // complete_len:    complete length of frame
+	SAMSUNG_STOP_BIT,                                                   // stop_bit:        flag: frame has stop bit
+	SAMSUNG_LSB,                                                        // lsb_first:       flag: LSB first
+	SAMSUNG_FLAGS                                                       // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER matsushita_param =
+{
+	IRMP_MATSUSHITA_PROTOCOL,                                           // protocol:        ir protocol
+	MATSUSHITA_PULSE_LEN_MIN,                                           // pulse_1_len_min: minimum length of pulse with bit value 1
+	MATSUSHITA_PULSE_LEN_MAX,                                           // pulse_1_len_max: maximum length of pulse with bit value 1
+	MATSUSHITA_1_PAUSE_LEN_MIN,                                         // pause_1_len_min: minimum length of pause with bit value 1
+	MATSUSHITA_1_PAUSE_LEN_MAX,                                         // pause_1_len_max: maximum length of pause with bit value 1
+	MATSUSHITA_PULSE_LEN_MIN,                                           // pulse_0_len_min: minimum length of pulse with bit value 0
+	MATSUSHITA_PULSE_LEN_MAX,                                           // pulse_0_len_max: maximum length of pulse with bit value 0
+	MATSUSHITA_0_PAUSE_LEN_MIN,                                         // pause_0_len_min: minimum length of pause with bit value 0
+	MATSUSHITA_0_PAUSE_LEN_MAX,                                         // pause_0_len_max: maximum length of pause with bit value 0
+	MATSUSHITA_ADDRESS_OFFSET,                                          // address_offset:  address offset
+	MATSUSHITA_ADDRESS_OFFSET + MATSUSHITA_ADDRESS_LEN,                 // address_end:     end of address
+	MATSUSHITA_COMMAND_OFFSET,                                          // command_offset:  command offset
+	MATSUSHITA_COMMAND_OFFSET + MATSUSHITA_COMMAND_LEN,                 // command_end:     end of command
+	MATSUSHITA_COMPLETE_DATA_LEN,                                       // complete_len:    complete length of frame
+	MATSUSHITA_STOP_BIT,                                                // stop_bit:        flag: frame has stop bit
+	MATSUSHITA_LSB,                                                     // lsb_first:       flag: LSB first
+	MATSUSHITA_FLAGS                                                    // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER kaseikyo_param =
+{
+	IRMP_KASEIKYO_PROTOCOL,                                             // protocol:        ir protocol
+	KASEIKYO_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum length of pulse with bit value 1
+	KASEIKYO_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum length of pulse with bit value 1
+	KASEIKYO_1_PAUSE_LEN_MIN,                                           // pause_1_len_min: minimum length of pause with bit value 1
+	KASEIKYO_1_PAUSE_LEN_MAX,                                           // pause_1_len_max: maximum length of pause with bit value 1
+	KASEIKYO_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum length of pulse with bit value 0
+	KASEIKYO_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum length of pulse with bit value 0
+	KASEIKYO_0_PAUSE_LEN_MIN,                                           // pause_0_len_min: minimum length of pause with bit value 0
+	KASEIKYO_0_PAUSE_LEN_MAX,                                           // pause_0_len_max: maximum length of pause with bit value 0
+	KASEIKYO_ADDRESS_OFFSET,                                            // address_offset:  address offset
+	KASEIKYO_ADDRESS_OFFSET + KASEIKYO_ADDRESS_LEN,                     // address_end:     end of address
+	KASEIKYO_COMMAND_OFFSET,                                            // command_offset:  command offset
+	KASEIKYO_COMMAND_OFFSET + KASEIKYO_COMMAND_LEN,                     // command_end:     end of command
+	KASEIKYO_COMPLETE_DATA_LEN,                                         // complete_len:    complete length of frame
+	KASEIKYO_STOP_BIT,                                                  // stop_bit:        flag: frame has stop bit
+	KASEIKYO_LSB,                                                       // lsb_first:       flag: LSB first
+	KASEIKYO_FLAGS                                                      // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_RECS80_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER recs80_param =
+{
+	IRMP_RECS80_PROTOCOL,                                               // protocol:        ir protocol
+	RECS80_PULSE_LEN_MIN,                                               // pulse_1_len_min: minimum length of pulse with bit value 1
+	RECS80_PULSE_LEN_MAX,                                               // pulse_1_len_max: maximum length of pulse with bit value 1
+	RECS80_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum length of pause with bit value 1
+	RECS80_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum length of pause with bit value 1
+	RECS80_PULSE_LEN_MIN,                                               // pulse_0_len_min: minimum length of pulse with bit value 0
+	RECS80_PULSE_LEN_MAX,                                               // pulse_0_len_max: maximum length of pulse with bit value 0
+	RECS80_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum length of pause with bit value 0
+	RECS80_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum length of pause with bit value 0
+	RECS80_ADDRESS_OFFSET,                                              // address_offset:  address offset
+	RECS80_ADDRESS_OFFSET + RECS80_ADDRESS_LEN,                         // address_end:     end of address
+	RECS80_COMMAND_OFFSET,                                              // command_offset:  command offset
+	RECS80_COMMAND_OFFSET + RECS80_COMMAND_LEN,                         // command_end:     end of command
+	RECS80_COMPLETE_DATA_LEN,                                           // complete_len:    complete length of frame
+	RECS80_STOP_BIT,                                                    // stop_bit:        flag: frame has stop bit
+	RECS80_LSB,                                                         // lsb_first:       flag: LSB first
+	RECS80_FLAGS                                                        // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER rc5_param =
+{
+	IRMP_RC5_PROTOCOL,                                                  // protocol:        ir protocol
+	RC5_BIT_LEN_MIN,                                                    // pulse_1_len_min: here: minimum length of short pulse
+	RC5_BIT_LEN_MAX,                                                    // pulse_1_len_max: here: maximum length of short pulse
+	RC5_BIT_LEN_MIN,                                                    // pause_1_len_min: here: minimum length of short pause
+	RC5_BIT_LEN_MAX,                                                    // pause_1_len_max: here: maximum length of short pause
+	0,                                                                  // pulse_0_len_min: here: not used
+	0,                                                                  // pulse_0_len_max: here: not used
+	0,                                                                  // pause_0_len_min: here: not used
+	0,                                                                  // pause_0_len_max: here: not used
+	RC5_ADDRESS_OFFSET,                                                 // address_offset:  address offset
+	RC5_ADDRESS_OFFSET + RC5_ADDRESS_LEN,                               // address_end:     end of address
+	RC5_COMMAND_OFFSET,                                                 // command_offset:  command offset
+	RC5_COMMAND_OFFSET + RC5_COMMAND_LEN,                               // command_end:     end of command
+	RC5_COMPLETE_DATA_LEN,                                              // complete_len:    complete length of frame
+	RC5_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
+	RC5_LSB,                                                            // lsb_first:       flag: LSB first
+	RC5_FLAGS                                                           // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_DENON_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER denon_param =
+{
+	IRMP_DENON_PROTOCOL,                                                // protocol:        ir protocol
+	DENON_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum length of pulse with bit value 1
+	DENON_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum length of pulse with bit value 1
+	DENON_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum length of pause with bit value 1
+	DENON_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum length of pause with bit value 1
+	DENON_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum length of pulse with bit value 0
+	DENON_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum length of pulse with bit value 0
+	DENON_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum length of pause with bit value 0
+	DENON_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum length of pause with bit value 0
+	DENON_ADDRESS_OFFSET,                                               // address_offset:  address offset
+	DENON_ADDRESS_OFFSET + DENON_ADDRESS_LEN,                           // address_end:     end of address
+	DENON_COMMAND_OFFSET,                                               // command_offset:  command offset
+	DENON_COMMAND_OFFSET + DENON_COMMAND_LEN,                           // command_end:     end of command
+	DENON_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame
+	DENON_STOP_BIT,                                                     // stop_bit:        flag: frame has stop bit
+	DENON_LSB,                                                          // lsb_first:       flag: LSB first
+	DENON_FLAGS                                                         // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_RC6_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER rc6_param =
+{
+	IRMP_RC6_PROTOCOL,                                                  // protocol:        ir protocol
+
+	RC6_BIT_PULSE_LEN_MIN,                                              // pulse_1_len_min: here: minimum length of short pulse
+	RC6_BIT_PULSE_LEN_MAX,                                              // pulse_1_len_max: here: maximum length of short pulse
+	RC6_BIT_PAUSE_LEN_MIN,                                              // pause_1_len_min: here: minimum length of short pause
+	RC6_BIT_PAUSE_LEN_MAX,                                              // pause_1_len_max: here: maximum length of short pause
+	0,                                                                  // pulse_0_len_min: here: not used
+	0,                                                                  // pulse_0_len_max: here: not used
+	0,                                                                  // pause_0_len_min: here: not used
+	0,                                                                  // pause_0_len_max: here: not used
+	RC6_ADDRESS_OFFSET,                                                 // address_offset:  address offset
+	RC6_ADDRESS_OFFSET + RC6_ADDRESS_LEN,                               // address_end:     end of address
+	RC6_COMMAND_OFFSET,                                                 // command_offset:  command offset
+	RC6_COMMAND_OFFSET + RC6_COMMAND_LEN,                               // command_end:     end of command
+	RC6_COMPLETE_DATA_LEN_SHORT,                                        // complete_len:    complete length of frame
+	RC6_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
+	RC6_LSB,                                                            // lsb_first:       flag: LSB first
+	RC6_FLAGS                                                           // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER recs80ext_param =
+{
+	IRMP_RECS80EXT_PROTOCOL,                                            // protocol:        ir protocol
+	RECS80EXT_PULSE_LEN_MIN,                                            // pulse_1_len_min: minimum length of pulse with bit value 1
+	RECS80EXT_PULSE_LEN_MAX,                                            // pulse_1_len_max: maximum length of pulse with bit value 1
+	RECS80EXT_1_PAUSE_LEN_MIN,                                          // pause_1_len_min: minimum length of pause with bit value 1
+	RECS80EXT_1_PAUSE_LEN_MAX,                                          // pause_1_len_max: maximum length of pause with bit value 1
+	RECS80EXT_PULSE_LEN_MIN,                                            // pulse_0_len_min: minimum length of pulse with bit value 0
+	RECS80EXT_PULSE_LEN_MAX,                                            // pulse_0_len_max: maximum length of pulse with bit value 0
+	RECS80EXT_0_PAUSE_LEN_MIN,                                          // pause_0_len_min: minimum length of pause with bit value 0
+	RECS80EXT_0_PAUSE_LEN_MAX,                                          // pause_0_len_max: maximum length of pause with bit value 0
+	RECS80EXT_ADDRESS_OFFSET,                                           // address_offset:  address offset
+	RECS80EXT_ADDRESS_OFFSET + RECS80EXT_ADDRESS_LEN,                   // address_end:     end of address
+	RECS80EXT_COMMAND_OFFSET,                                           // command_offset:  command offset
+	RECS80EXT_COMMAND_OFFSET + RECS80EXT_COMMAND_LEN,                   // command_end:     end of command
+	RECS80EXT_COMPLETE_DATA_LEN,                                        // complete_len:    complete length of frame
+	RECS80EXT_STOP_BIT,                                                 // stop_bit:        flag: frame has stop bit
+	RECS80EXT_LSB,                                                      // lsb_first:       flag: LSB first
+	RECS80EXT_FLAGS                                                     // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER nubert_param =
+{
+	IRMP_NUBERT_PROTOCOL,                                               // protocol:        ir protocol
+	NUBERT_1_PULSE_LEN_MIN,                                             // pulse_1_len_min: minimum length of pulse with bit value 1
+	NUBERT_1_PULSE_LEN_MAX,                                             // pulse_1_len_max: maximum length of pulse with bit value 1
+	NUBERT_1_PAUSE_LEN_MIN,                                             // pause_1_len_min: minimum length of pause with bit value 1
+	NUBERT_1_PAUSE_LEN_MAX,                                             // pause_1_len_max: maximum length of pause with bit value 1
+	NUBERT_0_PULSE_LEN_MIN,                                             // pulse_0_len_min: minimum length of pulse with bit value 0
+	NUBERT_0_PULSE_LEN_MAX,                                             // pulse_0_len_max: maximum length of pulse with bit value 0
+	NUBERT_0_PAUSE_LEN_MIN,                                             // pause_0_len_min: minimum length of pause with bit value 0
+	NUBERT_0_PAUSE_LEN_MAX,                                             // pause_0_len_max: maximum length of pause with bit value 0
+	NUBERT_ADDRESS_OFFSET,                                              // address_offset:  address offset
+	NUBERT_ADDRESS_OFFSET + NUBERT_ADDRESS_LEN,                         // address_end:     end of address
+	NUBERT_COMMAND_OFFSET,                                              // command_offset:  command offset
+	NUBERT_COMMAND_OFFSET + NUBERT_COMMAND_LEN,                         // command_end:     end of command
+	NUBERT_COMPLETE_DATA_LEN,                                           // complete_len:    complete length of frame
+	NUBERT_STOP_BIT,                                                    // stop_bit:        flag: frame has stop bit
+	NUBERT_LSB,                                                         // lsb_first:       flag: LSB first
+	NUBERT_FLAGS                                                        // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER bang_olufsen_param =
+{
+	IRMP_BANG_OLUFSEN_PROTOCOL,                                         // protocol:        ir protocol
+	BANG_OLUFSEN_PULSE_LEN_MIN,                                         // pulse_1_len_min: minimum length of pulse with bit value 1
+	BANG_OLUFSEN_PULSE_LEN_MAX,                                         // pulse_1_len_max: maximum length of pulse with bit value 1
+	BANG_OLUFSEN_1_PAUSE_LEN_MIN,                                       // pause_1_len_min: minimum length of pause with bit value 1
+	BANG_OLUFSEN_1_PAUSE_LEN_MAX,                                       // pause_1_len_max: maximum length of pause with bit value 1
+	BANG_OLUFSEN_PULSE_LEN_MIN,                                         // pulse_0_len_min: minimum length of pulse with bit value 0
+	BANG_OLUFSEN_PULSE_LEN_MAX,                                         // pulse_0_len_max: maximum length of pulse with bit value 0
+	BANG_OLUFSEN_0_PAUSE_LEN_MIN,                                       // pause_0_len_min: minimum length of pause with bit value 0
+	BANG_OLUFSEN_0_PAUSE_LEN_MAX,                                       // pause_0_len_max: maximum length of pause with bit value 0
+	BANG_OLUFSEN_ADDRESS_OFFSET,                                        // address_offset:  address offset
+	BANG_OLUFSEN_ADDRESS_OFFSET + BANG_OLUFSEN_ADDRESS_LEN,             // address_end:     end of address
+	BANG_OLUFSEN_COMMAND_OFFSET,                                        // command_offset:  command offset
+	BANG_OLUFSEN_COMMAND_OFFSET + BANG_OLUFSEN_COMMAND_LEN,             // command_end:     end of command
+	BANG_OLUFSEN_COMPLETE_DATA_LEN,                                     // complete_len:    complete length of frame
+	BANG_OLUFSEN_STOP_BIT,                                              // stop_bit:        flag: frame has stop bit
+	BANG_OLUFSEN_LSB,                                                   // lsb_first:       flag: LSB first
+	BANG_OLUFSEN_FLAGS                                                  // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
+
+static uint8_t first_bit;
+
+static const PROGMEM IRMP_PARAMETER grundig_param =
+{
+	IRMP_GRUNDIG_PROTOCOL,                                              // protocol:        ir protocol
+
+	GRUNDIG_NOKIA_IR60_BIT_LEN_MIN,                                     // pulse_1_len_min: here: minimum length of short pulse
+	GRUNDIG_NOKIA_IR60_BIT_LEN_MAX,                                     // pulse_1_len_max: here: maximum length of short pulse
+	GRUNDIG_NOKIA_IR60_BIT_LEN_MIN,                                     // pause_1_len_min: here: minimum length of short pause
+	GRUNDIG_NOKIA_IR60_BIT_LEN_MAX,                                     // pause_1_len_max: here: maximum length of short pause
+	0,                                                                  // pulse_0_len_min: here: not used
+	0,                                                                  // pulse_0_len_max: here: not used
+	0,                                                                  // pause_0_len_min: here: not used
+	0,                                                                  // pause_0_len_max: here: not used
+	GRUNDIG_ADDRESS_OFFSET,                                             // address_offset:  address offset
+	GRUNDIG_ADDRESS_OFFSET + GRUNDIG_ADDRESS_LEN,                       // address_end:     end of address
+	GRUNDIG_COMMAND_OFFSET,                                             // command_offset:  command offset
+	GRUNDIG_COMMAND_OFFSET + GRUNDIG_COMMAND_LEN + 1,                   // command_end:     end of command (USE 1 bit MORE to STORE NOKIA DATA!)
+	NOKIA_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame, here: NOKIA instead of GRUNDIG!
+	GRUNDIG_NOKIA_IR60_STOP_BIT,                                        // stop_bit:        flag: frame has stop bit
+	GRUNDIG_NOKIA_IR60_LSB,                                             // lsb_first:       flag: LSB first
+	GRUNDIG_NOKIA_IR60_FLAGS                                            // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER ruwido_param =
+{
+	IRMP_RUWIDO_PROTOCOL,                                               // protocol:        ir protocol
+	SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN,                                // pulse_1_len_min: here: minimum length of short pulse
+	SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX,                                // pulse_1_len_max: here: maximum length of short pulse
+	SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN,                                // pause_1_len_min: here: minimum length of short pause
+	SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX,                                // pause_1_len_max: here: maximum length of short pause
+	0,                                                                  // pulse_0_len_min: here: not used
+	0,                                                                  // pulse_0_len_max: here: not used
+	0,                                                                  // pause_0_len_min: here: not used
+	0,                                                                  // pause_0_len_max: here: not used
+	RUWIDO_ADDRESS_OFFSET,                                              // address_offset:  address offset
+	RUWIDO_ADDRESS_OFFSET + RUWIDO_ADDRESS_LEN,                         // address_end:     end of address
+	RUWIDO_COMMAND_OFFSET,                                              // command_offset:  command offset
+	RUWIDO_COMMAND_OFFSET + RUWIDO_COMMAND_LEN,                         // command_end:     end of command
+	SIEMENS_COMPLETE_DATA_LEN,                                          // complete_len:    complete length of frame, here: SIEMENS instead of RUWIDO!
+	SIEMENS_OR_RUWIDO_STOP_BIT,                                         // stop_bit:        flag: frame has stop bit
+	SIEMENS_OR_RUWIDO_LSB,                                              // lsb_first:       flag: LSB first
+	SIEMENS_OR_RUWIDO_FLAGS                                             // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_GRUNDIG2_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER grundig2_param =
+{
+	IRMP_GRUNDIG2_PROTOCOL,                                             // protocol:        ir protocol
+	GRUNDIG2_BIT_PULSE_LEN_MIN,                                         // pulse_1_len_min: here: minimum length of short pulse
+	GRUNDIG2_BIT_PULSE_LEN_MAX,                                         // pulse_1_len_max: here: maximum length of short pulse
+	GRUNDIG2_BIT_PAUSE_LEN_MIN,                                         // pause_1_len_min: here: minimum length of short pause
+	GRUNDIG2_BIT_PAUSE_LEN_MAX,                                         // pause_1_len_max: here: maximum length of short pause
+	0,                                                                  // pulse_0_len_min: here: not used
+	0,                                                                  // pulse_0_len_max: here: not used
+	0,                                                                  // pause_0_len_min: here: not used
+	0,                                                                  // pause_0_len_max: here: not used
+	GRUNDIG2_ADDRESS_OFFSET,                                            // address_offset:  address offset
+	GRUNDIG2_ADDRESS_OFFSET + GRUNDIG2_ADDRESS_LEN,                     // address_end:     end of address
+	GRUNDIG2_COMMAND_OFFSET,                                            // command_offset:  command offset
+	GRUNDIG2_COMMAND_OFFSET + GRUNDIG2_COMMAND_LEN,                     // command_end:     end of command
+	GRUNDIG2_COMPLETE_DATA_LEN,                                         // complete_len:    complete length of frame
+	GRUNDIG2_STOP_BIT,                                                  // stop_bit:        flag: frame has stop bit
+	GRUNDIG2_LSB,                                                       // lsb_first:       flag: LSB first
+	GRUNDIG2_FLAGS                                                      // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_FDC_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER fdc_param =
+{
+	IRMP_FDC_PROTOCOL,                                                  // protocol:        ir protocol
+	FDC_PULSE_LEN_MIN,                                                  // pulse_1_len_min: minimum length of pulse with bit value 1
+	FDC_PULSE_LEN_MAX,                                                  // pulse_1_len_max: maximum length of pulse with bit value 1
+	FDC_1_PAUSE_LEN_MIN,                                                // pause_1_len_min: minimum length of pause with bit value 1
+	FDC_1_PAUSE_LEN_MAX,                                                // pause_1_len_max: maximum length of pause with bit value 1
+	FDC_PULSE_LEN_MIN,                                                  // pulse_0_len_min: minimum length of pulse with bit value 0
+	FDC_PULSE_LEN_MAX,                                                  // pulse_0_len_max: maximum length of pulse with bit value 0
+	FDC_0_PAUSE_LEN_MIN,                                                // pause_0_len_min: minimum length of pause with bit value 0
+	FDC_0_PAUSE_LEN_MAX,                                                // pause_0_len_max: maximum length of pause with bit value 0
+	FDC_ADDRESS_OFFSET,                                                 // address_offset:  address offset
+	FDC_ADDRESS_OFFSET + FDC_ADDRESS_LEN,                               // address_end:     end of address
+	FDC_COMMAND_OFFSET,                                                 // command_offset:  command offset
+	FDC_COMMAND_OFFSET + FDC_COMMAND_LEN,                               // command_end:     end of command
+	FDC_COMPLETE_DATA_LEN,                                              // complete_len:    complete length of frame
+	FDC_STOP_BIT,                                                       // stop_bit:        flag: frame has stop bit
+	FDC_LSB,                                                            // lsb_first:       flag: LSB first
+	FDC_FLAGS                                                           // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER rccar_param =
+{
+	IRMP_RCCAR_PROTOCOL,                                                // protocol:        ir protocol
+	RCCAR_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum length of pulse with bit value 1
+	RCCAR_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum length of pulse with bit value 1
+	RCCAR_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum length of pause with bit value 1
+	RCCAR_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum length of pause with bit value 1
+	RCCAR_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum length of pulse with bit value 0
+	RCCAR_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum length of pulse with bit value 0
+	RCCAR_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum length of pause with bit value 0
+	RCCAR_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum length of pause with bit value 0
+	RCCAR_ADDRESS_OFFSET,                                               // address_offset:  address offset
+	RCCAR_ADDRESS_OFFSET + RCCAR_ADDRESS_LEN,                           // address_end:     end of address
+	RCCAR_COMMAND_OFFSET,                                               // command_offset:  command offset
+	RCCAR_COMMAND_OFFSET + RCCAR_COMMAND_LEN,                           // command_end:     end of command
+	RCCAR_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame
+	RCCAR_STOP_BIT,                                                     // stop_bit:        flag: frame has stop bit
+	RCCAR_LSB,                                                          // lsb_first:       flag: LSB first
+	RCCAR_FLAGS                                                         // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_NIKON_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER nikon_param =
+{
+	IRMP_NIKON_PROTOCOL,                                                // protocol:        ir protocol
+	NIKON_PULSE_LEN_MIN,                                                // pulse_1_len_min: minimum length of pulse with bit value 1
+	NIKON_PULSE_LEN_MAX,                                                // pulse_1_len_max: maximum length of pulse with bit value 1
+	NIKON_1_PAUSE_LEN_MIN,                                              // pause_1_len_min: minimum length of pause with bit value 1
+	NIKON_1_PAUSE_LEN_MAX,                                              // pause_1_len_max: maximum length of pause with bit value 1
+	NIKON_PULSE_LEN_MIN,                                                // pulse_0_len_min: minimum length of pulse with bit value 0
+	NIKON_PULSE_LEN_MAX,                                                // pulse_0_len_max: maximum length of pulse with bit value 0
+	NIKON_0_PAUSE_LEN_MIN,                                              // pause_0_len_min: minimum length of pause with bit value 0
+	NIKON_0_PAUSE_LEN_MAX,                                              // pause_0_len_max: maximum length of pause with bit value 0
+	NIKON_ADDRESS_OFFSET,                                               // address_offset:  address offset
+	NIKON_ADDRESS_OFFSET + NIKON_ADDRESS_LEN,                           // address_end:     end of address
+	NIKON_COMMAND_OFFSET,                                               // command_offset:  command offset
+	NIKON_COMMAND_OFFSET + NIKON_COMMAND_LEN,                           // command_end:     end of command
+	NIKON_COMPLETE_DATA_LEN,                                            // complete_len:    complete length of frame
+	NIKON_STOP_BIT,                                                     // stop_bit:        flag: frame has stop bit
+	NIKON_LSB,                                                          // lsb_first:       flag: LSB first
+	NIKON_FLAGS                                                         // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER kathrein_param =
+{
+	IRMP_KATHREIN_PROTOCOL,                                             // protocol:        ir protocol
+	KATHREIN_1_PULSE_LEN_MIN,                                           // pulse_1_len_min: minimum length of pulse with bit value 1
+	KATHREIN_1_PULSE_LEN_MAX,                                           // pulse_1_len_max: maximum length of pulse with bit value 1
+	KATHREIN_1_PAUSE_LEN_MIN,                                           // pause_1_len_min: minimum length of pause with bit value 1
+	KATHREIN_1_PAUSE_LEN_MAX,                                           // pause_1_len_max: maximum length of pause with bit value 1
+	KATHREIN_0_PULSE_LEN_MIN,                                           // pulse_0_len_min: minimum length of pulse with bit value 0
+	KATHREIN_0_PULSE_LEN_MAX,                                           // pulse_0_len_max: maximum length of pulse with bit value 0
+	KATHREIN_0_PAUSE_LEN_MIN,                                           // pause_0_len_min: minimum length of pause with bit value 0
+	KATHREIN_0_PAUSE_LEN_MAX,                                           // pause_0_len_max: maximum length of pause with bit value 0
+	KATHREIN_ADDRESS_OFFSET,                                            // address_offset:  address offset
+	KATHREIN_ADDRESS_OFFSET + KATHREIN_ADDRESS_LEN,                     // address_end:     end of address
+	KATHREIN_COMMAND_OFFSET,                                            // command_offset:  command offset
+	KATHREIN_COMMAND_OFFSET + KATHREIN_COMMAND_LEN,                     // command_end:     end of command
+	KATHREIN_COMPLETE_DATA_LEN,                                         // complete_len:    complete length of frame
+	KATHREIN_STOP_BIT,                                                  // stop_bit:        flag: frame has stop bit
+	KATHREIN_LSB,                                                       // lsb_first:       flag: LSB first
+	KATHREIN_FLAGS                                                      // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER netbox_param =
+{
+	IRMP_NETBOX_PROTOCOL,                                               // protocol:        ir protocol
+	NETBOX_PULSE_LEN,                                                   // pulse_1_len_min: minimum length of pulse with bit value 1, here: exact value
+	NETBOX_PULSE_REST_LEN,                                              // pulse_1_len_max: maximum length of pulse with bit value 1, here: rest value
+	NETBOX_PAUSE_LEN,                                                   // pause_1_len_min: minimum length of pause with bit value 1, here: exact value
+	NETBOX_PAUSE_REST_LEN,                                              // pause_1_len_max: maximum length of pause with bit value 1, here: rest value
+	NETBOX_PULSE_LEN,                                                   // pulse_0_len_min: minimum length of pulse with bit value 0, here: exact value
+	NETBOX_PULSE_REST_LEN,                                              // pulse_0_len_max: maximum length of pulse with bit value 0, here: rest value
+	NETBOX_PAUSE_LEN,                                                   // pause_0_len_min: minimum length of pause with bit value 0, here: exact value
+	NETBOX_PAUSE_REST_LEN,                                              // pause_0_len_max: maximum length of pause with bit value 0, here: rest value
+	NETBOX_ADDRESS_OFFSET,                                              // address_offset:  address offset
+	NETBOX_ADDRESS_OFFSET + NETBOX_ADDRESS_LEN,                         // address_end:     end of address
+	NETBOX_COMMAND_OFFSET,                                              // command_offset:  command offset
+	NETBOX_COMMAND_OFFSET + NETBOX_COMMAND_LEN,                         // command_end:     end of command
+	NETBOX_COMPLETE_DATA_LEN,                                           // complete_len:    complete length of frame
+	NETBOX_STOP_BIT,                                                    // stop_bit:        flag: frame has stop bit
+	NETBOX_LSB,                                                         // lsb_first:       flag: LSB first
+	NETBOX_FLAGS                                                        // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_LEGO_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER lego_param =
+{
+	IRMP_LEGO_PROTOCOL,                                                 // protocol:        ir protocol
+	LEGO_PULSE_LEN_MIN,                                                 // pulse_1_len_min: minimum length of pulse with bit value 1
+	LEGO_PULSE_LEN_MAX,                                                 // pulse_1_len_max: maximum length of pulse with bit value 1
+	LEGO_1_PAUSE_LEN_MIN,                                               // pause_1_len_min: minimum length of pause with bit value 1
+	LEGO_1_PAUSE_LEN_MAX,                                               // pause_1_len_max: maximum length of pause with bit value 1
+	LEGO_PULSE_LEN_MIN,                                                 // pulse_0_len_min: minimum length of pulse with bit value 0
+	LEGO_PULSE_LEN_MAX,                                                 // pulse_0_len_max: maximum length of pulse with bit value 0
+	LEGO_0_PAUSE_LEN_MIN,                                               // pause_0_len_min: minimum length of pause with bit value 0
+	LEGO_0_PAUSE_LEN_MAX,                                               // pause_0_len_max: maximum length of pause with bit value 0
+	LEGO_ADDRESS_OFFSET,                                                // address_offset:  address offset
+	LEGO_ADDRESS_OFFSET + LEGO_ADDRESS_LEN,                             // address_end:     end of address
+	LEGO_COMMAND_OFFSET,                                                // command_offset:  command offset
+	LEGO_COMMAND_OFFSET + LEGO_COMMAND_LEN,                             // command_end:     end of command
+	LEGO_COMPLETE_DATA_LEN,                                             // complete_len:    complete length of frame
+	LEGO_STOP_BIT,                                                      // stop_bit:        flag: frame has stop bit
+	LEGO_LSB,                                                           // lsb_first:       flag: LSB first
+	LEGO_FLAGS                                                          // flags:           some flags
+};
+
+#endif
+
+#if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
+
+static const PROGMEM IRMP_PARAMETER thomson_param =
+{
+	IRMP_THOMSON_PROTOCOL,                                              // protocol:        ir protocol
+	THOMSON_PULSE_LEN_MIN,                                              // pulse_1_len_min: minimum length of pulse with bit value 1
+	THOMSON_PULSE_LEN_MAX,                                              // pulse_1_len_max: maximum length of pulse with bit value 1
+	THOMSON_1_PAUSE_LEN_MIN,                                            // pause_1_len_min: minimum length of pause with bit value 1
+	THOMSON_1_PAUSE_LEN_MAX,                                            // pause_1_len_max: maximum length of pause with bit value 1
+	THOMSON_PULSE_LEN_MIN,                                              // pulse_0_len_min: minimum length of pulse with bit value 0
+	THOMSON_PULSE_LEN_MAX,                                              // pulse_0_len_max: maximum length of pulse with bit value 0
+	THOMSON_0_PAUSE_LEN_MIN,                                            // pause_0_len_min: minimum length of pause with bit value 0
+	THOMSON_0_PAUSE_LEN_MAX,                                            // pause_0_len_max: maximum length of pause with bit value 0
+	THOMSON_ADDRESS_OFFSET,                                             // address_offset:  address offset
+	THOMSON_ADDRESS_OFFSET + THOMSON_ADDRESS_LEN,                       // address_end:     end of address
+	THOMSON_COMMAND_OFFSET,                                             // command_offset:  command offset
+	THOMSON_COMMAND_OFFSET + THOMSON_COMMAND_LEN,                       // command_end:     end of command
+	THOMSON_COMPLETE_DATA_LEN,                                          // complete_len:    complete length of frame
+	THOMSON_STOP_BIT,                                                   // stop_bit:        flag: frame has stop bit
+	THOMSON_LSB,                                                        // lsb_first:       flag: LSB first
+	THOMSON_FLAGS                                                       // flags:           some flags
+};
+
+#endif
+
+static uint8_t                              irmp_bit;                   // current bit position
+static IRMP_PARAMETER                       irmp_param;
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
+static IRMP_PARAMETER                       irmp_param2;
+#endif
+
+static volatile uint8_t                     irmp_ir_detected;
+static volatile uint8_t                     irmp_protocol;
+static volatile uint16_t                    irmp_address;
+static volatile uint16_t                    irmp_command;
+static volatile uint16_t                    irmp_id;                    // only used for SAMSUNG protocol
+static volatile uint8_t                     irmp_flags;
+// static volatile uint8_t                     irmp_busy_flag;
+
+#ifdef ANALYZE
+static uint8_t                              IRMP_PIN;
+#endif
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ *  Initialize IRMP decoder
+ *  @details  Configures IRMP input pin
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#ifndef ANALYZE
+void
+irmp_init(void)
+{
+#ifndef ARDUINO
+#if !defined(PIC_CCS_COMPILER) && !defined(PIC_C18)                     // only AVR
+	IRMP_PORT &= ~(1 << IRMP_BIT);                                      // deactivate pullup
+	IRMP_DDR &= ~(1 << IRMP_BIT);                                       // set pin to input
+#endif
+
+#if IRMP_LOGGING == 1
+	irmp_uart_init();
+#endif
+#endif //ARDUINO
+}
+#endif
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ *  Get IRMP data
+ *  @details  gets decoded IRMP data
+ *  @param    pointer in order to store IRMP data
+ *  @return    TRUE: successful, FALSE: failed
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+uint8_t
+irmp_get_data(IRMP_DATA *irmp_data_p)
+{
+	uint8_t   rtc = FALSE;
+
+	if (irmp_ir_detected)
+	{
+		switch (irmp_protocol)
+		{
+#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
+			case IRMP_SAMSUNG_PROTOCOL:
+				if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
+				{
+					irmp_command &= 0xff;
+					irmp_command |= irmp_id << 8;
+					rtc = TRUE;
+				}
+				break;
+#endif
+#if IRMP_SUPPORT_NEC_PROTOCOL == 1
+			case IRMP_NEC_PROTOCOL:
+				if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
+				{
+					irmp_command &= 0xff;
+					rtc = TRUE;
+				}
+				else if (irmp_address == 0x87EE)
+				{
+					ANALYZE_PRINTF("Switching to APPLE protocol\n");
+					irmp_protocol = IRMP_APPLE_PROTOCOL;
+					irmp_address = (irmp_command & 0xFF00) >> 8;
+					irmp_command &= 0x00FF;
+					rtc = TRUE;
+				}
+				break;
+#endif
+#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
+			case IRMP_SIEMENS_PROTOCOL:
+			case IRMP_RUWIDO_PROTOCOL:
+				if (((irmp_command >> 1) & 0x0001) == (~irmp_command & 0x0001))
+				{
+					irmp_command >>= 1;
+					rtc = TRUE;
+				}
+				break;
+#endif
+#if IRMP_SUPPORT_GRUNDIG2_PROTOCOL == 1
+			case IRMP_GRUNDIG2_PROTOCOL:
+				if (irmp_command & 0x0001)
+				{
+					irmp_command >>= 1;
+					rtc = TRUE;
+				}
+				break;
+#endif
+#if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
+			case IRMP_KATHREIN_PROTOCOL:
+				if (irmp_command != 0x0000)
+				{
+					rtc = TRUE;
+				}
+				break;
+#endif
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1
+			case IRMP_RC5_PROTOCOL:
+				irmp_address &= ~0x20;                              // clear toggle bit
+				rtc = TRUE;
+				break;
+#endif
+#if IRMP_SUPPORT_IR60_PROTOCOL == 1
+			case IRMP_IR60_PROTOCOL:
+				if (irmp_command != 0x007d)                         // 0x007d (== 62<<1 + 1) is start instruction frame
+				{
+					rtc = TRUE;
+				}
+				break;
+#endif
+#if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
+			case IRMP_RCCAR_PROTOCOL:
+				// frame in irmp_data:
+				// Bit 12 11 10 9  8  7  6  5  4  3  2  1  0
+				//     V  D7 D6 D5 D4 D3 D2 D1 D0 A1 A0 C1 C0   //         10 9  8  7  6  5  4  3  2  1  0
+				irmp_address = (irmp_command & 0x000C) >> 2;    // addr:   0  0  0  0  0  0  0  0  0  A1 A0
+				irmp_command = ((irmp_command & 0x1000) >> 2) | // V-Bit:  V  0  0  0  0  0  0  0  0  0  0
+				    ((irmp_command & 0x0003) << 8) | // C-Bits: 0  C1 C0 0  0  0  0  0  0  0  0
+				    ((irmp_command & 0x0FF0) >> 4);  // D-Bits:          D7 D6 D5 D4 D3 D2 D1 D0
+				rtc = TRUE;                                     // Summe:  V  C1 C0 D7 D6 D5 D4 D3 D2 D1 D0
+				break;
+#endif
+
+#if IRMP_SUPPORT_NETBOX_PROTOCOL == 1                           // squeeze code to 8 bit, upper bit indicates release-key
+			case IRMP_NETBOX_PROTOCOL:
+				if (irmp_command & 0x1000)                      // last bit set?
+				{
+					if ((irmp_command & 0x1f) == 0x15)          // key pressed: 101 01 (LSB)
+					{
+						irmp_command >>= 5;
+						irmp_command &= 0x7F;
+						rtc = TRUE;
+					}
+					else if ((irmp_command & 0x1f) == 0x10)     // key released: 000 01 (LSB)
+					{
+						irmp_command >>= 5;
+						irmp_command |= 0x80;
+						rtc = TRUE;
+					}
+					else
+					{
+						ANALYZE_PRINTF("error NETBOX: bit6/7 must be 0/1\n");
+					}
+				}
+				else
+				{
+					ANALYZE_PRINTF("error NETBOX: last bit not set\n");
+				}
+				break;
+#endif
+#if IRMP_SUPPORT_LEGO_PROTOCOL == 1
+			case IRMP_LEGO_PROTOCOL:
+			{
+				uint8_t crc = 0x0F ^ ((irmp_command & 0xF000) >> 12) ^ ((irmp_command & 0x0F00) >> 8) ^ ((irmp_command & 0x00F0) >> 4);
+
+				if ((irmp_command & 0x000F) == crc)
+				{
+					irmp_command >>= 4;
+					rtc = TRUE;
+				}
+				else
+				{
+					ANALYZE_PRINTF("CRC error in LEGO protocol\n");
+					rtc = TRUE;
+				}
+				break;
+			}
+#endif
+			default:
+				rtc = TRUE;
+		}
+
+		if (rtc)
+		{
+			irmp_data_p->protocol = irmp_protocol;
+			irmp_data_p->address = irmp_address;
+			irmp_data_p->command = irmp_command;
+			irmp_data_p->flags   = irmp_flags;
+			irmp_command = 0;
+			irmp_address = 0;
+			irmp_flags   = 0;
+		}
+
+		irmp_ir_detected = FALSE;
+	}
+
+	return rtc;
+}
+
+// uint8_t
+// irmp_is_busy (void)
+// {
+//     return irmp_busy_flag;
+// }
+
+#if IRMP_USE_CALLBACK == 1
+void
+irmp_set_callback_ptr(void (*cb)(uint8_t))
+{
+	irmp_callback_ptr = cb;
+}
+#endif // IRMP_USE_CALLBACK == 1
+
+// these statics must not be volatile, because they are only used by irmp_store_bit(), which is called by irmp_ISR()
+static uint16_t irmp_tmp_address;                                                       // ir address
+static uint16_t irmp_tmp_command;                                                       // ir command
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1) || IRMP_SUPPORT_NEC42_PROTOCOL == 1
+static uint16_t irmp_tmp_address2;                                                      // ir address
+static uint16_t irmp_tmp_command2;                                                      // ir command
+#endif
+
+#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
+static uint16_t irmp_tmp_id;                                                            // ir id (only SAMSUNG)
+#endif
+#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
+static uint8_t  xor_check[6];                                                           // check kaseikyo "parity" bits
+static uint8_t  genre2;                                                                 // save genre2 bits here, later copied to MSB in flags
+#endif
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ *  store bit
+ *  @details  store bit in temp address or temp command
+ *  @param    value to store: 0 or 1
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+// verhindert, dass irmp_store_bit() inline compiliert wird:
+// static void irmp_store_bit (uint8_t) __attribute__ ((noinline));
+
+static void
+irmp_store_bit(uint8_t value)
+{
+#if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
+	if (irmp_bit == 0 && irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL)
+	{
+		first_bit = value;
+	}
+	else
+#endif
+
+		if (irmp_bit >= irmp_param.address_offset && irmp_bit < irmp_param.address_end)
+		{
+			if (irmp_param.lsb_first)
+			{
+				irmp_tmp_address |= (((uint16_t)(value)) << (irmp_bit - irmp_param.address_offset));    // CV wants cast
+			}
+			else
+			{
+				irmp_tmp_address <<= 1;
+				irmp_tmp_address |= value;
+			}
+		}
+		else if (irmp_bit >= irmp_param.command_offset && irmp_bit < irmp_param.command_end)
+		{
+			if (irmp_param.lsb_first)
+			{
+				irmp_tmp_command |= (((uint16_t)(value)) << (irmp_bit - irmp_param.command_offset));    // CV wants cast
+			}
+			else
+			{
+				irmp_tmp_command <<= 1;
+				irmp_tmp_command |= value;
+			}
+		}
+
+#if IRMP_SUPPORT_NEC42_PROTOCOL == 1
+		else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && irmp_bit >= 13 && irmp_bit < 26)
+		{
+			irmp_tmp_address2 |= (((uint16_t)(value)) << (irmp_bit - 13));                              // CV wants cast
+		}
+#endif
+
+#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
+		else if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit >= SAMSUNG_ID_OFFSET && irmp_bit < SAMSUNG_ID_OFFSET + SAMSUNG_ID_LEN)
+		{
+			irmp_tmp_id |= (((uint16_t)(value)) << (irmp_bit - SAMSUNG_ID_OFFSET));                     // store with LSB first
+		}
+#endif
+
+#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
+		else if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
+		{
+			if (irmp_bit >= 20 && irmp_bit < 24)
+			{
+				irmp_tmp_command |= (((uint16_t)(value)) << (irmp_bit - 8));        // store 4 system bits (genre 1) in upper nibble with LSB first
+			}
+			else if (irmp_bit >= 24 && irmp_bit < 28)
+			{
+				genre2 |= (((uint8_t)(value)) << (irmp_bit - 20));                  // store 4 system bits (genre 2) in upper nibble with LSB first
+			}
+
+			if (irmp_bit < KASEIKYO_COMPLETE_DATA_LEN)
+			{
+				if (value)
+				{
+					xor_check[irmp_bit / 8] |= 1 << (irmp_bit % 8);
+				}
+				else
+				{
+					xor_check[irmp_bit / 8] &= ~(1 << (irmp_bit % 8));
+				}
+			}
+		}
+#endif
+
+	irmp_bit++;
+}
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ *  store bit
+ *  @details  store bit in temp address or temp command
+ *  @param    value to store: 0 or 1
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
+static void
+irmp_store_bit2(uint8_t value)
+{
+	uint8_t irmp_bit2;
+
+	if (irmp_param.protocol)
+	{
+		irmp_bit2 = irmp_bit - 2;
+	}
+	else
+	{
+		irmp_bit2 = irmp_bit - 1;
+	}
+
+	if (irmp_bit2 >= irmp_param2.address_offset && irmp_bit2 < irmp_param2.address_end)
+	{
+		irmp_tmp_address2 |= (((uint16_t)(value)) << (irmp_bit2 - irmp_param2.address_offset));    // CV wants cast
+	}
+	else if (irmp_bit2 >= irmp_param2.command_offset && irmp_bit2 < irmp_param2.command_end)
+	{
+		irmp_tmp_command2 |= (((uint16_t)(value)) << (irmp_bit2 - irmp_param2.command_offset));    // CV wants cast
+	}
+}
+#endif // IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ *  ISR routine
+ *  @details  ISR routine, called 10000 times per second
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+uint8_t
+irmp_ISR(uint8_t x42)
+{
+	static uint8_t      irmp_start_bit_detected;                                // flag: start bit detected
+	static uint8_t      wait_for_space;                                         // flag: wait for data bit space
+	static uint8_t      wait_for_start_space;                                   // flag: wait for start bit space
+	static uint8_t      irmp_pulse_time;                                        // count bit time for pulse
+	static PAUSE_LEN    irmp_pause_time;                                        // count bit time for pause
+	static uint16_t     last_irmp_address = 0xFFFF;                             // save last irmp address to recognize key repetition
+	static uint16_t     last_irmp_command = 0xFFFF;                             // save last irmp command to recognize key repetition
+	static uint16_t     repetition_len;                                         // SIRCS repeats frame 2-5 times with 45 ms pause
+	static uint8_t      repetition_frame_number;
+#if IRMP_SUPPORT_DENON_PROTOCOL == 1
+	static uint16_t     last_irmp_denon_command;                                // save last irmp command to recognize DENON frame repetition
+#endif
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1
+	static uint8_t      rc5_cmd_bit6;                                           // bit 6 of RC5 command is the inverted 2nd start bit
+#endif
+#if IRMP_SUPPORT_MANCHESTER == 1
+	static PAUSE_LEN    last_pause;                                             // last pause value
+#endif
+#if IRMP_SUPPORT_MANCHESTER == 1 || IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
+	static uint8_t      last_value;                                             // last bit value
+#endif
+	uint8_t             irmp_input;                                             // input value
+
+#ifdef ANALYZE
+	time_counter++;
+#endif
+
+	irmp_input = input(x42);
+
+#if IRMP_USE_CALLBACK == 1
+	if (irmp_callback_ptr)
+	{
+		static uint8_t last_inverted_input;
+
+		if (last_inverted_input != !irmp_input)
+		{
+			(*irmp_callback_ptr)(! irmp_input);
+			last_inverted_input = !irmp_input;
+		}
+	}
+#endif // IRMP_USE_CALLBACK == 1
+
+	irmp_log(irmp_input);                                                       // log ir signal, if IRMP_LOGGING defined
+
+	if (! irmp_ir_detected)                                                     // ir code already detected?
+	{
+		// no...
+		if (! irmp_start_bit_detected)                                          // start bit detected?
+		{
+			// no...
+			if (! irmp_input)                                                   // receiving burst?
+			{
+				// yes...
+//              irmp_busy_flag = TRUE;
+#ifdef ANALYZE
+				if (! irmp_pulse_time)
+				{
+					ANALYZE_PRINTF("%8.3fms [starting pulse]\n", (double)(time_counter * 1000) / F_INTERRUPTS);
+				}
+#endif
+				irmp_pulse_time++;                                              // increment counter
+			}
+			else
+			{
+				// no...
+				if (irmp_pulse_time)                                            // it's dark....
+				{
+					// set flags for counting the time of darkness...
+					irmp_start_bit_detected = 1;
+					wait_for_start_space    = 1;
+					wait_for_space          = 0;
+					irmp_tmp_command        = 0;
+					irmp_tmp_address        = 0;
+#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
+					genre2                  = 0;
+#endif
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1) || IRMP_SUPPORT_NEC42_PROTOCOL == 1
+					irmp_tmp_command2       = 0;
+					irmp_tmp_address2       = 0;
+#endif
+
+					irmp_bit                = 0xff;
+					irmp_pause_time         = 1;                                // 1st pause: set to 1, not to 0!
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1
+					rc5_cmd_bit6            = 0;                                // fm 2010-03-07: bugfix: reset it after incomplete RC5 frame!
+#endif
+				}
+				else
+				{
+					if (repetition_len < 0xFFFF)                                // avoid overflow of counter
+					{
+						repetition_len++;
+					}
+				}
+			}
+		}
+		else
+		{
+			if (wait_for_start_space)                                           // we have received start bit...
+			{
+				// ...and are counting the time of darkness
+				if (irmp_input)                                                 // still dark?
+				{
+					// yes
+					irmp_pause_time++;                                          // increment counter
+
+#if IRMP_SUPPORT_NIKON_PROTOCOL == 1
+					if (((irmp_pulse_time < NIKON_START_BIT_PULSE_LEN_MIN || irmp_pulse_time > NIKON_START_BIT_PULSE_LEN_MAX) && irmp_pause_time > IRMP_TIMEOUT_LEN) ||
+					    irmp_pause_time > IRMP_TIMEOUT_NIKON_LEN)
+#else
+					if (irmp_pause_time > IRMP_TIMEOUT_LEN)                     // timeout?
+#endif
+					{
+						// yes...
+#if IRMP_SUPPORT_JVC_PROTOCOL == 1
+						if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // don't show eror if JVC protocol, irmp_pulse_time has been set below!
+						{
+							;
+						}
+						else
+#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
+						{
+							ANALYZE_PRINTF("%8.3fms error 1: pause after start bit pulse %d too long: %d\n", (double)(time_counter * 1000) / F_INTERRUPTS, irmp_pulse_time, irmp_pause_time);
+							ANALYZE_ONLY_NORMAL_PUTCHAR('\n');
+						}
+//                      irmp_busy_flag = FALSE;
+						irmp_start_bit_detected = 0;                            // reset flags, let's wait for another start bit
+						irmp_pulse_time         = 0;
+						irmp_pause_time         = 0;
+					}
+				}
+				else
+				{
+					// receiving first data pulse!
+					IRMP_PARAMETER *irmp_param_p = (IRMP_PARAMETER *) 0;
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
+					irmp_param2.protocol = 0;
+#endif
+
+					ANALYZE_PRINTF("%8.3fms [start-bit: pulse = %2d, pause = %2d]\n", (double)(time_counter * 1000) / F_INTERRUPTS, irmp_pulse_time, irmp_pause_time);
+
+#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
+					if (irmp_pulse_time >= SIRCS_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SIRCS_START_BIT_PULSE_LEN_MAX &&
+					    irmp_pause_time >= SIRCS_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SIRCS_START_BIT_PAUSE_LEN_MAX)
+					{
+						// it's SIRCS
+						ANALYZE_PRINTF("protocol = SIRCS, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+						    SIRCS_START_BIT_PULSE_LEN_MIN, SIRCS_START_BIT_PULSE_LEN_MAX,
+						    SIRCS_START_BIT_PAUSE_LEN_MIN, SIRCS_START_BIT_PAUSE_LEN_MAX);
+						irmp_param_p = (IRMP_PARAMETER *)(IRMP_PARAMETER *) &sircs_param;
+					}
+					else
+#endif // IRMP_SUPPORT_SIRCS_PROTOCOL == 1
+
+#if IRMP_SUPPORT_JVC_PROTOCOL == 1
+						if (irmp_protocol == IRMP_JVC_PROTOCOL &&                                                       // last protocol was JVC, awaiting repeat frame
+						    irmp_pulse_time >= JVC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= JVC_START_BIT_PULSE_LEN_MAX &&
+						    irmp_pause_time >= JVC_REPEAT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= JVC_REPEAT_START_BIT_PAUSE_LEN_MAX)
+						{
+							ANALYZE_PRINTF("protocol = NEC or JVC (type 1) repeat frame, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+							    JVC_START_BIT_PULSE_LEN_MIN, JVC_START_BIT_PULSE_LEN_MAX,
+							    JVC_REPEAT_START_BIT_PAUSE_LEN_MIN, JVC_REPEAT_START_BIT_PAUSE_LEN_MAX);
+							irmp_param_p = (IRMP_PARAMETER *) &nec_param;
+						}
+						else
+#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
+
+#if IRMP_SUPPORT_NEC_PROTOCOL == 1
+							if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
+							    irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_START_BIT_PAUSE_LEN_MAX)
+							{
+#if IRMP_SUPPORT_NEC42_PROTOCOL == 1
+								ANALYZE_PRINTF("protocol = NEC42, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+								    NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
+								    NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX);
+								irmp_param_p = (IRMP_PARAMETER *) &nec42_param;
+#else
+								ANALYZE_PRINTF("protocol = NEC, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+								    NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
+								    NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX);
+								irmp_param_p = (IRMP_PARAMETER *) &nec_param;
+#endif
+
+							}
+							else if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN        && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
+							    irmp_pause_time >= NEC_REPEAT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_REPEAT_START_BIT_PAUSE_LEN_MAX)
+							{
+								// it's NEC
+#if IRMP_SUPPORT_JVC_PROTOCOL == 1
+								if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // last protocol was JVC, awaiting repeat frame
+								{
+									// some jvc remote controls use nec repetition frame for jvc repetition frame
+									ANALYZE_PRINTF("protocol = JVC repeat frame type 2, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+									    NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
+									    NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BIT_PAUSE_LEN_MAX);
+									irmp_param_p = (IRMP_PARAMETER *) &nec_param;
+								}
+								else
+#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
+								{
+									ANALYZE_PRINTF("protocol = NEC (repetition frame), start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+									    NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
+									    NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BIT_PAUSE_LEN_MAX);
+
+									irmp_param_p = (IRMP_PARAMETER *) &nec_rep_param;
+								}
+							}
+							else
+
+#if IRMP_SUPPORT_JVC_PROTOCOL == 1
+								if (irmp_protocol == IRMP_JVC_PROTOCOL &&                   // last protocol was JVC, awaiting repeat frame
+								    irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
+								    irmp_pause_time >= NEC_0_PAUSE_LEN_MIN         && irmp_pause_time <= NEC_0_PAUSE_LEN_MAX)
+								{
+									// it's JVC repetition type 3
+									ANALYZE_PRINTF("protocol = JVC repeat frame type 3, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+									    NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX,
+									    NEC_0_PAUSE_LEN_MIN, NEC_0_PAUSE_LEN_MAX);
+									irmp_param_p = (IRMP_PARAMETER *) &nec_param;
+								}
+								else
+#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
+
+#endif // IRMP_SUPPORT_NEC_PROTOCOL == 1
+
+#if IRMP_SUPPORT_NIKON_PROTOCOL == 1
+									if (irmp_pulse_time >= NIKON_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NIKON_START_BIT_PULSE_LEN_MAX &&
+									    irmp_pause_time >= NIKON_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NIKON_START_BIT_PAUSE_LEN_MAX)
+									{
+										ANALYZE_PRINTF("protocol = NIKON, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+										    NIKON_START_BIT_PULSE_LEN_MIN, NIKON_START_BIT_PULSE_LEN_MAX,
+										    NIKON_START_BIT_PAUSE_LEN_MIN, NIKON_START_BIT_PAUSE_LEN_MAX);
+										irmp_param_p = (IRMP_PARAMETER *) &nikon_param;
+									}
+									else
+#endif // IRMP_SUPPORT_NIKON_PROTOCOL == 1
+
+#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
+										if (irmp_pulse_time >= SAMSUNG_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_START_BIT_PULSE_LEN_MAX &&
+										    irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_START_BIT_PAUSE_LEN_MAX)
+										{
+											// it's SAMSUNG
+											ANALYZE_PRINTF("protocol = SAMSUNG, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+											    SAMSUNG_START_BIT_PULSE_LEN_MIN, SAMSUNG_START_BIT_PULSE_LEN_MAX,
+											    SAMSUNG_START_BIT_PAUSE_LEN_MIN, SAMSUNG_START_BIT_PAUSE_LEN_MAX);
+											irmp_param_p = (IRMP_PARAMETER *) &samsung_param;
+										}
+										else
+#endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
+
+#if IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
+											if (irmp_pulse_time >= MATSUSHITA_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= MATSUSHITA_START_BIT_PULSE_LEN_MAX &&
+											    irmp_pause_time >= MATSUSHITA_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= MATSUSHITA_START_BIT_PAUSE_LEN_MAX)
+											{
+												// it's MATSUSHITA
+												ANALYZE_PRINTF("protocol = MATSUSHITA, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+												    MATSUSHITA_START_BIT_PULSE_LEN_MIN, MATSUSHITA_START_BIT_PULSE_LEN_MAX,
+												    MATSUSHITA_START_BIT_PAUSE_LEN_MIN, MATSUSHITA_START_BIT_PAUSE_LEN_MAX);
+												irmp_param_p = (IRMP_PARAMETER *) &matsushita_param;
+											}
+											else
+#endif // IRMP_SUPPORT_MATSUSHITA_PROTOCOL == 1
+
+#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
+												if (irmp_pulse_time >= KASEIKYO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= KASEIKYO_START_BIT_PULSE_LEN_MAX &&
+												    irmp_pause_time >= KASEIKYO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= KASEIKYO_START_BIT_PAUSE_LEN_MAX)
+												{
+													// it's KASEIKYO
+													ANALYZE_PRINTF("protocol = KASEIKYO, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+													    KASEIKYO_START_BIT_PULSE_LEN_MIN, KASEIKYO_START_BIT_PULSE_LEN_MAX,
+													    KASEIKYO_START_BIT_PAUSE_LEN_MIN, KASEIKYO_START_BIT_PAUSE_LEN_MAX);
+													irmp_param_p = (IRMP_PARAMETER *) &kaseikyo_param;
+												}
+												else
+#endif // IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
+
+#if IRMP_SUPPORT_RECS80_PROTOCOL == 1
+													if (irmp_pulse_time >= RECS80_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RECS80_START_BIT_PULSE_LEN_MAX &&
+													    irmp_pause_time >= RECS80_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RECS80_START_BIT_PAUSE_LEN_MAX)
+													{
+														// it's RECS80
+														ANALYZE_PRINTF("protocol = RECS80, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+														    RECS80_START_BIT_PULSE_LEN_MIN, RECS80_START_BIT_PULSE_LEN_MAX,
+														    RECS80_START_BIT_PAUSE_LEN_MIN, RECS80_START_BIT_PAUSE_LEN_MAX);
+														irmp_param_p = (IRMP_PARAMETER *) &recs80_param;
+													}
+													else
+#endif // IRMP_SUPPORT_RECS80_PROTOCOL == 1
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1
+														if (((irmp_pulse_time >= RC5_START_BIT_LEN_MIN     && irmp_pulse_time <= RC5_START_BIT_LEN_MAX) ||
+														        (irmp_pulse_time >= 2 * RC5_START_BIT_LEN_MIN && irmp_pulse_time <= 2 * RC5_START_BIT_LEN_MAX)) &&
+														    ((irmp_pause_time >= RC5_START_BIT_LEN_MIN     && irmp_pause_time <= RC5_START_BIT_LEN_MAX) ||
+														        (irmp_pause_time >= 2 * RC5_START_BIT_LEN_MIN && irmp_pause_time <= 2 * RC5_START_BIT_LEN_MAX)))
+														{
+															// it's RC5
+#if IRMP_SUPPORT_FDC_PROTOCOL == 1
+															if (irmp_pulse_time >= FDC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= FDC_START_BIT_PULSE_LEN_MAX &&
+															    irmp_pause_time >= FDC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= FDC_START_BIT_PAUSE_LEN_MAX)
+															{
+																ANALYZE_PRINTF("protocol = RC5 or FDC\n");
+																ANALYZE_PRINTF("FDC start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																    FDC_START_BIT_PULSE_LEN_MIN, FDC_START_BIT_PULSE_LEN_MAX,
+																    FDC_START_BIT_PAUSE_LEN_MIN, FDC_START_BIT_PAUSE_LEN_MAX);
+																ANALYZE_PRINTF("RC5 start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																    RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
+																    RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX);
+																memcpy_P(&irmp_param2, &fdc_param, sizeof(IRMP_PARAMETER));
+															}
+															else
+#endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
+
+#if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
+																if (irmp_pulse_time >= RCCAR_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RCCAR_START_BIT_PULSE_LEN_MAX &&
+																    irmp_pause_time >= RCCAR_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_START_BIT_PAUSE_LEN_MAX)
+																{
+																	ANALYZE_PRINTF("protocol = RC5 or RCCAR\n");
+																	ANALYZE_PRINTF("RCCAR start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																	    RCCAR_START_BIT_PULSE_LEN_MIN, RCCAR_START_BIT_PULSE_LEN_MAX,
+																	    RCCAR_START_BIT_PAUSE_LEN_MIN, RCCAR_START_BIT_PAUSE_LEN_MAX);
+																	ANALYZE_PRINTF("RC5 start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																	    RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
+																	    RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX);
+																	memcpy_P(&irmp_param2, &rccar_param, sizeof(IRMP_PARAMETER));
+																}
+																else
+#endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
+																{
+																	ANALYZE_PRINTF("protocol = RC5, start bit timings: pulse: %3d - %3d, pause: %3d - %3d or pulse: %3d - %3d, pause: %3d - %3d\n",
+																	    RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
+																	    2 * RC5_START_BIT_LEN_MIN, 2 * RC5_START_BIT_LEN_MAX,
+																	    RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
+																	    2 * RC5_START_BIT_LEN_MIN, 2 * RC5_START_BIT_LEN_MAX);
+																}
+
+															irmp_param_p = (IRMP_PARAMETER *) &rc5_param;
+															last_pause = irmp_pause_time;
+
+															if ((irmp_pulse_time > RC5_START_BIT_LEN_MAX && irmp_pulse_time <= 2 * RC5_START_BIT_LEN_MAX) ||
+															    (irmp_pause_time > RC5_START_BIT_LEN_MAX && irmp_pause_time <= 2 * RC5_START_BIT_LEN_MAX))
+															{
+																last_value  = 0;
+																rc5_cmd_bit6 = 1 << 6;
+															}
+															else
+															{
+																last_value  = 1;
+															}
+														}
+														else
+#endif // IRMP_SUPPORT_RC5_PROTOCOL == 1
+
+#if IRMP_SUPPORT_DENON_PROTOCOL == 1
+															if ((irmp_pulse_time >= DENON_PULSE_LEN_MIN && irmp_pulse_time <= DENON_PULSE_LEN_MAX) &&
+															    ((irmp_pause_time >= DENON_1_PAUSE_LEN_MIN && irmp_pause_time <= DENON_1_PAUSE_LEN_MAX) ||
+															        (irmp_pause_time >= DENON_0_PAUSE_LEN_MIN && irmp_pause_time <= DENON_0_PAUSE_LEN_MAX)))
+															{
+																// it's DENON
+																ANALYZE_PRINTF("protocol = DENON, start bit timings: pulse: %3d - %3d, pause: %3d - %3d or %3d - %3d\n",
+																    DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX,
+																    DENON_1_PAUSE_LEN_MIN, DENON_1_PAUSE_LEN_MAX,
+																    DENON_0_PAUSE_LEN_MIN, DENON_0_PAUSE_LEN_MAX);
+																irmp_param_p = (IRMP_PARAMETER *) &denon_param;
+															}
+															else
+#endif // IRMP_SUPPORT_DENON_PROTOCOL == 1
+
+#if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
+																if ((irmp_pulse_time >= THOMSON_PULSE_LEN_MIN && irmp_pulse_time <= THOMSON_PULSE_LEN_MAX) &&
+																    ((irmp_pause_time >= THOMSON_1_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_1_PAUSE_LEN_MAX) ||
+																        (irmp_pause_time >= THOMSON_0_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_0_PAUSE_LEN_MAX)))
+																{
+																	// it's THOMSON
+																	ANALYZE_PRINTF("protocol = THOMSON, start bit timings: pulse: %3d - %3d, pause: %3d - %3d or %3d - %3d\n",
+																	    THOMSON_PULSE_LEN_MIN, THOMSON_PULSE_LEN_MAX,
+																	    THOMSON_1_PAUSE_LEN_MIN, THOMSON_1_PAUSE_LEN_MAX,
+																	    THOMSON_0_PAUSE_LEN_MIN, THOMSON_0_PAUSE_LEN_MAX);
+																	irmp_param_p = (IRMP_PARAMETER *) &thomson_param;
+																}
+																else
+#endif // IRMP_SUPPORT_THOMSON_PROTOCOL == 1
+
+#if IRMP_SUPPORT_RC6_PROTOCOL == 1
+																	if (irmp_pulse_time >= RC6_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RC6_START_BIT_PULSE_LEN_MAX &&
+																	    irmp_pause_time >= RC6_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RC6_START_BIT_PAUSE_LEN_MAX)
+																	{
+																		// it's RC6
+																		ANALYZE_PRINTF("protocol = RC6, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																		    RC6_START_BIT_PULSE_LEN_MIN, RC6_START_BIT_PULSE_LEN_MAX,
+																		    RC6_START_BIT_PAUSE_LEN_MIN, RC6_START_BIT_PAUSE_LEN_MAX);
+																		irmp_param_p = (IRMP_PARAMETER *) &rc6_param;
+																		last_pause = 0;
+																		last_value = 1;
+																	}
+																	else
+#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
+
+#if IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
+																		if (irmp_pulse_time >= RECS80EXT_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RECS80EXT_START_BIT_PULSE_LEN_MAX &&
+																		    irmp_pause_time >= RECS80EXT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RECS80EXT_START_BIT_PAUSE_LEN_MAX)
+																		{
+																			// it's RECS80EXT
+																			ANALYZE_PRINTF("protocol = RECS80EXT, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																			    RECS80EXT_START_BIT_PULSE_LEN_MIN, RECS80EXT_START_BIT_PULSE_LEN_MAX,
+																			    RECS80EXT_START_BIT_PAUSE_LEN_MIN, RECS80EXT_START_BIT_PAUSE_LEN_MAX);
+																			irmp_param_p = (IRMP_PARAMETER *) &recs80ext_param;
+																		}
+																		else
+#endif // IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1
+
+#if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
+																			if (irmp_pulse_time >= NUBERT_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NUBERT_START_BIT_PULSE_LEN_MAX &&
+																			    irmp_pause_time >= NUBERT_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NUBERT_START_BIT_PAUSE_LEN_MAX)
+																			{
+																				// it's NUBERT
+																				ANALYZE_PRINTF("protocol = NUBERT, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																				    NUBERT_START_BIT_PULSE_LEN_MIN, NUBERT_START_BIT_PULSE_LEN_MAX,
+																				    NUBERT_START_BIT_PAUSE_LEN_MIN, NUBERT_START_BIT_PAUSE_LEN_MAX);
+																				irmp_param_p = (IRMP_PARAMETER *) &nubert_param;
+																			}
+																			else
+#endif // IRMP_SUPPORT_NUBERT_PROTOCOL == 1
+
+#if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
+																				if (irmp_pulse_time >= BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN && irmp_pulse_time <= BANG_OLUFSEN_START_BIT1_PULSE_LEN_MAX &&
+																				    irmp_pause_time >= BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MAX)
+																				{
+																					// it's BANG_OLUFSEN
+																					ANALYZE_PRINTF("protocol = BANG_OLUFSEN\n");
+																					ANALYZE_PRINTF("start bit 1 timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																					    BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT1_PULSE_LEN_MAX,
+																					    BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MAX);
+																					ANALYZE_PRINTF("start bit 2 timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																					    BANG_OLUFSEN_START_BIT2_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT2_PULSE_LEN_MAX,
+																					    BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MAX);
+																					ANALYZE_PRINTF("start bit 3 timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																					    BANG_OLUFSEN_START_BIT3_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT3_PULSE_LEN_MAX,
+																					    BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MAX);
+																					ANALYZE_PRINTF("start bit 4 timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																					    BANG_OLUFSEN_START_BIT4_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT4_PULSE_LEN_MAX,
+																					    BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MAX);
+																					irmp_param_p = (IRMP_PARAMETER *) &bang_olufsen_param;
+																					last_value = 0;
+																				}
+																				else
+#endif // IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
+
+#if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
+																					if (irmp_pulse_time >= GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN && irmp_pulse_time <= GRUNDIG_NOKIA_IR60_START_BIT_LEN_MAX &&
+																					    irmp_pause_time >= GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN && irmp_pause_time <= GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MAX)
+																					{
+																						// it's GRUNDIG
+																						ANALYZE_PRINTF("protocol = GRUNDIG, pre bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																						    GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN, GRUNDIG_NOKIA_IR60_START_BIT_LEN_MAX,
+																						    GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN, GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MAX);
+																						irmp_param_p = (IRMP_PARAMETER *) &grundig_param;
+																						last_pause = irmp_pause_time;
+																						last_value  = 1;
+																					}
+																					else
+#endif // IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
+
+#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
+																						if (((irmp_pulse_time >= SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX) ||
+																						        (irmp_pulse_time >= 2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= 2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX)) &&
+																						    ((irmp_pause_time >= SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX) ||
+																						        (irmp_pause_time >= 2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= 2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX)))
+																						{
+																							// it's RUWIDO or SIEMENS
+																							ANALYZE_PRINTF("protocol = RUWIDO, start bit timings: pulse: %3d - %3d or %3d - %3d, pause: %3d - %3d or %3d - %3d\n",
+																							    SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN,   SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX,
+																							    2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN, 2 * SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX,
+																							    SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN,   SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX,
+																							    2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN, 2 * SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX);
+																							irmp_param_p = (IRMP_PARAMETER *) &ruwido_param;
+																							last_pause = irmp_pause_time;
+																							last_value  = 1;
+																						}
+																						else
+#endif // IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
+
+#if IRMP_SUPPORT_GRUNDIG2_PROTOCOL == 1
+																							if ((irmp_pulse_time >= GRUNDIG2_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= GRUNDIG2_START_BIT_PULSE_LEN_MAX) &&
+																							    (irmp_pause_time >= GRUNDIG2_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= GRUNDIG2_START_BIT_PAUSE_LEN_MAX))
+																							{
+																								// it's GRUNDIG2
+																								ANALYZE_PRINTF("protocol = GRUNDIG2, start bit timings: pulse: %3d - %3d or %3d - %3d, pause: %3d - %3d or %3d - %3d\n",
+																								    GRUNDIG2_START_BIT_PULSE_LEN_MIN,   GRUNDIG2_START_BIT_PULSE_LEN_MAX,
+																								    2 * GRUNDIG2_START_BIT_PULSE_LEN_MIN, 2 * GRUNDIG2_START_BIT_PULSE_LEN_MAX,
+																								    GRUNDIG2_START_BIT_PAUSE_LEN_MIN,   GRUNDIG2_START_BIT_PAUSE_LEN_MAX,
+																								    2 * GRUNDIG2_START_BIT_PAUSE_LEN_MIN, 2 * GRUNDIG2_START_BIT_PAUSE_LEN_MAX);
+																								irmp_param_p = (IRMP_PARAMETER *) &grundig2_param;
+																								last_pause = irmp_pause_time;
+																								last_value  = 1;
+																							}
+																							else
+#endif // IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
+
+#if IRMP_SUPPORT_FDC_PROTOCOL == 1
+																								if (irmp_pulse_time >= FDC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= FDC_START_BIT_PULSE_LEN_MAX &&
+																								    irmp_pause_time >= FDC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= FDC_START_BIT_PAUSE_LEN_MAX)
+																								{
+																									ANALYZE_PRINTF("protocol = FDC, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																									    FDC_START_BIT_PULSE_LEN_MIN, FDC_START_BIT_PULSE_LEN_MAX,
+																									    FDC_START_BIT_PAUSE_LEN_MIN, FDC_START_BIT_PAUSE_LEN_MAX);
+																									irmp_param_p = (IRMP_PARAMETER *) &fdc_param;
+																								}
+																								else
+#endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
+
+#if IRMP_SUPPORT_RCCAR_PROTOCOL == 1
+																									if (irmp_pulse_time >= RCCAR_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RCCAR_START_BIT_PULSE_LEN_MAX &&
+																									    irmp_pause_time >= RCCAR_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_START_BIT_PAUSE_LEN_MAX)
+																									{
+																										ANALYZE_PRINTF("protocol = RCCAR, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																										    RCCAR_START_BIT_PULSE_LEN_MIN, RCCAR_START_BIT_PULSE_LEN_MAX,
+																										    RCCAR_START_BIT_PAUSE_LEN_MIN, RCCAR_START_BIT_PAUSE_LEN_MAX);
+																										irmp_param_p = (IRMP_PARAMETER *) &rccar_param;
+																									}
+																									else
+#endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
+
+#if IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
+																										if (irmp_pulse_time >= KATHREIN_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= KATHREIN_START_BIT_PULSE_LEN_MAX &&
+																										    irmp_pause_time >= KATHREIN_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= KATHREIN_START_BIT_PAUSE_LEN_MAX)
+																										{
+																											// it's KATHREIN
+																											ANALYZE_PRINTF("protocol = KATHREIN, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																											    KATHREIN_START_BIT_PULSE_LEN_MIN, KATHREIN_START_BIT_PULSE_LEN_MAX,
+																											    KATHREIN_START_BIT_PAUSE_LEN_MIN, KATHREIN_START_BIT_PAUSE_LEN_MAX);
+																											irmp_param_p = (IRMP_PARAMETER *) &kathrein_param;
+																										}
+																										else
+#endif // IRMP_SUPPORT_KATHREIN_PROTOCOL == 1
+
+#if IRMP_SUPPORT_NETBOX_PROTOCOL == 1
+																											if (irmp_pulse_time >= NETBOX_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NETBOX_START_BIT_PULSE_LEN_MAX &&
+																											    irmp_pause_time >= NETBOX_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NETBOX_START_BIT_PAUSE_LEN_MAX)
+																											{
+																												// it's NETBOX
+																												ANALYZE_PRINTF("protocol = NETBOX, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																												    NETBOX_START_BIT_PULSE_LEN_MIN, NETBOX_START_BIT_PULSE_LEN_MAX,
+																												    NETBOX_START_BIT_PAUSE_LEN_MIN, NETBOX_START_BIT_PAUSE_LEN_MAX);
+																												irmp_param_p = (IRMP_PARAMETER *) &netbox_param;
+																											}
+																											else
+#endif // IRMP_SUPPORT_NETBOX_PROTOCOL == 1
+
+#if IRMP_SUPPORT_LEGO_PROTOCOL == 1
+																												if (irmp_pulse_time >= LEGO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= LEGO_START_BIT_PULSE_LEN_MAX &&
+																												    irmp_pause_time >= LEGO_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= LEGO_START_BIT_PAUSE_LEN_MAX)
+																												{
+																													ANALYZE_PRINTF("protocol = LEGO, start bit timings: pulse: %3d - %3d, pause: %3d - %3d\n",
+																													    LEGO_START_BIT_PULSE_LEN_MIN, LEGO_START_BIT_PULSE_LEN_MAX,
+																													    LEGO_START_BIT_PAUSE_LEN_MIN, LEGO_START_BIT_PAUSE_LEN_MAX);
+																													irmp_param_p = (IRMP_PARAMETER *) &lego_param;
+																												}
+																												else
+#endif // IRMP_SUPPORT_LEGO_PROTOCOL == 1
+
+																												{
+																													ANALYZE_PRINTF("protocol = UNKNOWN\n");
+//                      irmp_busy_flag = FALSE;
+																													irmp_start_bit_detected = 0;                            // wait for another start bit...
+																												}
+
+					if (irmp_start_bit_detected)
+					{
+						memcpy_P(&irmp_param, irmp_param_p, sizeof(IRMP_PARAMETER));
+
+#ifdef ANALYZE
+						if (!(irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
+						{
+							ANALYZE_PRINTF("pulse_1: %3d - %3d\n", irmp_param.pulse_1_len_min, irmp_param.pulse_1_len_max);
+							ANALYZE_PRINTF("pause_1: %3d - %3d\n", irmp_param.pause_1_len_min, irmp_param.pause_1_len_max);
+						}
+						else
+						{
+							ANALYZE_PRINTF("pulse: %3d - %3d or %3d - %3d\n", irmp_param.pulse_1_len_min, irmp_param.pulse_1_len_max,
+							    2 * irmp_param.pulse_1_len_min, 2 * irmp_param.pulse_1_len_max);
+							ANALYZE_PRINTF("pause: %3d - %3d or %3d - %3d\n", irmp_param.pause_1_len_min, irmp_param.pause_1_len_max,
+							    2 * irmp_param.pause_1_len_min, 2 * irmp_param.pause_1_len_max);
+						}
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
+						if (irmp_param2.protocol)
+						{
+							ANALYZE_PRINTF("pulse_0: %3d - %3d\n", irmp_param2.pulse_0_len_min, irmp_param2.pulse_0_len_max);
+							ANALYZE_PRINTF("pause_0: %3d - %3d\n", irmp_param2.pause_0_len_min, irmp_param2.pause_0_len_max);
+							ANALYZE_PRINTF("pulse_1: %3d - %3d\n", irmp_param2.pulse_1_len_min, irmp_param2.pulse_1_len_max);
+							ANALYZE_PRINTF("pause_1: %3d - %3d\n", irmp_param2.pause_1_len_min, irmp_param2.pause_1_len_max);
+						}
+#endif
+
+
+#if IRMP_SUPPORT_RC6_PROTOCOL == 1
+						if (irmp_param.protocol == IRMP_RC6_PROTOCOL)
+						{
+							ANALYZE_PRINTF("pulse_toggle: %3d - %3d\n", RC6_TOGGLE_BIT_LEN_MIN, RC6_TOGGLE_BIT_LEN_MAX);
+						}
+#endif
+
+						if (!(irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
+						{
+							ANALYZE_PRINTF("pulse_0: %3d - %3d\n", irmp_param.pulse_0_len_min, irmp_param.pulse_0_len_max);
+							ANALYZE_PRINTF("pause_0: %3d - %3d\n", irmp_param.pause_0_len_min, irmp_param.pause_0_len_max);
+						}
+						else
+						{
+							ANALYZE_PRINTF("pulse: %3d - %3d or %3d - %3d\n", irmp_param.pulse_0_len_min, irmp_param.pulse_0_len_max,
+							    2 * irmp_param.pulse_0_len_min, 2 * irmp_param.pulse_0_len_max);
+							ANALYZE_PRINTF("pause: %3d - %3d or %3d - %3d\n", irmp_param.pause_0_len_min, irmp_param.pause_0_len_max,
+							    2 * irmp_param.pause_0_len_min, 2 * irmp_param.pause_0_len_max);
+						}
+
+#if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
+						if (irmp_param.protocol == IRMP_BANG_OLUFSEN_PROTOCOL)
+						{
+							ANALYZE_PRINTF("pulse_r: %3d - %3d\n", irmp_param.pulse_0_len_min, irmp_param.pulse_0_len_max);
+							ANALYZE_PRINTF("pause_r: %3d - %3d\n", BANG_OLUFSEN_R_PAUSE_LEN_MIN, BANG_OLUFSEN_R_PAUSE_LEN_MAX);
+						}
+#endif
+
+						ANALYZE_PRINTF("command_offset: %2d\n", irmp_param.command_offset);
+						ANALYZE_PRINTF("command_len:    %3d\n", irmp_param.command_end - irmp_param.command_offset);
+						ANALYZE_PRINTF("complete_len:   %3d\n", irmp_param.complete_len);
+						ANALYZE_PRINTF("stop_bit:       %3d\n", irmp_param.stop_bit);
+#endif // ANALYZE
+					}
+
+					irmp_bit = 0;
+
+#if IRMP_SUPPORT_MANCHESTER == 1
+					if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
+					    irmp_param.protocol != IRMP_RUWIDO_PROTOCOL && // Manchester, but not RUWIDO
+					    irmp_param.protocol != IRMP_RC6_PROTOCOL)      // Manchester, but not RC6
+					{
+						if (irmp_pause_time > irmp_param.pulse_1_len_max && irmp_pause_time <= 2 * irmp_param.pulse_1_len_max)
+						{
+							ANALYZE_PRINTF("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double)(time_counter * 1000) / F_INTERRUPTS, irmp_bit, irmp_pulse_time, irmp_pause_time);
+							ANALYZE_PUTCHAR((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '0' : '1');
+							ANALYZE_NEWLINE();
+							irmp_store_bit((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 0 : 1);
+						}
+						else if (! last_value)  // && irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_param.pause_1_len_max)
+						{
+							ANALYZE_PRINTF("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double)(time_counter * 1000) / F_INTERRUPTS, irmp_bit, irmp_pulse_time, irmp_pause_time);
+
+							ANALYZE_PUTCHAR((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '1' : '0');
+							ANALYZE_NEWLINE();
+							irmp_store_bit((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 : 0);
+						}
+					}
+					else
+#endif // IRMP_SUPPORT_MANCHESTER == 1
+
+#if IRMP_SUPPORT_SERIAL == 1
+						if (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL)
+						{
+							; // do nothing
+						}
+						else
+#endif // IRMP_SUPPORT_SERIAL == 1
+
+
+#if IRMP_SUPPORT_DENON_PROTOCOL == 1
+							if (irmp_param.protocol == IRMP_DENON_PROTOCOL)
+							{
+								ANALYZE_PRINTF("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double)(time_counter * 1000) / F_INTERRUPTS, irmp_bit, irmp_pulse_time, irmp_pause_time);
+
+								if (irmp_pause_time >= DENON_1_PAUSE_LEN_MIN && irmp_pause_time <= DENON_1_PAUSE_LEN_MAX)
+								{
+									// pause timings correct for "1"?
+									ANALYZE_PUTCHAR('1');                                   // yes, store 1
+									ANALYZE_NEWLINE();
+									irmp_store_bit(1);
+								}
+								else // if (irmp_pause_time >= DENON_0_PAUSE_LEN_MIN && irmp_pause_time <= DENON_0_PAUSE_LEN_MAX)
+								{
+									// pause timings correct for "0"?
+									ANALYZE_PUTCHAR('0');                                   // yes, store 0
+									ANALYZE_NEWLINE();
+									irmp_store_bit(0);
+								}
+							}
+							else
+#endif // IRMP_SUPPORT_DENON_PROTOCOL == 1
+#if IRMP_SUPPORT_THOMSON_PROTOCOL == 1
+								if (irmp_param.protocol == IRMP_THOMSON_PROTOCOL)
+								{
+									ANALYZE_PRINTF("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double)(time_counter * 1000) / F_INTERRUPTS, irmp_bit, irmp_pulse_time, irmp_pause_time);
+
+									if (irmp_pause_time >= THOMSON_1_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_1_PAUSE_LEN_MAX)
+									{
+										// pause timings correct for "1"?
+										ANALYZE_PUTCHAR('1');                                   // yes, store 1
+										ANALYZE_NEWLINE();
+										irmp_store_bit(1);
+									}
+									else // if (irmp_pause_time >= THOMSON_0_PAUSE_LEN_MIN && irmp_pause_time <= THOMSON_0_PAUSE_LEN_MAX)
+									{
+										// pause timings correct for "0"?
+										ANALYZE_PUTCHAR('0');                                   // yes, store 0
+										ANALYZE_NEWLINE();
+										irmp_store_bit(0);
+									}
+								}
+								else
+#endif // IRMP_SUPPORT_THOMSON_PROTOCOL == 1
+								{
+									;                                                       // else do nothing
+								}
+
+					irmp_pulse_time = 1;                                        // set counter to 1, not 0
+					irmp_pause_time = 0;
+					wait_for_start_space = 0;
+				}
+			}
+			else if (wait_for_space)                                            // the data section....
+			{
+				// counting the time of darkness....
+				uint8_t got_light = FALSE;
+
+				if (irmp_input)                                                 // still dark?
+				{
+					// yes...
+					if (irmp_bit == irmp_param.complete_len && irmp_param.stop_bit == 1)
+					{
+						if (
+#if IRMP_SUPPORT_MANCHESTER == 1
+						    (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) ||
+#endif
+#if IRMP_SUPPORT_SERIAL == 1
+						    (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL) ||
+#endif
+						    (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= irmp_param.pulse_0_len_max))
+						{
+#ifdef ANALYZE
+							if (!(irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))
+							{
+								ANALYZE_PRINTF("stop bit detected\n");
+							}
+#endif
+							irmp_param.stop_bit = 0;
+						}
+						else
+						{
+							ANALYZE_PRINTF("error: stop bit timing wrong, irmp_bit = %d, irmp_pulse_time = %d, pulse_0_len_min = %d, pulse_0_len_max = %d\n",
+							    irmp_bit, irmp_pulse_time, irmp_param.pulse_0_len_min, irmp_param.pulse_0_len_max);
+
+//                          irmp_busy_flag = FALSE;
+							irmp_start_bit_detected = 0;                        // wait for another start bit...
+							irmp_pulse_time         = 0;
+							irmp_pause_time         = 0;
+						}
+					}
+					else
+					{
+						irmp_pause_time++;                                                          // increment counter
+
+#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
+						if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL &&                           // Sony has a variable number of bits:
+						    irmp_pause_time > SIRCS_PAUSE_LEN_MAX &&                                // minimum is 12
+						    irmp_bit >= 12 - 1)                                                     // pause too long?
+						{
+							// yes, break and close this frame
+							irmp_param.complete_len = irmp_bit + 1;                                 // set new complete length
+							got_light = TRUE;                                                       // this is a lie, but helps (generates stop bit)
+							irmp_tmp_address |= (irmp_bit - SIRCS_MINIMUM_DATA_LEN + 1) << 8;       // new: store number of additional bits in upper byte of address!
+							irmp_param.command_end = irmp_param.command_offset + irmp_bit + 1;      // correct command length
+							irmp_pause_time = SIRCS_PAUSE_LEN_MAX - 1;                              // correct pause length
+						}
+						else
+#endif
+#if IRMP_SUPPORT_SERIAL == 1
+							// NETBOX generates no stop bit, here is the timeout condition:
+							if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL) && irmp_param.protocol == IRMP_NETBOX_PROTOCOL &&
+							    irmp_pause_time >= NETBOX_PULSE_LEN * (NETBOX_COMPLETE_DATA_LEN - irmp_bit))
+							{
+								got_light = TRUE;                                                       // this is a lie, but helps (generates stop bit)
+							}
+							else
+#endif
+#if IRMP_SUPPORT_GRUNDIG_NOKIA_IR60_PROTOCOL == 1
+								if (irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL && !irmp_param.stop_bit)
+								{
+									if (irmp_pause_time > IR60_TIMEOUT_LEN && irmp_bit == 6)
+									{
+										ANALYZE_PRINTF("Switching to IR60 protocol\n");
+										got_light = TRUE;                                       // this is a lie, but generates a stop bit ;-)
+										irmp_param.stop_bit = TRUE;                             // set flag
+
+										irmp_param.protocol         = IRMP_IR60_PROTOCOL;       // change protocol
+										irmp_param.complete_len     = IR60_COMPLETE_DATA_LEN;   // correct complete len
+										irmp_param.address_offset   = IR60_ADDRESS_OFFSET;
+										irmp_param.address_end      = IR60_ADDRESS_OFFSET + IR60_ADDRESS_LEN;
+										irmp_param.command_offset   = IR60_COMMAND_OFFSET;
+										irmp_param.command_end      = IR60_COMMAND_OFFSET + IR60_COMMAND_LEN;
+
+										irmp_tmp_command <<= 1;
+										irmp_tmp_command |= first_bit;
+									}
+									else if (irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= GRUNDIG_COMPLETE_DATA_LEN - 2)
+									{
+										// special manchester decoder
+										irmp_param.complete_len = GRUNDIG_COMPLETE_DATA_LEN;    // correct complete len
+										got_light = TRUE;                                       // this is a lie, but generates a stop bit ;-)
+										irmp_param.stop_bit = TRUE;                             // set flag
+									}
+									else if (irmp_bit >= GRUNDIG_COMPLETE_DATA_LEN)
+									{
+										ANALYZE_PRINTF("Switching to NOKIA protocol\n");
+										irmp_param.protocol         = IRMP_NOKIA_PROTOCOL;      // change protocol
+										irmp_param.address_offset   = NOKIA_ADDRESS_OFFSET;
+										irmp_param.address_end      = NOKIA_ADDRESS_OFFSET + NOKIA_ADDRESS_LEN;
+										irmp_param.command_offset   = NOKIA_COMMAND_OFFSET;
+										irmp_param.command_end      = NOKIA_COMMAND_OFFSET + NOKIA_COMMAND_LEN;
+
+										if (irmp_tmp_command & 0x300)
+										{
+											irmp_tmp_address = (irmp_tmp_command >> 8);
+											irmp_tmp_command &= 0xFF;
+										}
+									}
+								}
+								else
+#endif
+#if IRMP_SUPPORT_SIEMENS_OR_RUWIDO_PROTOCOL == 1
+									if (irmp_param.protocol == IRMP_RUWIDO_PROTOCOL && !irmp_param.stop_bit)
+									{
+										if (irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= RUWIDO_COMPLETE_DATA_LEN - 2)
+										{
+											// special manchester decoder
+											irmp_param.complete_len = RUWIDO_COMPLETE_DATA_LEN;     // correct complete len
+											got_light = TRUE;                                       // this is a lie, but generates a stop bit ;-)
+											irmp_param.stop_bit = TRUE;                             // set flag
+										}
+										else if (irmp_bit >= RUWIDO_COMPLETE_DATA_LEN)
+										{
+											ANALYZE_PRINTF("Switching to SIEMENS protocol\n");
+											irmp_param.protocol         = IRMP_SIEMENS_PROTOCOL;    // change protocol
+											irmp_param.address_offset   = SIEMENS_ADDRESS_OFFSET;
+											irmp_param.address_end      = SIEMENS_ADDRESS_OFFSET + SIEMENS_ADDRESS_LEN;
+											irmp_param.command_offset   = SIEMENS_COMMAND_OFFSET;
+											irmp_param.command_end      = SIEMENS_COMMAND_OFFSET + SIEMENS_COMMAND_LEN;
+
+											//                   76543210
+											// RUWIDO:  AAAAAAAAACCCCCCCp
+											// SIEMENS: AAAAAAAAAAACCCCCCCCCCp
+											irmp_tmp_address <<= 2;
+											irmp_tmp_address |= (irmp_tmp_command >> 6);
+											irmp_tmp_command &= 0x003F;
+											irmp_tmp_command <<= 4;
+											irmp_tmp_command |= last_value;
+										}
+									}
+									else
+#endif
+#if IRMP_SUPPORT_MANCHESTER == 1
+										if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
+										    irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= irmp_param.complete_len - 2 && !irmp_param.stop_bit)
+										{
+											// special manchester decoder
+											got_light = TRUE;                                   // this is a lie, but generates a stop bit ;-)
+											irmp_param.stop_bit = TRUE;                         // set flag
+										}
+										else
+#endif // IRMP_SUPPORT_MANCHESTER == 1
+											if (irmp_pause_time > IRMP_TIMEOUT_LEN)                 // timeout?
+											{
+												// yes...
+												if (irmp_bit == irmp_param.complete_len - 1 && irmp_param.stop_bit == 0)
+												{
+													irmp_bit++;
+												}
+#if IRMP_SUPPORT_JVC_PROTOCOL == 1
+												else if (irmp_param.protocol == IRMP_NEC_PROTOCOL && (irmp_bit == 16 || irmp_bit == 17))      // it was a JVC stop bit
+												{
+													ANALYZE_PRINTF("Switching to JVC protocol, irmp_bit = %d\n", irmp_bit);
+													irmp_param.stop_bit     = TRUE;                                     // set flag
+													irmp_param.protocol     = IRMP_JVC_PROTOCOL;                        // switch protocol
+													irmp_param.complete_len = irmp_bit;                                 // patch length: 16 or 17
+													irmp_tmp_command        = (irmp_tmp_address >> 4);                  // set command: upper 12 bits are command bits
+													irmp_tmp_address        = irmp_tmp_address & 0x000F;                // lower 4 bits are address bits
+													irmp_start_bit_detected = 1;                                        // tricky: don't wait for another start bit...
+												}
+#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
+
+#if IRMP_SUPPORT_NEC42_PROTOCOL == 1
+#if IRMP_SUPPORT_NEC_PROTOCOL == 1
+												else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && irmp_bit == 32)  // it was a NEC stop bit
+												{
+													ANALYZE_PRINTF("Switching to NEC protocol\n");
+													irmp_param.stop_bit     = TRUE;                                     // set flag
+													irmp_param.protocol     = IRMP_NEC_PROTOCOL;                        // switch protocol
+													irmp_param.complete_len = irmp_bit;                                 // patch length: 16 or 17
+
+													//        0123456789ABC0123456789ABC0123456701234567
+													// NEC42: AAAAAAAAAAAAAaaaaaaaaaaaaaCCCCCCCCcccccccc
+													// NEC:   AAAAAAAAaaaaaaaaCCCCCCCCcccccccc
+													irmp_tmp_address        |= (irmp_tmp_address2 & 0x0007) << 13;      // fm 2012-02-13: 12 -> 13
+													irmp_tmp_command        = (irmp_tmp_address2 >> 3) | (irmp_tmp_command << 10);
+												}
+#endif // IRMP_SUPPORT_NEC_PROTOCOL == 1
+#if IRMP_SUPPORT_JVC_PROTOCOL == 1
+												else if (irmp_param.protocol == IRMP_NEC42_PROTOCOL && (irmp_bit == 16 || irmp_bit == 17))  // it was a JVC stop bit
+												{
+													ANALYZE_PRINTF("Switching to JVC protocol, irmp_bit = %d\n", irmp_bit);
+													irmp_param.stop_bit     = TRUE;                                     // set flag
+													irmp_param.protocol     = IRMP_JVC_PROTOCOL;                        // switch protocol
+													irmp_param.complete_len = irmp_bit;                                 // patch length: 16 or 17
+
+													//        0123456789ABC0123456789ABC0123456701234567
+													// NEC42: AAAAAAAAAAAAAaaaaaaaaaaaaaCCCCCCCCcccccccc
+													// JVC:   AAAACCCCCCCCCCCC
+													irmp_tmp_command        = (irmp_tmp_address >> 4) | (irmp_tmp_address2 << 9);   // set command: upper 12 bits are command bits
+													irmp_tmp_address        = irmp_tmp_address & 0x000F;                            // lower 4 bits are address bits
+												}
+#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
+#endif // IRMP_SUPPORT_NEC42_PROTOCOL == 1
+												else
+												{
+													ANALYZE_PRINTF("error 2: pause %d after data bit %d too long\n", irmp_pause_time, irmp_bit);
+													ANALYZE_ONLY_NORMAL_PUTCHAR('\n');
+
+//                              irmp_busy_flag = FALSE;
+													irmp_start_bit_detected = 0;                    // wait for another start bit...
+													irmp_pulse_time         = 0;
+													irmp_pause_time         = 0;
+												}
+											}
+					}
+				}
+				else
+				{
+					// got light now!
+					got_light = TRUE;
+				}
+
+				if (got_light)
+				{
+					ANALYZE_PRINTF("%8.3fms [bit %2d: pulse = %3d, pause = %3d] ", (double)(time_counter * 1000) / F_INTERRUPTS, irmp_bit, irmp_pulse_time, irmp_pause_time);
+
+#if IRMP_SUPPORT_MANCHESTER == 1
+					if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))                                     // Manchester
+					{
+#if 1
+						if (irmp_pulse_time > irmp_param.pulse_1_len_max /* && irmp_pulse_time <= 2 * irmp_param.pulse_1_len_max */)
+#else // better, but some IR-RCs use asymmetric timings :-/
+						if (irmp_pulse_time > irmp_param.pulse_1_len_max && irmp_pulse_time <= 2 * irmp_param.pulse_1_len_max &&
+						    irmp_pause_time <= 2 * irmp_param.pause_1_len_max)
+#endif
+						{
+#if IRMP_SUPPORT_RC6_PROTOCOL == 1
+							if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 4 && irmp_pulse_time > RC6_TOGGLE_BIT_LEN_MIN)         // RC6 toggle bit
+							{
+								ANALYZE_PUTCHAR('T');
+								if (irmp_param.complete_len == RC6_COMPLETE_DATA_LEN_LONG)                      // RC6 mode 6A
+								{
+									irmp_store_bit(1);
+									last_value = 1;
+								}
+								else                                                                            // RC6 mode 0
+								{
+									irmp_store_bit(0);
+									last_value = 0;
+								}
+								ANALYZE_NEWLINE();
+							}
+							else
+#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
+							{
+								ANALYZE_PUTCHAR((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '0' : '1');
+								irmp_store_bit((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 0  :  1);
+
+#if IRMP_SUPPORT_RC6_PROTOCOL == 1
+								if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 4 && irmp_pulse_time > RC6_TOGGLE_BIT_LEN_MIN)      // RC6 toggle bit
+								{
+									ANALYZE_PUTCHAR('T');
+									irmp_store_bit(1);
+
+									if (irmp_pause_time > 2 * irmp_param.pause_1_len_max)
+									{
+										last_value = 0;
+									}
+									else
+									{
+										last_value = 1;
+									}
+									ANALYZE_NEWLINE();
+								}
+								else
+#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
+								{
+									ANALYZE_PUTCHAR((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? '1' : '0');
+									irmp_store_bit((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 :   0);
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
+									if (! irmp_param2.protocol)
+#endif
+									{
+										ANALYZE_NEWLINE();
+									}
+									last_value = (irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 : 0;
+								}
+							}
+						}
+						else if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_param.pulse_1_len_max
+						    /* && irmp_pause_time <= 2 * irmp_param.pause_1_len_max */)
+						{
+							uint8_t manchester_value;
+
+							if (last_pause > irmp_param.pause_1_len_max && last_pause <= 2 * irmp_param.pause_1_len_max)
+							{
+								manchester_value = last_value ? 0 : 1;
+								last_value  = manchester_value;
+							}
+							else
+							{
+								manchester_value = last_value;
+							}
+
+							ANALYZE_PUTCHAR(manchester_value + '0');
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && (IRMP_SUPPORT_FDC_PROTOCOL == 1 || IRMP_SUPPORT_RCCAR_PROTOCOL == 1)
+							if (! irmp_param2.protocol)
+#endif
+							{
+								ANALYZE_NEWLINE();
+							}
+
+#if IRMP_SUPPORT_RC6_PROTOCOL == 1
+							if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 1 && manchester_value == 1)     // RC6 mode != 0 ???
+							{
+								ANALYZE_PRINTF("Switching to RC6A protocol\n");
+								irmp_param.complete_len = RC6_COMPLETE_DATA_LEN_LONG;
+								irmp_param.address_offset = 5;
+								irmp_param.address_end = irmp_param.address_offset + 15;
+								irmp_param.command_offset = irmp_param.address_end + 1;                                 // skip 1 system bit, changes like a toggle bit
+								irmp_param.command_end = irmp_param.command_offset + 16 - 1;
+								irmp_tmp_address = 0;
+							}
+#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
+
+							irmp_store_bit(manchester_value);
+						}
+						else
+						{
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_FDC_PROTOCOL == 1
+							if (irmp_param2.protocol == IRMP_FDC_PROTOCOL &&
+							    irmp_pulse_time >= FDC_PULSE_LEN_MIN && irmp_pulse_time <= FDC_PULSE_LEN_MAX &&
+							    ((irmp_pause_time >= FDC_1_PAUSE_LEN_MIN && irmp_pause_time <= FDC_1_PAUSE_LEN_MAX) ||
+							        (irmp_pause_time >= FDC_0_PAUSE_LEN_MIN && irmp_pause_time <= FDC_0_PAUSE_LEN_MAX)))
+							{
+								ANALYZE_PUTCHAR('?');
+								irmp_param.protocol = 0;                // switch to FDC, see below
+							}
+							else
+#endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_RCCAR_PROTOCOL == 1
+								if (irmp_param2.protocol == IRMP_RCCAR_PROTOCOL &&
+								    irmp_pulse_time >= RCCAR_PULSE_LEN_MIN && irmp_pulse_time <= RCCAR_PULSE_LEN_MAX &&
+								    ((irmp_pause_time >= RCCAR_1_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_1_PAUSE_LEN_MAX) ||
+								        (irmp_pause_time >= RCCAR_0_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_0_PAUSE_LEN_MAX)))
+								{
+									ANALYZE_PUTCHAR('?');
+									irmp_param.protocol = 0;                // switch to RCCAR, see below
+								}
+								else
+#endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
+								{
+									ANALYZE_PUTCHAR('?');
+									ANALYZE_NEWLINE();
+									ANALYZE_PRINTF("error 3 manchester: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
+									ANALYZE_ONLY_NORMAL_PUTCHAR('\n');
+//                              irmp_busy_flag = FALSE;
+									irmp_start_bit_detected = 0;                            // reset flags and wait for next start bit
+									irmp_pause_time         = 0;
+								}
+						}
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_FDC_PROTOCOL == 1
+						if (irmp_param2.protocol == IRMP_FDC_PROTOCOL && irmp_pulse_time >= FDC_PULSE_LEN_MIN && irmp_pulse_time <= FDC_PULSE_LEN_MAX)
+						{
+							if (irmp_pause_time >= FDC_1_PAUSE_LEN_MIN && irmp_pause_time <= FDC_1_PAUSE_LEN_MAX)
+							{
+								ANALYZE_PRINTF("   1 (FDC)\n");
+								irmp_store_bit2(1);
+							}
+							else if (irmp_pause_time >= FDC_0_PAUSE_LEN_MIN && irmp_pause_time <= FDC_0_PAUSE_LEN_MAX)
+							{
+								ANALYZE_PRINTF("   0 (FDC)\n");
+								irmp_store_bit2(0);
+							}
+
+							if (! irmp_param.protocol)
+							{
+								ANALYZE_PRINTF("Switching to FDC protocol\n");
+								memcpy(&irmp_param, &irmp_param2, sizeof(IRMP_PARAMETER));
+								irmp_param2.protocol = 0;
+								irmp_tmp_address = irmp_tmp_address2;
+								irmp_tmp_command = irmp_tmp_command2;
+							}
+						}
+#endif // IRMP_SUPPORT_FDC_PROTOCOL == 1
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1 && IRMP_SUPPORT_RCCAR_PROTOCOL == 1
+						if (irmp_param2.protocol == IRMP_RCCAR_PROTOCOL && irmp_pulse_time >= RCCAR_PULSE_LEN_MIN && irmp_pulse_time <= RCCAR_PULSE_LEN_MAX)
+						{
+							if (irmp_pause_time >= RCCAR_1_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_1_PAUSE_LEN_MAX)
+							{
+								ANALYZE_PRINTF("   1 (RCCAR)\n");
+								irmp_store_bit2(1);
+							}
+							else if (irmp_pause_time >= RCCAR_0_PAUSE_LEN_MIN && irmp_pause_time <= RCCAR_0_PAUSE_LEN_MAX)
+							{
+								ANALYZE_PRINTF("   0 (RCCAR)\n");
+								irmp_store_bit2(0);
+							}
+
+							if (! irmp_param.protocol)
+							{
+								ANALYZE_PRINTF("Switching to RCCAR protocol\n");
+								memcpy(&irmp_param, &irmp_param2, sizeof(IRMP_PARAMETER));
+								irmp_param2.protocol = 0;
+								irmp_tmp_address = irmp_tmp_address2;
+								irmp_tmp_command = irmp_tmp_command2;
+							}
+						}
+#endif // IRMP_SUPPORT_RCCAR_PROTOCOL == 1
+
+						last_pause      = irmp_pause_time;
+						wait_for_space  = 0;
+					}
+					else
+#endif // IRMP_SUPPORT_MANCHESTER == 1
+
+#if IRMP_SUPPORT_SERIAL == 1
+						if (irmp_param.flags & IRMP_PARAM_FLAG_IS_SERIAL)
+						{
+							while (irmp_bit < irmp_param.complete_len && irmp_pulse_time > irmp_param.pulse_1_len_max)
+							{
+								ANALYZE_PUTCHAR('1');
+								irmp_store_bit(1);
+
+								if (irmp_pulse_time >= irmp_param.pulse_1_len_min)
+								{
+									irmp_pulse_time -= irmp_param.pulse_1_len_min;
+								}
+								else
+								{
+									irmp_pulse_time = 0;
+								}
+							}
+
+							while (irmp_bit < irmp_param.complete_len && irmp_pause_time > irmp_param.pause_1_len_max)
+							{
+								ANALYZE_PUTCHAR('0');
+								irmp_store_bit(0);
+
+								if (irmp_pause_time >= irmp_param.pause_1_len_min)
+								{
+									irmp_pause_time -= irmp_param.pause_1_len_min;
+								}
+								else
+								{
+									irmp_pause_time = 0;
+								}
+							}
+							ANALYZE_NEWLINE();
+							wait_for_space = 0;
+						}
+						else
+#endif // IRMP_SUPPORT_SERIAL == 1
+
+#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
+							if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit == 16)       // Samsung: 16th bit
+							{
+								if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_PULSE_LEN_MAX &&
+								    irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_START_BIT_PAUSE_LEN_MAX)
+								{
+									ANALYZE_PRINTF("SYNC\n");
+									wait_for_space = 0;
+									irmp_tmp_id = 0;
+									irmp_bit++;
+								}
+								else  if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_PULSE_LEN_MAX)
+								{
+									irmp_param.protocol         = IRMP_SAMSUNG32_PROTOCOL;
+									irmp_param.command_offset   = SAMSUNG32_COMMAND_OFFSET;
+									irmp_param.command_end      = SAMSUNG32_COMMAND_OFFSET + SAMSUNG32_COMMAND_LEN;
+									irmp_param.complete_len     = SAMSUNG32_COMPLETE_DATA_LEN;
+
+									if (irmp_pause_time >= SAMSUNG_1_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_1_PAUSE_LEN_MAX)
+									{
+										ANALYZE_PUTCHAR('1');
+										ANALYZE_NEWLINE();
+										irmp_store_bit(1);
+										wait_for_space = 0;
+									}
+									else
+									{
+										ANALYZE_PUTCHAR('0');
+										ANALYZE_NEWLINE();
+										irmp_store_bit(0);
+										wait_for_space = 0;
+									}
+
+									ANALYZE_PRINTF("Switching to SAMSUNG32 protocol\n");
+								}
+								else
+								{
+									// timing incorrect!
+									ANALYZE_PRINTF("error 3 Samsung: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
+									ANALYZE_ONLY_NORMAL_PUTCHAR('\n');
+//                          irmp_busy_flag = FALSE;
+									irmp_start_bit_detected = 0;                            // reset flags and wait for next start bit
+									irmp_pause_time         = 0;
+								}
+							}
+							else
+#endif // IRMP_SUPPORT_SAMSUNG_PROTOCOL
+
+#if IRMP_SUPPORT_NEC16_PROTOCOL
+#if IRMP_SUPPORT_NEC42_PROTOCOL == 1
+								if (irmp_param.protocol == IRMP_NEC42_PROTOCOL &&
+#else // IRMP_SUPPORT_NEC_PROTOCOL instead
+								if (irmp_param.protocol == IRMP_NEC_PROTOCOL &&
+#endif // IRMP_SUPPORT_NEC42_PROTOCOL == 1
+								    irmp_bit == 8 && irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_START_BIT_PAUSE_LEN_MAX)
+								{
+									ANALYZE_PRINTF("Switching to NEC16 protocol\n");
+									irmp_param.protocol         = IRMP_NEC16_PROTOCOL;
+									irmp_param.address_offset   = NEC16_ADDRESS_OFFSET;
+									irmp_param.address_end      = NEC16_ADDRESS_OFFSET + NEC16_ADDRESS_LEN;
+									irmp_param.command_offset   = NEC16_COMMAND_OFFSET;
+									irmp_param.command_end      = NEC16_COMMAND_OFFSET + NEC16_COMMAND_LEN;
+									irmp_param.complete_len     = NEC16_COMPLETE_DATA_LEN;
+									wait_for_space = 0;
+								}
+								else
+#endif // IRMP_SUPPORT_NEC16_PROTOCOL
+
+#if IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL == 1
+									if (irmp_param.protocol == IRMP_BANG_OLUFSEN_PROTOCOL)
+									{
+										if (irmp_pulse_time >= BANG_OLUFSEN_PULSE_LEN_MIN && irmp_pulse_time <= BANG_OLUFSEN_PULSE_LEN_MAX)
+										{
+											if (irmp_bit == 1)                                      // Bang & Olufsen: 3rd bit
+											{
+												if (irmp_pause_time >= BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MAX)
+												{
+													ANALYZE_PRINTF("3rd start bit\n");
+													wait_for_space = 0;
+													irmp_bit++;
+												}
+												else
+												{
+													// timing incorrect!
+													ANALYZE_PRINTF("error 3a B&O: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
+													ANALYZE_ONLY_NORMAL_PUTCHAR('\n');
+//                                  irmp_busy_flag = FALSE;
+													irmp_start_bit_detected = 0;                    // reset flags and wait for next start bit
+													irmp_pause_time         = 0;
+												}
+											}
+											else if (irmp_bit == 19)                                // Bang & Olufsen: trailer bit
+											{
+												if (irmp_pause_time >= BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_TRAILER_BIT_PAUSE_LEN_MAX)
+												{
+													ANALYZE_PRINTF("trailer bit\n");
+													wait_for_space = 0;
+													irmp_bit++;
+												}
+												else
+												{
+													// timing incorrect!
+													ANALYZE_PRINTF("error 3b B&O: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
+													ANALYZE_ONLY_NORMAL_PUTCHAR('\n');
+//                                  irmp_busy_flag = FALSE;
+													irmp_start_bit_detected = 0;                    // reset flags and wait for next start bit
+													irmp_pause_time         = 0;
+												}
+											}
+											else
+											{
+												if (irmp_pause_time >= BANG_OLUFSEN_1_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_1_PAUSE_LEN_MAX)
+												{
+													// pulse & pause timings correct for "1"?
+													ANALYZE_PUTCHAR('1');
+													ANALYZE_NEWLINE();
+													irmp_store_bit(1);
+													last_value = 1;
+													wait_for_space = 0;
+												}
+												else if (irmp_pause_time >= BANG_OLUFSEN_0_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_0_PAUSE_LEN_MAX)
+												{
+													// pulse & pause timings correct for "0"?
+													ANALYZE_PUTCHAR('0');
+													ANALYZE_NEWLINE();
+													irmp_store_bit(0);
+													last_value = 0;
+													wait_for_space = 0;
+												}
+												else if (irmp_pause_time >= BANG_OLUFSEN_R_PAUSE_LEN_MIN && irmp_pause_time <= BANG_OLUFSEN_R_PAUSE_LEN_MAX)
+												{
+													ANALYZE_PUTCHAR(last_value + '0');
+													ANALYZE_NEWLINE();
+													irmp_store_bit(last_value);
+													wait_for_space = 0;
+												}
+												else
+												{
+													// timing incorrect!
+													ANALYZE_PRINTF("error 3c B&O: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
+													ANALYZE_ONLY_NORMAL_PUTCHAR('\n');
+//                                  irmp_busy_flag = FALSE;
+													irmp_start_bit_detected = 0;                    // reset flags and wait for next start bit
+													irmp_pause_time         = 0;
+												}
+											}
+										}
+										else
+										{
+											// timing incorrect!
+											ANALYZE_PRINTF("error 3d B&O: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
+											ANALYZE_ONLY_NORMAL_PUTCHAR('\n');
+//                          irmp_busy_flag = FALSE;
+											irmp_start_bit_detected = 0;                            // reset flags and wait for next start bit
+											irmp_pause_time         = 0;
+										}
+									}
+									else
+#endif // IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL
+
+										if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_param.pulse_1_len_max &&
+										    irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_param.pause_1_len_max)
+										{
+											// pulse & pause timings correct for "1"?
+											ANALYZE_PUTCHAR('1');
+											ANALYZE_NEWLINE();
+											irmp_store_bit(1);
+											wait_for_space = 0;
+										}
+										else if (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= irmp_param.pulse_0_len_max &&
+										    irmp_pause_time >= irmp_param.pause_0_len_min && irmp_pause_time <= irmp_param.pause_0_len_max)
+										{
+											// pulse & pause timings correct for "0"?
+											ANALYZE_PUTCHAR('0');
+											ANALYZE_NEWLINE();
+											irmp_store_bit(0);
+											wait_for_space = 0;
+										}
+										else
+#if IRMP_SUPPORT_KATHREIN_PROTOCOL
+
+											if (irmp_param.protocol == IRMP_KATHREIN_PROTOCOL &&
+											    irmp_pulse_time >= KATHREIN_1_PULSE_LEN_MIN && irmp_pulse_time <= KATHREIN_1_PULSE_LEN_MAX &&
+											    (((irmp_bit == 8 || irmp_bit == 6) &&
+											            irmp_pause_time >= KATHREIN_SYNC_BIT_PAUSE_LEN_MIN && irmp_pause_time <= KATHREIN_SYNC_BIT_PAUSE_LEN_MAX) ||
+											        (irmp_bit == 12 &&
+											            irmp_pause_time >= KATHREIN_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= KATHREIN_START_BIT_PAUSE_LEN_MAX)))
+
+											{
+												if (irmp_bit == 8)
+												{
+													irmp_bit++;
+													ANALYZE_PUTCHAR('S');
+													ANALYZE_NEWLINE();
+													irmp_tmp_command <<= 1;
+												}
+												else
+												{
+													ANALYZE_PUTCHAR('S');
+													ANALYZE_NEWLINE();
+													irmp_store_bit(1);
+												}
+												wait_for_space = 0;
+											}
+											else
+#endif // IRMP_SUPPORT_KATHREIN_PROTOCOL
+											{
+												// timing incorrect!
+												ANALYZE_PRINTF("error 3: timing not correct: data bit %d,  pulse: %d, pause: %d\n", irmp_bit, irmp_pulse_time, irmp_pause_time);
+												ANALYZE_ONLY_NORMAL_PUTCHAR('\n');
+//                      irmp_busy_flag = FALSE;
+												irmp_start_bit_detected = 0;                                // reset flags and wait for next start bit
+												irmp_pause_time         = 0;
+											}
+
+					irmp_pulse_time = 1;                                            // set counter to 1, not 0
+				}
+			}
+			else
+			{
+				// counting the pulse length ...
+				if (! irmp_input)                                                   // still light?
+				{
+					// yes...
+					irmp_pulse_time++;                                              // increment counter
+				}
+				else
+				{
+					// now it's dark!
+					wait_for_space  = 1;                                            // let's count the time (see above)
+					irmp_pause_time = 1;                                            // set pause counter to 1, not 0
+				}
+			}
+
+			if (irmp_start_bit_detected && irmp_bit == irmp_param.complete_len && irmp_param.stop_bit == 0)    // enough bits received?
+			{
+				if (last_irmp_command == irmp_tmp_command && repetition_len < AUTO_FRAME_REPETITION_LEN)
+				{
+					repetition_frame_number++;
+				}
+				else
+				{
+					repetition_frame_number = 0;
+				}
+
+#if IRMP_SUPPORT_SIRCS_PROTOCOL == 1
+				// if SIRCS protocol and the code will be repeated within 50 ms, we will ignore 2nd and 3rd repetition frame
+				if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL && (repetition_frame_number == 1 || repetition_frame_number == 2))
+				{
+					ANALYZE_PRINTF("code skipped: SIRCS auto repetition frame #%d, counter = %d, auto repetition len = %d\n",
+					    repetition_frame_number + 1, repetition_len, AUTO_FRAME_REPETITION_LEN);
+					repetition_len = 0;
+				}
+				else
+#endif
+
+#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
+					// if KASEIKYO protocol and the code will be repeated within 50 ms, we will ignore 2nd repetition frame
+					if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL && repetition_frame_number == 1)
+					{
+						ANALYZE_PRINTF("code skipped: KASEIKYO auto repetition frame #%d, counter = %d, auto repetition len = %d\n",
+						    repetition_frame_number + 1, repetition_len, AUTO_FRAME_REPETITION_LEN);
+						repetition_len = 0;
+					}
+					else
+#endif
+
+#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
+						// if SAMSUNG32 protocol and the code will be repeated within 50 ms, we will ignore every 2nd frame
+						if (irmp_param.protocol == IRMP_SAMSUNG32_PROTOCOL && (repetition_frame_number & 0x01))
+						{
+							ANALYZE_PRINTF("code skipped: SAMSUNG32 auto repetition frame #%d, counter = %d, auto repetition len = %d\n",
+							    repetition_frame_number + 1, repetition_len, AUTO_FRAME_REPETITION_LEN);
+							repetition_len = 0;
+						}
+						else
+#endif
+
+#if IRMP_SUPPORT_NUBERT_PROTOCOL == 1
+							// if NUBERT protocol and the code will be repeated within 50 ms, we will ignore every 2nd frame
+							if (irmp_param.protocol == IRMP_NUBERT_PROTOCOL && (repetition_frame_number & 0x01))
+							{
+								ANALYZE_PRINTF("code skipped: NUBERT auto repetition frame #%d, counter = %d, auto repetition len = %d\n",
+								    repetition_frame_number + 1, repetition_len, AUTO_FRAME_REPETITION_LEN);
+								repetition_len = 0;
+							}
+							else
+#endif
+
+							{
+								ANALYZE_PRINTF("%8.3fms code detected, length = %d\n", (double)(time_counter * 1000) / F_INTERRUPTS, irmp_bit);
+								irmp_ir_detected = TRUE;
+
+#if IRMP_SUPPORT_DENON_PROTOCOL == 1
+								if (irmp_param.protocol == IRMP_DENON_PROTOCOL)
+								{
+									// check for repetition frame
+									if ((~irmp_tmp_command & 0x3FF) == last_irmp_denon_command) // command bits must be inverted
+									{
+										irmp_tmp_command = last_irmp_denon_command;             // use command received before!
+
+										irmp_protocol = irmp_param.protocol;                    // store protocol
+										irmp_address = irmp_tmp_address;                        // store address
+										irmp_command = irmp_tmp_command ;                       // store command
+									}
+									else
+									{
+										ANALYZE_PRINTF("waiting for inverted command repetition\n");
+										irmp_ir_detected = FALSE;
+										last_irmp_denon_command = irmp_tmp_command;
+									}
+								}
+								else
+#endif // IRMP_SUPPORT_DENON_PROTOCOL
+
+#if IRMP_SUPPORT_GRUNDIG_PROTOCOL == 1
+									if (irmp_param.protocol == IRMP_GRUNDIG_PROTOCOL && irmp_tmp_command == 0x01ff)
+									{
+										// Grundig start frame?
+										ANALYZE_PRINTF("Detected GRUNDIG start frame, ignoring it\n");
+										irmp_ir_detected = FALSE;
+									}
+									else
+#endif // IRMP_SUPPORT_GRUNDIG_PROTOCOL
+
+#if IRMP_SUPPORT_NOKIA_PROTOCOL == 1
+										if (irmp_param.protocol == IRMP_NOKIA_PROTOCOL && irmp_tmp_address == 0x00ff && irmp_tmp_command == 0x00fe)
+										{
+											// Nokia start frame?
+											ANALYZE_PRINTF("Detected NOKIA start frame, ignoring it\n");
+											irmp_ir_detected = FALSE;
+										}
+										else
+#endif // IRMP_SUPPORT_NOKIA_PROTOCOL
+										{
+#if IRMP_SUPPORT_NEC_PROTOCOL == 1
+											if (irmp_param.protocol == IRMP_NEC_PROTOCOL && irmp_bit == 0)  // repetition frame
+											{
+												if (repetition_len < NEC_FRAME_REPEAT_PAUSE_LEN_MAX)
+												{
+													ANALYZE_PRINTF("Detected NEC repetition frame, repetition_len = %d\n", repetition_len);
+													irmp_tmp_address = last_irmp_address;                   // address is last address
+													irmp_tmp_command = last_irmp_command;                   // command is last command
+													irmp_flags |= IRMP_FLAG_REPETITION;
+													repetition_len = 0;
+												}
+												else
+												{
+													ANALYZE_PRINTF("Detected NEC repetition frame, ignoring it: timeout occured, repetition_len = %d > %d\n",
+													    repetition_len, NEC_FRAME_REPEAT_PAUSE_LEN_MAX);
+													irmp_ir_detected = FALSE;
+												}
+											}
+#endif // IRMP_SUPPORT_NEC_PROTOCOL
+
+#if IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
+											if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
+											{
+												uint8_t xor;
+												// ANALYZE_PRINTF ("0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",
+												//                 xor_check[0], xor_check[1], xor_check[2], xor_check[3], xor_check[4], xor_check[5]);
+
+												xor = (xor_check[0] & 0x0F) ^ ((xor_check[0] & 0xF0) >> 4) ^ (xor_check[1] & 0x0F) ^ ((xor_check[1] & 0xF0) >> 4);
+
+												if (xor != (xor_check[2] & 0x0F))
+												{
+													ANALYZE_PRINTF("error 4: wrong XOR check for customer id: 0x%1x 0x%1x\n", xor, xor_check[2] & 0x0F);
+													irmp_ir_detected = FALSE;
+												}
+
+												xor = xor_check[2] ^ xor_check[3] ^ xor_check[4];
+
+												if (xor != xor_check[5])
+												{
+													ANALYZE_PRINTF("error 4: wrong XOR check for data bits: 0x%02x 0x%02x\n", xor, xor_check[5]);
+													irmp_ir_detected = FALSE;
+												}
+
+												irmp_flags |= genre2;       // write the genre2 bits into MSB of the flag byte
+											}
+#endif // IRMP_SUPPORT_KASEIKYO_PROTOCOL == 1
+
+#if IRMP_SUPPORT_RC6_PROTOCOL == 1
+											if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_param.complete_len == RC6_COMPLETE_DATA_LEN_LONG)     // RC6 mode = 6?
+											{
+												irmp_protocol = IRMP_RC6A_PROTOCOL;
+											}
+											else
+#endif // IRMP_SUPPORT_RC6_PROTOCOL == 1
+
+												irmp_protocol = irmp_param.protocol;
+
+#if IRMP_SUPPORT_FDC_PROTOCOL == 1
+											if (irmp_param.protocol == IRMP_FDC_PROTOCOL)
+											{
+												if (irmp_tmp_command & 0x000F)                          // released key?
+												{
+													irmp_tmp_command = (irmp_tmp_command >> 4) | 0x80;  // yes, set bit 7
+												}
+												else
+												{
+													irmp_tmp_command >>= 4;                             // no, it's a pressed key
+												}
+												irmp_tmp_command |= (irmp_tmp_address << 2) & 0x0F00;   // 000000CCCCAAAAAA -> 0000CCCC00000000
+												irmp_tmp_address &= 0x003F;
+											}
+#endif
+
+											irmp_address = irmp_tmp_address;                            // store address
+#if IRMP_SUPPORT_NEC_PROTOCOL == 1
+											if (irmp_param.protocol == IRMP_NEC_PROTOCOL)
+											{
+												last_irmp_address = irmp_tmp_address;                   // store as last address, too
+											}
+#endif
+
+#if IRMP_SUPPORT_RC5_PROTOCOL == 1
+											if (irmp_param.protocol == IRMP_RC5_PROTOCOL)
+											{
+												irmp_tmp_command |= rc5_cmd_bit6;                       // store bit 6
+											}
+#endif
+											irmp_command = irmp_tmp_command;                            // store command
+
+#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
+											irmp_id = irmp_tmp_id;
+#endif
+										}
+							}
+
+				if (irmp_ir_detected)
+				{
+					if (last_irmp_command == irmp_tmp_command &&
+					    last_irmp_address == irmp_tmp_address &&
+					    repetition_len < IRMP_KEY_REPETITION_LEN)
+					{
+						irmp_flags |= IRMP_FLAG_REPETITION;
+					}
+
+					last_irmp_address = irmp_tmp_address;                           // store as last address, too
+					last_irmp_command = irmp_tmp_command;                           // store as last command, too
+
+					repetition_len = 0;
+				}
+				else
+				{
+					ANALYZE_ONLY_NORMAL_PUTCHAR('\n');
+				}
+
+//              irmp_busy_flag          = FALSE;
+				irmp_start_bit_detected = 0;                                        // and wait for next start bit
+				irmp_tmp_command        = 0;
+				irmp_pulse_time         = 0;
+				irmp_pause_time         = 0;
+
+#if IRMP_SUPPORT_JVC_PROTOCOL == 1
+				if (irmp_protocol == IRMP_JVC_PROTOCOL)                             // the stop bit of JVC frame is also start bit of next frame
+				{
+					// set pulse time here!
+					irmp_pulse_time = ((uint8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME));
+				}
+#endif // IRMP_SUPPORT_JVC_PROTOCOL == 1
+			}
+		}
+	}
+	return (irmp_ir_detected);
+}
+
+#ifdef ANALYZE
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * main functions - for Unix/Linux + Windows only!
+ *
+ * AVR: see main.c!
+ *
+ * Compile it under linux with:
+ * cc irmp.c -o irmp
+ *
+ * usage: ./irmp [-v|-s|-a|-l|-p] < file
+ *
+ * options:
+ *   -v verbose
+ *   -s silent
+ *   -a analyze
+ *   -l list pulse/pauses
+ *   -p print timings
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+
+#ifndef IRMP_EMBED
+static void
+print_timings(void)
+{
+	printf("IRMP_TIMEOUT_LEN:        %d [%d byte(s)]\n", IRMP_TIMEOUT_LEN, sizeof(PAUSE_LEN));
+	printf("IRMP_KEY_REPETITION_LEN  %d\n", IRMP_KEY_REPETITION_LEN);
+	puts("");
+	printf("PROTOCOL       S  S-PULSE    S-PAUSE    PULSE-0    PAUSE-0    PULSE-1    PAUSE-1\n");
+	printf("====================================================================================\n");
+	printf("SIRCS          1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    SIRCS_START_BIT_PULSE_LEN_MIN, SIRCS_START_BIT_PULSE_LEN_MAX, SIRCS_START_BIT_PAUSE_LEN_MIN, SIRCS_START_BIT_PAUSE_LEN_MAX,
+	    SIRCS_0_PULSE_LEN_MIN, SIRCS_0_PULSE_LEN_MAX, SIRCS_PAUSE_LEN_MIN, SIRCS_PAUSE_LEN_MAX,
+	    SIRCS_1_PULSE_LEN_MIN, SIRCS_1_PULSE_LEN_MAX, SIRCS_PAUSE_LEN_MIN, SIRCS_PAUSE_LEN_MAX);
+
+	printf("NEC            1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX, NEC_START_BIT_PAUSE_LEN_MIN, NEC_START_BIT_PAUSE_LEN_MAX,
+	    NEC_PULSE_LEN_MIN, NEC_PULSE_LEN_MAX, NEC_0_PAUSE_LEN_MIN, NEC_0_PAUSE_LEN_MAX,
+	    NEC_PULSE_LEN_MIN, NEC_PULSE_LEN_MAX, NEC_1_PAUSE_LEN_MIN, NEC_1_PAUSE_LEN_MAX);
+
+	printf("NEC (rep)      1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    NEC_START_BIT_PULSE_LEN_MIN, NEC_START_BIT_PULSE_LEN_MAX, NEC_REPEAT_START_BIT_PAUSE_LEN_MIN, NEC_REPEAT_START_BIT_PAUSE_LEN_MAX,
+	    NEC_PULSE_LEN_MIN, NEC_PULSE_LEN_MAX, NEC_0_PAUSE_LEN_MIN, NEC_0_PAUSE_LEN_MAX,
+	    NEC_PULSE_LEN_MIN, NEC_PULSE_LEN_MAX, NEC_1_PAUSE_LEN_MIN, NEC_1_PAUSE_LEN_MAX);
+
+	printf("SAMSUNG        1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    SAMSUNG_START_BIT_PULSE_LEN_MIN, SAMSUNG_START_BIT_PULSE_LEN_MAX, SAMSUNG_START_BIT_PAUSE_LEN_MIN, SAMSUNG_START_BIT_PAUSE_LEN_MAX,
+	    SAMSUNG_PULSE_LEN_MIN, SAMSUNG_PULSE_LEN_MAX, SAMSUNG_0_PAUSE_LEN_MIN, SAMSUNG_0_PAUSE_LEN_MAX,
+	    SAMSUNG_PULSE_LEN_MIN, SAMSUNG_PULSE_LEN_MAX, SAMSUNG_1_PAUSE_LEN_MIN, SAMSUNG_1_PAUSE_LEN_MAX);
+
+	printf("MATSUSHITA     1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    MATSUSHITA_START_BIT_PULSE_LEN_MIN, MATSUSHITA_START_BIT_PULSE_LEN_MAX, MATSUSHITA_START_BIT_PAUSE_LEN_MIN, MATSUSHITA_START_BIT_PAUSE_LEN_MAX,
+	    MATSUSHITA_PULSE_LEN_MIN, MATSUSHITA_PULSE_LEN_MAX, MATSUSHITA_0_PAUSE_LEN_MIN, MATSUSHITA_0_PAUSE_LEN_MAX,
+	    MATSUSHITA_PULSE_LEN_MIN, MATSUSHITA_PULSE_LEN_MAX, MATSUSHITA_1_PAUSE_LEN_MIN, MATSUSHITA_1_PAUSE_LEN_MAX);
+
+	printf("KASEIKYO       1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    KASEIKYO_START_BIT_PULSE_LEN_MIN, KASEIKYO_START_BIT_PULSE_LEN_MAX, KASEIKYO_START_BIT_PAUSE_LEN_MIN, KASEIKYO_START_BIT_PAUSE_LEN_MAX,
+	    KASEIKYO_PULSE_LEN_MIN, KASEIKYO_PULSE_LEN_MAX, KASEIKYO_0_PAUSE_LEN_MIN, KASEIKYO_0_PAUSE_LEN_MAX,
+	    KASEIKYO_PULSE_LEN_MIN, KASEIKYO_PULSE_LEN_MAX, KASEIKYO_1_PAUSE_LEN_MIN, KASEIKYO_1_PAUSE_LEN_MAX);
+
+	printf("RECS80         1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    RECS80_START_BIT_PULSE_LEN_MIN, RECS80_START_BIT_PULSE_LEN_MAX, RECS80_START_BIT_PAUSE_LEN_MIN, RECS80_START_BIT_PAUSE_LEN_MAX,
+	    RECS80_PULSE_LEN_MIN, RECS80_PULSE_LEN_MAX, RECS80_0_PAUSE_LEN_MIN, RECS80_0_PAUSE_LEN_MAX,
+	    RECS80_PULSE_LEN_MIN, RECS80_PULSE_LEN_MAX, RECS80_1_PAUSE_LEN_MIN, RECS80_1_PAUSE_LEN_MAX);
+
+	printf("RC5            1  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX, RC5_START_BIT_LEN_MIN, RC5_START_BIT_LEN_MAX,
+	    RC5_BIT_LEN_MIN, RC5_BIT_LEN_MAX);
+
+	printf("DENON          1  %3d - %3d             %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX,
+	    DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX, DENON_0_PAUSE_LEN_MIN, DENON_0_PAUSE_LEN_MAX,
+	    DENON_PULSE_LEN_MIN, DENON_PULSE_LEN_MAX, DENON_1_PAUSE_LEN_MIN, DENON_1_PAUSE_LEN_MAX);
+
+	printf("THOMSON        1  %3d - %3d             %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    THOMSON_PULSE_LEN_MIN, THOMSON_PULSE_LEN_MAX,
+	    THOMSON_PULSE_LEN_MIN, THOMSON_PULSE_LEN_MAX, THOMSON_0_PAUSE_LEN_MIN, THOMSON_0_PAUSE_LEN_MAX,
+	    THOMSON_PULSE_LEN_MIN, THOMSON_PULSE_LEN_MAX, THOMSON_1_PAUSE_LEN_MIN, THOMSON_1_PAUSE_LEN_MAX);
+
+	printf("RC6            1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    RC6_START_BIT_PULSE_LEN_MIN, RC6_START_BIT_PULSE_LEN_MAX, RC6_START_BIT_PAUSE_LEN_MIN, RC6_START_BIT_PAUSE_LEN_MAX,
+	    RC6_BIT_PULSE_LEN_MIN, RC6_BIT_PULSE_LEN_MAX, RC6_BIT_PAUSE_LEN_MIN, RC6_BIT_PAUSE_LEN_MAX);
+
+	printf("RECS80EXT      1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    RECS80EXT_START_BIT_PULSE_LEN_MIN, RECS80EXT_START_BIT_PULSE_LEN_MAX, RECS80EXT_START_BIT_PAUSE_LEN_MIN, RECS80EXT_START_BIT_PAUSE_LEN_MAX,
+	    RECS80EXT_PULSE_LEN_MIN, RECS80EXT_PULSE_LEN_MAX, RECS80EXT_0_PAUSE_LEN_MIN, RECS80EXT_0_PAUSE_LEN_MAX,
+	    RECS80EXT_PULSE_LEN_MIN, RECS80EXT_PULSE_LEN_MAX, RECS80EXT_1_PAUSE_LEN_MIN, RECS80EXT_1_PAUSE_LEN_MAX);
+
+	printf("NUBERT         1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    NUBERT_START_BIT_PULSE_LEN_MIN, NUBERT_START_BIT_PULSE_LEN_MAX, NUBERT_START_BIT_PAUSE_LEN_MIN, NUBERT_START_BIT_PAUSE_LEN_MAX,
+	    NUBERT_0_PULSE_LEN_MIN, NUBERT_0_PULSE_LEN_MAX, NUBERT_0_PAUSE_LEN_MIN, NUBERT_0_PAUSE_LEN_MAX,
+	    NUBERT_1_PULSE_LEN_MIN, NUBERT_1_PULSE_LEN_MAX, NUBERT_1_PAUSE_LEN_MIN, NUBERT_1_PAUSE_LEN_MAX);
+
+	printf("BANG_OLUFSEN   1  %3d - %3d  %3d - %3d\n",
+	    BANG_OLUFSEN_START_BIT1_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT1_PULSE_LEN_MAX,
+	    BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT1_PAUSE_LEN_MAX);
+
+	printf("BANG_OLUFSEN   2  %3d - %3d  %3d - %3d\n",
+	    BANG_OLUFSEN_START_BIT2_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT2_PULSE_LEN_MAX,
+	    BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT2_PAUSE_LEN_MAX);
+
+	printf("BANG_OLUFSEN   3  %3d - %3d  %3d - %3d\n",
+	    BANG_OLUFSEN_START_BIT3_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT3_PULSE_LEN_MAX,
+	    BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT3_PAUSE_LEN_MAX);
+
+	printf("BANG_OLUFSEN   4  %3d - %3d  %3d - %3d\n",
+	    BANG_OLUFSEN_START_BIT4_PULSE_LEN_MIN, BANG_OLUFSEN_START_BIT4_PULSE_LEN_MAX,
+	    BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MIN, BANG_OLUFSEN_START_BIT4_PAUSE_LEN_MAX);
+
+	printf("BANG_OLUFSEN   -                        %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    BANG_OLUFSEN_PULSE_LEN_MIN, BANG_OLUFSEN_PULSE_LEN_MAX, BANG_OLUFSEN_0_PAUSE_LEN_MIN, BANG_OLUFSEN_0_PAUSE_LEN_MAX,
+	    BANG_OLUFSEN_PULSE_LEN_MIN, BANG_OLUFSEN_PULSE_LEN_MAX, BANG_OLUFSEN_1_PAUSE_LEN_MIN, BANG_OLUFSEN_1_PAUSE_LEN_MAX);
+
+	printf("GRUNDIG/NOKIA  1  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    GRUNDIG_NOKIA_IR60_START_BIT_LEN_MIN, GRUNDIG_NOKIA_IR60_START_BIT_LEN_MAX,
+	    GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MIN, GRUNDIG_NOKIA_IR60_PRE_PAUSE_LEN_MAX,
+	    GRUNDIG_NOKIA_IR60_BIT_LEN_MIN, GRUNDIG_NOKIA_IR60_BIT_LEN_MAX);
+
+	printf("SIEMENS/RUWIDO 1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MIN, SIEMENS_OR_RUWIDO_START_BIT_PULSE_LEN_MAX,
+	    SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MIN, SIEMENS_OR_RUWIDO_START_BIT_PAUSE_LEN_MAX,
+	    SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN, SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX,
+	    SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN, SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX,
+	    2 * SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MIN, 2 * SIEMENS_OR_RUWIDO_BIT_PULSE_LEN_MAX,
+	    2 * SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MIN, 2 * SIEMENS_OR_RUWIDO_BIT_PAUSE_LEN_MAX);
+
+	printf("GRUNDIG2       1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    GRUNDIG2_START_BIT_PULSE_LEN_MIN, GRUNDIG2_START_BIT_PULSE_LEN_MAX,
+	    GRUNDIG2_START_BIT_PAUSE_LEN_MIN, GRUNDIG2_START_BIT_PAUSE_LEN_MAX,
+	    GRUNDIG2_BIT_PULSE_LEN_MIN, GRUNDIG2_BIT_PULSE_LEN_MAX,
+	    GRUNDIG2_BIT_PAUSE_LEN_MIN, GRUNDIG2_BIT_PAUSE_LEN_MAX,
+	    2 * GRUNDIG2_BIT_PULSE_LEN_MIN, 2 * GRUNDIG2_BIT_PULSE_LEN_MAX,
+	    2 * GRUNDIG2_BIT_PAUSE_LEN_MIN, 2 * GRUNDIG2_BIT_PAUSE_LEN_MAX);
+
+	printf("FDC            1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    FDC_START_BIT_PULSE_LEN_MIN, FDC_START_BIT_PULSE_LEN_MAX, FDC_START_BIT_PAUSE_LEN_MIN, FDC_START_BIT_PAUSE_LEN_MAX,
+	    FDC_PULSE_LEN_MIN, FDC_PULSE_LEN_MAX, FDC_0_PAUSE_LEN_MIN, FDC_0_PAUSE_LEN_MAX,
+	    FDC_PULSE_LEN_MIN, FDC_PULSE_LEN_MAX, FDC_1_PAUSE_LEN_MIN, FDC_1_PAUSE_LEN_MAX);
+
+	printf("RCCAR          1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    RCCAR_START_BIT_PULSE_LEN_MIN, RCCAR_START_BIT_PULSE_LEN_MAX, RCCAR_START_BIT_PAUSE_LEN_MIN, RCCAR_START_BIT_PAUSE_LEN_MAX,
+	    RCCAR_PULSE_LEN_MIN, RCCAR_PULSE_LEN_MAX, RCCAR_0_PAUSE_LEN_MIN, RCCAR_0_PAUSE_LEN_MAX,
+	    RCCAR_PULSE_LEN_MIN, RCCAR_PULSE_LEN_MAX, RCCAR_1_PAUSE_LEN_MIN, RCCAR_1_PAUSE_LEN_MAX);
+
+	printf("NIKON          1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    NIKON_START_BIT_PULSE_LEN_MIN, NIKON_START_BIT_PULSE_LEN_MAX, NIKON_START_BIT_PAUSE_LEN_MIN, NIKON_START_BIT_PAUSE_LEN_MAX,
+	    NIKON_PULSE_LEN_MIN, NIKON_PULSE_LEN_MAX, NIKON_0_PAUSE_LEN_MIN, NIKON_0_PAUSE_LEN_MAX,
+	    NIKON_PULSE_LEN_MIN, NIKON_PULSE_LEN_MAX, NIKON_1_PAUSE_LEN_MIN, NIKON_1_PAUSE_LEN_MAX);
+
+	printf("LEGO           1  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d  %3d - %3d\n",
+	    LEGO_START_BIT_PULSE_LEN_MIN, LEGO_START_BIT_PULSE_LEN_MAX, LEGO_START_BIT_PAUSE_LEN_MIN, LEGO_START_BIT_PAUSE_LEN_MAX,
+	    LEGO_PULSE_LEN_MIN, LEGO_PULSE_LEN_MAX, LEGO_0_PAUSE_LEN_MIN, LEGO_0_PAUSE_LEN_MAX,
+	    LEGO_PULSE_LEN_MIN, LEGO_PULSE_LEN_MAX, LEGO_1_PAUSE_LEN_MIN, LEGO_1_PAUSE_LEN_MAX);
+
+}
+
+void
+print_spectrum(char *text, int *buf, int is_pulse)
+{
+	int     i;
+	int     j;
+	int     min;
+	int     max;
+	int     max_value = 0;
+	int     value;
+	int     sum = 0;
+	int     counter = 0;
+	double  average = 0;
+	double  tolerance;
+
+	puts("-------------------------------------------------------------------------------");
+	printf("%s:\n", text);
+
+	for (i = 0; i < 256; i++)
+	{
+		if (buf[i] > max_value)
+		{
+			max_value = buf[i];
+		}
+	}
+
+	for (i = 1; i < 100; i++)
+	{
+		if (buf[i] > 0)
+		{
+			printf("%3d ", i);
+			value = (buf[i] * 60) / max_value;
+
+			for (j = 0; j < value; j++)
+			{
+				putchar('o');
+			}
+			printf(" %d\n", buf[i]);
+
+			sum += i * buf[i];
+			counter += buf[i];
+		}
+		else
+		{
+			max = i - 1;
+
+			if (counter > 0)
+			{
+				average = (float) sum / (float) counter;
+
+				if (is_pulse)
+				{
+					printf("pulse ");
+				}
+				else
+				{
+					printf("pause ");
+				}
+
+				printf("avg: %4.1f=%6.1f us, ", average, (1000000. * average) / (float) F_INTERRUPTS);
+				printf("min: %2d=%6.1f us, ", min, (1000000. * min) / (float) F_INTERRUPTS);
+				printf("max: %2d=%6.1f us, ", max, (1000000. * max) / (float) F_INTERRUPTS);
+
+				tolerance = (max - average);
+
+				if (average - min > tolerance)
+				{
+					tolerance = average - min;
+				}
+
+				tolerance = tolerance * 100 / average;
+				printf("tol: %4.1f%%\n", tolerance);
+			}
+
+			counter = 0;
+			sum = 0;
+			min = i + 1;
+		}
+	}
+}
+#endif
+
+#define STATE_LEFT_SHIFT    0x01
+#define STATE_RIGHT_SHIFT   0x02
+#define STATE_LEFT_CTRL     0x04
+#define STATE_LEFT_ALT      0x08
+#define STATE_RIGHT_ALT     0x10
+
+#define KEY_ESCAPE          0x1B            // keycode = 0x006e
+#define KEY_MENUE           0x80            // keycode = 0x0070
+#define KEY_BACK            0x81            // keycode = 0x0071
+#define KEY_FORWARD         0x82            // keycode = 0x0072
+#define KEY_ADDRESS         0x83            // keycode = 0x0073
+#define KEY_WINDOW          0x84            // keycode = 0x0074
+#define KEY_1ST_PAGE        0x85            // keycode = 0x0075
+#define KEY_STOP            0x86            // keycode = 0x0076
+#define KEY_MAIL            0x87            // keycode = 0x0077
+#define KEY_FAVORITES       0x88            // keycode = 0x0078
+#define KEY_NEW_PAGE        0x89            // keycode = 0x0079
+#define KEY_SETUP           0x8A            // keycode = 0x007a
+#define KEY_FONT            0x8B            // keycode = 0x007b
+#define KEY_PRINT           0x8C            // keycode = 0x007c
+#define KEY_ON_OFF          0x8E            // keycode = 0x007c
+
+#define KEY_INSERT          0x90            // keycode = 0x004b
+#define KEY_DELETE          0x91            // keycode = 0x004c
+#define KEY_LEFT            0x92            // keycode = 0x004f
+#define KEY_HOME            0x93            // keycode = 0x0050
+#define KEY_END             0x94            // keycode = 0x0051
+#define KEY_UP              0x95            // keycode = 0x0053
+#define KEY_DOWN            0x96            // keycode = 0x0054
+#define KEY_PAGE_UP         0x97            // keycode = 0x0055
+#define KEY_PAGE_DOWN       0x98            // keycode = 0x0056
+#define KEY_RIGHT           0x99            // keycode = 0x0059
+#define KEY_MOUSE_1         0x9E            // keycode = 0x0400
+#define KEY_MOUSE_2         0x9F            // keycode = 0x0800
+
+#ifndef LIRC_IRMP
+static uint8_t
+get_fdc_key(uint16_t cmd)
+{
+	static uint8_t key_table[128] =
+	{
+		// 0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
+		0,  '^', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'ß', '´',  0,  '\b',
+		'\t', 'q', 'w', 'e', 'r', 't', 'z', 'u', 'i', 'o', 'p', 'ü', '+',  0,   0,  'a',
+		's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'ö', 'ä', '#',  '\r', 0,  '<', 'y', 'x',
+		'c', 'v', 'b', 'n', 'm', ',', '.', '-',  0,   0,   0,   0,   0,  ' ',  0,   0,
+
+		0,  '°', '!', '"', '§', '$', '%', '&', '/', '(', ')', '=', '?', '`',  0,  '\b',
+		'\t', 'Q', 'W', 'E', 'R', 'T', 'Z', 'U', 'I', 'O', 'P', 'Ü', '*',  0,   0,  'A',
+		'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'Ö', 'Ä', '\'', '\r', 0,  '>', 'Y', 'X',
+		'C', 'V', 'B', 'N', 'M', ';', ':', '_',  0,   0,   0,   0,   0,  ' ',  0,   0
+	};
+	static uint8_t state;
+
+	uint8_t key = 0;
+
+	switch (cmd)
+	{
+		case 0x002C:
+			state |=  STATE_LEFT_SHIFT;
+			break;              // pressed left shift
+		case 0x00AC:
+			state &= ~STATE_LEFT_SHIFT;
+			break;              // released left shift
+		case 0x0039:
+			state |=  STATE_RIGHT_SHIFT;
+			break;              // pressed right shift
+		case 0x00B9:
+			state &= ~STATE_RIGHT_SHIFT;
+			break;              // released right shift
+		case 0x003A:
+			state |=  STATE_LEFT_CTRL;
+			break;              // pressed left ctrl
+		case 0x00BA:
+			state &= ~STATE_LEFT_CTRL;
+			break;              // released left ctrl
+		case 0x003C:
+			state |=  STATE_LEFT_ALT;
+			break;              // pressed left alt
+		case 0x00BC:
+			state &= ~STATE_LEFT_ALT;
+			break;              // released left alt
+		case 0x003E:
+			state |=  STATE_RIGHT_ALT;
+			break;              // pressed left alt
+		case 0x00BE:
+			state &= ~STATE_RIGHT_ALT;
+			break;              // released left alt
+
+		case 0x006e:
+			key = KEY_ESCAPE;
+			break;
+		case 0x004b:
+			key = KEY_INSERT;
+			break;
+		case 0x004c:
+			key = KEY_DELETE;
+			break;
+		case 0x004f:
+			key = KEY_LEFT;
+			break;
+		case 0x0050:
+			key = KEY_HOME;
+			break;
+		case 0x0051:
+			key = KEY_END;
+			break;
+		case 0x0053:
+			key = KEY_UP;
+			break;
+		case 0x0054:
+			key = KEY_DOWN;
+			break;
+		case 0x0055:
+			key = KEY_PAGE_UP;
+			break;
+		case 0x0056:
+			key = KEY_PAGE_DOWN;
+			break;
+		case 0x0059:
+			key = KEY_RIGHT;
+			break;
+		case 0x0400:
+			key = KEY_MOUSE_1;
+			break;
+		case 0x0800:
+			key = KEY_MOUSE_2;
+			break;
+
+		default:
+		{
+			if (!(cmd & 0x80))                      // pressed key
+			{
+				if (cmd >= 0x70 && cmd <= 0x7F)     // function keys
+				{
+					key = cmd + 0x10;               // 7x -> 8x
+				}
+				else if (cmd < 64)                  // key listed in key_table
+				{
+					if (state & (STATE_LEFT_ALT | STATE_RIGHT_ALT))
+					{
+						switch (cmd)
+						{
+							case 0x0003:
+								key = '²';
+								break;
+							case 0x0008:
+								key = '{';
+								break;
+							case 0x0009:
+								key = '[';
+								break;
+							case 0x000A:
+								key = ']';
+								break;
+							case 0x000B:
+								key = '}';
+								break;
+							case 0x000C:
+								key = '\\';
+								break;
+							case 0x001C:
+								key = '~';
+								break;
+							case 0x002D:
+								key = '|';
+								break;
+							case 0x0034:
+								key = 0xB5;
+								break; // Mu
+						}
+					}
+					else if (state & (STATE_LEFT_CTRL))
+					{
+						if (key_table[cmd] >= 'a' && key_table[cmd] <= 'z')
+						{
+							key = key_table[cmd] - 'a' + 1;
+						}
+						else
+						{
+							key = key_table[cmd];
+						}
+					}
+					else
+					{
+						int idx = cmd + ((state & (STATE_LEFT_SHIFT | STATE_RIGHT_SHIFT)) ? 64 : 0);
+
+						if (key_table[idx])
+						{
+							key = key_table[idx];
+						}
+					}
+				}
+			}
+			break;
+		}
+	}
+
+	return (key);
+}
+
+static int         analyze = FALSE;
+static int         list = FALSE;
+static IRMP_DATA   irmp_data;
+
+static void
+next_tick(void)
+{
+	if (! analyze && ! list)
+	{
+		(void) irmp_ISR();
+
+		if (irmp_get_data(&irmp_data))
+		{
+			uint8_t key;
+
+			ANALYZE_ONLY_NORMAL_PUTCHAR(' ');
+
+			if (verbose)
+			{
+				printf("%8.3fms ", (double)(time_counter * 1000) / F_INTERRUPTS);
+			}
+
+			if (irmp_data.protocol == IRMP_FDC_PROTOCOL && (key = get_fdc_key(irmp_data.command)) != 0)
+			{
+				if ((key >= 0x20 && key < 0x7F) || key >= 0xA0)
+				{
+					printf("p = %2d, a = 0x%04x, c = 0x%04x, f = 0x%02x, asc = 0x%02x, key = '%c'\n",
+					    irmp_data.protocol, irmp_data.address, irmp_data.command, irmp_data.flags, key, key);
+				}
+				else if (key == '\r' || key == '\t' || key == KEY_ESCAPE || (key >= 0x80 && key <= 0x9F))                 // function keys
+				{
+					char *p = (char *) NULL;
+
+					switch (key)
+					{
+						case '\t'                :
+							p = "TAB";
+							break;
+						case '\r'                :
+							p = "CR";
+							break;
+						case KEY_ESCAPE          :
+							p = "ESCAPE";
+							break;
+						case KEY_MENUE           :
+							p = "MENUE";
+							break;
+						case KEY_BACK            :
+							p = "BACK";
+							break;
+						case KEY_FORWARD         :
+							p = "FORWARD";
+							break;
+						case KEY_ADDRESS         :
+							p = "ADDRESS";
+							break;
+						case KEY_WINDOW          :
+							p = "WINDOW";
+							break;
+						case KEY_1ST_PAGE        :
+							p = "1ST_PAGE";
+							break;
+						case KEY_STOP            :
+							p = "STOP";
+							break;
+						case KEY_MAIL            :
+							p = "MAIL";
+							break;
+						case KEY_FAVORITES       :
+							p = "FAVORITES";
+							break;
+						case KEY_NEW_PAGE        :
+							p = "NEW_PAGE";
+							break;
+						case KEY_SETUP           :
+							p = "SETUP";
+							break;
+						case KEY_FONT            :
+							p = "FONT";
+							break;
+						case KEY_PRINT           :
+							p = "PRINT";
+							break;
+						case KEY_ON_OFF          :
+							p = "ON_OFF";
+							break;
+
+						case KEY_INSERT          :
+							p = "INSERT";
+							break;
+						case KEY_DELETE          :
+							p = "DELETE";
+							break;
+						case KEY_LEFT            :
+							p = "LEFT";
+							break;
+						case KEY_HOME            :
+							p = "HOME";
+							break;
+						case KEY_END             :
+							p = "END";
+							break;
+						case KEY_UP              :
+							p = "UP";
+							break;
+						case KEY_DOWN            :
+							p = "DOWN";
+							break;
+						case KEY_PAGE_UP         :
+							p = "PAGE_UP";
+							break;
+						case KEY_PAGE_DOWN       :
+							p = "PAGE_DOWN";
+							break;
+						case KEY_RIGHT           :
+							p = "RIGHT";
+							break;
+						case KEY_MOUSE_1         :
+							p = "KEY_MOUSE_1";
+							break;
+						case KEY_MOUSE_2         :
+							p = "KEY_MOUSE_2";
+							break;
+						default                  :
+							p = "<UNKNWON>";
+							break;
+					}
+
+					printf("p = %2d, a = 0x%04x, c = 0x%04x, f = 0x%02x, asc = 0x%02x, key = %s\n",
+					    irmp_data.protocol, irmp_data.address, irmp_data.command, irmp_data.flags, key, p);
+				}
+				else
+				{
+					printf("p = %2d, a = 0x%04x, c = 0x%04x, f = 0x%02x, asc = 0x%02x\n",
+					    irmp_data.protocol, irmp_data.address, irmp_data.command, irmp_data.flags, key);
+				}
+			}
+			else
+			{
+				printf("p = %2d, a = 0x%04x, c = 0x%04x, f = 0x%02x\n",
+				    irmp_data.protocol, irmp_data.address, irmp_data.command, irmp_data.flags);
+			}
+		}
+	}
+}
+#endif
+
+#ifndef LIRC_IRMP
+int
+main(int argc, char **argv)
+{
+	int         i;
+	int         ch;
+	int         last_ch = 0;
+	int         pulse = 0;
+	int         pause = 0;
+
+	int         start_pulses[256];
+	int         start_pauses[256];
+	int         pulses[256];
+	int         pauses[256];
+
+	int         first_pulse = TRUE;
+	int         first_pause = TRUE;
+
+	if (argc == 2)
+	{
+		if (! strcmp(argv[1], "-v"))
+		{
+			verbose = TRUE;
+		}
+		else if (! strcmp(argv[1], "-l"))
+		{
+			list = TRUE;
+		}
+		else if (! strcmp(argv[1], "-a"))
+		{
+			analyze = TRUE;
+		}
+		else if (! strcmp(argv[1], "-s"))
+		{
+			silent = TRUE;
+		}
+		else if (! strcmp(argv[1], "-p"))
+		{
+			print_timings();
+			return (0);
+		}
+	}
+
+	for (i = 0; i < 256; i++)
+	{
+		start_pulses[i] = 0;
+		start_pauses[i] = 0;
+		pulses[i] = 0;
+		pauses[i] = 0;
+	}
+
+	IRMP_PIN = 0xFF;
+
+	while ((ch = getchar()) != EOF)
+	{
+		if (ch == '_' || ch == '0')
+		{
+			if (last_ch != ch)
+			{
+				if (pause > 0)
+				{
+					if (list)
+					{
+						printf("pause: %d\n", pause);
+					}
+
+					if (analyze)
+					{
+						if (first_pause)
+						{
+							if (pause < 256)
+							{
+								start_pauses[pause]++;
+							}
+							first_pause = FALSE;
+						}
+						else
+						{
+							if (pause < 256)
+							{
+								pauses[pause]++;
+							}
+						}
+					}
+				}
+				pause = 0;
+			}
+			pulse++;
+			IRMP_PIN = 0x00;
+		}
+		else if (ch == 0xaf || ch == '-' || ch == '1')
+		{
+			if (last_ch != ch)
+			{
+				if (list)
+				{
+					printf("pulse: %d ", pulse);
+				}
+
+				if (analyze)
+				{
+					if (first_pulse)
+					{
+						if (pulse < 256)
+						{
+							start_pulses[pulse]++;
+						}
+						first_pulse = FALSE;
+					}
+					else
+					{
+						if (pulse < 256)
+						{
+							pulses[pulse]++;
+						}
+					}
+				}
+				pulse = 0;
+			}
+
+			pause++;
+			IRMP_PIN = 0xff;
+		}
+		else if (ch == '\n')
+		{
+			IRMP_PIN = 0xff;
+
+			if (list && pause > 0)
+			{
+				printf("pause: %d\n", pause);
+			}
+			pause = 0;
+
+			if (! analyze)
+			{
+				for (i = 0; i < (int)((8000.0 * F_INTERRUPTS) / 10000); i++)                // newline: long pause of 800 msec
+				{
+					next_tick();
+				}
+			}
+			first_pulse = TRUE;
+			first_pause = TRUE;
+		}
+		else if (ch == '#')
+		{
+			if (analyze)
+			{
+				while ((ch = getchar()) != '\n' && ch != EOF)
+				{
+					;
+				}
+			}
+			else
+			{
+				puts("-------------------------------------------------------------------");
+				putchar(ch);
+
+				while ((ch = getchar()) != '\n' && ch != EOF)
+				{
+					if (ch != '\r')                                                         // ignore CR in DOS/Windows files
+					{
+						putchar(ch);
+					}
+				}
+				putchar('\n');
+			}
+
+		}
+
+		last_ch = ch;
+
+		next_tick();
+	}
+
+	if (analyze)
+	{
+		print_spectrum("START PULSES", start_pulses, TRUE);
+		print_spectrum("START PAUSES", start_pauses, FALSE);
+		print_spectrum("PULSES", pulses, TRUE);
+		print_spectrum("PAUSES", pauses, FALSE);
+		puts("-------------------------------------------------------------------------------");
+	}
+	return 0;
+}
+#else
+#ifndef IRMP_EMBED
+/* 50 ms. This should be longer than the longest light pulse */
+#define POLL_MS     (50 * 1000)
+#define LIRC_PULSE  0x01000000
+#define LIRC_PULSE_MASK 0x00FFFFFF
+
+int main(int argc, char **argv)
+{
+	int fd;
+	int pulse;
+	int last_pulse = 1;
+	uint32_t lircdata;  /* lirc_t to be correct... */
+	unsigned int count = 0; /* how many timeouts? */
+	IRMP_DATA d;
+
+	silent = TRUE;
+
+	if (argc == 2)
+	{
+		if (! strcmp(argv[1], "-v"))
+		{
+			verbose = TRUE;
+			silent = FALSE;
+		}
+		else if (! strcmp(argv[1], "-p"))
+		{
+			print_timings();
+			return (0);
+		}
+	}
+
+	IRMP_PIN = 0xFF;
+	fd = open("/dev/lirc", O_RDONLY);
+	if (fd < 0)
+	{
+		perror("open /dev/lirc");
+		return 1;
+	}
+	/* TODO: ioctl to find out if we have a compatible LIRC_MODE2 device */
+
+	while (1)
+	{
+		fd_set fds;
+		struct timeval tv;
+		int ret;
+
+		FD_ZERO(&fds);
+		FD_SET(fd, &fds);
+		tv.tv_sec = 0;
+		tv.tv_usec = POLL_MS;
+		/* any singal can interrupt select. we rely on the linux-only feature
+		 * that the timeout is automatcally recalculated in this case! */
+		do
+		{
+			ret = select(fd + 1, &fds, NULL, NULL, &tv);
+		}
+		while (ret == -1 && errno == EINTR);
+
+		if (ret == -1)
+		{
+			/* errno != EINTR... */
+			perror("lirmp: select");
+			break;
+		}
+
+		if (ret == 0)
+		{
+			count++;
+			lircdata = POLL_MS; /* timeout */
+			pulse = !last_pulse;    /* lirc sends data on signal change */
+		}
+		else
+		{
+			if (read(fd, &lircdata, sizeof(lircdata)) != sizeof(lircdata))
+			{
+				perror("read");
+				break;
+			}
+			pulse = (lircdata & LIRC_PULSE);    /* we got light... */
+			last_pulse = pulse;
+			lircdata &= LIRC_PULSE_MASK;        /* how long the pulse was in microseconds */
+		}
+
+		if (ret && count)
+		{
+			if (count * POLL_MS > lircdata)
+				lircdata = 0;
+			else
+				lircdata -= count * POLL_MS;
+			count = 0;
+		}
+		//printf("lircdata: ret:%d c:%d %d\n", ret, ch - '0', lircdata);
+		lircdata /= (1000000 / F_INTERRUPTS);
+
+		if (pulse)
+			IRMP_PIN = 0x00;
+		else
+			IRMP_PIN = 0xff;
+
+		do
+		{
+			(void) irmp_ISR();
+			if (irmp_get_data(&d))
+			{
+				printf("protocol: %2d address: 0x%04x command: 0x%04x flags: %d\n",
+				    d.protocol, d.address, d.command, d.flags);
+
+				/* do something else here... */
+
+				/* todo: do we need to complete the loop if we already
+				 * detected the singal in this pulse? */
+			}
+		}
+		while (lircdata-- > 0);
+	}
+	return 0;
+}
+#endif // IRMP_EMBED
+#endif // LIRC_IRMP
+#endif // ANALYZE
diff -Nur libstb-hal-ddt.git.orig/libspark/irmpconfig.h libstb-hal-ddt.git/libspark/irmpconfig.h
--- libstb-hal-ddt.git.orig/libspark/irmpconfig.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/irmpconfig.h	2022-07-23 18:18:31.543772226 +0200
@@ -1,191 +1,191 @@
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * irmpconfig.h
- *
- * Copyright (c) 2009-2011 Frank Meyer - frank(at)fli4l.de
- *
- * $Id: irmpconfig.h,v 1.80 2012/02/21 08:41:46 fm Exp $
- *
- * ATMEGA88 @ 8 MHz
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-
-#ifndef _IRMPCONFIG_H_
-#define _IRMPCONFIG_H_
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * Change F_INTERRUPTS if you change the number of interrupts per second,
- * Normally, F_INTERRUPTS should be in the range from 10000 to 15000, typical is 15000
- * A value above 15000 costs additional program space, absolute maximum value is 20000.
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#ifndef F_INTERRUPTS
-#define F_INTERRUPTS                            15000   // interrupts per second, min: 10000, max: 20000, typ: 15000
-#endif
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * Change settings from 1 to 0 if you want to disable one or more decoders.
- * This saves program space.
- *
- * 1 enable  decoder
- * 0 disable decoder
- *
- * The standard decoders are enabled per default.
- * Less common protocols are disabled here, you need to enable them manually.
- *
- * If you want to use FDC or RCCAR simultaneous with RC5 protocol, additional program space is required.
- * If you don't need RC5 when using FDC/RCCAR, you should disable RC5.
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-
-// typical protocols, disable here!             Enable  Remarks                 F_INTERRUPTS            Program Space
-#define IRMP_SUPPORT_SIRCS_PROTOCOL             1       // Sony SIRCS           >= 10000                 ~150 bytes
-#define IRMP_SUPPORT_NEC_PROTOCOL               1       // NEC + APPLE          >= 10000                 ~300 bytes
-#define IRMP_SUPPORT_SAMSUNG_PROTOCOL           1       // Samsung + Samsung32  >= 10000                 ~300 bytes
-#define IRMP_SUPPORT_MATSUSHITA_PROTOCOL        1       // Matsushita           >= 10000                  ~50 bytes
-#define IRMP_SUPPORT_KASEIKYO_PROTOCOL          1       // Kaseikyo             >= 10000                 ~250 bytes
-#define IRMP_SUPPORT_DENON_PROTOCOL             1       // DENON, Sharp         >= 10000                 ~250 bytes
-
-// more protocols, enable here!                 Enable  Remarks                 F_INTERRUPTS            Program Space
-#define IRMP_SUPPORT_RC5_PROTOCOL               0       // RC5                  >= 10000                 ~250 bytes
-#define IRMP_SUPPORT_RC6_PROTOCOL               0       // RC6 & RC6A           >= 10000                 ~250 bytes
-#define IRMP_SUPPORT_JVC_PROTOCOL               0       // JVC                  >= 10000                 ~150 bytes
-#define IRMP_SUPPORT_NEC16_PROTOCOL             0       // NEC16                >= 10000                 ~100 bytes
-#define IRMP_SUPPORT_NEC42_PROTOCOL             0       // NEC42                >= 10000                 ~300 bytes
-#define IRMP_SUPPORT_IR60_PROTOCOL              0       // IR60 (SAB2008)       >= 10000                 ~300 bytes
-#define IRMP_SUPPORT_GRUNDIG_PROTOCOL           0       // Grundig              >= 10000                 ~300 bytes
-#define IRMP_SUPPORT_SIEMENS_PROTOCOL           0       // Siemens Gigaset      >= 15000                 ~550 bytes
-#define IRMP_SUPPORT_NOKIA_PROTOCOL             0       // Nokia                >= 10000                 ~300 bytes
-
-// exotic protocols, enable here!               Enable  Remarks                 F_INTERRUPTS            Program Space
-#define IRMP_SUPPORT_GRUNDIG2_PROTOCOL          0       // Grundig TP400        >= 10000                 ~300 bytes
-#define IRMP_SUPPORT_KATHREIN_PROTOCOL          0       // Kathrein             >= 10000                 ~200 bytes
-#define IRMP_SUPPORT_NUBERT_PROTOCOL            0       // NUBERT               >= 10000                  ~50 bytes
-#define IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL      0       // Bang & Olufsen       >= 10000                 ~200 bytes
-#define IRMP_SUPPORT_RECS80_PROTOCOL            0       // RECS80 (SAA3004)     >= 15000                  ~50 bytes
-#define IRMP_SUPPORT_RECS80EXT_PROTOCOL         0       // RECS80EXT (SAA3008)  >= 15000                  ~50 bytes
-#define IRMP_SUPPORT_THOMSON_PROTOCOL           0       // Thomson              >= 10000                 ~250 bytes
-#define IRMP_SUPPORT_NIKON_PROTOCOL             0       // NIKON camera         >= 10000                 ~250 bytes
-#define IRMP_SUPPORT_NETBOX_PROTOCOL            0       // Netbox keyboard      >= 10000                 ~400 bytes (PROTOTYPE!)
-#define IRMP_SUPPORT_FDC_PROTOCOL               0       // FDC3402 keyboard     >= 10000 (better 15000)  ~150 bytes (~400 in combination with RC5)
-#define IRMP_SUPPORT_RCCAR_PROTOCOL             0       // RC Car               >= 10000 (better 15000)  ~150 bytes (~500 in combination with RC5)
-#define IRMP_SUPPORT_RUWIDO_PROTOCOL            0       // RUWIDO, T-Home       >= 15000                 ~550 bytes
-#define IRMP_SUPPORT_LEGO_PROTOCOL              0       // LEGO Power RC        >= 20000                 ~150 bytes
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * Change hardware pin here:
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#if defined (PIC_C18)                                                   // Microchip C18 Compiler
-#include <p18cxxx.h>                                                    // main PIC18 h file
-#define IRMP_PIN                                PORTBbits.RB4           // use RB4 as IR input on PIC
-#define input(x)                                (x)
-
-#elif defined (PIC_CCS_COMPILER)                                        // PIC CCS Compiler:
-#define IRMP_PIN                                PIN_B4                  // use PB4 as IR input on PIC
-
-#else                                                                   // AVR:
-
-#ifndef ARDUINO
-#define IRMP_PORT                               PORTB
-#define IRMP_DDR                                DDRB
-#define IRMP_PIN                                PINB
-#define IRMP_BIT                                6                       // use PB6 as IR input on AVR
-#else  // ARDUINO
-#define IRMP_PIN                                PIND                    // use digital pin 2 as IR input
-#define IRMP_BIT                                2                       // on arduino
-#endif // ARDUINO
-
-#define input(x)                                ((x) & (1 << IRMP_BIT))
-#endif
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * Set IRMP_LOGGING to 1 if want to log data to UART with 9600Bd
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#ifndef IRMP_LOGGING
-#define IRMP_LOGGING                            0       // 1: log IR signal (scan), 0: do not (default)
-#endif
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * Use external logging routines
- * If you enable external logging, you have also to enable IRMP_LOGGING above
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#ifndef IRMP_EXT_LOGGING
-#define IRMP_EXT_LOGGING                        0       // 1:log, 0: do not log  ; 
-#endif
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * Set IRMP_PROTOCOL_NAMES to 1 if want to access protocol names (for logging etc), costs ~300 bytes RAM!
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#define IRMP_PROTOCOL_NAMES                     0       // 1: access protocol names, 0: do not (default),
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * Use Callbacks to indicate input signal
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#define IRMP_USE_CALLBACK                       0       // flag: 0 = don't use callbacks, 1 = use callbacks, default is 0
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * DO NOT CHANGE THE FOLLOWING LINES !
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#if IRMP_SUPPORT_SIEMENS_PROTOCOL == 1 && F_INTERRUPTS < 15000
-#  warning F_INTERRUPTS too low, SIEMENS protocol disabled (should be at least 15000)
-#  undef IRMP_SUPPORT_SIEMENS_PROTOCOL
-#  define IRMP_SUPPORT_SIEMENS_PROTOCOL         0
-#endif
-
-#if IRMP_SUPPORT_RUWIDO_PROTOCOL == 1 && F_INTERRUPTS < 15000
-#  warning F_INTERRUPTS too low, RUWIDO protocol disabled (should be at least 15000)
-#  undef IRMP_SUPPORT_RUWIDO_PROTOCOL
-#  define IRMP_SUPPORT_RUWIDO_PROTOCOL          0
-#endif
-
-#if IRMP_SUPPORT_RECS80_PROTOCOL == 1 && F_INTERRUPTS < 15000
-#  warning F_INTERRUPTS too low, RECS80 protocol disabled (should be at least 15000)
-#  undef IRMP_SUPPORT_RECS80_PROTOCOL
-#  define IRMP_SUPPORT_RECS80_PROTOCOL          0
-#endif
-
-#if IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1 && F_INTERRUPTS < 15000
-#  warning F_INTERRUPTS too low, RECS80EXT protocol disabled (should be at least 15000)
-#  undef IRMP_SUPPORT_RECS80EXT_PROTOCOL
-#  define IRMP_SUPPORT_RECS80EXT_PROTOCOL       0
-#endif
-
-#if IRMP_SUPPORT_LEGO_PROTOCOL == 1 && F_INTERRUPTS < 20000
-#  warning F_INTERRUPTS too low, LEGO protocol disabled (should be at least 20000)
-#  undef IRMP_SUPPORT_LEGO_PROTOCOL
-#  define IRMP_SUPPORT_LEGO_PROTOCOL            0
-#endif
-
-#if IRMP_SUPPORT_JVC_PROTOCOL == 1 && IRMP_SUPPORT_NEC_PROTOCOL == 0
-#  warning JVC protocol needs also NEC protocol, NEC protocol enabled
-#  undef IRMP_SUPPORT_NEC_PROTOCOL
-#  define IRMP_SUPPORT_NEC_PROTOCOL             1
-#endif
-
-#if IRMP_SUPPORT_NEC16_PROTOCOL == 1 && IRMP_SUPPORT_NEC_PROTOCOL == 0
-#  warning NEC16 protocol needs also NEC protocol, NEC protocol enabled
-#  undef IRMP_SUPPORT_NEC_PROTOCOL
-#  define IRMP_SUPPORT_NEC_PROTOCOL             1
-#endif
-
-#if IRMP_SUPPORT_NEC42_PROTOCOL == 1 && IRMP_SUPPORT_NEC_PROTOCOL == 0
-#  warning NEC42 protocol needs also NEC protocol, NEC protocol enabled
-#  undef IRMP_SUPPORT_NEC_PROTOCOL
-#  define IRMP_SUPPORT_NEC_PROTOCOL             1
-#endif
-
-#if F_INTERRUPTS > 20000
-#error F_INTERRUPTS too high (should be not greater than 20000)
-#endif
-
-#endif /* _WC_IRMPCONFIG_H_ */
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * irmpconfig.h
+ *
+ * Copyright (c) 2009-2011 Frank Meyer - frank(at)fli4l.de
+ *
+ * $Id: irmpconfig.h,v 1.80 2012/02/21 08:41:46 fm Exp $
+ *
+ * ATMEGA88 @ 8 MHz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+
+#ifndef _IRMPCONFIG_H_
+#define _IRMPCONFIG_H_
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * Change F_INTERRUPTS if you change the number of interrupts per second,
+ * Normally, F_INTERRUPTS should be in the range from 10000 to 15000, typical is 15000
+ * A value above 15000 costs additional program space, absolute maximum value is 20000.
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#ifndef F_INTERRUPTS
+#define F_INTERRUPTS                            15000   // interrupts per second, min: 10000, max: 20000, typ: 15000
+#endif
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * Change settings from 1 to 0 if you want to disable one or more decoders.
+ * This saves program space.
+ *
+ * 1 enable  decoder
+ * 0 disable decoder
+ *
+ * The standard decoders are enabled per default.
+ * Less common protocols are disabled here, you need to enable them manually.
+ *
+ * If you want to use FDC or RCCAR simultaneous with RC5 protocol, additional program space is required.
+ * If you don't need RC5 when using FDC/RCCAR, you should disable RC5.
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+
+// typical protocols, disable here!             Enable  Remarks                 F_INTERRUPTS            Program Space
+#define IRMP_SUPPORT_SIRCS_PROTOCOL             1       // Sony SIRCS           >= 10000                 ~150 bytes
+#define IRMP_SUPPORT_NEC_PROTOCOL               1       // NEC + APPLE          >= 10000                 ~300 bytes
+#define IRMP_SUPPORT_SAMSUNG_PROTOCOL           1       // Samsung + Samsung32  >= 10000                 ~300 bytes
+#define IRMP_SUPPORT_MATSUSHITA_PROTOCOL        1       // Matsushita           >= 10000                  ~50 bytes
+#define IRMP_SUPPORT_KASEIKYO_PROTOCOL          1       // Kaseikyo             >= 10000                 ~250 bytes
+#define IRMP_SUPPORT_DENON_PROTOCOL             1       // DENON, Sharp         >= 10000                 ~250 bytes
+
+// more protocols, enable here!                 Enable  Remarks                 F_INTERRUPTS            Program Space
+#define IRMP_SUPPORT_RC5_PROTOCOL               0       // RC5                  >= 10000                 ~250 bytes
+#define IRMP_SUPPORT_RC6_PROTOCOL               0       // RC6 & RC6A           >= 10000                 ~250 bytes
+#define IRMP_SUPPORT_JVC_PROTOCOL               0       // JVC                  >= 10000                 ~150 bytes
+#define IRMP_SUPPORT_NEC16_PROTOCOL             0       // NEC16                >= 10000                 ~100 bytes
+#define IRMP_SUPPORT_NEC42_PROTOCOL             0       // NEC42                >= 10000                 ~300 bytes
+#define IRMP_SUPPORT_IR60_PROTOCOL              0       // IR60 (SAB2008)       >= 10000                 ~300 bytes
+#define IRMP_SUPPORT_GRUNDIG_PROTOCOL           0       // Grundig              >= 10000                 ~300 bytes
+#define IRMP_SUPPORT_SIEMENS_PROTOCOL           0       // Siemens Gigaset      >= 15000                 ~550 bytes
+#define IRMP_SUPPORT_NOKIA_PROTOCOL             0       // Nokia                >= 10000                 ~300 bytes
+
+// exotic protocols, enable here!               Enable  Remarks                 F_INTERRUPTS            Program Space
+#define IRMP_SUPPORT_GRUNDIG2_PROTOCOL          0       // Grundig TP400        >= 10000                 ~300 bytes
+#define IRMP_SUPPORT_KATHREIN_PROTOCOL          0       // Kathrein             >= 10000                 ~200 bytes
+#define IRMP_SUPPORT_NUBERT_PROTOCOL            0       // NUBERT               >= 10000                  ~50 bytes
+#define IRMP_SUPPORT_BANG_OLUFSEN_PROTOCOL      0       // Bang & Olufsen       >= 10000                 ~200 bytes
+#define IRMP_SUPPORT_RECS80_PROTOCOL            0       // RECS80 (SAA3004)     >= 15000                  ~50 bytes
+#define IRMP_SUPPORT_RECS80EXT_PROTOCOL         0       // RECS80EXT (SAA3008)  >= 15000                  ~50 bytes
+#define IRMP_SUPPORT_THOMSON_PROTOCOL           0       // Thomson              >= 10000                 ~250 bytes
+#define IRMP_SUPPORT_NIKON_PROTOCOL             0       // NIKON camera         >= 10000                 ~250 bytes
+#define IRMP_SUPPORT_NETBOX_PROTOCOL            0       // Netbox keyboard      >= 10000                 ~400 bytes (PROTOTYPE!)
+#define IRMP_SUPPORT_FDC_PROTOCOL               0       // FDC3402 keyboard     >= 10000 (better 15000)  ~150 bytes (~400 in combination with RC5)
+#define IRMP_SUPPORT_RCCAR_PROTOCOL             0       // RC Car               >= 10000 (better 15000)  ~150 bytes (~500 in combination with RC5)
+#define IRMP_SUPPORT_RUWIDO_PROTOCOL            0       // RUWIDO, T-Home       >= 15000                 ~550 bytes
+#define IRMP_SUPPORT_LEGO_PROTOCOL              0       // LEGO Power RC        >= 20000                 ~150 bytes
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * Change hardware pin here:
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#if defined (PIC_C18)                                                   // Microchip C18 Compiler
+#include <p18cxxx.h>                                                    // main PIC18 h file
+#define IRMP_PIN                                PORTBbits.RB4           // use RB4 as IR input on PIC
+#define input(x)                                (x)
+
+#elif defined (PIC_CCS_COMPILER)                                        // PIC CCS Compiler:
+#define IRMP_PIN                                PIN_B4                  // use PB4 as IR input on PIC
+
+#else                                                                   // AVR:
+
+#ifndef ARDUINO
+#define IRMP_PORT                               PORTB
+#define IRMP_DDR                                DDRB
+#define IRMP_PIN                                PINB
+#define IRMP_BIT                                6                       // use PB6 as IR input on AVR
+#else  // ARDUINO
+#define IRMP_PIN                                PIND                    // use digital pin 2 as IR input
+#define IRMP_BIT                                2                       // on arduino
+#endif // ARDUINO
+
+#define input(x)                                ((x) & (1 << IRMP_BIT))
+#endif
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * Set IRMP_LOGGING to 1 if want to log data to UART with 9600Bd
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#ifndef IRMP_LOGGING
+#define IRMP_LOGGING                            0       // 1: log IR signal (scan), 0: do not (default)
+#endif
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * Use external logging routines
+ * If you enable external logging, you have also to enable IRMP_LOGGING above
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#ifndef IRMP_EXT_LOGGING
+#define IRMP_EXT_LOGGING                        0       // 1:log, 0: do not log  ;
+#endif
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * Set IRMP_PROTOCOL_NAMES to 1 if want to access protocol names (for logging etc), costs ~300 bytes RAM!
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#define IRMP_PROTOCOL_NAMES                     0       // 1: access protocol names, 0: do not (default),
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * Use Callbacks to indicate input signal
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#define IRMP_USE_CALLBACK                       0       // flag: 0 = don't use callbacks, 1 = use callbacks, default is 0
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * DO NOT CHANGE THE FOLLOWING LINES !
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#if IRMP_SUPPORT_SIEMENS_PROTOCOL == 1 && F_INTERRUPTS < 15000
+#  warning F_INTERRUPTS too low, SIEMENS protocol disabled (should be at least 15000)
+#  undef IRMP_SUPPORT_SIEMENS_PROTOCOL
+#  define IRMP_SUPPORT_SIEMENS_PROTOCOL         0
+#endif
+
+#if IRMP_SUPPORT_RUWIDO_PROTOCOL == 1 && F_INTERRUPTS < 15000
+#  warning F_INTERRUPTS too low, RUWIDO protocol disabled (should be at least 15000)
+#  undef IRMP_SUPPORT_RUWIDO_PROTOCOL
+#  define IRMP_SUPPORT_RUWIDO_PROTOCOL          0
+#endif
+
+#if IRMP_SUPPORT_RECS80_PROTOCOL == 1 && F_INTERRUPTS < 15000
+#  warning F_INTERRUPTS too low, RECS80 protocol disabled (should be at least 15000)
+#  undef IRMP_SUPPORT_RECS80_PROTOCOL
+#  define IRMP_SUPPORT_RECS80_PROTOCOL          0
+#endif
+
+#if IRMP_SUPPORT_RECS80EXT_PROTOCOL == 1 && F_INTERRUPTS < 15000
+#  warning F_INTERRUPTS too low, RECS80EXT protocol disabled (should be at least 15000)
+#  undef IRMP_SUPPORT_RECS80EXT_PROTOCOL
+#  define IRMP_SUPPORT_RECS80EXT_PROTOCOL       0
+#endif
+
+#if IRMP_SUPPORT_LEGO_PROTOCOL == 1 && F_INTERRUPTS < 20000
+#  warning F_INTERRUPTS too low, LEGO protocol disabled (should be at least 20000)
+#  undef IRMP_SUPPORT_LEGO_PROTOCOL
+#  define IRMP_SUPPORT_LEGO_PROTOCOL            0
+#endif
+
+#if IRMP_SUPPORT_JVC_PROTOCOL == 1 && IRMP_SUPPORT_NEC_PROTOCOL == 0
+#  warning JVC protocol needs also NEC protocol, NEC protocol enabled
+#  undef IRMP_SUPPORT_NEC_PROTOCOL
+#  define IRMP_SUPPORT_NEC_PROTOCOL             1
+#endif
+
+#if IRMP_SUPPORT_NEC16_PROTOCOL == 1 && IRMP_SUPPORT_NEC_PROTOCOL == 0
+#  warning NEC16 protocol needs also NEC protocol, NEC protocol enabled
+#  undef IRMP_SUPPORT_NEC_PROTOCOL
+#  define IRMP_SUPPORT_NEC_PROTOCOL             1
+#endif
+
+#if IRMP_SUPPORT_NEC42_PROTOCOL == 1 && IRMP_SUPPORT_NEC_PROTOCOL == 0
+#  warning NEC42 protocol needs also NEC protocol, NEC protocol enabled
+#  undef IRMP_SUPPORT_NEC_PROTOCOL
+#  define IRMP_SUPPORT_NEC_PROTOCOL             1
+#endif
+
+#if F_INTERRUPTS > 20000
+#error F_INTERRUPTS too high (should be not greater than 20000)
+#endif
+
+#endif /* _WC_IRMPCONFIG_H_ */
diff -Nur libstb-hal-ddt.git.orig/libspark/irmp.h libstb-hal-ddt.git/libspark/irmp.h
--- libstb-hal-ddt.git.orig/libspark/irmp.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/irmp.h	2022-07-23 18:18:31.543772226 +0200
@@ -1,528 +1,528 @@
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * irmp.h
- *
- * Copyright (c) 2009-2011 Frank Meyer - frank(at)fli4l.de
- *
- * $Id: irmp.h,v 1.70 2012/02/21 08:41:46 fm Exp $
- *
- * ATMEGA88 @ 8 MHz
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-
-#ifndef _WC_IRMP_H_
-#define _WC_IRMP_H_
-
-#if defined(__18CXX)                                                        // Microchip C18 declaration of missing typedef
-typedef unsigned char                           uint8_t;
-typedef unsigned int                            uint16_t;
-#endif //Microchip C18
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * timing constants:
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-// fm 22.09.2011: may not be more than 16000L, otherwise some JVC codes will not be accepted
-#define IRMP_TIMEOUT_TIME                       15500.0e-6                  // timeout after 15.5 ms darkness
-#define IRMP_TIMEOUT_TIME_MS                    15500L                      // timeout after 15.5 ms darkness
-
-#if IRMP_SUPPORT_NIKON_PROTOCOL == 1
-#define IRMP_TIMEOUT_NIKON_TIME                 29500.0e-6                  // 2nd timeout after 29.5 ms darkness (only for NIKON!)
-#define IRMP_TIMEOUT_NIKON_TIME_MS              29500L                      // 2nd timeout after 29.5 ms darkness
-typedef uint16_t    PAUSE_LEN;
-#define IRMP_TIMEOUT_NIKON_LEN                  (PAUSE_LEN)(F_INTERRUPTS * IRMP_TIMEOUT_NIKON_TIME + 0.5)
-#else
-#if (F_INTERRUPTS * IRMP_TIMEOUT_TIME_MS) / 1000000 >= 254
-typedef uint16_t    PAUSE_LEN;
-#else
-typedef uint8_t     PAUSE_LEN;
-#endif
-#endif
-
-#define IRMP_TIMEOUT_LEN                        (PAUSE_LEN)(F_INTERRUPTS * IRMP_TIMEOUT_TIME + 0.5)
-
-/*---------------------------------------------------------------------------------------------------------------------------------------------------
- * IR protocols
- *---------------------------------------------------------------------------------------------------------------------------------------------------
- */
-#define IRMP_SIRCS_PROTOCOL                      1              // Sony
-#define IRMP_NEC_PROTOCOL                        2              // NEC, Pioneer, JVC, Toshiba, NoName etc.
-#define IRMP_SAMSUNG_PROTOCOL                    3              // Samsung
-#define IRMP_MATSUSHITA_PROTOCOL                 4              // Matsushita
-#define IRMP_KASEIKYO_PROTOCOL                   5              // Kaseikyo (Panasonic etc)
-#define IRMP_RECS80_PROTOCOL                     6              // Philips, Thomson, Nordmende, Telefunken, Saba
-#define IRMP_RC5_PROTOCOL                        7              // Philips etc
-#define IRMP_DENON_PROTOCOL                      8              // Denon, Sharp
-#define IRMP_RC6_PROTOCOL                        9              // Philips etc
-#define IRMP_SAMSUNG32_PROTOCOL                 10              // Samsung32: no sync pulse at bit 16, length 32 instead of 37
-#define IRMP_APPLE_PROTOCOL                     11              // Apple, very similar to NEC
-#define IRMP_RECS80EXT_PROTOCOL                 12              // Philips, Technisat, Thomson, Nordmende, Telefunken, Saba
-#define IRMP_NUBERT_PROTOCOL                    13              // Nubert
-#define IRMP_BANG_OLUFSEN_PROTOCOL              14              // Bang & Olufsen
-#define IRMP_GRUNDIG_PROTOCOL                   15              // Grundig
-#define IRMP_NOKIA_PROTOCOL                     16              // Nokia
-#define IRMP_SIEMENS_PROTOCOL                   17              // Siemens, e.g. Gigaset
-#define IRMP_FDC_PROTOCOL                       18              // FDC keyboard
-#define IRMP_RCCAR_PROTOCOL                     19              // RC Car
-#define IRMP_JVC_PROTOCOL                       20              // JVC (NEC with 16 bits)
-#define IRMP_RC6A_PROTOCOL                      21              // RC6A, e.g. Kathrein, XBOX
-#define IRMP_NIKON_PROTOCOL                     22              // Nikon
-#define IRMP_RUWIDO_PROTOCOL                    23              // Ruwido, e.g. T-Home Mediareceiver
-#define IRMP_IR60_PROTOCOL                      24              // IR60 (SAB2008)
-#define IRMP_KATHREIN_PROTOCOL                  25              // Kathrein
-#define IRMP_NETBOX_PROTOCOL                    26              // Netbox keyboard (bitserial)
-#define IRMP_NEC16_PROTOCOL                     27              // NEC with 16 bits (incl. sync)
-#define IRMP_NEC42_PROTOCOL                     28              // NEC with 42 bits
-#define IRMP_LEGO_PROTOCOL                      29              // LEGO Power Functions RC
-#define IRMP_THOMSON_PROTOCOL                   30              // Thomson
-#define IRMP_GRUNDIG2_PROTOCOL                  31              // Grundig, e.g. TP400
-
-#define IRMP_N_PROTOCOLS                        31              // number of supported protocols
-
-// some flags of struct IRMP_PARAMETER:
-#define IRMP_PARAM_FLAG_IS_MANCHESTER           0x01
-#define IRMP_PARAM_FLAG_1ST_PULSE_IS_1          0x02
-#define IRMP_PARAM_FLAG_IS_SERIAL               0x04
-
-#define SIRCS_START_BIT_PULSE_TIME              2400.0e-6                       // 2400 usec pulse
-#define SIRCS_START_BIT_PAUSE_TIME               600.0e-6                       //  600 usec pause
-#define SIRCS_1_PULSE_TIME                      1200.0e-6                       // 1200 usec pulse
-#define SIRCS_0_PULSE_TIME                       600.0e-6                       //  600 usec pulse
-#define SIRCS_PAUSE_TIME                         600.0e-6                       //  600 usec pause
-#define SIRCS_FRAMES                            3                               // SIRCS sends each frame 3 times
-#define SIRCS_AUTO_REPETITION_PAUSE_TIME          25.0e-3                       // auto repetition after 25ms
-#define SIRCS_FRAME_REPEAT_PAUSE_TIME             25.0e-3                       // frame repeat after 25ms
-#define SIRCS_ADDRESS_OFFSET                    15                              // skip 15 bits
-#define SIRCS_ADDRESS_LEN                       5                               // read up to 5 address bits
-#define SIRCS_COMMAND_OFFSET                    0                               // skip 0 bits
-#define SIRCS_COMMAND_LEN                       15                              // read 12-15 command bits
-#define SIRCS_MINIMUM_DATA_LEN                  12                              // minimum data length
-#define SIRCS_COMPLETE_DATA_LEN                 20                              // complete length - may be up to 20
-#define SIRCS_STOP_BIT                          0                               // has no stop bit
-#define SIRCS_LSB                               1                               // LSB...MSB
-#define SIRCS_FLAGS                             0                               // flags
-
-#define NEC_START_BIT_PULSE_TIME                9000.0e-6                       // 9000 usec pulse
-#define NEC_START_BIT_PAUSE_TIME                4500.0e-6                       // 4500 usec pause
-#define NEC_REPEAT_START_BIT_PAUSE_TIME         2250.0e-6                       // 2250 usec pause
-#define NEC_PULSE_TIME                           560.0e-6                       //  560 usec pulse
-#define NEC_1_PAUSE_TIME                        1690.0e-6                       // 1690 usec pause
-#define NEC_0_PAUSE_TIME                         560.0e-6                       //  560 usec pause
-#define NEC_FRAME_REPEAT_PAUSE_TIME               40.0e-3                       // frame repeat after 40ms
-#define NEC_ADDRESS_OFFSET                       0                              // skip 0 bits
-#define NEC_ADDRESS_LEN                         16                              // read 16 address bits
-#define NEC_COMMAND_OFFSET                      16                              // skip 16 bits (8 address + 8 /address)
-#define NEC_COMMAND_LEN                         16                              // read 16 bits (8 command + 8 /command)
-#define NEC_COMPLETE_DATA_LEN                   32                              // complete length
-#define NEC_STOP_BIT                            1                               // has stop bit
-#define NEC_LSB                                 1                               // LSB...MSB
-#define NEC_FLAGS                               0                               // flags
-
-#define NEC42_ADDRESS_OFFSET                    0                               // skip 0 bits
-#define NEC42_ADDRESS_LEN                      13                               // read 13 address bits
-#define NEC42_COMMAND_OFFSET                   26                               // skip 26 bits (2 x 13 address bits)
-#define NEC42_COMMAND_LEN                       8                               // read 8 command bits
-#define NEC42_COMPLETE_DATA_LEN                42                               // complete length (2 x 13 + 2 x 8)
-
-#define NEC16_ADDRESS_OFFSET                    0                               // skip 0 bits
-#define NEC16_ADDRESS_LEN                       8                               // read 8 address bits
-#define NEC16_COMMAND_OFFSET                    8                               // skip 8 bits (8 address)
-#define NEC16_COMMAND_LEN                       8                               // read 8 bits (8 command)
-#define NEC16_COMPLETE_DATA_LEN                 16                              // complete length
-
-#define SAMSUNG_START_BIT_PULSE_TIME            4500.0e-6                       // 4500 usec pulse
-#define SAMSUNG_START_BIT_PAUSE_TIME            4500.0e-6                       // 4500 usec pause
-#define SAMSUNG_PULSE_TIME                       550.0e-6                       //  550 usec pulse
-#define SAMSUNG_1_PAUSE_TIME                    1650.0e-6                       // 1650 usec pause
-#define SAMSUNG_0_PAUSE_TIME                     550.0e-6                       //  550 usec pause
-
-#define SAMSUNG_FRAME_REPEAT_PAUSE_TIME           25.0e-3                       // frame repeat after 25ms
-#define SAMSUNG_ADDRESS_OFFSET                   0                              // skip 0 bits
-#define SAMSUNG_ADDRESS_LEN                     16                              // read 16 address bits
-#define SAMSUNG_ID_OFFSET                       17                              // skip 16 + 1 sync bit
-#define SAMSUNG_ID_LEN                          4                               // read 4 id bits
-#define SAMSUNG_COMMAND_OFFSET                  21                              // skip 16 + 1 sync + 4 data bits
-#define SAMSUNG_COMMAND_LEN                     16                              // read 16 command bits
-#define SAMSUNG_COMPLETE_DATA_LEN               37                              // complete length
-#define SAMSUNG_STOP_BIT                        1                               // has stop bit
-#define SAMSUNG_LSB                             1                               // LSB...MSB?
-#define SAMSUNG_FLAGS                           0                               // flags
-
-#define SAMSUNG32_COMMAND_OFFSET                16                              // skip 16 bits
-#define SAMSUNG32_COMMAND_LEN                   16                              // read 16 command bits
-#define SAMSUNG32_COMPLETE_DATA_LEN             32                              // complete length
-#define SAMSUNG32_FRAMES                        1                               // SAMSUNG32 sends each frame 1 times
-#define SAMSUNG32_AUTO_REPETITION_PAUSE_TIME    47.0e-3                         // repetition after 47 ms
-#define SAMSUNG32_FRAME_REPEAT_PAUSE_TIME       47.0e-3                         // frame repeat after 47ms
-
-#define MATSUSHITA_START_BIT_PULSE_TIME         3488.0e-6                       // 3488 usec pulse
-#define MATSUSHITA_START_BIT_PAUSE_TIME         3488.0e-6                       // 3488 usec pause
-#define MATSUSHITA_PULSE_TIME                    872.0e-6                       //  872 usec pulse
-#define MATSUSHITA_1_PAUSE_TIME                 2616.0e-6                       // 2616 usec pause
-#define MATSUSHITA_0_PAUSE_TIME                  872.0e-6                       //  872 usec pause
-#define MATSUSHITA_FRAME_REPEAT_PAUSE_TIME        45.0e-3                       // frame repeat after 45ms
-#define MATSUSHITA_ADDRESS_OFFSET               12                              // skip 12 bits
-#define MATSUSHITA_ADDRESS_LEN                  12                              // read 12 address bits
-#define MATSUSHITA_COMMAND_OFFSET               0                               // skip 0 bits
-#define MATSUSHITA_COMMAND_LEN                  12                              // read 12 bits (6 custom + 6 command)
-#define MATSUSHITA_COMPLETE_DATA_LEN            24                              // complete length
-#define MATSUSHITA_STOP_BIT                     1                               // has stop bit
-#define MATSUSHITA_LSB                          1                               // LSB...MSB?
-#define MATSUSHITA_FLAGS                        0                               // flags
-
-#define KASEIKYO_START_BIT_PULSE_TIME           3380.0e-6                       // 3380 usec pulse
-#define KASEIKYO_START_BIT_PAUSE_TIME           1690.0e-6                       // 1690 usec pause
-#define KASEIKYO_PULSE_TIME                      423.0e-6                       //  525 usec pulse
-#define KASEIKYO_1_PAUSE_TIME                   1269.0e-6                       //  525 usec pause
-#define KASEIKYO_0_PAUSE_TIME                    423.0e-6                       // 1690 usec pause
-#define KASEIKYO_AUTO_REPETITION_PAUSE_TIME       74.0e-3                       // repetition after 74 ms
-#define KASEIKYO_FRAME_REPEAT_PAUSE_TIME          74.0e-3                       // frame repeat after 74 ms
-#define KASEIKYO_ADDRESS_OFFSET                  0                              // skip 0 bits
-#define KASEIKYO_ADDRESS_LEN                    16                              // read 16 address bits
-#define KASEIKYO_COMMAND_OFFSET                 28                              // skip 28 bits (16 manufacturer & 4 parity & 8 genre)
-#define KASEIKYO_COMMAND_LEN                    12                              // read 12 command bits (10 real command & 2 id)
-#define KASEIKYO_COMPLETE_DATA_LEN              48                              // complete length
-#define KASEIKYO_STOP_BIT                       1                               // has stop bit
-#define KASEIKYO_LSB                            1                               // LSB...MSB?
-#define KASEIKYO_FRAMES                         2                               // KASEIKYO sends 1st frame 2 times
-#define KASEIKYO_FLAGS                          0                               // flags
-
-#define RECS80_START_BIT_PULSE_TIME              158.0e-6                       //  158 usec pulse
-#define RECS80_START_BIT_PAUSE_TIME             7432.0e-6                       // 7432 usec pause
-#define RECS80_PULSE_TIME                        158.0e-6                       //  158 usec pulse
-#define RECS80_1_PAUSE_TIME                     7432.0e-6                       // 7432 usec pause
-#define RECS80_0_PAUSE_TIME                     4902.0e-6                       // 4902 usec pause
-#define RECS80_FRAME_REPEAT_PAUSE_TIME            45.0e-3                       // frame repeat after 45ms
-#define RECS80_ADDRESS_OFFSET                   1                               // skip 1 bit (toggle bit)
-#define RECS80_ADDRESS_LEN                      3                               // read 3 address bits
-#define RECS80_COMMAND_OFFSET                   4                               // skip 4 bits (1 toggle + 3 address)
-#define RECS80_COMMAND_LEN                      6                               // read 6 command bits
-#define RECS80_COMPLETE_DATA_LEN                10                              // complete length
-#define RECS80_STOP_BIT                         1                               // has stop bit
-#define RECS80_LSB                              0                               // MSB...LSB
-#define RECS80_FLAGS                            0                               // flags
-
-#define RC5_BIT_TIME                             889.0e-6                       // 889 usec pulse/pause
-#define RC5_FRAME_REPEAT_PAUSE_TIME               45.0e-3                       // frame repeat after 45ms
-
-#define RC5_ADDRESS_OFFSET                      1                               // skip 1 bit (2nd start)
-#define RC5_ADDRESS_LEN                         6                               // read 1 toggle bit (for key repetition detection) + 5 address bits
-#define RC5_COMMAND_OFFSET                      7                               // skip 5 bits (2nd start + 1 toggle + 5 address)
-#define RC5_COMMAND_LEN                         6                               // read 6 command bits
-#define RC5_COMPLETE_DATA_LEN                   13                              // complete length
-#define RC5_STOP_BIT                            0                               // has no stop bit
-#define RC5_LSB                                 0                               // MSB...LSB
-#define RC5_FLAGS                               IRMP_PARAM_FLAG_IS_MANCHESTER   // flags
-
-#define DENON_PULSE_TIME                         310.0e-6                       //  310 usec pulse in practice,  275 in theory
-#define DENON_1_PAUSE_TIME                      1780.0e-6                       // 1780 usec pause in practice, 1900 in theory
-#define DENON_0_PAUSE_TIME                       745.0e-6                       //  745 usec pause in practice,  775 in theory
-#define DENON_FRAMES                            2                               // DENON sends each frame 2 times
-#define DENON_AUTO_REPETITION_PAUSE_TIME          65.0e-3                       // inverted repetition after 65ms
-#define DENON_FRAME_REPEAT_PAUSE_TIME             65.0e-3                       // frame repeat after 65ms
-#define DENON_ADDRESS_OFFSET                    0                               // skip 0 bits
-#define DENON_ADDRESS_LEN                       5                               // read 5 address bits
-#define DENON_COMMAND_OFFSET                    5                               // skip 5
-#define DENON_COMMAND_LEN                       10                              // read 10 command bits
-#define DENON_COMPLETE_DATA_LEN                 15                              // complete length
-#define DENON_STOP_BIT                          1                               // has stop bit
-#define DENON_LSB                               0                               // MSB...LSB
-#define DENON_FLAGS                             0                               // flags
-
-#define RC6_START_BIT_PULSE_TIME                2666.0e-6                       // 2.666 msec pulse
-#define RC6_START_BIT_PAUSE_TIME                 889.0e-6                       // 889 usec pause
-#define RC6_TOGGLE_BIT_TIME                      889.0e-6                       // 889 msec pulse/pause
-#define RC6_BIT_TIME                             444.0e-6                       // 889 usec pulse/pause
-#define RC6_FRAME_REPEAT_PAUSE_TIME               45.0e-3                       // frame repeat after 45ms
-#define RC6_ADDRESS_OFFSET                      5                               // skip "1" + 3 mode bits + 1 toggle bit
-#define RC6_ADDRESS_LEN                         8                               // read 8 address bits
-#define RC6_COMMAND_OFFSET                      13                              // skip 12 bits ("1" + 3 mode + 1 toggle + 8 address)
-#define RC6_COMMAND_LEN                         8                               // read 8 command bits
-#define RC6_COMPLETE_DATA_LEN_SHORT             21                              // complete length
-#define RC6_COMPLETE_DATA_LEN_LONG              36                              // complete length
-#define RC6_STOP_BIT                            0                               // has no stop bit
-#define RC6_LSB                                 0                               // MSB...LSB
-#define RC6_FLAGS                               (IRMP_PARAM_FLAG_IS_MANCHESTER | IRMP_PARAM_FLAG_1ST_PULSE_IS_1)   // flags
-
-#define RECS80EXT_START_BIT_PULSE_TIME           158.0e-6                       //  158 usec pulse
-#define RECS80EXT_START_BIT_PAUSE_TIME          3637.0e-6                       // 3637 usec pause
-#define RECS80EXT_PULSE_TIME                     158.0e-6                       //  158 usec pulse
-#define RECS80EXT_1_PAUSE_TIME                  7432.0e-6                       // 7432 usec pause
-#define RECS80EXT_0_PAUSE_TIME                  4902.0e-6                       // 4902 usec pause
-#define RECS80EXT_FRAME_REPEAT_PAUSE_TIME         45.0e-3                       // frame repeat after 45ms
-#define RECS80EXT_ADDRESS_OFFSET                2                               // skip 2 bits (2nd start + 1 toggle)
-#define RECS80EXT_ADDRESS_LEN                   4                               // read 4 address bits
-#define RECS80EXT_COMMAND_OFFSET                6                               // skip 6 bits (2nd start + 1 toggle + 4 address)
-#define RECS80EXT_COMMAND_LEN                   6                               // read 6 command bits
-#define RECS80EXT_COMPLETE_DATA_LEN             12                              // complete length
-#define RECS80EXT_STOP_BIT                      1                               // has stop bit
-#define RECS80EXT_LSB                           0                               // MSB...LSB
-#define RECS80EXT_FLAGS                         0                               // flags
-
-#define NUBERT_START_BIT_PULSE_TIME             1340.0e-6                       // 1340 usec pulse
-#define NUBERT_START_BIT_PAUSE_TIME              340.0e-6                       //  340 usec pause
-#define NUBERT_1_PULSE_TIME                     1340.0e-6                       // 1340 usec pulse
-#define NUBERT_1_PAUSE_TIME                      340.0e-6                       //  340 usec pause
-#define NUBERT_0_PULSE_TIME                      500.0e-6                       //  500 usec pulse
-#define NUBERT_0_PAUSE_TIME                     1300.0e-6                       // 1300 usec pause
-#define NUBERT_FRAMES                           2                               // Nubert sends 2 frames
-#define NUBERT_AUTO_REPETITION_PAUSE_TIME         35.0e-3                       // auto repetition after 35ms
-#define NUBERT_FRAME_REPEAT_PAUSE_TIME            35.0e-3                       // frame repeat after 45ms
-#define NUBERT_ADDRESS_OFFSET                   0                               // skip 0 bits
-#define NUBERT_ADDRESS_LEN                      0                               // read 0 address bits
-#define NUBERT_COMMAND_OFFSET                   0                               // skip 0 bits
-#define NUBERT_COMMAND_LEN                      10                              // read 10 bits
-#define NUBERT_COMPLETE_DATA_LEN                10                              // complete length
-#define NUBERT_STOP_BIT                         1                               // has stop bit
-#define NUBERT_LSB                              0                               // MSB?
-#define NUBERT_FLAGS                            0                               // flags
-
-#define BANG_OLUFSEN_START_BIT1_PULSE_TIME       200.0e-6                       //   200 usec pulse
-#define BANG_OLUFSEN_START_BIT1_PAUSE_TIME      3125.0e-6                       //  3125 usec pause
-#define BANG_OLUFSEN_START_BIT2_PULSE_TIME       200.0e-6                       //   200 usec pulse
-#define BANG_OLUFSEN_START_BIT2_PAUSE_TIME      3125.0e-6                       //  3125 usec pause
-#define BANG_OLUFSEN_START_BIT3_PULSE_TIME       200.0e-6                       //   200 usec pulse
-#define BANG_OLUFSEN_START_BIT3_PAUSE_TIME     15625.0e-6                       // 15625 usec pause
-#define BANG_OLUFSEN_START_BIT4_PULSE_TIME       200.0e-6                       //   200 usec pulse
-#define BANG_OLUFSEN_START_BIT4_PAUSE_TIME      3125.0e-6                       //  3125 usec pause
-#define BANG_OLUFSEN_PULSE_TIME                  200.0e-6                       //   200 usec pulse
-#define BANG_OLUFSEN_1_PAUSE_TIME               9375.0e-6                       //  9375 usec pause
-#define BANG_OLUFSEN_0_PAUSE_TIME               3125.0e-6                       //  3125 usec pause
-#define BANG_OLUFSEN_R_PAUSE_TIME               6250.0e-6                       //  6250 usec pause (repeat last bit)
-#define BANG_OLUFSEN_TRAILER_BIT_PAUSE_TIME    12500.0e-6                       // 12500 usec pause (trailer bit)
-#define BANG_OLUFSEN_FRAME_REPEAT_PAUSE_TIME      45.0e-3                       // frame repeat after 45ms
-#define BANG_OLUFSEN_ADDRESS_OFFSET             0                               // no address bits
-#define BANG_OLUFSEN_ADDRESS_LEN                0                               // no address bits
-#define BANG_OLUFSEN_COMMAND_OFFSET             3                               // skip startbits 2, 3, 4
-#define BANG_OLUFSEN_COMMAND_LEN                16                              // read 16 command bits
-#define BANG_OLUFSEN_COMPLETE_DATA_LEN          20                              // complete length: startbits 2, 3, 4 + 16 data bits + trailer bit
-#define BANG_OLUFSEN_STOP_BIT                   1                               // has stop bit
-#define BANG_OLUFSEN_LSB                        0                               // MSB...LSB
-#define BANG_OLUFSEN_FLAGS                      0                               // flags
-
-#define GRUNDIG_NOKIA_IR60_BIT_TIME             528.0e-6                        // 528 usec pulse/pause
-#define GRUNDIG_NOKIA_IR60_PRE_PAUSE_TIME       2639.0e-6                       // 2639 usec pause after pre bit
-#define GRUNDIG_NOKIA_IR60_FRAME_REPEAT_PAUSE_TIME  117.76e-3                   // info frame repeat after 117.76 ms
-#define GRUNDIG_NOKIA_IR60_STOP_BIT             0                               // has no stop bit
-#define GRUNDIG_NOKIA_IR60_LSB                  1                               // MSB...LSB
-#define GRUNDIG_NOKIA_IR60_FLAGS                (IRMP_PARAM_FLAG_IS_MANCHESTER | IRMP_PARAM_FLAG_1ST_PULSE_IS_1)  // flags
-
-#define GRUNDIG_FRAMES                          2                               // GRUNDIG sends each frame 1+1 times
-#define GRUNDIG_AUTO_REPETITION_PAUSE_TIME        20.0e-3                       // repetition after 20ms
-#define GRUNDIG_ADDRESS_OFFSET                  0                               // no address
-#define GRUNDIG_ADDRESS_LEN                     0                               // no address
-#define GRUNDIG_COMMAND_OFFSET                  1                               // skip 1 start bit
-#define GRUNDIG_COMMAND_LEN                     9                               // read 9 command bits
-#define GRUNDIG_COMPLETE_DATA_LEN               10                              // complete length: 1 start bit + 9 data bits
-
-#define NOKIA_FRAMES                            3                               // NOKIA sends each frame 1 + 1 + 1 times
-#define NOKIA_AUTO_REPETITION_PAUSE_TIME          20.0e-3                       // repetition after 20ms
-#define NOKIA_ADDRESS_OFFSET                    9                               // skip 9 bits (1 start bit + 8 data bits)
-#define NOKIA_ADDRESS_LEN                       8                               // 7 address bits
-#define NOKIA_COMMAND_OFFSET                    1                               // skip 1 bit (1 start bit)
-#define NOKIA_COMMAND_LEN                       8                               // read 8 command bits
-#define NOKIA_COMPLETE_DATA_LEN                 17                              // complete length: 1 start bit + 8 address bits + 8 command bits
-
-#define IR60_TIMEOUT_TIME                       5000.0e-6                       // timeout grundig frame, switch to IR60
-#define IR60_ADDRESS_OFFSET                     0                               // skip 1 bits
-#define IR60_ADDRESS_LEN                        0                               // read 0 address bits
-#define IR60_COMMAND_OFFSET                     0                               // skip 1 bit (start bit after pre bit, always 1)
-#define IR60_COMMAND_LEN                        7                               // read 6 command bits
-#define IR60_COMPLETE_DATA_LEN                  7                               // complete length
-
-#define SIEMENS_OR_RUWIDO_START_BIT_PULSE_TIME    275.0e-6                      //  275 usec pulse
-#define SIEMENS_OR_RUWIDO_START_BIT_PAUSE_TIME    550.0e-6                      //  550 usec pause
-#define SIEMENS_OR_RUWIDO_BIT_PULSE_TIME          275.0e-6                      //  275 usec short pulse
-#define SIEMENS_OR_RUWIDO_BIT_PULSE_TIME_2        550.0e-6                      //  550 usec long pulse
-#define SIEMENS_OR_RUWIDO_BIT_PAUSE_TIME          275.0e-6                      //  275 usec short pause
-#define SIEMENS_OR_RUWIDO_BIT_PAUSE_TIME_2        550.0e-6                      //  550 usec long pause
-#define SIEMENS_OR_RUWIDO_FRAME_REPEAT_PAUSE_TIME 45.0e-3                       // frame repeat after 45ms
-#define SIEMENS_OR_RUWIDO_STOP_BIT                0                             // has no stop bit
-#define SIEMENS_OR_RUWIDO_LSB                     0                             // MSB...LSB
-#define SIEMENS_OR_RUWIDO_FLAGS                   (IRMP_PARAM_FLAG_IS_MANCHESTER | IRMP_PARAM_FLAG_1ST_PULSE_IS_1)  // flags
-
-#define RUWIDO_ADDRESS_OFFSET                   0                               // skip 0 bits
-#define RUWIDO_ADDRESS_LEN                      9                               // read 9 address bits
-#define RUWIDO_COMMAND_OFFSET                   9                               // skip 9 bits
-#define RUWIDO_COMMAND_LEN                      8                               // read 7 + 1 command bits, last bit is only check bit
-#define RUWIDO_COMPLETE_DATA_LEN                17                              // complete length
-
-#define SIEMENS_ADDRESS_OFFSET                  0                               // skip 0 bits
-#define SIEMENS_ADDRESS_LEN                     11                              // read 11 bits
-#define SIEMENS_COMMAND_OFFSET                  11                              // skip 11 bits
-#define SIEMENS_COMMAND_LEN                     11                              // read 10 + 1 command bits, last bit is only check bit
-#define SIEMENS_COMPLETE_DATA_LEN               22                              // complete length
-
-#define FDC_START_BIT_PULSE_TIME                 2085.0e-6                      // 2085 usec pulse
-#define FDC_START_BIT_PAUSE_TIME                  966.0e-6                      //  966 usec pause
-#define FDC_PULSE_TIME                            300.0e-6                      //  300 usec pulse
-#define FDC_1_PAUSE_TIME                          715.0e-6                      //  715 usec pause
-#define FDC_0_PAUSE_TIME                          220.0e-6                      //  220 usec pause
-#define FDC_FRAME_REPEAT_PAUSE_TIME                60.0e-3                      // frame repeat after 60ms
-#define FDC_ADDRESS_OFFSET                       0                              // skip 0 bits
-#define FDC_ADDRESS_LEN                         14                              // read 14 address bits, but use only 6, shift 8 into command
-#define FDC_COMMAND_OFFSET                      20                              // skip 20 bits
-#define FDC_COMMAND_LEN                         12                              // read 12 bits
-#define FDC_COMPLETE_DATA_LEN                   40                              // complete length
-#define FDC_STOP_BIT                            1                               // has stop bit
-#define FDC_LSB                                 1                               // LSB...MSB
-#define FDC_FLAGS                               0                               // flags
-
-#define RCCAR_START_BIT_PULSE_TIME               2000.0e-6                      // 2000 usec pulse
-#define RCCAR_START_BIT_PAUSE_TIME               2000.0e-6                      // 2000 usec pause
-#define RCCAR_PULSE_TIME                          600.0e-6                      //  360 usec pulse
-#define RCCAR_1_PAUSE_TIME                        450.0e-6                      //  650 usec pause
-#define RCCAR_0_PAUSE_TIME                        900.0e-6                      //  180 usec pause
-#define RCCAR_FRAME_REPEAT_PAUSE_TIME              40.0e-3                      // frame repeat after 40ms
-#define RCCAR_ADDRESS_OFFSET                     0                              // skip 0 bits
-#define RCCAR_ADDRESS_LEN                        0                              // read 0 address bits
-#define RCCAR_COMMAND_OFFSET                     0                              // skip 0 bits
-#define RCCAR_COMMAND_LEN                       13                              // read 13 bits
-#define RCCAR_COMPLETE_DATA_LEN                 13                              // complete length
-#define RCCAR_STOP_BIT                          1                               // has stop bit
-#define RCCAR_LSB                               1                               // LSB...MSB
-#define RCCAR_FLAGS                             0                               // flags
-
-#define JVC_START_BIT_PULSE_TIME                9000.0e-6                       // 9000 usec pulse
-#define JVC_START_BIT_PAUSE_TIME                4500.0e-6                       // 4500 usec pause
-#define JVC_PULSE_TIME                           560.0e-6                       //  560 usec pulse
-#define JVC_1_PAUSE_TIME                        1690.0e-6                       // 1690 usec pause
-#define JVC_0_PAUSE_TIME                         560.0e-6                       //  560 usec pause
-#define JVC_FRAME_REPEAT_PAUSE_TIME               22.0e-3                       // frame repeat after 22ms
-#define JVC_ADDRESS_OFFSET                       0                              // skip 0 bits
-#define JVC_ADDRESS_LEN                          4                              // read 4 address bits
-#define JVC_COMMAND_OFFSET                       4                              // skip 4 bits
-#define JVC_COMMAND_LEN                         12                              // read 12 bits
-#define JVC_COMPLETE_DATA_LEN                   16                              // complete length
-#define JVC_STOP_BIT                            1                               // has stop bit
-#define JVC_LSB                                 1                               // LSB...MSB
-#define JVC_FLAGS                               0                               // flags
-
-#define NIKON_START_BIT_PULSE_TIME              2200.0e-6                       //  2200 usec pulse
-#define NIKON_START_BIT_PAUSE_TIME             27100.0e-6                       // 27100 usec pause
-#define NIKON_PULSE_TIME                         500.0e-6                       //   500 usec pulse
-#define NIKON_1_PAUSE_TIME                      3500.0e-6                       //  3500 usec pause
-#define NIKON_0_PAUSE_TIME                      1500.0e-6                       //  1500 usec pause
-#define NIKON_FRAME_REPEAT_PAUSE_TIME             60.0e-3                       // frame repeat after 60ms
-#define NIKON_ADDRESS_OFFSET                    0                               // skip 0 bits
-#define NIKON_ADDRESS_LEN                       0                               // read 0 address bits
-#define NIKON_COMMAND_OFFSET                    0                               // skip 0 bits
-#define NIKON_COMMAND_LEN                       2                               // read 2 bits
-#define NIKON_COMPLETE_DATA_LEN                 2                               // complete length
-#define NIKON_STOP_BIT                          1                               // has stop bit
-#define NIKON_LSB                               0                               // LSB...MSB
-#define NIKON_FLAGS                             0                               // flags
-
-#define KATHREIN_START_BIT_PULSE_TIME            210.0e-6                       // 1340 usec pulse
-#define KATHREIN_START_BIT_PAUSE_TIME           6218.0e-6                       //  340 usec pause
-#define KATHREIN_1_PULSE_TIME                    210.0e-6                       // 1340 usec pulse
-#define KATHREIN_1_PAUSE_TIME                   3000.0e-6                       //  340 usec pause
-#define KATHREIN_0_PULSE_TIME                    210.0e-6                       //  500 usec pulse
-#define KATHREIN_0_PAUSE_TIME                   1400.0e-6                       // 1300 usec pause
-#define KATHREIN_SYNC_BIT_PAUSE_LEN_TIME        4600.0e-6                       // 4600 usec sync (on 6th and/or 8th bit)
-#define KATHREIN_FRAMES                         1                               // Kathrein sends 1 frame
-#define KATHREIN_AUTO_REPETITION_PAUSE_TIME     35.0e-3                         // auto repetition after 35ms
-#define KATHREIN_FRAME_REPEAT_PAUSE_TIME        35.0e-3                         // frame repeat after 35ms
-#define KATHREIN_ADDRESS_OFFSET                 1                               // skip 1 bits
-#define KATHREIN_ADDRESS_LEN                    4                               // read 4 address bits
-#define KATHREIN_COMMAND_OFFSET                 5                               // skip 5 bits
-#define KATHREIN_COMMAND_LEN                    7                               // read 7 bits
-#define KATHREIN_COMPLETE_DATA_LEN              13                              // complete length
-#define KATHREIN_STOP_BIT                       1                               // has stop bit
-#define KATHREIN_LSB                            0                               // MSB
-#define KATHREIN_FLAGS                          0                               // flags
-
-#define NETBOX_START_BIT_PULSE_TIME             2400.0e-6                       // 2400 usec pulse
-#define NETBOX_START_BIT_PAUSE_TIME              800.0e-6                       //  800 usec pause
-#define NETBOX_PULSE_TIME                        800.0e-6                       //  800 usec pulse
-#define NETBOX_PAUSE_TIME                        800.0e-6                       //  800 usec pause
-#define NETBOX_FRAMES                           1                               // Netbox sends 1 frame
-#define NETBOX_AUTO_REPETITION_PAUSE_TIME       35.0e-3                         // auto repetition after 35ms
-#define NETBOX_FRAME_REPEAT_PAUSE_TIME          35.0e-3                         // frame repeat after 35ms
-#define NETBOX_ADDRESS_OFFSET                   0                               // skip 0 bits
-#define NETBOX_ADDRESS_LEN                      3                               // read 3 address bits
-#define NETBOX_COMMAND_OFFSET                   3                               // skip 3 bits
-#define NETBOX_COMMAND_LEN                      13                              // read 13 bits
-#define NETBOX_COMPLETE_DATA_LEN                16                              // complete length
-#define NETBOX_STOP_BIT                         0                               // has no stop bit
-#define NETBOX_LSB                              1                               // LSB
-#define NETBOX_FLAGS                            IRMP_PARAM_FLAG_IS_SERIAL       // flags
-
-#define LEGO_START_BIT_PULSE_TIME                158.0e-6                       //  158 usec pulse ( 6 x 1/38kHz)
-#define LEGO_START_BIT_PAUSE_TIME               1026.0e-6                       // 1026 usec pause (39 x 1/38kHz)
-#define LEGO_PULSE_TIME                          158.0e-6                       //  158 usec pulse ( 6 x 1/38kHz)
-#define LEGO_1_PAUSE_TIME                        553.0e-6                       //  553 usec pause (21 x 1/38kHz)
-#define LEGO_0_PAUSE_TIME                        263.0e-6                       //  263 usec pause (10 x 1/38kHz)
-#define LEGO_FRAME_REPEAT_PAUSE_TIME              40.0e-3                       // frame repeat after 40ms
-#define LEGO_ADDRESS_OFFSET                     0                               // skip 0 bits
-#define LEGO_ADDRESS_LEN                        0                               // read 0 address bits
-#define LEGO_COMMAND_OFFSET                     0                               // skip 0 bits
-#define LEGO_COMMAND_LEN                        16                              // read 16 bits (12 command + 4 CRC)
-#define LEGO_COMPLETE_DATA_LEN                  16                              // complete length
-#define LEGO_STOP_BIT                           1                               // has stop bit
-#define LEGO_LSB                                0                               // MSB...LSB
-#define LEGO_FLAGS                              0                               // flags
-
-#define THOMSON_PULSE_TIME                       550.0e-6                       //  550 usec pulse
-#define THOMSON_1_PAUSE_TIME                    4500.0e-6                       // 4500 usec pause
-#define THOMSON_0_PAUSE_TIME                    2000.0e-6                       // 2000 usec pause
-#define THOMSON_FRAMES                          1                               // THOMSON sends 1 frame
-#define THOMSON_AUTO_REPETITION_PAUSE_TIME        65.0e-3                       // repetition after 65ms
-#define THOMSON_FRAME_REPEAT_PAUSE_TIME           65.0e-3                       // frame repeat after 65ms
-#define THOMSON_ADDRESS_OFFSET                  0                               // skip 0 bits
-#define THOMSON_ADDRESS_LEN                     4                               // read 4 address bits
-#define THOMSON_COMMAND_OFFSET                  5                               // skip 4 address bits + 1 toggle bit
-#define THOMSON_COMMAND_LEN                     7                               // read 7 command bits
-#define THOMSON_COMPLETE_DATA_LEN               12                              // complete length
-#define THOMSON_STOP_BIT                        1                               // has stop bit
-#define THOMSON_LSB                             0                               // MSB...LSB
-#define THOMSON_FLAGS                           0                               // flags
-
-#define GRUNDIG2_START_BIT_PULSE_TIME            550.0e-6                       //   550 usec pulse
-#define GRUNDIG2_START_BIT_PAUSE_TIME           2700.0e-6                       //  2700 usec pause
-#define GRUNDIG2_BIT_PULSE_TIME                  550.0e-6                       //   550 usec short pulse
-#define GRUNDIG2_BIT_PAUSE_TIME                  550.0e-6                       //   550 usec short pause
-#define GRUNDIG2_FRAME_REPEAT_PAUSE_TIME         100.0e-3                       // frame repeat after 100ms
-#define GRUNDIG2_STOP_BIT                       0                               // has no stop bit
-#define GRUNDIG2_LSB                            1                               // MSB...LSB
-#define GRUNDIG2_FLAGS                          (IRMP_PARAM_FLAG_IS_MANCHESTER | IRMP_PARAM_FLAG_1ST_PULSE_IS_1)  // flags
-#define GRUNDIG2_ADDRESS_OFFSET                 0                               // skip 0 bits
-#define GRUNDIG2_ADDRESS_LEN                    0                               // read 0 bits
-#define GRUNDIG2_COMMAND_OFFSET                 0                               // skip 0 bits
-#define GRUNDIG2_COMMAND_LEN                    7                               // read 6 + 1 command bits, last bit is always 1
-#define GRUNDIG2_COMPLETE_DATA_LEN              7                               // complete length
-
-#define AUTO_FRAME_REPETITION_TIME              80.0e-3                         // SIRCS/SAMSUNG32/NUBERT: automatic repetition after 25-50ms
-                                                                                // KASEIKYO: automatic repetition after 75ms
-
-#define TRUE                                    1
-#define FALSE                                   0
-
-#define IRMP_FLAG_REPETITION                    0x01
-
-typedef struct
-{
-  uint8_t               protocol;                                               // protocol, i.e. NEC_PROTOCOL
-  uint16_t              address;                                                // address
-  uint16_t              command;                                                // command
-  uint8_t               flags;                                                  // flags, e.g. repetition
-} IRMP_DATA;
-
-extern void                             irmp_init (void);
-extern uint8_t                          irmp_get_data (IRMP_DATA *);
-extern uint8_t                          irmp_is_busy (void);
-extern uint8_t                          irmp_ISR (uint8_t);
-
-#if IRMP_PROTOCOL_NAMES == 1
-extern char *                           irmp_protocol_names[IRMP_N_PROTOCOLS + 1];
-#endif
-
-#if IRMP_USE_CALLBACK == 1
-extern void                             irmp_set_callback_ptr (void (*cb)(uint8_t));
-#endif // IRSND_USE_CALLBACK == 1
-
-#endif /* _WC_IRMP_H_ */
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * irmp.h
+ *
+ * Copyright (c) 2009-2011 Frank Meyer - frank(at)fli4l.de
+ *
+ * $Id: irmp.h,v 1.70 2012/02/21 08:41:46 fm Exp $
+ *
+ * ATMEGA88 @ 8 MHz
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+
+#ifndef _WC_IRMP_H_
+#define _WC_IRMP_H_
+
+#if defined(__18CXX)                                                        // Microchip C18 declaration of missing typedef
+typedef unsigned char                           uint8_t;
+typedef unsigned int                            uint16_t;
+#endif //Microchip C18
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * timing constants:
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+// fm 22.09.2011: may not be more than 16000L, otherwise some JVC codes will not be accepted
+#define IRMP_TIMEOUT_TIME                       15500.0e-6                  // timeout after 15.5 ms darkness
+#define IRMP_TIMEOUT_TIME_MS                    15500L                      // timeout after 15.5 ms darkness
+
+#if IRMP_SUPPORT_NIKON_PROTOCOL == 1
+#define IRMP_TIMEOUT_NIKON_TIME                 29500.0e-6                  // 2nd timeout after 29.5 ms darkness (only for NIKON!)
+#define IRMP_TIMEOUT_NIKON_TIME_MS              29500L                      // 2nd timeout after 29.5 ms darkness
+typedef uint16_t    PAUSE_LEN;
+#define IRMP_TIMEOUT_NIKON_LEN                  (PAUSE_LEN)(F_INTERRUPTS * IRMP_TIMEOUT_NIKON_TIME + 0.5)
+#else
+#if (F_INTERRUPTS * IRMP_TIMEOUT_TIME_MS) / 1000000 >= 254
+typedef uint16_t    PAUSE_LEN;
+#else
+typedef uint8_t     PAUSE_LEN;
+#endif
+#endif
+
+#define IRMP_TIMEOUT_LEN                        (PAUSE_LEN)(F_INTERRUPTS * IRMP_TIMEOUT_TIME + 0.5)
+
+/*---------------------------------------------------------------------------------------------------------------------------------------------------
+ * IR protocols
+ *---------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+#define IRMP_SIRCS_PROTOCOL                      1              // Sony
+#define IRMP_NEC_PROTOCOL                        2              // NEC, Pioneer, JVC, Toshiba, NoName etc.
+#define IRMP_SAMSUNG_PROTOCOL                    3              // Samsung
+#define IRMP_MATSUSHITA_PROTOCOL                 4              // Matsushita
+#define IRMP_KASEIKYO_PROTOCOL                   5              // Kaseikyo (Panasonic etc)
+#define IRMP_RECS80_PROTOCOL                     6              // Philips, Thomson, Nordmende, Telefunken, Saba
+#define IRMP_RC5_PROTOCOL                        7              // Philips etc
+#define IRMP_DENON_PROTOCOL                      8              // Denon, Sharp
+#define IRMP_RC6_PROTOCOL                        9              // Philips etc
+#define IRMP_SAMSUNG32_PROTOCOL                 10              // Samsung32: no sync pulse at bit 16, length 32 instead of 37
+#define IRMP_APPLE_PROTOCOL                     11              // Apple, very similar to NEC
+#define IRMP_RECS80EXT_PROTOCOL                 12              // Philips, Technisat, Thomson, Nordmende, Telefunken, Saba
+#define IRMP_NUBERT_PROTOCOL                    13              // Nubert
+#define IRMP_BANG_OLUFSEN_PROTOCOL              14              // Bang & Olufsen
+#define IRMP_GRUNDIG_PROTOCOL                   15              // Grundig
+#define IRMP_NOKIA_PROTOCOL                     16              // Nokia
+#define IRMP_SIEMENS_PROTOCOL                   17              // Siemens, e.g. Gigaset
+#define IRMP_FDC_PROTOCOL                       18              // FDC keyboard
+#define IRMP_RCCAR_PROTOCOL                     19              // RC Car
+#define IRMP_JVC_PROTOCOL                       20              // JVC (NEC with 16 bits)
+#define IRMP_RC6A_PROTOCOL                      21              // RC6A, e.g. Kathrein, XBOX
+#define IRMP_NIKON_PROTOCOL                     22              // Nikon
+#define IRMP_RUWIDO_PROTOCOL                    23              // Ruwido, e.g. T-Home Mediareceiver
+#define IRMP_IR60_PROTOCOL                      24              // IR60 (SAB2008)
+#define IRMP_KATHREIN_PROTOCOL                  25              // Kathrein
+#define IRMP_NETBOX_PROTOCOL                    26              // Netbox keyboard (bitserial)
+#define IRMP_NEC16_PROTOCOL                     27              // NEC with 16 bits (incl. sync)
+#define IRMP_NEC42_PROTOCOL                     28              // NEC with 42 bits
+#define IRMP_LEGO_PROTOCOL                      29              // LEGO Power Functions RC
+#define IRMP_THOMSON_PROTOCOL                   30              // Thomson
+#define IRMP_GRUNDIG2_PROTOCOL                  31              // Grundig, e.g. TP400
+
+#define IRMP_N_PROTOCOLS                        31              // number of supported protocols
+
+// some flags of struct IRMP_PARAMETER:
+#define IRMP_PARAM_FLAG_IS_MANCHESTER           0x01
+#define IRMP_PARAM_FLAG_1ST_PULSE_IS_1          0x02
+#define IRMP_PARAM_FLAG_IS_SERIAL               0x04
+
+#define SIRCS_START_BIT_PULSE_TIME              2400.0e-6                       // 2400 usec pulse
+#define SIRCS_START_BIT_PAUSE_TIME               600.0e-6                       //  600 usec pause
+#define SIRCS_1_PULSE_TIME                      1200.0e-6                       // 1200 usec pulse
+#define SIRCS_0_PULSE_TIME                       600.0e-6                       //  600 usec pulse
+#define SIRCS_PAUSE_TIME                         600.0e-6                       //  600 usec pause
+#define SIRCS_FRAMES                            3                               // SIRCS sends each frame 3 times
+#define SIRCS_AUTO_REPETITION_PAUSE_TIME          25.0e-3                       // auto repetition after 25ms
+#define SIRCS_FRAME_REPEAT_PAUSE_TIME             25.0e-3                       // frame repeat after 25ms
+#define SIRCS_ADDRESS_OFFSET                    15                              // skip 15 bits
+#define SIRCS_ADDRESS_LEN                       5                               // read up to 5 address bits
+#define SIRCS_COMMAND_OFFSET                    0                               // skip 0 bits
+#define SIRCS_COMMAND_LEN                       15                              // read 12-15 command bits
+#define SIRCS_MINIMUM_DATA_LEN                  12                              // minimum data length
+#define SIRCS_COMPLETE_DATA_LEN                 20                              // complete length - may be up to 20
+#define SIRCS_STOP_BIT                          0                               // has no stop bit
+#define SIRCS_LSB                               1                               // LSB...MSB
+#define SIRCS_FLAGS                             0                               // flags
+
+#define NEC_START_BIT_PULSE_TIME                9000.0e-6                       // 9000 usec pulse
+#define NEC_START_BIT_PAUSE_TIME                4500.0e-6                       // 4500 usec pause
+#define NEC_REPEAT_START_BIT_PAUSE_TIME         2250.0e-6                       // 2250 usec pause
+#define NEC_PULSE_TIME                           560.0e-6                       //  560 usec pulse
+#define NEC_1_PAUSE_TIME                        1690.0e-6                       // 1690 usec pause
+#define NEC_0_PAUSE_TIME                         560.0e-6                       //  560 usec pause
+#define NEC_FRAME_REPEAT_PAUSE_TIME               40.0e-3                       // frame repeat after 40ms
+#define NEC_ADDRESS_OFFSET                       0                              // skip 0 bits
+#define NEC_ADDRESS_LEN                         16                              // read 16 address bits
+#define NEC_COMMAND_OFFSET                      16                              // skip 16 bits (8 address + 8 /address)
+#define NEC_COMMAND_LEN                         16                              // read 16 bits (8 command + 8 /command)
+#define NEC_COMPLETE_DATA_LEN                   32                              // complete length
+#define NEC_STOP_BIT                            1                               // has stop bit
+#define NEC_LSB                                 1                               // LSB...MSB
+#define NEC_FLAGS                               0                               // flags
+
+#define NEC42_ADDRESS_OFFSET                    0                               // skip 0 bits
+#define NEC42_ADDRESS_LEN                      13                               // read 13 address bits
+#define NEC42_COMMAND_OFFSET                   26                               // skip 26 bits (2 x 13 address bits)
+#define NEC42_COMMAND_LEN                       8                               // read 8 command bits
+#define NEC42_COMPLETE_DATA_LEN                42                               // complete length (2 x 13 + 2 x 8)
+
+#define NEC16_ADDRESS_OFFSET                    0                               // skip 0 bits
+#define NEC16_ADDRESS_LEN                       8                               // read 8 address bits
+#define NEC16_COMMAND_OFFSET                    8                               // skip 8 bits (8 address)
+#define NEC16_COMMAND_LEN                       8                               // read 8 bits (8 command)
+#define NEC16_COMPLETE_DATA_LEN                 16                              // complete length
+
+#define SAMSUNG_START_BIT_PULSE_TIME            4500.0e-6                       // 4500 usec pulse
+#define SAMSUNG_START_BIT_PAUSE_TIME            4500.0e-6                       // 4500 usec pause
+#define SAMSUNG_PULSE_TIME                       550.0e-6                       //  550 usec pulse
+#define SAMSUNG_1_PAUSE_TIME                    1650.0e-6                       // 1650 usec pause
+#define SAMSUNG_0_PAUSE_TIME                     550.0e-6                       //  550 usec pause
+
+#define SAMSUNG_FRAME_REPEAT_PAUSE_TIME           25.0e-3                       // frame repeat after 25ms
+#define SAMSUNG_ADDRESS_OFFSET                   0                              // skip 0 bits
+#define SAMSUNG_ADDRESS_LEN                     16                              // read 16 address bits
+#define SAMSUNG_ID_OFFSET                       17                              // skip 16 + 1 sync bit
+#define SAMSUNG_ID_LEN                          4                               // read 4 id bits
+#define SAMSUNG_COMMAND_OFFSET                  21                              // skip 16 + 1 sync + 4 data bits
+#define SAMSUNG_COMMAND_LEN                     16                              // read 16 command bits
+#define SAMSUNG_COMPLETE_DATA_LEN               37                              // complete length
+#define SAMSUNG_STOP_BIT                        1                               // has stop bit
+#define SAMSUNG_LSB                             1                               // LSB...MSB?
+#define SAMSUNG_FLAGS                           0                               // flags
+
+#define SAMSUNG32_COMMAND_OFFSET                16                              // skip 16 bits
+#define SAMSUNG32_COMMAND_LEN                   16                              // read 16 command bits
+#define SAMSUNG32_COMPLETE_DATA_LEN             32                              // complete length
+#define SAMSUNG32_FRAMES                        1                               // SAMSUNG32 sends each frame 1 times
+#define SAMSUNG32_AUTO_REPETITION_PAUSE_TIME    47.0e-3                         // repetition after 47 ms
+#define SAMSUNG32_FRAME_REPEAT_PAUSE_TIME       47.0e-3                         // frame repeat after 47ms
+
+#define MATSUSHITA_START_BIT_PULSE_TIME         3488.0e-6                       // 3488 usec pulse
+#define MATSUSHITA_START_BIT_PAUSE_TIME         3488.0e-6                       // 3488 usec pause
+#define MATSUSHITA_PULSE_TIME                    872.0e-6                       //  872 usec pulse
+#define MATSUSHITA_1_PAUSE_TIME                 2616.0e-6                       // 2616 usec pause
+#define MATSUSHITA_0_PAUSE_TIME                  872.0e-6                       //  872 usec pause
+#define MATSUSHITA_FRAME_REPEAT_PAUSE_TIME        45.0e-3                       // frame repeat after 45ms
+#define MATSUSHITA_ADDRESS_OFFSET               12                              // skip 12 bits
+#define MATSUSHITA_ADDRESS_LEN                  12                              // read 12 address bits
+#define MATSUSHITA_COMMAND_OFFSET               0                               // skip 0 bits
+#define MATSUSHITA_COMMAND_LEN                  12                              // read 12 bits (6 custom + 6 command)
+#define MATSUSHITA_COMPLETE_DATA_LEN            24                              // complete length
+#define MATSUSHITA_STOP_BIT                     1                               // has stop bit
+#define MATSUSHITA_LSB                          1                               // LSB...MSB?
+#define MATSUSHITA_FLAGS                        0                               // flags
+
+#define KASEIKYO_START_BIT_PULSE_TIME           3380.0e-6                       // 3380 usec pulse
+#define KASEIKYO_START_BIT_PAUSE_TIME           1690.0e-6                       // 1690 usec pause
+#define KASEIKYO_PULSE_TIME                      423.0e-6                       //  525 usec pulse
+#define KASEIKYO_1_PAUSE_TIME                   1269.0e-6                       //  525 usec pause
+#define KASEIKYO_0_PAUSE_TIME                    423.0e-6                       // 1690 usec pause
+#define KASEIKYO_AUTO_REPETITION_PAUSE_TIME       74.0e-3                       // repetition after 74 ms
+#define KASEIKYO_FRAME_REPEAT_PAUSE_TIME          74.0e-3                       // frame repeat after 74 ms
+#define KASEIKYO_ADDRESS_OFFSET                  0                              // skip 0 bits
+#define KASEIKYO_ADDRESS_LEN                    16                              // read 16 address bits
+#define KASEIKYO_COMMAND_OFFSET                 28                              // skip 28 bits (16 manufacturer & 4 parity & 8 genre)
+#define KASEIKYO_COMMAND_LEN                    12                              // read 12 command bits (10 real command & 2 id)
+#define KASEIKYO_COMPLETE_DATA_LEN              48                              // complete length
+#define KASEIKYO_STOP_BIT                       1                               // has stop bit
+#define KASEIKYO_LSB                            1                               // LSB...MSB?
+#define KASEIKYO_FRAMES                         2                               // KASEIKYO sends 1st frame 2 times
+#define KASEIKYO_FLAGS                          0                               // flags
+
+#define RECS80_START_BIT_PULSE_TIME              158.0e-6                       //  158 usec pulse
+#define RECS80_START_BIT_PAUSE_TIME             7432.0e-6                       // 7432 usec pause
+#define RECS80_PULSE_TIME                        158.0e-6                       //  158 usec pulse
+#define RECS80_1_PAUSE_TIME                     7432.0e-6                       // 7432 usec pause
+#define RECS80_0_PAUSE_TIME                     4902.0e-6                       // 4902 usec pause
+#define RECS80_FRAME_REPEAT_PAUSE_TIME            45.0e-3                       // frame repeat after 45ms
+#define RECS80_ADDRESS_OFFSET                   1                               // skip 1 bit (toggle bit)
+#define RECS80_ADDRESS_LEN                      3                               // read 3 address bits
+#define RECS80_COMMAND_OFFSET                   4                               // skip 4 bits (1 toggle + 3 address)
+#define RECS80_COMMAND_LEN                      6                               // read 6 command bits
+#define RECS80_COMPLETE_DATA_LEN                10                              // complete length
+#define RECS80_STOP_BIT                         1                               // has stop bit
+#define RECS80_LSB                              0                               // MSB...LSB
+#define RECS80_FLAGS                            0                               // flags
+
+#define RC5_BIT_TIME                             889.0e-6                       // 889 usec pulse/pause
+#define RC5_FRAME_REPEAT_PAUSE_TIME               45.0e-3                       // frame repeat after 45ms
+
+#define RC5_ADDRESS_OFFSET                      1                               // skip 1 bit (2nd start)
+#define RC5_ADDRESS_LEN                         6                               // read 1 toggle bit (for key repetition detection) + 5 address bits
+#define RC5_COMMAND_OFFSET                      7                               // skip 5 bits (2nd start + 1 toggle + 5 address)
+#define RC5_COMMAND_LEN                         6                               // read 6 command bits
+#define RC5_COMPLETE_DATA_LEN                   13                              // complete length
+#define RC5_STOP_BIT                            0                               // has no stop bit
+#define RC5_LSB                                 0                               // MSB...LSB
+#define RC5_FLAGS                               IRMP_PARAM_FLAG_IS_MANCHESTER   // flags
+
+#define DENON_PULSE_TIME                         310.0e-6                       //  310 usec pulse in practice,  275 in theory
+#define DENON_1_PAUSE_TIME                      1780.0e-6                       // 1780 usec pause in practice, 1900 in theory
+#define DENON_0_PAUSE_TIME                       745.0e-6                       //  745 usec pause in practice,  775 in theory
+#define DENON_FRAMES                            2                               // DENON sends each frame 2 times
+#define DENON_AUTO_REPETITION_PAUSE_TIME          65.0e-3                       // inverted repetition after 65ms
+#define DENON_FRAME_REPEAT_PAUSE_TIME             65.0e-3                       // frame repeat after 65ms
+#define DENON_ADDRESS_OFFSET                    0                               // skip 0 bits
+#define DENON_ADDRESS_LEN                       5                               // read 5 address bits
+#define DENON_COMMAND_OFFSET                    5                               // skip 5
+#define DENON_COMMAND_LEN                       10                              // read 10 command bits
+#define DENON_COMPLETE_DATA_LEN                 15                              // complete length
+#define DENON_STOP_BIT                          1                               // has stop bit
+#define DENON_LSB                               0                               // MSB...LSB
+#define DENON_FLAGS                             0                               // flags
+
+#define RC6_START_BIT_PULSE_TIME                2666.0e-6                       // 2.666 msec pulse
+#define RC6_START_BIT_PAUSE_TIME                 889.0e-6                       // 889 usec pause
+#define RC6_TOGGLE_BIT_TIME                      889.0e-6                       // 889 msec pulse/pause
+#define RC6_BIT_TIME                             444.0e-6                       // 889 usec pulse/pause
+#define RC6_FRAME_REPEAT_PAUSE_TIME               45.0e-3                       // frame repeat after 45ms
+#define RC6_ADDRESS_OFFSET                      5                               // skip "1" + 3 mode bits + 1 toggle bit
+#define RC6_ADDRESS_LEN                         8                               // read 8 address bits
+#define RC6_COMMAND_OFFSET                      13                              // skip 12 bits ("1" + 3 mode + 1 toggle + 8 address)
+#define RC6_COMMAND_LEN                         8                               // read 8 command bits
+#define RC6_COMPLETE_DATA_LEN_SHORT             21                              // complete length
+#define RC6_COMPLETE_DATA_LEN_LONG              36                              // complete length
+#define RC6_STOP_BIT                            0                               // has no stop bit
+#define RC6_LSB                                 0                               // MSB...LSB
+#define RC6_FLAGS                               (IRMP_PARAM_FLAG_IS_MANCHESTER | IRMP_PARAM_FLAG_1ST_PULSE_IS_1)   // flags
+
+#define RECS80EXT_START_BIT_PULSE_TIME           158.0e-6                       //  158 usec pulse
+#define RECS80EXT_START_BIT_PAUSE_TIME          3637.0e-6                       // 3637 usec pause
+#define RECS80EXT_PULSE_TIME                     158.0e-6                       //  158 usec pulse
+#define RECS80EXT_1_PAUSE_TIME                  7432.0e-6                       // 7432 usec pause
+#define RECS80EXT_0_PAUSE_TIME                  4902.0e-6                       // 4902 usec pause
+#define RECS80EXT_FRAME_REPEAT_PAUSE_TIME         45.0e-3                       // frame repeat after 45ms
+#define RECS80EXT_ADDRESS_OFFSET                2                               // skip 2 bits (2nd start + 1 toggle)
+#define RECS80EXT_ADDRESS_LEN                   4                               // read 4 address bits
+#define RECS80EXT_COMMAND_OFFSET                6                               // skip 6 bits (2nd start + 1 toggle + 4 address)
+#define RECS80EXT_COMMAND_LEN                   6                               // read 6 command bits
+#define RECS80EXT_COMPLETE_DATA_LEN             12                              // complete length
+#define RECS80EXT_STOP_BIT                      1                               // has stop bit
+#define RECS80EXT_LSB                           0                               // MSB...LSB
+#define RECS80EXT_FLAGS                         0                               // flags
+
+#define NUBERT_START_BIT_PULSE_TIME             1340.0e-6                       // 1340 usec pulse
+#define NUBERT_START_BIT_PAUSE_TIME              340.0e-6                       //  340 usec pause
+#define NUBERT_1_PULSE_TIME                     1340.0e-6                       // 1340 usec pulse
+#define NUBERT_1_PAUSE_TIME                      340.0e-6                       //  340 usec pause
+#define NUBERT_0_PULSE_TIME                      500.0e-6                       //  500 usec pulse
+#define NUBERT_0_PAUSE_TIME                     1300.0e-6                       // 1300 usec pause
+#define NUBERT_FRAMES                           2                               // Nubert sends 2 frames
+#define NUBERT_AUTO_REPETITION_PAUSE_TIME         35.0e-3                       // auto repetition after 35ms
+#define NUBERT_FRAME_REPEAT_PAUSE_TIME            35.0e-3                       // frame repeat after 45ms
+#define NUBERT_ADDRESS_OFFSET                   0                               // skip 0 bits
+#define NUBERT_ADDRESS_LEN                      0                               // read 0 address bits
+#define NUBERT_COMMAND_OFFSET                   0                               // skip 0 bits
+#define NUBERT_COMMAND_LEN                      10                              // read 10 bits
+#define NUBERT_COMPLETE_DATA_LEN                10                              // complete length
+#define NUBERT_STOP_BIT                         1                               // has stop bit
+#define NUBERT_LSB                              0                               // MSB?
+#define NUBERT_FLAGS                            0                               // flags
+
+#define BANG_OLUFSEN_START_BIT1_PULSE_TIME       200.0e-6                       //   200 usec pulse
+#define BANG_OLUFSEN_START_BIT1_PAUSE_TIME      3125.0e-6                       //  3125 usec pause
+#define BANG_OLUFSEN_START_BIT2_PULSE_TIME       200.0e-6                       //   200 usec pulse
+#define BANG_OLUFSEN_START_BIT2_PAUSE_TIME      3125.0e-6                       //  3125 usec pause
+#define BANG_OLUFSEN_START_BIT3_PULSE_TIME       200.0e-6                       //   200 usec pulse
+#define BANG_OLUFSEN_START_BIT3_PAUSE_TIME     15625.0e-6                       // 15625 usec pause
+#define BANG_OLUFSEN_START_BIT4_PULSE_TIME       200.0e-6                       //   200 usec pulse
+#define BANG_OLUFSEN_START_BIT4_PAUSE_TIME      3125.0e-6                       //  3125 usec pause
+#define BANG_OLUFSEN_PULSE_TIME                  200.0e-6                       //   200 usec pulse
+#define BANG_OLUFSEN_1_PAUSE_TIME               9375.0e-6                       //  9375 usec pause
+#define BANG_OLUFSEN_0_PAUSE_TIME               3125.0e-6                       //  3125 usec pause
+#define BANG_OLUFSEN_R_PAUSE_TIME               6250.0e-6                       //  6250 usec pause (repeat last bit)
+#define BANG_OLUFSEN_TRAILER_BIT_PAUSE_TIME    12500.0e-6                       // 12500 usec pause (trailer bit)
+#define BANG_OLUFSEN_FRAME_REPEAT_PAUSE_TIME      45.0e-3                       // frame repeat after 45ms
+#define BANG_OLUFSEN_ADDRESS_OFFSET             0                               // no address bits
+#define BANG_OLUFSEN_ADDRESS_LEN                0                               // no address bits
+#define BANG_OLUFSEN_COMMAND_OFFSET             3                               // skip startbits 2, 3, 4
+#define BANG_OLUFSEN_COMMAND_LEN                16                              // read 16 command bits
+#define BANG_OLUFSEN_COMPLETE_DATA_LEN          20                              // complete length: startbits 2, 3, 4 + 16 data bits + trailer bit
+#define BANG_OLUFSEN_STOP_BIT                   1                               // has stop bit
+#define BANG_OLUFSEN_LSB                        0                               // MSB...LSB
+#define BANG_OLUFSEN_FLAGS                      0                               // flags
+
+#define GRUNDIG_NOKIA_IR60_BIT_TIME             528.0e-6                        // 528 usec pulse/pause
+#define GRUNDIG_NOKIA_IR60_PRE_PAUSE_TIME       2639.0e-6                       // 2639 usec pause after pre bit
+#define GRUNDIG_NOKIA_IR60_FRAME_REPEAT_PAUSE_TIME  117.76e-3                   // info frame repeat after 117.76 ms
+#define GRUNDIG_NOKIA_IR60_STOP_BIT             0                               // has no stop bit
+#define GRUNDIG_NOKIA_IR60_LSB                  1                               // MSB...LSB
+#define GRUNDIG_NOKIA_IR60_FLAGS                (IRMP_PARAM_FLAG_IS_MANCHESTER | IRMP_PARAM_FLAG_1ST_PULSE_IS_1)  // flags
+
+#define GRUNDIG_FRAMES                          2                               // GRUNDIG sends each frame 1+1 times
+#define GRUNDIG_AUTO_REPETITION_PAUSE_TIME        20.0e-3                       // repetition after 20ms
+#define GRUNDIG_ADDRESS_OFFSET                  0                               // no address
+#define GRUNDIG_ADDRESS_LEN                     0                               // no address
+#define GRUNDIG_COMMAND_OFFSET                  1                               // skip 1 start bit
+#define GRUNDIG_COMMAND_LEN                     9                               // read 9 command bits
+#define GRUNDIG_COMPLETE_DATA_LEN               10                              // complete length: 1 start bit + 9 data bits
+
+#define NOKIA_FRAMES                            3                               // NOKIA sends each frame 1 + 1 + 1 times
+#define NOKIA_AUTO_REPETITION_PAUSE_TIME          20.0e-3                       // repetition after 20ms
+#define NOKIA_ADDRESS_OFFSET                    9                               // skip 9 bits (1 start bit + 8 data bits)
+#define NOKIA_ADDRESS_LEN                       8                               // 7 address bits
+#define NOKIA_COMMAND_OFFSET                    1                               // skip 1 bit (1 start bit)
+#define NOKIA_COMMAND_LEN                       8                               // read 8 command bits
+#define NOKIA_COMPLETE_DATA_LEN                 17                              // complete length: 1 start bit + 8 address bits + 8 command bits
+
+#define IR60_TIMEOUT_TIME                       5000.0e-6                       // timeout grundig frame, switch to IR60
+#define IR60_ADDRESS_OFFSET                     0                               // skip 1 bits
+#define IR60_ADDRESS_LEN                        0                               // read 0 address bits
+#define IR60_COMMAND_OFFSET                     0                               // skip 1 bit (start bit after pre bit, always 1)
+#define IR60_COMMAND_LEN                        7                               // read 6 command bits
+#define IR60_COMPLETE_DATA_LEN                  7                               // complete length
+
+#define SIEMENS_OR_RUWIDO_START_BIT_PULSE_TIME    275.0e-6                      //  275 usec pulse
+#define SIEMENS_OR_RUWIDO_START_BIT_PAUSE_TIME    550.0e-6                      //  550 usec pause
+#define SIEMENS_OR_RUWIDO_BIT_PULSE_TIME          275.0e-6                      //  275 usec short pulse
+#define SIEMENS_OR_RUWIDO_BIT_PULSE_TIME_2        550.0e-6                      //  550 usec long pulse
+#define SIEMENS_OR_RUWIDO_BIT_PAUSE_TIME          275.0e-6                      //  275 usec short pause
+#define SIEMENS_OR_RUWIDO_BIT_PAUSE_TIME_2        550.0e-6                      //  550 usec long pause
+#define SIEMENS_OR_RUWIDO_FRAME_REPEAT_PAUSE_TIME 45.0e-3                       // frame repeat after 45ms
+#define SIEMENS_OR_RUWIDO_STOP_BIT                0                             // has no stop bit
+#define SIEMENS_OR_RUWIDO_LSB                     0                             // MSB...LSB
+#define SIEMENS_OR_RUWIDO_FLAGS                   (IRMP_PARAM_FLAG_IS_MANCHESTER | IRMP_PARAM_FLAG_1ST_PULSE_IS_1)  // flags
+
+#define RUWIDO_ADDRESS_OFFSET                   0                               // skip 0 bits
+#define RUWIDO_ADDRESS_LEN                      9                               // read 9 address bits
+#define RUWIDO_COMMAND_OFFSET                   9                               // skip 9 bits
+#define RUWIDO_COMMAND_LEN                      8                               // read 7 + 1 command bits, last bit is only check bit
+#define RUWIDO_COMPLETE_DATA_LEN                17                              // complete length
+
+#define SIEMENS_ADDRESS_OFFSET                  0                               // skip 0 bits
+#define SIEMENS_ADDRESS_LEN                     11                              // read 11 bits
+#define SIEMENS_COMMAND_OFFSET                  11                              // skip 11 bits
+#define SIEMENS_COMMAND_LEN                     11                              // read 10 + 1 command bits, last bit is only check bit
+#define SIEMENS_COMPLETE_DATA_LEN               22                              // complete length
+
+#define FDC_START_BIT_PULSE_TIME                 2085.0e-6                      // 2085 usec pulse
+#define FDC_START_BIT_PAUSE_TIME                  966.0e-6                      //  966 usec pause
+#define FDC_PULSE_TIME                            300.0e-6                      //  300 usec pulse
+#define FDC_1_PAUSE_TIME                          715.0e-6                      //  715 usec pause
+#define FDC_0_PAUSE_TIME                          220.0e-6                      //  220 usec pause
+#define FDC_FRAME_REPEAT_PAUSE_TIME                60.0e-3                      // frame repeat after 60ms
+#define FDC_ADDRESS_OFFSET                       0                              // skip 0 bits
+#define FDC_ADDRESS_LEN                         14                              // read 14 address bits, but use only 6, shift 8 into command
+#define FDC_COMMAND_OFFSET                      20                              // skip 20 bits
+#define FDC_COMMAND_LEN                         12                              // read 12 bits
+#define FDC_COMPLETE_DATA_LEN                   40                              // complete length
+#define FDC_STOP_BIT                            1                               // has stop bit
+#define FDC_LSB                                 1                               // LSB...MSB
+#define FDC_FLAGS                               0                               // flags
+
+#define RCCAR_START_BIT_PULSE_TIME               2000.0e-6                      // 2000 usec pulse
+#define RCCAR_START_BIT_PAUSE_TIME               2000.0e-6                      // 2000 usec pause
+#define RCCAR_PULSE_TIME                          600.0e-6                      //  360 usec pulse
+#define RCCAR_1_PAUSE_TIME                        450.0e-6                      //  650 usec pause
+#define RCCAR_0_PAUSE_TIME                        900.0e-6                      //  180 usec pause
+#define RCCAR_FRAME_REPEAT_PAUSE_TIME              40.0e-3                      // frame repeat after 40ms
+#define RCCAR_ADDRESS_OFFSET                     0                              // skip 0 bits
+#define RCCAR_ADDRESS_LEN                        0                              // read 0 address bits
+#define RCCAR_COMMAND_OFFSET                     0                              // skip 0 bits
+#define RCCAR_COMMAND_LEN                       13                              // read 13 bits
+#define RCCAR_COMPLETE_DATA_LEN                 13                              // complete length
+#define RCCAR_STOP_BIT                          1                               // has stop bit
+#define RCCAR_LSB                               1                               // LSB...MSB
+#define RCCAR_FLAGS                             0                               // flags
+
+#define JVC_START_BIT_PULSE_TIME                9000.0e-6                       // 9000 usec pulse
+#define JVC_START_BIT_PAUSE_TIME                4500.0e-6                       // 4500 usec pause
+#define JVC_PULSE_TIME                           560.0e-6                       //  560 usec pulse
+#define JVC_1_PAUSE_TIME                        1690.0e-6                       // 1690 usec pause
+#define JVC_0_PAUSE_TIME                         560.0e-6                       //  560 usec pause
+#define JVC_FRAME_REPEAT_PAUSE_TIME               22.0e-3                       // frame repeat after 22ms
+#define JVC_ADDRESS_OFFSET                       0                              // skip 0 bits
+#define JVC_ADDRESS_LEN                          4                              // read 4 address bits
+#define JVC_COMMAND_OFFSET                       4                              // skip 4 bits
+#define JVC_COMMAND_LEN                         12                              // read 12 bits
+#define JVC_COMPLETE_DATA_LEN                   16                              // complete length
+#define JVC_STOP_BIT                            1                               // has stop bit
+#define JVC_LSB                                 1                               // LSB...MSB
+#define JVC_FLAGS                               0                               // flags
+
+#define NIKON_START_BIT_PULSE_TIME              2200.0e-6                       //  2200 usec pulse
+#define NIKON_START_BIT_PAUSE_TIME             27100.0e-6                       // 27100 usec pause
+#define NIKON_PULSE_TIME                         500.0e-6                       //   500 usec pulse
+#define NIKON_1_PAUSE_TIME                      3500.0e-6                       //  3500 usec pause
+#define NIKON_0_PAUSE_TIME                      1500.0e-6                       //  1500 usec pause
+#define NIKON_FRAME_REPEAT_PAUSE_TIME             60.0e-3                       // frame repeat after 60ms
+#define NIKON_ADDRESS_OFFSET                    0                               // skip 0 bits
+#define NIKON_ADDRESS_LEN                       0                               // read 0 address bits
+#define NIKON_COMMAND_OFFSET                    0                               // skip 0 bits
+#define NIKON_COMMAND_LEN                       2                               // read 2 bits
+#define NIKON_COMPLETE_DATA_LEN                 2                               // complete length
+#define NIKON_STOP_BIT                          1                               // has stop bit
+#define NIKON_LSB                               0                               // LSB...MSB
+#define NIKON_FLAGS                             0                               // flags
+
+#define KATHREIN_START_BIT_PULSE_TIME            210.0e-6                       // 1340 usec pulse
+#define KATHREIN_START_BIT_PAUSE_TIME           6218.0e-6                       //  340 usec pause
+#define KATHREIN_1_PULSE_TIME                    210.0e-6                       // 1340 usec pulse
+#define KATHREIN_1_PAUSE_TIME                   3000.0e-6                       //  340 usec pause
+#define KATHREIN_0_PULSE_TIME                    210.0e-6                       //  500 usec pulse
+#define KATHREIN_0_PAUSE_TIME                   1400.0e-6                       // 1300 usec pause
+#define KATHREIN_SYNC_BIT_PAUSE_LEN_TIME        4600.0e-6                       // 4600 usec sync (on 6th and/or 8th bit)
+#define KATHREIN_FRAMES                         1                               // Kathrein sends 1 frame
+#define KATHREIN_AUTO_REPETITION_PAUSE_TIME     35.0e-3                         // auto repetition after 35ms
+#define KATHREIN_FRAME_REPEAT_PAUSE_TIME        35.0e-3                         // frame repeat after 35ms
+#define KATHREIN_ADDRESS_OFFSET                 1                               // skip 1 bits
+#define KATHREIN_ADDRESS_LEN                    4                               // read 4 address bits
+#define KATHREIN_COMMAND_OFFSET                 5                               // skip 5 bits
+#define KATHREIN_COMMAND_LEN                    7                               // read 7 bits
+#define KATHREIN_COMPLETE_DATA_LEN              13                              // complete length
+#define KATHREIN_STOP_BIT                       1                               // has stop bit
+#define KATHREIN_LSB                            0                               // MSB
+#define KATHREIN_FLAGS                          0                               // flags
+
+#define NETBOX_START_BIT_PULSE_TIME             2400.0e-6                       // 2400 usec pulse
+#define NETBOX_START_BIT_PAUSE_TIME              800.0e-6                       //  800 usec pause
+#define NETBOX_PULSE_TIME                        800.0e-6                       //  800 usec pulse
+#define NETBOX_PAUSE_TIME                        800.0e-6                       //  800 usec pause
+#define NETBOX_FRAMES                           1                               // Netbox sends 1 frame
+#define NETBOX_AUTO_REPETITION_PAUSE_TIME       35.0e-3                         // auto repetition after 35ms
+#define NETBOX_FRAME_REPEAT_PAUSE_TIME          35.0e-3                         // frame repeat after 35ms
+#define NETBOX_ADDRESS_OFFSET                   0                               // skip 0 bits
+#define NETBOX_ADDRESS_LEN                      3                               // read 3 address bits
+#define NETBOX_COMMAND_OFFSET                   3                               // skip 3 bits
+#define NETBOX_COMMAND_LEN                      13                              // read 13 bits
+#define NETBOX_COMPLETE_DATA_LEN                16                              // complete length
+#define NETBOX_STOP_BIT                         0                               // has no stop bit
+#define NETBOX_LSB                              1                               // LSB
+#define NETBOX_FLAGS                            IRMP_PARAM_FLAG_IS_SERIAL       // flags
+
+#define LEGO_START_BIT_PULSE_TIME                158.0e-6                       //  158 usec pulse (6 x 1/38kHz)
+#define LEGO_START_BIT_PAUSE_TIME               1026.0e-6                       // 1026 usec pause (39 x 1/38kHz)
+#define LEGO_PULSE_TIME                          158.0e-6                       //  158 usec pulse (6 x 1/38kHz)
+#define LEGO_1_PAUSE_TIME                        553.0e-6                       //  553 usec pause (21 x 1/38kHz)
+#define LEGO_0_PAUSE_TIME                        263.0e-6                       //  263 usec pause (10 x 1/38kHz)
+#define LEGO_FRAME_REPEAT_PAUSE_TIME              40.0e-3                       // frame repeat after 40ms
+#define LEGO_ADDRESS_OFFSET                     0                               // skip 0 bits
+#define LEGO_ADDRESS_LEN                        0                               // read 0 address bits
+#define LEGO_COMMAND_OFFSET                     0                               // skip 0 bits
+#define LEGO_COMMAND_LEN                        16                              // read 16 bits (12 command + 4 CRC)
+#define LEGO_COMPLETE_DATA_LEN                  16                              // complete length
+#define LEGO_STOP_BIT                           1                               // has stop bit
+#define LEGO_LSB                                0                               // MSB...LSB
+#define LEGO_FLAGS                              0                               // flags
+
+#define THOMSON_PULSE_TIME                       550.0e-6                       //  550 usec pulse
+#define THOMSON_1_PAUSE_TIME                    4500.0e-6                       // 4500 usec pause
+#define THOMSON_0_PAUSE_TIME                    2000.0e-6                       // 2000 usec pause
+#define THOMSON_FRAMES                          1                               // THOMSON sends 1 frame
+#define THOMSON_AUTO_REPETITION_PAUSE_TIME        65.0e-3                       // repetition after 65ms
+#define THOMSON_FRAME_REPEAT_PAUSE_TIME           65.0e-3                       // frame repeat after 65ms
+#define THOMSON_ADDRESS_OFFSET                  0                               // skip 0 bits
+#define THOMSON_ADDRESS_LEN                     4                               // read 4 address bits
+#define THOMSON_COMMAND_OFFSET                  5                               // skip 4 address bits + 1 toggle bit
+#define THOMSON_COMMAND_LEN                     7                               // read 7 command bits
+#define THOMSON_COMPLETE_DATA_LEN               12                              // complete length
+#define THOMSON_STOP_BIT                        1                               // has stop bit
+#define THOMSON_LSB                             0                               // MSB...LSB
+#define THOMSON_FLAGS                           0                               // flags
+
+#define GRUNDIG2_START_BIT_PULSE_TIME            550.0e-6                       //   550 usec pulse
+#define GRUNDIG2_START_BIT_PAUSE_TIME           2700.0e-6                       //  2700 usec pause
+#define GRUNDIG2_BIT_PULSE_TIME                  550.0e-6                       //   550 usec short pulse
+#define GRUNDIG2_BIT_PAUSE_TIME                  550.0e-6                       //   550 usec short pause
+#define GRUNDIG2_FRAME_REPEAT_PAUSE_TIME         100.0e-3                       // frame repeat after 100ms
+#define GRUNDIG2_STOP_BIT                       0                               // has no stop bit
+#define GRUNDIG2_LSB                            1                               // MSB...LSB
+#define GRUNDIG2_FLAGS                          (IRMP_PARAM_FLAG_IS_MANCHESTER | IRMP_PARAM_FLAG_1ST_PULSE_IS_1)  // flags
+#define GRUNDIG2_ADDRESS_OFFSET                 0                               // skip 0 bits
+#define GRUNDIG2_ADDRESS_LEN                    0                               // read 0 bits
+#define GRUNDIG2_COMMAND_OFFSET                 0                               // skip 0 bits
+#define GRUNDIG2_COMMAND_LEN                    7                               // read 6 + 1 command bits, last bit is always 1
+#define GRUNDIG2_COMPLETE_DATA_LEN              7                               // complete length
+
+#define AUTO_FRAME_REPETITION_TIME              80.0e-3                         // SIRCS/SAMSUNG32/NUBERT: automatic repetition after 25-50ms
+// KASEIKYO: automatic repetition after 75ms
+
+#define TRUE                                    1
+#define FALSE                                   0
+
+#define IRMP_FLAG_REPETITION                    0x01
+
+typedef struct
+{
+	uint8_t               protocol;                                               // protocol, i.e. NEC_PROTOCOL
+	uint16_t              address;                                                // address
+	uint16_t              command;                                                // command
+	uint8_t               flags;                                                  // flags, e.g. repetition
+} IRMP_DATA;
+
+extern void                             irmp_init(void);
+extern uint8_t                          irmp_get_data(IRMP_DATA *);
+extern uint8_t                          irmp_is_busy(void);
+extern uint8_t                          irmp_ISR(uint8_t);
+
+#if IRMP_PROTOCOL_NAMES == 1
+extern char                            *irmp_protocol_names[IRMP_N_PROTOCOLS + 1];
+#endif
+
+#if IRMP_USE_CALLBACK == 1
+extern void                             irmp_set_callback_ptr(void (*cb)(uint8_t));
+#endif // IRSND_USE_CALLBACK == 1
+
+#endif /* _WC_IRMP_H_ */
diff -Nur libstb-hal-ddt.git.orig/libspark/lirmp_input.cpp libstb-hal-ddt.git/libspark/lirmp_input.cpp
--- libstb-hal-ddt.git.orig/libspark/lirmp_input.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/lirmp_input.cpp	2022-07-23 18:18:31.543772226 +0200
@@ -51,23 +51,25 @@
 #define hal_info(args...) _hal_info(HAL_DEBUG_INIT, NULL, args)
 
 /* same defines as in neutrino's rcinput.h */
-#define KEY_TTTV	KEY_FN_1
-#define KEY_TTZOOM	KEY_FN_2
-#define KEY_REVEAL	KEY_FN_D
+#define KEY_TTTV    KEY_FN_1
+#define KEY_TTZOOM  KEY_FN_2
+#define KEY_REVEAL  KEY_FN_D
 /* only defined in newer kernels / headers... */
 #ifndef KEY_ZOOMIN
-#define KEY_ZOOMIN	KEY_FN_E
+#define KEY_ZOOMIN  KEY_FN_E
 #endif
 #ifndef KEY_ZOOMOUT
-#define KEY_ZOOMOUT	KEY_FN_F
+#define KEY_ZOOMOUT KEY_FN_F
 #endif
 
-typedef struct {
-	uint16_t ir;	/* IR command */
-	int code;	/* input key code */
+typedef struct
+{
+	uint16_t ir;    /* IR command */
+	int code;   /* input key code */
 } key_map_t;
 
-static const key_map_t key_map[] = {
+static const key_map_t key_map[] =
+{
 	{ 0x13, KEY_0 },
 	{ 0x1a, KEY_1 },
 	{ 0x1f, KEY_2 },
@@ -101,15 +103,15 @@
 	{ 0x4e, KEY_GREEN },
 	{ 0x11, KEY_YELLOW },
 	{ 0x4a, KEY_BLUE },
-	{ 0x4c, KEY_TV },	/* TV/Radio */
-	{ 0x5c, KEY_VIDEO },	/* FIND */
-	{ 0x19, KEY_AUDIO },	/* FOLDER */
-/*	KEY_AUX,
-	KEY_TEXT,
-	KEY_TTTV,
-	KEY_TTZOOM,
-	KEY_REVEAL,
-*/
+	{ 0x4c, KEY_TV },   /* TV/Radio */
+	{ 0x5c, KEY_VIDEO },    /* FIND */
+	{ 0x19, KEY_AUDIO },    /* FOLDER */
+	/*  KEY_AUX,
+	    KEY_TEXT,
+	    KEY_TTTV,
+	    KEY_TTZOOM,
+	    KEY_REVEAL,
+	*/
 	{ 0x01, KEY_REWIND },
 	{ 0x53, KEY_FORWARD },
 	{ 0x22, KEY_STOP },
@@ -121,7 +123,8 @@
 	{ 0x10, KEY_RECORD }
 };
 
-static const int key_list[] = {
+static const int key_list[] =
+{
 	KEY_0,
 	KEY_1,
 	KEY_2,
@@ -191,9 +194,9 @@
 	int i = 0;
 	int last_pulse = 1;
 	int last_code = -1;
-	uint32_t lircdata;	/* lirc_t to be correct... */
-	unsigned int count = 0;	/* how many timeouts? */
-	unsigned int nodec = 0;	/* how many timeouts since last decoded? */
+	uint32_t lircdata;  /* lirc_t to be correct... */
+	unsigned int count = 0; /* how many timeouts? */
+	unsigned int nodec = 0; /* how many timeouts since last decoded? */
 	int aotom_fd = -1;
 	IRMP_DATA d;
 
@@ -201,10 +204,12 @@
 
 	/* modprobe does not complain if the module is already loaded... */
 	system("/sbin/modprobe uinput");
-	do {
+	do
+	{
 		usleep(100000); /* mdev needs some time to create the device? */
-		uinput = open("/dev/uinput", O_WRONLY|O_NDELAY);
-	} while (uinput < 0 && ++count < 100);
+		uinput = open("/dev/uinput", O_WRONLY | O_NDELAY);
+	}
+	while (uinput < 0 && ++count < 100);
 
 	if (uinput < 0)
 	{
@@ -253,7 +258,7 @@
 		char newdev[20];
 		while (getline(&line, &n, f) != -1)
 		{
-			switch(line[0])
+			switch (line[0])
 			{
 				case 'I':
 					if (strncmp(line, DEVLINE, strlen(DEVLINE)) == 0)
@@ -295,10 +300,10 @@
 	}
 	IRMP_PIN = 0xFF;
 
-/* 50 ms. This should be longer than the longest light pulse */
-#define POLL_MS		(100 * 1000)
-#define LIRC_PULSE	0x01000000
-#define LIRC_PULSE_MASK	0x00FFFFFF
+	/* 50 ms. This should be longer than the longest light pulse */
+#define POLL_MS     (100 * 1000)
+#define LIRC_PULSE  0x01000000
+#define LIRC_PULSE_MASK 0x00FFFFFF
 	hal_info("LIRC/IRMP input converter going into main loop...\n");
 
 	aotom_fd = open("/dev/vfd", O_RDONLY);
@@ -317,11 +322,14 @@
 		tv.tv_usec = POLL_MS;
 		/* any singal can interrupt select. we rely on the linux-only feature
 		 * that the timeout is automatcally recalculated in this case! */
-		do {
+		do
+		{
 			ret = select(lircfd + 1, &fds, NULL, NULL, &tv);
-		} while (ret == -1 && errno == EINTR);
+		}
+		while (ret == -1 && errno == EINTR);
 
-		if (ret == -1) {
+		if (ret == -1)
+		{
 			/* errno != EINTR... */
 			hal_info("%s: lirmp: lircfd select: %m\n", __func__);
 			break;
@@ -331,13 +339,13 @@
 		{
 			count++;
 			nodec++;
-			lircdata = POLL_MS;	/* timeout */
-			pulse = !last_pulse;	/* lirc sends data on signal change */
+			lircdata = POLL_MS; /* timeout */
+			pulse = !last_pulse;    /* lirc sends data on signal change */
 			if (last_code != -1 && nodec > 1)
 			{
 				// fprintf(stderr, "timeout!\n");
 				u.code = last_code;
-				u.value = 0;	/* release */
+				u.value = 0;    /* release */
 				write(uinput, &u, sizeof(u));
 				last_code = -1;
 			}
@@ -349,9 +357,9 @@
 				perror("read");
 				break;
 			}
-			pulse = (lircdata & LIRC_PULSE);	/* we got light... */
+			pulse = (lircdata & LIRC_PULSE);    /* we got light... */
 			last_pulse = pulse;
-			lircdata &= LIRC_PULSE_MASK;		/* how long the pulse was in microseconds */
+			lircdata &= LIRC_PULSE_MASK;        /* how long the pulse was in microseconds */
 		}
 
 		if (ret && count)
@@ -370,19 +378,20 @@
 		else
 			IRMP_PIN = 0xff;
 
-		do {
-			(void) irmp_ISR (IRMP_PIN);
-			if (irmp_get_data (&d))
+		do
+		{
+			(void) irmp_ISR(IRMP_PIN);
+			if (irmp_get_data(&d))
 			{
 				nodec = 0;
 				hal_debug("irmp_get_data proto: %2d addr: 0x%04x cmd: 0x%04x fl: %d\n",
-					d.protocol, d.address, d.command, d.flags);
+				    d.protocol, d.address, d.command, d.flags);
 
 				/* todo: do we need to complete the loop if we already
 				 * detected the singal in this pulse? */
 				if (d.protocol == IRMP_NEC_PROTOCOL && d.address == 0xba45)
 				{
-					for (i = 0; i < (int)(sizeof(key_map)/sizeof(key_map_t)); i++)
+					for (i = 0; i < (int)(sizeof(key_map) / sizeof(key_map_t)); i++)
 					{
 						if (key_map[i].ir == d.command)
 						{
@@ -397,7 +406,8 @@
 							//hal_debug("uinput write: value: %d code: %d\n", u.value, u.code);
 							last_code = u.code;
 							write(uinput, &u, sizeof(u));
-							if (aotom_fd > -1) {
+							if (aotom_fd > -1)
+							{
 								struct aotom_ioctl_data vfd_data;
 								vfd_data.u.led.led_nr = 1;
 								vfd_data.u.led.on = 10;
@@ -408,15 +418,16 @@
 					}
 				}
 			}
-		} while (lircdata-- > 0);
+		}
+		while (lircdata-- > 0);
 	}
 	/* clean up */
-	close (lircfd);
+	close(lircfd);
 
 	if (aotom_fd > -1)
 		close(aotom_fd);
 
- out:
+out:
 	ioctl(uinput, UI_DEV_DESTROY);
 	return NULL;
 }
@@ -432,7 +443,7 @@
 	/* wait until the device is created before continuing */
 	while (! thread_running)
 		usleep(1000);
-	if (thread_running == 2) /* failed... :-( */
+	if (thread_running == 2) /* failed... :-(*/
 		thread_running = 0;
 }
 
diff -Nur libstb-hal-ddt.git.orig/libspark/Makefile.am libstb-hal-ddt.git/libspark/Makefile.am
--- libstb-hal-ddt.git.orig/libspark/Makefile.am	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/Makefile.am	2022-07-23 18:18:31.539772306 +0200
@@ -24,4 +24,4 @@
 	playback_libeplayer3.cpp \
 	record.cpp
 
-AM_CPPFLAGS += -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS
+AM_CPPFLAGS += -D__STDC_FORMAT_MACROS -D__STDC_CONSTANT_MACROS -D__STDC_LIMIT_MACROS
diff -Nur libstb-hal-ddt.git.orig/libspark/playback_libeplayer3.cpp libstb-hal-ddt.git/libspark/playback_libeplayer3.cpp
--- libstb-hal-ddt.git.orig/libspark/playback_libeplayer3.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libspark/playback_libeplayer3.cpp	2022-07-23 18:18:31.543772226 +0200
@@ -54,7 +54,7 @@
 
 bool cPlayback::Start(std::string filename, std::string headers)
 {
-	return Start((char*) filename.c_str(),0,0,0,0,0, headers);
+	return Start((char *) filename.c_str(), 0, 0, 0, 0, 0, headers);
 }
 
 bool cPlayback::Start(char *filename, int vpid, int vtype, int apid, int ac3, int, std::string headers)
@@ -77,40 +77,53 @@
 	if ((file.find(":31339/id=") != std::string::npos) || (file.find(":10000") != std::string::npos) || (file.find(":8001/") != std::string::npos)) // for LocalTV and Entertain-TV streaming
 		no_probe = true;
 
-	if (file.substr(0, 7) == "file://") {
-		if (file.substr(file.length() - 3) ==  ".ts") {
+	if (file.substr(0, 7) == "file://")
+	{
+		if (file.substr(file.length() - 3) ==  ".ts")
+		{
 			fn_ts = file.substr(7);
 			fn_xml = file.substr(7, file.length() - 9);
 			fn_xml += "xml";
 			no_probe = true;
 		}
-	} else
+	}
+	else
 		isHTTP = true;
 
-	if (player->Open(file.c_str(), no_probe, headers)) {
-		if (pm == PLAYMODE_TS) {
+	if (player->Open(file.c_str(), no_probe, headers))
+	{
+		if (pm == PLAYMODE_TS)
+		{
 			struct stat64 s;
 			if (!stat64(file.c_str(), &s))
 				last_size = s.st_size;
 			ret = true;
 			videoDecoder->Stop(false);
 			audioDecoder->Stop();
-		} else {
+		}
+		else
+		{
 			std::vector<std::string> keys, values;
 			int selected_program = 0;
-			if (vpid || apid) {
+			if (vpid || apid)
+			{
 				;
-			} else if (GetPrograms(keys, values) && (keys.size() > 1) && ProgramSelectionCallback) {
+			}
+			else if (GetPrograms(keys, values) && (keys.size() > 1) && ProgramSelectionCallback)
+			{
 				const char *key = ProgramSelectionCallback(ProgramSelectionCallbackData, keys, values);
-				if (!key) {
+				if (!key)
+				{
 					player->Close();
 					return false;
 				}
 				selected_program = atoi(key);
-			} else if (keys.size() > 0)
+			}
+			else if (keys.size() > 0)
 				selected_program = atoi(keys[0].c_str());
 
-			if (!keys.size() || !player->SelectProgram(selected_program)) {
+			if (!keys.size() || !player->SelectProgram(selected_program))
+			{
 				if (apid)
 					SetAPid(apid);
 				if (vpid)
@@ -181,27 +194,35 @@
 
 	nPlaybackSpeed = speed;
 
-	if (speed > 1) {
+	if (speed > 1)
+	{
 		/* direction switch ? */
 		if (player->isBackWard)
 			player->FastBackward(0);
 		res = player->FastForward(speed);
-	} else if (speed < 0) {
+	}
+	else if (speed < 0)
+	{
 		/* direction switch ? */
 		if (player->isForwarding)
 			player->Continue();
 		res = player->FastBackward(speed);
-	} else if (speed == 0) {
+	}
+	else if (speed == 0)
+	{
 		/* konfetti: hmmm accessing the member isn't very proper */
 		if ((player->isForwarding) || (!player->isBackWard))
 			/* res = */ player->Pause();
 		else
 			/* res = */ player->FastForward(0);
-	} else /* speed == 1 */ {
+	}
+	else /* speed == 1 */
+	{
 		res = player->Continue();
 	}
 
-	if (init_jump > -1) {
+	if (init_jump > -1)
+	{
 		SetPosition(init_jump);
 		init_jump = -1;
 	}
@@ -252,7 +273,8 @@
 	if (!playing)
 		return false;
 
-	if (!player->isPlaying) {
+	if (!player->isPlaying)
+	{
 		hal_info("%s !!!!EOF!!!! < -1\n", __func__);
 		position = duration + 1000;
 		// duration = 0;
@@ -263,11 +285,14 @@
 	int64_t vpts = 0;
 	player->GetPts(vpts);
 
-	if(vpts <= 0) {
+	if (vpts <= 0)
+	{
 		//printf("ERROR: vpts==0");
-	} else {
+	}
+	else
+	{
 		/* len is in nanoseconds. we have 90 000 pts per second. */
-		position = vpts/90;
+		position = vpts / 90;
 	}
 
 	if (got_duration)
@@ -277,7 +302,7 @@
 
 	player->GetDuration(length);
 
-	if(length <= 0)
+	if (length <= 0)
 		duration = position + AV_TIME_BASE / 1000;
 	else
 		duration = length * 1000 / AV_TIME_BASE;
@@ -308,9 +333,11 @@
 	hal_info("%s\n", __func__);
 	unsigned int i = 0;
 
-	if (IsPlaying()) {
+	if (IsPlaying())
+	{
 		std::vector<Track> tracks = player->manager.getAudioTracks();
-		for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it) {
+		for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it)
+		{
 			pids[i] = it->pid;
 			ac3flags[i] = it->ac3flags;
 			language[i] = it->title;
@@ -326,7 +353,8 @@
 	unsigned int i = 0;
 
 	std::vector<Track> tracks = player->manager.getSubtitleTracks();
-	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it) {
+	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it)
+	{
 		pids[i] = it->pid;
 		language[i] = it->title;
 		i++;
@@ -341,7 +369,8 @@
 	unsigned int i = 0;
 
 	std::vector<Track> tracks = player->manager.getTeletextTracks();
-	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it) {
+	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end() && i < *numpids; ++it)
+	{
 		if (it->type != 2 && it->type != 5) // return subtitles only
 			continue;
 		pids[i] = it->pid;
@@ -357,7 +386,8 @@
 int cPlayback::GetFirstTeletextPid(void)
 {
 	std::vector<Track> tracks = player->manager.getTeletextTracks();
-	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end(); ++it) {
+	for (std::vector<Track>::iterator it = tracks.begin(); it != tracks.end(); ++it)
+	{
 		if (it->type == 1)
 			return it->pid;
 	}
@@ -413,17 +443,20 @@
 	delete player;
 }
 
-void cPlayback::RequestAbort() {
+void cPlayback::RequestAbort()
+{
 	player->RequestAbort();
 	while (player->isPlaying)
 		usleep(100000);
 }
 
-bool cPlayback::IsPlaying() {
+bool cPlayback::IsPlaying()
+{
 	return player->isPlaying;
 }
 
-uint64_t cPlayback::GetReadCount() {
+uint64_t cPlayback::GetReadCount()
+{
 	return player->readCount;
 }
 
diff -Nur libstb-hal-ddt.git.orig/libspark/playback_libeplayer3.h libstb-hal-ddt.git/libspark/playback_libeplayer3.h
--- libstb-hal-ddt.git.orig/libspark/playback_libeplayer3.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/playback_libeplayer3.h	2022-07-23 18:18:31.543772226 +0200
@@ -4,7 +4,8 @@
 #include <string>
 #include <vector>
 
-typedef enum {
+typedef enum
+{
 	PLAYMODE_TS = 0,
 	PLAYMODE_FILE
 } playmode_t;
@@ -14,7 +15,7 @@
 
 class cPlayback
 {
-	friend class CStreamInfo2;
+		friend class CStreamInfo2;
 
 	private:
 		bool enabled;
@@ -82,10 +83,10 @@
 		bool GetOffset(off64_t &offset);
 		bool IsPlaying(void) const;
 		bool IsEnabled(void) const;
-		void * GetHandle(void);
-		void * GetDmHandle(void);
+		void *GetHandle(void);
+		void *GetDmHandle(void);
 		int GetCurrPlaybackSpeed(void) const;
-		void PlaybackNotify (int  Event, void *pData, void *pTag);
+		void PlaybackNotify(int  Event, void *pData, void *pTag);
 		void DMNotify(int Event, void *pTsBuf, void *Tag);
 #endif
 };
diff -Nur libstb-hal-ddt.git.orig/libspark/record.cpp libstb-hal-ddt.git/libspark/record.cpp
--- libstb-hal-ddt.git.orig/libspark/record.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/record.cpp	2022-07-23 18:18:31.543772226 +0200
@@ -134,17 +134,21 @@
 	bool found;
 	unsigned short pid;
 	hal_info("%s\n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
 	/* the first PID is the video pid, so start with the second PID... */
-	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+	{
 		found = false;
 		pid = (*i).pid;
-		for (j = 0; j < numapids; j++) {
-			if (pid == apids[j]) {
+		for (j = 0; j < numapids; j++)
+		{
+			if (pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -152,10 +156,13 @@
 		if (!found)
 			dmx->removePid(pid);
 	}
-	for (j = 0; j < numapids; j++) {
+	for (j = 0; j < numapids; j++)
+	{
 		found = false;
-		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
-			if ((*i).pid == apids[j]) {
+		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i)
+		{
+			if ((*i).pid == apids[j])
+			{
 				found = true;
 				break;
 			}
@@ -170,12 +177,14 @@
 {
 	std::vector<pes_pids> pids;
 	hal_info("%s: \n", __func__);
-	if (!dmx) {
+	if (!dmx)
+	{
 		hal_info("%s: DMX = NULL\n", __func__);
 		return false;
 	}
 	pids = dmx->pesfds;
-	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i) {
+	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i)
+	{
 		if ((*i).pid == pid)
 			return true; /* or is it an error to try to add the same PID twice? */
 	}
@@ -187,14 +196,16 @@
 	char threadname[17];
 	strncpy(threadname, "WriterThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	unsigned int chunk = 0;
-	while (!sem_wait(&sem)) {
+	while (!sem_wait(&sem))
+	{
 		if (!io_len[chunk]) // empty, assume end of recording
 			return;
 		unsigned char *p_buf = io_buf[chunk];
 		size_t p_len = io_len[chunk];
-		while (p_len) {
+		while (p_len)
+		{
 			ssize_t written = write(file_fd, p_buf, p_len);
 			if (written < 0)
 				break;
@@ -214,7 +225,7 @@
 	char threadname[17];
 	strncpy(threadname, "RecordThread", sizeof(threadname));
 	threadname[16] = 0;
-	prctl (PR_SET_NAME, (unsigned long)&threadname);
+	prctl(PR_SET_NAME, (unsigned long)&threadname);
 	int readsize = bufsize / 16;
 	int buf_pos = 0;
 	int count = 0;
@@ -235,7 +246,7 @@
 	}
 
 	int val = fcntl(file_fd, F_GETFL);
-	if (fcntl(file_fd, F_SETFL, val|O_APPEND))
+	if (fcntl(file_fd, F_SETFL, val | O_APPEND))
 		hal_info("%s: O_APPEND? (%m)\n", __func__);
 
 	memset(&a, 0, sizeof(a));
@@ -250,7 +261,8 @@
 	{
 		if (buf_pos < bufsize)
 		{
-			if (overflow_count) {
+			if (overflow_count)
+			{
 				hal_info("%s: Overflow cleared after %d iterations\n", __func__, overflow_count);
 				overflow_count = 0;
 			}
@@ -259,7 +271,7 @@
 				toread = readsize;
 			ssize_t s = dmx->Read(buf + buf_pos, toread, 50);
 			hal_debug("%s: buf_pos %6d s %6d / %6d\n", __func__,
-				buf_pos, (int)s, bufsize - buf_pos);
+			    buf_pos, (int)s, bufsize - buf_pos);
 			if (s < 0)
 			{
 				if (errno != EAGAIN && (errno != EOVERFLOW || !overflow))
@@ -362,9 +374,9 @@
 	eventServer.registerEvent2(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, "/tmp/neutrino.sock");
 	stream2file_status2_t s;
 	s.status = exit_flag;
-	strncpy(s.filename,basename(myfilename),512);
+	strncpy(s.filename, basename(myfilename), 512);
 	s.filename[511] = '\0';
-	strncpy(s.dir,dirname(myfilename),100);
+	strncpy(s.dir, dirname(myfilename), 100);
 	s.dir[99] = '\0';
 	eventServer.sendEvent(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, &s, sizeof(s));
 	printf("[stream2file]: pthreads exit code: %i, dir: '%s', filename: '%s' myfilename: '%s'\n", exit_flag, s.dir, s.filename, myfilename);
diff -Nur libstb-hal-ddt.git.orig/libspark/record_lib.h libstb-hal-ddt.git/libspark/record_lib.h
--- libstb-hal-ddt.git.orig/libspark/record_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/record_lib.h	2022-07-23 18:18:31.543772226 +0200
@@ -9,13 +9,14 @@
 #define REC_STATUS_OVERFLOW 2
 #define REC_STATUS_STOPPED 4
 
-typedef enum {
+typedef enum
+{
 	RECORD_RUNNING,
 	RECORD_STOPPED,
-	RECORD_FAILED_READ,	/* failed to read from DMX */
-	RECORD_FAILED_OVERFLOW,	/* cannot write fast enough */
-	RECORD_FAILED_FILE,	/* cannot write to file */
-	RECORD_FAILED_MEMORY	/* out of memory */
+	RECORD_FAILED_READ, /* failed to read from DMX */
+	RECORD_FAILED_OVERFLOW, /* cannot write fast enough */
+	RECORD_FAILED_FILE, /* cannot write to file */
+	RECORD_FAILED_MEMORY    /* out of memory */
 } record_state_t;
 
 class cRecord
@@ -38,8 +39,12 @@
 		unsigned char *io_buf[RECORD_WRITER_CHUNKS];
 		size_t io_len[RECORD_WRITER_CHUNKS];
 	public:
-		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024); 
-		void setFailureCallback(void (*f)(void *), void *d) { failureCallback = f; failureData = d; }
+		cRecord(int num = 0, int bs_dmx = 2048 * 1024, int bs = 4096 * 1024);
+		void setFailureCallback(void (*f)(void *), void *d)
+		{
+			failureCallback = f;
+			failureData = d;
+		}
 		~cRecord();
 
 		bool Open();
diff -Nur libstb-hal-ddt.git.orig/libspark/video.cpp libstb-hal-ddt.git/libspark/video.cpp
--- libstb-hal-ddt.git.orig/libspark/video.cpp	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/libspark/video.cpp	2022-07-23 18:18:31.543772226 +0200
@@ -39,6 +39,7 @@
 #include "video_lib.h"
 #include "hal_debug.h"
 
+#include <hardware_caps.h>
 #include <proc_tools.h>
 
 extern "C"
@@ -53,70 +54,104 @@
 #define hal_debug_c(args...) _hal_debug(HAL_DEBUG_VIDEO, NULL, args)
 #define hal_info_c(args...) _hal_info(HAL_DEBUG_VIDEO, NULL, args)
 
-#define fop(cmd, args...) ({				\
-	int _r;						\
-	if (fd >= 0) { 					\
-		if ((_r = ::cmd(fd, args)) < 0)		\
-			hal_info(#cmd"(fd, "#args")\n");	\
-		else					\
-			hal_debug(#cmd"(fd, "#args")\n");\
-	}						\
-	else { _r = fd; } 				\
-	_r;						\
+#define fop(cmd, args...) ({                \
+    int _r;                     \
+    if (fd >= 0) {                  \
+        if ((_r = ::cmd(fd, args)) < 0)     \
+            hal_info(#cmd"(fd, "#args")\n");    \
+        else                    \
+            hal_debug(#cmd"(fd, "#args")\n");\
+    }                       \
+    else { _r = fd; }               \
+    _r;                     \
 })
 
-cVideo * videoDecoder = NULL;
-cVideo * pipDecoder = NULL;
+enum
+{
+	ENCODER,
+	AUX
+};
+
+cVideo *videoDecoder = NULL;
+cVideo *pipVideoDecoder[3] = { NULL, NULL, NULL };
 
 int system_rev = 0;
 
 static bool hdmi_enabled = true;
 static bool stillpicture = false;
 
-static const char *VDEV[] = {
+static const char *VDEV[] =
+{
 	"/dev/dvb/adapter0/video0",
-	"/dev/dvb/adapter0/video1"
+	"/dev/dvb/adapter0/video1",
+	"/dev/dvb/adapter0/video2",
+	"/dev/dvb/adapter0/video3"
 };
-static const char *VMPEG_aspect[] = {
+static const char *VMPEG_aspect[] =
+{
 	"/proc/stb/vmpeg/0/aspect",
-	"/proc/stb/vmpeg/1/aspect"
+	"/proc/stb/vmpeg/1/aspect",
+	"/proc/stb/vmpeg/2/aspect",
+	"/proc/stb/vmpeg/3/aspect"
 };
 
-static const char *VMPEG_xres[] = {
+static const char *VMPEG_xres[] =
+{
 	"/proc/stb/vmpeg/0/xres",
-	"/proc/stb/vmpeg/1/xres"
+	"/proc/stb/vmpeg/1/xres",
+	"/proc/stb/vmpeg/2/xres",
+	"/proc/stb/vmpeg/3/xres"
 };
 
-static const char *VMPEG_yres[] = {
+static const char *VMPEG_yres[] =
+{
 	"/proc/stb/vmpeg/0/yres",
-	"/proc/stb/vmpeg/1/yres"
+	"/proc/stb/vmpeg/1/yres",
+	"/proc/stb/vmpeg/2/yres",
+	"/proc/stb/vmpeg/3/yres"
 };
 
-static const char *VMPEG_dst_all[] = {
+static const char *VMPEG_dst_all[] =
+{
 	"/proc/stb/vmpeg/0/dst_all",
-	"/proc/stb/vmpeg/1/dst_all"
+	"/proc/stb/vmpeg/1/dst_all",
+	"/proc/stb/vmpeg/2/dst_all",
+	"/proc/stb/vmpeg/3/dst_all"
 };
 
-static const char *VMPEG_framerate[] = {
+static const char *VMPEG_framerate[] =
+{
 	"/proc/stb/vmpeg/0/framerate",
-	"/proc/stb/vmpeg/1/framerate"
+	"/proc/stb/vmpeg/1/framerate",
+	"/proc/stb/vmpeg/2/framerate",
+	"/proc/stb/vmpeg/3/framerate"
 };
 
-static const char *vid_modes[] = {
-	"pal",		// VIDEO_STD_NTSC
-	"pal",		// VIDEO_STD_SECAM
-	"pal",		// VIDEO_STD_PAL
-	"480p",		// VIDEO_STD_480P
-	"576p50",	// VIDEO_STD_576P
-	"720p60",	// VIDEO_STD_720P60
-	"1080i60",	// VIDEO_STD_1080I60
-	"720p50",	// VIDEO_STD_720P50
-	"1080i50",	// VIDEO_STD_1080I50
-	"1080p30",	// VIDEO_STD_1080P30
-	"1080p24",	// VIDEO_STD_1080P24
-	"1080p25",	// VIDEO_STD_1080P25
-	"720p50",	// VIDEO_STD_AUTO -> not implemented
-	"1080p50",	// VIDEO_STD_1080P50 -> SPARK only
+static const char *VMPEG_visible[] =
+{
+	"/proc/stb/vmpeg/0/visible",
+	"/proc/stb/vmpeg/1/visible",
+	"/proc/stb/vmpeg/2/visible",
+	"/proc/stb/vmpeg/3/visible"
+};
+
+
+static const char *vid_modes[] =
+{
+	"pal",      // VIDEO_STD_NTSC
+	"pal",      // VIDEO_STD_SECAM
+	"pal",      // VIDEO_STD_PAL
+	"480p",     // VIDEO_STD_480P
+	"576p50",   // VIDEO_STD_576P
+	"720p60",   // VIDEO_STD_720P60
+	"1080i60",  // VIDEO_STD_1080I60
+	"720p50",   // VIDEO_STD_720P50
+	"1080i50",  // VIDEO_STD_1080I50
+	"1080p30",  // VIDEO_STD_1080P30
+	"1080p24",  // VIDEO_STD_1080P24
+	"1080p25",  // VIDEO_STD_1080P25
+	"720p50",   // VIDEO_STD_AUTO -> not implemented
+	"1080p50",  // VIDEO_STD_1080P50 -> SPARK only
 	NULL
 };
 
@@ -164,49 +199,61 @@
 }
 
 
-void init_parameters(AVFrame* in_frame, AVCodecContext *codec_context)
+void init_parameters(AVFrame *in_frame, AVCodecContext *codec_context)
 {
 	/* put sample parameters */
 	codec_context->bit_rate = 400000;
 	/* resolution must be a multiple of two */
-	codec_context->width = (in_frame->width/2)*2;
-	codec_context->height = (in_frame->height/2)*2;
+	codec_context->width = (in_frame->width / 2) * 2;
+	codec_context->height = (in_frame->height / 2) * 2;
 	/* frames per second */
-	codec_context->time_base = (AVRational ) { 1, 60 };
+	codec_context->time_base = (AVRational)
+	{
+		1, 60
+	};
 	codec_context->gop_size = 10; /* emit one intra frame every ten frames */
 	codec_context->max_b_frames = 1;
 	codec_context->pix_fmt = AV_PIX_FMT_YUV420P;
 }
 
-void write_frame(AVFrame* in_frame, FILE* fp)
+void write_frame(AVFrame *in_frame, FILE *fp)
 {
-	if(in_frame == NULL || fp == NULL)
+	if (in_frame == NULL || fp == NULL)
 		return;
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
 	AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MPEG2VIDEO);
+#else
+	const AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MPEG2VIDEO);
+#endif
 	if (codec)
 	{
 		AVCodecContext *codec_context = avcodec_alloc_context3(codec);
 		if (codec_context)
 		{
 			init_parameters(in_frame, codec_context);
-			if (avcodec_open2(codec_context, codec, 0) != -1) {
+			if (avcodec_open2(codec_context, codec, 0) != -1)
+			{
 				AVPacket pkt;
 				av_init_packet(&pkt);
 				/* encode the image */
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 				int got_output = 0;
 				int ret = avcodec_encode_video2(codec_context, &pkt, in_frame, &got_output);
-				if (ret != -1) {
-					if (got_output) {
+				if (ret != -1)
+				{
+					if (got_output)
+					{
 						fwrite(pkt.data, 1, pkt.size, fp);
 						av_packet_unref(&pkt);
 					}
 					int i = 1;
-					for (got_output = 1; got_output; i++) {
-					/* get the delayed frames */
+					for (got_output = 1; got_output; i++)
+					{
+						/* get the delayed frames */
 						in_frame->pts = i;
 						ret = avcodec_encode_video2(codec_context, &pkt, 0, &got_output);
-						if (ret != -1 && got_output) {
+						if (ret != -1 && got_output)
+						{
 							fwrite(pkt.data, 1, pkt.size, fp);
 							av_packet_unref(&pkt);
 						}
@@ -214,16 +261,19 @@
 				}
 #else
 				int ret = avcodec_send_frame(codec_context, in_frame);
-				if (!ret) {
+				if (!ret)
+				{
 					/* signalling end of stream */
 					ret = avcodec_send_frame(codec_context, NULL);
 				}
-				if (!ret) {
+				if (!ret)
+				{
 					int i = 1;
 					/* get the delayed frames */
 					in_frame->pts = i;
 					ret = avcodec_receive_packet(codec_context, &pkt);
-					if (!ret) {
+					if (!ret)
+					{
 						fwrite(pkt.data, 1, pkt.size, fp);
 						av_packet_unref(&pkt);
 					}
@@ -236,13 +286,15 @@
 	}
 }
 
-int decode_frame(AVCodecContext *codecContext,AVPacket &packet, FILE* fp)
+int decode_frame(AVCodecContext *codecContext, AVPacket &packet, FILE *fp)
 {
 	AVFrame *frame = av_frame_alloc();
-	if(frame){
+	if (frame)
+	{
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57,37,100)
 		int decode_ok = 0;
-		if ((avcodec_decode_video2(codecContext, frame, &decode_ok, &packet)) < 0 || !decode_ok){
+		if ((avcodec_decode_video2(codecContext, frame, &decode_ok, &packet)) < 0 || !decode_ok)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
@@ -251,25 +303,29 @@
 		ret = avcodec_send_packet(codecContext, &packet);
 		// In particular, we don't expect AVERROR(EAGAIN), because we read all
 		// decoded frames with avcodec_receive_frame() until done.
-		if (ret < 0) {
+		if (ret < 0)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
 		ret = avcodec_receive_frame(codecContext, frame);
-		if (ret < 0) {
+		if (ret < 0)
+		{
 			av_frame_free(&frame);
 			return -1;
 		}
 #endif
 		AVFrame *dest_frame = av_frame_alloc();
-		if(dest_frame){
-			dest_frame->height = (frame->height/2)*2;
-			dest_frame->width = (frame->width/2)*2;
+		if (dest_frame)
+		{
+			dest_frame->height = (frame->height / 2) * 2;
+			dest_frame->width = (frame->width / 2) * 2;
 			dest_frame->format = AV_PIX_FMT_YUV420P;
 			av_frame_get_buffer(dest_frame, 32);
 			struct SwsContext *convert = NULL;
 			convert = sws_getContext(frame->width, frame->height, (AVPixelFormat)frame->format, dest_frame->width, dest_frame->height, AV_PIX_FMT_YUVJ420P, SWS_FAST_BILINEAR, NULL, NULL, NULL);
-			if(convert){
+			if (convert)
+			{
 				sws_scale(convert, frame->data, frame->linesize, 0, frame->height, dest_frame->data, dest_frame->linesize);
 				sws_freeContext(convert);
 			}
@@ -282,19 +338,27 @@
 
 }
 
-AVCodecContext* open_codec(AVMediaType mediaType, AVFormatContext* formatContext)
+AVCodecContext *open_codec(AVMediaType mediaType, AVFormatContext *formatContext)
 {
-	AVCodec * codec = NULL;
-	AVCodecContext * codecContext = NULL;
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59,0,100)
+	AVCodec *codec = NULL;
+#else
+	const AVCodec *codec = NULL;
+#endif
+	AVCodecContext *codecContext = NULL;
 	int stream_index;
-#if (LIBAVFORMAT_VERSION_INT < AV_VERSION_INT( 57,25,101 ))
+#if LIBAVFORMAT_VERSION_INT < AV_VERSION_INT(57,25,101)
 	stream_index = av_find_best_stream(formatContext, mediaType, -1, -1, NULL, 0);
-	if (stream_index >=0 ){
+	if (stream_index >= 0)
+	{
 		codecContext = formatContext->streams[stream_index]->codec;
-		if(codecContext){
+		if (codecContext)
+		{
 			codec = avcodec_find_decoder(codecContext->codec_id);
-			if(codec){
-				if ((avcodec_open2(codecContext, codec, NULL)) != 0){
+			if (codec)
+			{
+				if ((avcodec_open2(codecContext, codec, NULL)) != 0)
+				{
 					return NULL;
 				}
 			}
@@ -304,13 +368,17 @@
 	return NULL;
 #else
 	stream_index = av_find_best_stream(formatContext, mediaType, -1, -1, &codec, 0);
-	if (stream_index >= 0) {
+	if (stream_index >= 0)
+	{
 		codec = avcodec_find_decoder(formatContext->streams[stream_index]->codecpar->codec_id);
-		if (codec) {
+		if (codec)
+		{
 			codecContext = avcodec_alloc_context3(codec);
 		}
-		if (codecContext) {
-			if ((avcodec_open2(codecContext, codec, NULL)) != 0) {
+		if (codecContext)
+		{
+			if ((avcodec_open2(codecContext, codec, NULL)) != 0)
+			{
 				return NULL;
 			}
 			return codecContext;
@@ -329,15 +397,20 @@
 #endif
 
 	AVFormatContext *formatContext = avformat_alloc_context();
-	if (formatContext && (ret = avformat_open_input(&formatContext, image_name, NULL, NULL)) == 0){
+	if (formatContext && (ret = avformat_open_input(&formatContext, image_name, NULL, NULL)) == 0)
+	{
 		AVCodecContext *codecContext = open_codec(AVMEDIA_TYPE_VIDEO, formatContext);
-		if(codecContext){
+		if (codecContext)
+		{
 			AVPacket packet;
 			av_init_packet(&packet);
-			if ((ret = av_read_frame(formatContext, &packet)) !=-1){
-				FILE* fp = fopen(encode_name, "wb");
-				if(fp){
-					if(decode_frame(codecContext, packet, fp) != 1){
+			if ((ret = av_read_frame(formatContext, &packet)) != -1)
+			{
+				FILE *fp = fopen(encode_name, "wb");
+				if (fp)
+				{
+					if (decode_frame(codecContext, packet, fp) != 1)
+					{
 						/* add sequence end code to have a real mpeg file */
 						uint8_t endcode[] = { 0, 0, 1, 0xb7 };
 						fwrite(endcode, 1, sizeof(endcode), fp);
@@ -347,7 +420,7 @@
 				av_packet_unref(&packet);
 			}
 			avcodec_close(codecContext);
-#if (LIBAVFORMAT_VERSION_INT > AV_VERSION_INT( 57,25,100 ))
+#if LIBAVFORMAT_VERSION_INT > AV_VERSION_INT(57,25,100)
 			avcodec_free_context(&codecContext);
 #endif
 		}
@@ -357,6 +430,20 @@
 	return 0;
 }
 
+void cVideo::setAVInput(int val)
+{
+	hal_info("%s not implemented yet - switching to: %s\n", __func__, val == AUX ? "SCART" : "ENCODER");
+#if 0 // not working
+	int input_fd = open("/proc/stb/avs/0/input", O_WRONLY);
+	if (input_fd)
+	{
+		const char *input[] = {"encoder", "scart"};
+		write(input_fd, input[val], strlen(input[val]));
+		close(input_fd);
+	}
+#endif
+}
+
 cVideo::cVideo(int, void *, void *, unsigned int unit)
 {
 	hal_debug("%s unit %u\n", __func__, unit);
@@ -368,10 +455,12 @@
 
 	scartvoltage = -1;
 	video_standby = 0;
-	if (unit > 1) {
+	if (unit > 1)
+	{
 		hal_info("%s: unit %d out of range, setting to 0\n", __func__, unit);
 		devnum = 0;
-	} else
+	}
+	else
 		devnum = unit;
 	fd = -1;
 	openDevice();
@@ -390,7 +479,7 @@
 	if (fd != -1) /* already open */
 		return;
 retry:
-	if ((fd = open(VDEV[devnum], O_RDWR|O_CLOEXEC)) < 0)
+	if ((fd = open(VDEV[devnum], O_RDWR | O_CLOEXEC)) < 0)
 	{
 		if (errno == EBUSY)
 		{
@@ -417,11 +506,11 @@
 
 int cVideo::setAspectRatio(int aspect, int mode)
 {
-	static const char *a[] = { "n/a", "4:3", "14:9", "16:9" };
+	static const char *a[] = { "n/a", "4:3", "16:9" };
 	static const char *m[] = { "panscan", "letterbox", "bestfit", "nonlinear", "(unset)" };
 	int n;
 
-	int mo = (mode < 0||mode > 3) ? 4 : mode;
+	int mo = (mode < 0 || mode > 3) ? 4 : mode;
 	hal_debug("%s: a:%d m:%d  %s\n", __func__, aspect, mode, m[mo]);
 
 	if (aspect > 3 || aspect == 0)
@@ -488,7 +577,8 @@
 		fop(ioctl, MPEG_VID_CONTINUE);
 #endif
 	/* implicitly do StopPicture() on video->Start() */
-	if (stillpicture) {
+	if (stillpicture)
+	{
 		hal_info("%s: stillpicture == true, doing implicit StopPicture()\n", __func__);
 		stillpicture = false;
 		Stop(1);
@@ -496,19 +586,23 @@
 	playstate = VIDEO_PLAYING;
 	fop(ioctl, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
 	int res = fop(ioctl, VIDEO_PLAY);
-	if (brightness > -1) {
+	if (brightness > -1)
+	{
 		SetControl(VIDEO_CONTROL_BRIGHTNESS, brightness);
 		brightness = -1;
 	}
-	if (contrast > -1) {
+	if (contrast > -1)
+	{
 		SetControl(VIDEO_CONTROL_CONTRAST, contrast);
 		contrast = -1;
 	}
-	if (saturation > -1) {
+	if (saturation > -1)
+	{
 		SetControl(VIDEO_CONTROL_SATURATION, saturation);
 		saturation = -1;
 	}
-	if (hue > -1) {
+	if (hue > -1)
+	{
 		SetControl(VIDEO_CONTROL_HUE, hue);
 		hue = -1;
 	}
@@ -561,7 +655,7 @@
 		stopped = true;
 	}
 	hdmi_out(false);
-	ret = proc_put("/proc/stb/video/videomode", vid_modes[video_system],strlen(vid_modes[video_system]));
+	ret = proc_put("/proc/stb/video/videomode", vid_modes[video_system], strlen(vid_modes[video_system]));
 	hdmi_out(true);
 	if (stopped)
 		Start();
@@ -586,10 +680,12 @@
 {
 	if (system == -1)
 		system = GetVideoSystem();
-	if (system < 0 || system > VIDEO_STD_1080P50) {
+	if (system < 0 || system > VIDEO_STD_1080P50)
+	{
 		hal_info("%s: invalid system %d\n", __func__, system);
 		strcpy(format->format, "invalid");
-	} else
+	}
+	else
 		strcpy(format->format, vid_modes[system]);
 }
 
@@ -598,33 +694,9 @@
 	return playstate;
 }
 
-void cVideo::SetVideoMode(analog_mode_t mode)
-{
-	hal_debug("#%d: %s(%d)\n", devnum, __func__, mode);
-	if (!(mode & ANALOG_SCART_MASK))
-	{
-		hal_debug("%s: non-SCART mode ignored\n", __func__);
-		return;
-	}
-	const char *m;
-	switch(mode)
-	{
-		case ANALOG_SD_YPRPB_SCART:
-			m = "yuv";
-			break;
-		case ANALOG_SD_RGB_SCART:
-			m = "rgb";
-			break;
-		default:
-			hal_info("%s unknown mode %d\n", __func__, mode);
-			m = "rgb";
-			break; /* default to rgb */
-	}
-	proc_put("/proc/stb/avs/0/colorformat", m, strlen(m));
-}
-
-void cVideo::ShowPicture(const char * fname, const char *_destname)
+bool cVideo::ShowPicture(const char *fname, const char *_destname)
 {
+	bool ret = false;
 	hal_debug("%s(%s)\n", __func__, fname);
 	//static const unsigned char pes_header[] = { 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x80, 0x00, 0x00 };
 	static const unsigned char pes_header[] = {0x0, 0x0, 0x1, 0xe0, 0x00, 0x00, 0x80, 0x80, 0x5, 0x21, 0x0, 0x1, 0x0, 0x1};
@@ -637,20 +709,29 @@
 	{
 		/* does not work and the driver does not seem to like it */
 		hal_info("%s: video_standby == true\n", __func__);
-		return;
+		return ret;
+	}
+	if (fd == -1)
+	{
+		/* in movieplayer mode, fd is not opened */
+		hal_info("%s: decoder not opened\n", __func__);
+		return ret;
 	}
+
 	const char *lastDot = strrchr(fname, '.');
 	if (lastDot && !strcasecmp(lastDot + 1, "m2v"))
 		strncpy(destname, fname, sizeof(destname));
-	else {
+	else
+	{
 		if (_destname)
 			strncpy(destname, _destname, sizeof(destname));
-		else {
+		else
+		{
 			strcpy(destname, "/tmp/cache");
 			if (stat(fname, &st2))
 			{
 				hal_info("%s: could not stat %s (%m)\n", __func__, fname);
-				return;
+				return ret;
 			}
 			mkdir(destname, 0755);
 			/* the cache filename is (example for /share/tuxbox/neutrino/icons/radiomode.jpg):
@@ -660,7 +741,7 @@
 			strcat(destname, fname);
 			p = &destname[strlen("/tmp/cache/")];
 			while ((p = strchr(p, '/')) != NULL)
-				*p = '.';
+				* p = '.';
 			strcat(destname, ".m2v");
 		}
 		/* ...then check if it exists already... */
@@ -692,7 +773,7 @@
 		if (ioctl(fd, VIDEO_SET_FORMAT, VIDEO_FORMAT_16_9) < 0)
 			hal_info("%s: VIDEO_SET_FORMAT failed (%m)\n", __func__);
 		bool seq_end_avail = false;
-		off_t pos=0;
+		off_t pos = 0;
 		unsigned char *iframe = (unsigned char *)malloc((st.st_size < 8192) ? 8192 : st.st_size);
 		if (! iframe)
 		{
@@ -704,7 +785,7 @@
 		ioctl(fd, VIDEO_PLAY);
 		ioctl(fd, VIDEO_CONTINUE);
 		ioctl(fd, VIDEO_CLEAR_BUFFER);
-		while (pos <= (st.st_size-4) && !(seq_end_avail = (!iframe[pos] && !iframe[pos+1] && iframe[pos+2] == 1 && iframe[pos+3] == 0xB7)))
+		while (pos <= (st.st_size - 4) && !(seq_end_avail = (!iframe[pos] && !iframe[pos + 1] && iframe[pos + 2] == 1 && iframe[pos + 3] == 0xB7)))
 			++pos;
 
 		if ((iframe[3] >> 4) != 0xE) // no pes header
@@ -716,10 +797,11 @@
 		write(fd, iframe, 8192);
 		ioctl(fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX);
 		free(iframe);
+		ret = true;
 	}
- out:
+out:
 	close(mfd);
-	return;
+	return ret;
 }
 
 void cVideo::StopPicture()
@@ -741,7 +823,7 @@
 	{
 		/* only enable HDMI output when coming from standby, not on
 		 * start. I have no idea why, but enabling it on startup leads
-		 * to strange locking problems of the framebuffer driver :-( */
+		 * to strange locking problems of the framebuffer driver :-(*/
 		if (!hdmi_enabled)
 		{
 			hdmi_out(true);
@@ -804,6 +886,13 @@
 #endif
 }
 
+void cVideo::ShowPig(int _x)
+{
+	char buffer[64];
+	sprintf(buffer, "%d", _x);
+	proc_put(VMPEG_visible[devnum], buffer, strlen(buffer));
+}
+
 void cVideo::Pig(int x, int y, int w, int h, int osd_w, int osd_h, int startx, int starty, int endx, int endy)
 {
 	char buffer[64];
@@ -911,7 +1000,8 @@
 
 int cVideo::SetStreamType(VIDEO_FORMAT type)
 {
-	static const char *VF[] = {
+	static const char *VF[] =
+	{
 		"VIDEO_FORMAT_MPEG2",
 		"VIDEO_FORMAT_MPEG4",
 		"VIDEO_FORMAT_VC1",
@@ -960,27 +1050,30 @@
 	hal_debug("#%d %s not implemented yet\n", devnum, __func__);
 }
 
-void cVideo::SetControl(int control, int value) {
+void cVideo::SetControl(int control, int value)
+{
 	const char *p = NULL;
-	switch (control) {
-	case VIDEO_CONTROL_BRIGHTNESS:
-		brightness = value;
-		p = "/proc/stb/video/plane/psi_brightness";
-		break;
-	case VIDEO_CONTROL_CONTRAST:
-		contrast = value;
-		p = "/proc/stb/video/plane/psi_contrast";
-		break;
-	case VIDEO_CONTROL_SATURATION:
-		saturation = value;
-		p = "/proc/stb/video/plane/psi_saturation";
-		break;
-	case VIDEO_CONTROL_HUE:
-		hue = value;
-		p = "/proc/stb/video/plane/psi_tint";
-		break;
+	switch (control)
+	{
+		case VIDEO_CONTROL_BRIGHTNESS:
+			brightness = value;
+			p = "/proc/stb/video/plane/psi_brightness";
+			break;
+		case VIDEO_CONTROL_CONTRAST:
+			contrast = value;
+			p = "/proc/stb/video/plane/psi_contrast";
+			break;
+		case VIDEO_CONTROL_SATURATION:
+			saturation = value;
+			p = "/proc/stb/video/plane/psi_saturation";
+			break;
+		case VIDEO_CONTROL_HUE:
+			hue = value;
+			p = "/proc/stb/video/plane/psi_tint";
+			break;
 	}
-	if (p) {
+	if (p)
+	{
 		char buf[20];
 		int len = snprintf(buf, sizeof(buf), "%d", value);
 		if (len < (int) sizeof(buf))
@@ -988,30 +1081,32 @@
 	}
 }
 
-void cVideo::SetColorFormat(COLOR_FORMAT color_format) {
+void cVideo::SetColorFormat(COLOR_FORMAT color_format)
+{
 	const char *p = NULL;
-	switch(color_format) {
-	case COLORFORMAT_RGB:
-		p = "rgb";
-		break;
-	case COLORFORMAT_YUV:
-		p = "yuv";
-		break;
-	case COLORFORMAT_CVBS:
-		p = "cvbs";
-		break;
-	case COLORFORMAT_SVIDEO:
-		p = "svideo";
-		break;
-	case COLORFORMAT_HDMI_RGB:
-		p = "hdmi_rgb";
-		break;
-	case COLORFORMAT_HDMI_YCBCR444:
-		p = "hdmi_yuv";
-		break;
-	case COLORFORMAT_HDMI_YCBCR422:
-		p = "hdmi_422";
-		break;
+	switch (color_format)
+	{
+		case COLORFORMAT_RGB:
+			p = "rgb";
+			break;
+		case COLORFORMAT_YUV:
+			p = "yuv";
+			break;
+		case COLORFORMAT_CVBS:
+			p = "cvbs";
+			break;
+		case COLORFORMAT_SVIDEO:
+			p = "svideo";
+			break;
+		case COLORFORMAT_HDMI_RGB:
+			p = "hdmi_rgb";
+			break;
+		case COLORFORMAT_HDMI_YCBCR444:
+			p = "hdmi_yuv";
+			break;
+		case COLORFORMAT_HDMI_YCBCR422:
+			p = "hdmi_422";
+			break;
 	}
 	if (p)
 		proc_put("/proc/stb/avs/0/colorformat", p, strlen(p));
@@ -1023,7 +1118,8 @@
  * and the patches for STi support from
  * https://github.com/Schischu/STLinux.BSP-Duckbox.git */
 /* static lookup tables for faster yuv2rgb conversion */
-static const uint32_t yuv2rgbtable_y[256] = {
+static const uint32_t yuv2rgbtable_y[256] =
+{
 	0xFFED5EA0, 0xFFEE88B6, 0xFFEFB2CC, 0xFFF0DCE2, 0xFFF206F8, 0xFFF3310E, 0xFFF45B24, 0xFFF5853A,
 	0xFFF6AF50, 0xFFF7D966, 0xFFF9037C, 0xFFFA2D92, 0xFFFB57A8, 0xFFFC81BE, 0xFFFDABD4, 0xFFFED5EA,
 	0x00000000, 0x00012A16, 0x0002542C, 0x00037E42, 0x0004A858, 0x0005D26E, 0x0006FC84, 0x0008269A,
@@ -1057,7 +1153,8 @@
 	0x0104D340, 0x0105FD56, 0x0107276C, 0x01085182, 0x01097B98, 0x010AA5AE, 0x010BCFC4, 0x010CF9DA,
 	0x010E23F0, 0x010F4E06, 0x0110781C, 0x0111A232, 0x0112CC48, 0x0113F65E, 0x01152074, 0x01164A8A
 };
-static const uint32_t yuv2rgbtable_ru[256] = {
+static const uint32_t yuv2rgbtable_ru[256] =
+{
 	0xFEFDA500, 0xFEFFA9B6, 0xFF01AE6C, 0xFF03B322, 0xFF05B7D8, 0xFF07BC8E, 0xFF09C144, 0xFF0BC5FA,
 	0xFF0DCAB0, 0xFF0FCF66, 0xFF11D41C, 0xFF13D8D2, 0xFF15DD88, 0xFF17E23E, 0xFF19E6F4, 0xFF1BEBAA,
 	0xFF1DF060, 0xFF1FF516, 0xFF21F9CC, 0xFF23FE82, 0xFF260338, 0xFF2807EE, 0xFF2A0CA4, 0xFF2C115A,
@@ -1091,7 +1188,8 @@
 	0x00E20FA0, 0x00E41456, 0x00E6190C, 0x00E81DC2, 0x00EA2278, 0x00EC272E, 0x00EE2BE4, 0x00F0309A,
 	0x00F23550, 0x00F43A06, 0x00F63EBC, 0x00F84372, 0x00FA4828, 0x00FC4CDE, 0x00FE5194, 0x00100564A
 };
-static const uint32_t yuv2rgbtable_gu[256] = {
+static const uint32_t yuv2rgbtable_gu[256] =
+{
 	0xFFCDD300, 0xFFCE375A, 0xFFCE9BB4, 0xFFCF000E, 0xFFCF6468, 0xFFCFC8C2, 0xFFD02D1C, 0xFFD09176,
 	0xFFD0F5D0, 0xFFD15A2A, 0xFFD1BE84, 0xFFD222DE, 0xFFD28738, 0xFFD2EB92, 0xFFD34FEC, 0xFFD3B446,
 	0xFFD418A0, 0xFFD47CFA, 0xFFD4E154, 0xFFD545AE, 0xFFD5AA08, 0xFFD60E62, 0xFFD672BC, 0xFFD6D716,
@@ -1125,7 +1223,8 @@
 	0x002BE760, 0x002C4BBA, 0x002CB014, 0x002D146E, 0x002D78C8, 0x002DDD22, 0x002E417C, 0x002EA5D6,
 	0x002F0A30, 0x002F6E8A, 0x002FD2E4, 0x0030373E, 0x00309B98, 0x0030FFF2, 0x0031644C, 0x0031C8A6
 };
-static const uint32_t yuv2rgbtable_gv[256] = {
+static const uint32_t yuv2rgbtable_gv[256] =
+{
 	0xFF97E900, 0xFF98B92E, 0xFF99895C, 0xFF9A598A, 0xFF9B29B8, 0xFF9BF9E6, 0xFF9CCA14, 0xFF9D9A42,
 	0xFF9E6A70, 0xFF9F3A9E, 0xFFA00ACC, 0xFFA0DAFA, 0xFFA1AB28, 0xFFA27B56, 0xFFA34B84, 0xFFA41BB2,
 	0xFFA4EBE0, 0xFFA5BC0E, 0xFFA68C3C, 0xFFA75C6A, 0xFFA82C98, 0xFFA8FCC6, 0xFFA9CCF4, 0xFFAA9D22,
@@ -1159,7 +1258,8 @@
 	0x005B1420, 0x005BE44E, 0x005CB47C, 0x005D84AA, 0x005E54D8, 0x005F2506, 0x005FF534, 0x0060C562,
 	0x00619590, 0x006265BE, 0x006335EC, 0x0064061A, 0x0064D648, 0x0065A676, 0x006676A4, 0x006746D2
 };
-static const uint32_t yuv2rgbtable_bv[256] = {
+static const uint32_t yuv2rgbtable_bv[256] =
+{
 	0xFF33A280, 0xFF353B3B, 0xFF36D3F6, 0xFF386CB1, 0xFF3A056C, 0xFF3B9E27, 0xFF3D36E2, 0xFF3ECF9D,
 	0xFF406858, 0xFF420113, 0xFF4399CE, 0xFF453289, 0xFF46CB44, 0xFF4863FF, 0xFF49FCBA, 0xFF4B9575,
 	0xFF4D2E30, 0xFF4EC6EB, 0xFF505FA6, 0xFF51F861, 0xFF53911C, 0xFF5529D7, 0xFF56C292, 0xFF585B4D,
@@ -1195,49 +1295,49 @@
 };
 
 #define OUT(x) \
-	out[OUTITER] = (uint8_t)*(decode_surface + x)&0xFF; \
-	OUTITER += OUTINC;
+    out[OUTITER] = (uint8_t)*(decode_surface + x)&0xFF; \
+    OUTITER += OUTINC;
 
 #define OUT4(x) \
-	OUT(x + 0x03); \
-	OUT(x + 0x02); \
-	OUT(x + 0x01); \
-	OUT(x + 0x00);
+    OUT(x + 0x03); \
+    OUT(x + 0x02); \
+    OUT(x + 0x01); \
+    OUT(x + 0x00);
 
 #define OUT8(x) \
-	OUT4(x + 0x04); \
-	OUT4(x + 0x00);
+    OUT4(x + 0x04); \
+    OUT4(x + 0x00);
 
 #define OUT_LU_16A(x) \
-	OUT8(x); \
-	OUT8(x + 0x40);
+    OUT8(x); \
+    OUT8(x + 0x40);
 
 #define OUT_CH_8A(x) \
-	OUT4(x); \
-	OUT4(x + 0x20);
+    OUT4(x); \
+    OUT4(x + 0x20);
 
 //pppppppppppppppp
 //x: macroblock address
 //l: line 0-15
 #define OUT_LU_16(x,l) \
-	OUT_LU_16A(x + (l/4) * 0x10 + (l%2) * 0x80 + ((l/2)%2?0x00:0x08));
+    OUT_LU_16A(x + (l/4) * 0x10 + (l%2) * 0x80 + ((l/2)%2?0x00:0x08));
 
 //pppppppp
 //x: macroblock address
 //l: line 0-7
 //b: 0=cr 1=cb
 #define OUT_CH_8(x,l,b) \
-	OUT_CH_8A(x + (l/4) * 0x10 + (l%2) * 0x40 + ((l/2)%2?0x00:0x08) + (b?0x04:0x00));
+    OUT_CH_8A(x + (l/4) * 0x10 + (l%2) * 0x40 + ((l/2)%2?0x00:0x08) + (b?0x04:0x00));
 
 //----
-#define CLAMP(x)	((x < 0) ? 0 : ((x > 255) ? 255 : x))
-#define SWAP(x,y)	{ x ^= y; y ^= x; x ^= y; }
+#define CLAMP(x)    ((x < 0) ? 0 : ((x > 255) ? 255 : x))
+#define SWAP(x,y)   { x ^= y; y ^= x; x ^= y; }
 
 /* TODO: aspect ratio correction and PIP */
-bool cVideo::GetScreenImage(unsigned char * &video, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
+bool cVideo::GetScreenImage(unsigned char*&video, int &xres, int &yres, bool get_video, bool get_osd, bool scale_to_video)
 {
 	hal_info("%s: get_video: %d get_osd: %d scale_to_video: %d\n",
-		 __func__, get_video, get_osd, scale_to_video);
+	    __func__, get_video, get_osd, scale_to_video);
 
 	int fbfd = -1, bpafd = -1;
 	int vid_x, vid_y, osd_x, osd_y, aspect;
@@ -1251,7 +1351,8 @@
 		hal_info("%s: WARNING, video != NULL?\n", __func__);
 
 	fbfd = open("/dev/fb0", O_RDWR);
-	if (fbfd < 0) {
+	if (fbfd < 0)
+	{
 		hal_info("%s: cannot open open /dev/fb0 (%m)\n", __func__);
 		return false;
 	}
@@ -1261,12 +1362,14 @@
 	if (ioctl(fbfd, FBIOGET_VSCREENINFO, &var_screeninfo) == -1)
 		hal_info("%s: FBIOGET_VSCREENINFO (%m)\n", __func__);
 
-	if (var_screeninfo.bits_per_pixel != 32) {
+	if (var_screeninfo.bits_per_pixel != 32)
+	{
 		hal_info("%s: only 32bit framebuffer supported.\n", __func__);
 		close(fbfd);
 		return false;
 	}
-	if (fix_screeninfo.line_length - (var_screeninfo.xres * 4) != 0) {
+	if (fix_screeninfo.line_length - (var_screeninfo.xres * 4) != 0)
+	{
 		hal_info("%s: framebuffer with offset not supported.\n", __func__);
 		close(fbfd);
 		return false;
@@ -1284,10 +1387,13 @@
 
 	if (get_video && get_osd)
 	{
-		if (scale_to_video) {
+		if (scale_to_video)
+		{
 			xres = vid_x;
 			yres = vid_y;
-		} else {
+		}
+		else
+		{
 			xres = osd_x;
 			yres = osd_y;
 		}
@@ -1335,7 +1441,7 @@
 		hal_info("%s: cannot open secondary bpamem device %s: %m\n", __func__, bpa_mem_device);
 		goto error_cleanup;
 	}
-	bpa = (uint8_t *)mmap(0, bpa_data.mem_size, PROT_WRITE|PROT_READ, MAP_SHARED, bpafd, 0);
+	bpa = (uint8_t *)mmap(0, bpa_data.mem_size, PROT_WRITE | PROT_READ, MAP_SHARED, bpafd, 0);
 	if (bpa == MAP_FAILED)
 	{
 		hal_info("%s: cannot map from bpamem: %m\n", __func__);
@@ -1376,19 +1482,22 @@
 			}
 			fclose(pipe);
 		}
-		if (vid_phys_addr == 0) {
+		if (vid_phys_addr == 0)
+		{
 			hal_info("%s: primary display pane not found in /proc/bpa2\n", __func__);
 		}
 
 		mfd = open("/dev/mem", O_RDWR | O_CLOEXEC);
-		if (mfd < 0) {
+		if (mfd < 0)
+		{
 			hal_info("%s: cannot open open /dev/mem (%m)\n", __func__);
 			goto error_cleanup;
 		}
 
 		hal_info("%s: Using bpa2 part LMI_VID - 0x%lx %lu\n", __func__, vid_phys_addr, vid_mem_size);
 		decode_surface = (uint8_t *)mmap(0, vid_mem_size, PROT_READ, MAP_SHARED, mfd, vid_phys_addr);
-		if (decode_surface == MAP_FAILED) {
+		if (decode_surface == MAP_FAILED)
+		{
 			hal_info("%s: cannot mmap /dev/mem for VIDEO (%m)\n", __func__);
 			close(mfd);
 			goto error_cleanup;
@@ -1457,21 +1566,21 @@
 		xblock = stride_half >> 3;/// 8; //no roundin
 
 		//if xblock is not even than we will have to move to the next even value an
-		yblockoffset = (((xblock + 1) >> 1 /* / 2*/) << 1 /* * 2*/ ) << 8 /* * 64=8x8px * 2=2 block rows * 2=cr cb*/;
+		yblockoffset = (((xblock + 1) >> 1 /* / 2*/) << 1 /* * 2*/) << 8 /* * 64=8x8px * 2=2 block rows * 2=cr cb*/;
 
 		OUTITER       = 0;
 		OUTITERoffset = 0;
 		OUTINC        = 2;
 		out           = chroma;
 
-		for(cr = 0; cr < 2; cr++)
+		for (cr = 0; cr < 2; cr++)
 		{
-			for(even = 0; even < 2; even++)
+			for (even = 0; even < 2; even++)
 			{
 				offset        = layer_offset + (even  << 8 /* * 0x100*/);
 				OUTITERoffset = even * (xblock << 7 /* * 128=8x8px * 2*/) + cr;
 
-				for (iyblock = even; iyblock < yblock; iyblock+=2)
+				for (iyblock = even; iyblock < yblock; iyblock += 2)
 				{
 					for (ixblock = 0; ixblock < xblock; ixblock++)
 					{
@@ -1485,7 +1594,7 @@
 						}
 
 						//0x00 0x80 0x200 0x280, ...
-						offset += (offset%0x100?0x180/*80->200*/:0x80/*0->80*/);
+						offset += (offset % 0x100 ? 0x180/*80->200*/ : 0x80/*0->80*/);
 						OUTITERoffset += 16/*OUTINC*8=16*/;
 					}
 					OUTITERoffset += (vid_x << 4) - vid_x /* * 15*/;
@@ -1503,7 +1612,7 @@
 		const int rgbstride = vid_x * 3;
 		const int scans = vid_y / 2;
 		int y;
-		for (y=0; y < scans; ++y)
+		for (y = 0; y < scans; ++y)
 		{
 			int x;
 			int out1 = y * rgbstride * 2;
@@ -1524,16 +1633,16 @@
 				int Y = yuv2rgbtable_y[luma[pos]];
 
 				//p0:0
-				vid[out1  ] = CLAMP((Y + RU)>>16);
-				vid[out1+1] = CLAMP((Y - GV - GU)>>16);
-				vid[out1+2] = CLAMP((Y + BV)>>16);
+				vid[out1  ] = CLAMP((Y + RU) >> 16);
+				vid[out1 + 1] = CLAMP((Y - GV - GU) >> 16);
+				vid[out1 + 2] = CLAMP((Y + BV) >> 16);
 
 				Y = yuv2rgbtable_y[luma[vid_x + pos]];
 
 				//p1:0
-				vid[out1  +rgbstride] = CLAMP((Y + RU)>>16);
-				vid[out1+1+rgbstride] = CLAMP((Y - GV - GU)>>16);
-				vid[out1+2+rgbstride] = CLAMP((Y + BV)>>16);
+				vid[out1  + rgbstride] = CLAMP((Y + RU) >> 16);
+				vid[out1 + 1 + rgbstride] = CLAMP((Y - GV - GU) >> 16);
+				vid[out1 + 2 + rgbstride] = CLAMP((Y + BV) >> 16);
 
 				out1 += 3;
 				pos++;
@@ -1541,16 +1650,16 @@
 				Y = yuv2rgbtable_y[luma[pos]];
 
 				//p0:1
-				vid[out1  ] = CLAMP((Y + RU)>>16);
-				vid[out1+1] = CLAMP((Y - GV - GU)>>16);
-				vid[out1+2] = CLAMP((Y + BV)>>16);
+				vid[out1  ] = CLAMP((Y + RU) >> 16);
+				vid[out1 + 1] = CLAMP((Y - GV - GU) >> 16);
+				vid[out1 + 2] = CLAMP((Y + BV) >> 16);
 
 				Y = yuv2rgbtable_y[luma[vid_x + pos]];
 
 				//p1:1
-				vid[out1  +rgbstride] = CLAMP((Y + RU)>>16);
-				vid[out1+1+rgbstride] = CLAMP((Y - GV - GU)>>16);
-				vid[out1+2+rgbstride] = CLAMP((Y + BV)>>16);
+				vid[out1  + rgbstride] = CLAMP((Y + RU) >> 16);
+				vid[out1 + 1 + rgbstride] = CLAMP((Y - GV - GU) >> 16);
+				vid[out1 + 2 + rgbstride] = CLAMP((Y + BV) >> 16);
 
 				out1 += 3;
 				pos++;
@@ -1563,8 +1672,9 @@
 		uint8_t *lfb = (uint8_t *)mmap(0, fix_screeninfo.smem_len, PROT_READ, MAP_SHARED, fbfd, 0);
 		if (lfb == MAP_FAILED)
 			hal_info("%s: mmap fb memory failed (%m)\n", __func__);
-		else {
-			memcpy(osd, lfb, fix_screeninfo.line_length*var_screeninfo.yres);
+		else
+		{
+			memcpy(osd, lfb, fix_screeninfo.line_length * var_screeninfo.yres);
 			munmap(lfb, fix_screeninfo.smem_len);
 		}
 	}
@@ -1578,7 +1688,8 @@
 		int pip_w = xres;
 		int pip_h = yres;
 		bool scale = false;
-		if (get_osd) {
+		if (get_osd)
+		{
 			pip_x = proc_get_hex("/proc/stb/vmpeg/0/dst_left");
 			pip_y = proc_get_hex("/proc/stb/vmpeg/0/dst_top");
 			pip_w = proc_get_hex("/proc/stb/vmpeg/0/dst_width");
@@ -1591,15 +1702,20 @@
 			pip_h = pip_h * yres / 576;
 			if (scale == false && aspect == 1)
 			{
-				pip_w = xres * 9/16*4/3;
+				pip_w = xres * 9 / 16 * 4 / 3;
 				pip_x = (xres - pip_w) / 2;
 			}
 		}
-		if (scale || aspect == 1) {
+		if (scale || aspect == 1)
+		{
 			/* todo: use the blitter, luke */
 			uint8_t *p = bpa - 1;
-			for (int i = 0; i < outmem; i += 4) {
-				*++p = 0; *++p = 0; *++p = 0; *++p = 0xff;
+			for (int i = 0; i < outmem; i += 4)
+			{
+				*++p = 0;
+				*++p = 0;
+				*++p = 0;
+				*++p = 0xff;
 			}
 		}
 
@@ -1632,7 +1748,7 @@
 		memset(&blt_data, 0, sizeof(STMFBIO_BLT_EXTERN_DATA));
 		blt_data.operation  = BLT_OP_COPY;
 		if (get_video)
-			blt_data.ulFlags    = BLT_OP_FLAGS_BLEND_SRC_ALPHA|BLT_OP_FLAGS_BLEND_DST_MEMORY;
+			blt_data.ulFlags    = BLT_OP_FLAGS_BLEND_SRC_ALPHA | BLT_OP_FLAGS_BLEND_DST_MEMORY;
 		else
 			blt_data.ulFlags    = 0;
 		blt_data.srcOffset  = 0;
@@ -1669,10 +1785,11 @@
 	close(fbfd);
 	return true;
 
- error_cleanup:
+error_cleanup:
 	if (bpa != MAP_FAILED)
 		munmap(bpa, bpa_data.mem_size);
-	if (bpafd > -1) {
+	if (bpafd > -1)
+	{
 		ioctl(bpafd, BPAMEMIO_FREEMEM);
 		close(bpafd);
 	}
diff -Nur libstb-hal-ddt.git.orig/libspark/video_lib.h libstb-hal-ddt.git/libspark/video_lib.h
--- libstb-hal-ddt.git.orig/libspark/video_lib.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libspark/video_lib.h	2022-07-23 18:18:31.543772226 +0200
@@ -10,20 +10,9 @@
 	char format[16];
 } cs_vs_format_struct_t;
 
-typedef enum {
-	ANALOG_SD_RGB_CINCH = 0x00,
-	ANALOG_SD_YPRPB_CINCH,
-	ANALOG_HD_RGB_CINCH,
-	ANALOG_HD_YPRPB_CINCH,
-	ANALOG_SD_RGB_SCART = 0x10,
-	ANALOG_SD_YPRPB_SCART,
-	ANALOG_HD_RGB_SCART,
-	ANALOG_HD_YPRPB_SCART,
-	ANALOG_SCART_MASK = 0x10
-} analog_mode_t;
-
-typedef enum {
-	COLORFORMAT_RGB = 0x10, // keep compatible with analog_mode_t
+typedef enum
+{
+	COLORFORMAT_RGB = 0x10,
 	COLORFORMAT_YUV,
 	COLORFORMAT_CVBS,
 	COLORFORMAT_SVIDEO,
@@ -32,7 +21,8 @@
 	COLORFORMAT_HDMI_YCBCR422
 } COLOR_FORMAT;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_FORMAT_MPEG2 = 0,
 	VIDEO_FORMAT_MPEG4_H264,
 	VIDEO_FORMAT_VC1,
@@ -43,16 +33,8 @@
 	VIDEO_FORMAT_AVS = 16
 } VIDEO_FORMAT;
 
-typedef enum {
-	VIDEO_SD = 0,
-	VIDEO_HD,
-	VIDEO_120x60i,
-	VIDEO_320x240i,
-	VIDEO_1440x800i,
-	VIDEO_360x288i
-} VIDEO_DEFINITION;
-
-typedef enum {
+typedef enum
+{
 	VIDEO_FRAME_RATE_23_976 = 0,
 	VIDEO_FRAME_RATE_24,
 	VIDEO_FRAME_RATE_25,
@@ -63,29 +45,24 @@
 	VIDEO_FRAME_RATE_60
 } VIDEO_FRAME_RATE;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_1_1,
 	DISPLAY_AR_4_3,
-	DISPLAY_AR_14_9,
 	DISPLAY_AR_16_9,
 	DISPLAY_AR_20_9,
 	DISPLAY_AR_RAW
 } DISPLAY_AR;
 
-typedef enum {
+typedef enum
+{
 	DISPLAY_AR_MODE_PANSCAN = 0,
 	DISPLAY_AR_MODE_LETTERBOX,
-	DISPLAY_AR_MODE_NONE,
-	DISPLAY_AR_MODE_PANSCAN2
+	DISPLAY_AR_MODE_NONE
 } DISPLAY_AR_MODE;
 
-typedef enum {
-	VIDEO_DB_DR_NEITHER = 0,
-	VIDEO_DB_ON,
-	VIDEO_DB_DR_BOTH
-} VIDEO_DB_DR;
-
-typedef enum {
+typedef enum
+{
 	VIDEO_PLAY_STILL = 0,
 	VIDEO_PLAY_CLIP,
 	VIDEO_PLAY_TRICK,
@@ -93,7 +70,8 @@
 	VIDEO_PLAY_MOTION_NO_SYNC
 } VIDEO_PLAY_MODE;
 
-typedef enum {
+typedef enum
+{
 	VIDEO_STD_NTSC,
 	VIDEO_STD_SECAM,
 	VIDEO_STD_PAL,
@@ -107,12 +85,13 @@
 	VIDEO_STD_1080P24,
 	VIDEO_STD_1080P25,
 	VIDEO_STD_AUTO,
-	VIDEO_STD_1080P50,	/* SPARK only */
+	VIDEO_STD_1080P50,  /* SPARK only */
 	VIDEO_STD_MAX
 } VIDEO_STD;
 
 /* not used, for dummy functions */
-typedef enum {
+typedef enum
+{
 	VIDEO_HDMI_CEC_MODE_OFF = 0,
 	VIDEO_HDMI_CEC_MODE_TUNER,
 	VIDEO_HDMI_CEC_MODE_RECORDER
@@ -128,11 +107,10 @@
 	VIDEO_CONTROL_MAX = VIDEO_CONTROL_SHARPNESS
 } VIDEO_CONTROL;
 
-
 class cVideo
 {
-	friend class cPlayback;
-	friend class cDemux;
+		friend class cPlayback;
+		friend class cDemux;
 	private:
 		/* video device */
 		int fd;
@@ -145,11 +123,9 @@
 		int scartvoltage;
 
 		VIDEO_FORMAT StreamType;
-		VIDEO_DEFINITION VideoDefinition;
 		DISPLAY_AR DisplayAR;
 		VIDEO_PLAY_MODE SyncMode;
 		DISPLAY_AR_MODE ARMode;
-		VIDEO_DB_DR eDbDr;
 		DISPLAY_AR PictureAR;
 		VIDEO_FRAME_RATE FrameRate;
 		int video_standby;
@@ -157,6 +133,7 @@
 
 		int brightness, contrast, saturation, hue;
 
+		/* used internally by playback */
 		void openDevice(void);
 		void closeDevice(void);
 	public:
@@ -164,8 +141,25 @@
 		cVideo(int mode, void *, void *, unsigned int unit = 0);
 		~cVideo(void);
 
-		void * GetTVEnc() { return NULL; };
-		void * GetTVEncSD() { return NULL; };
+		void open_AVInput_Device(void)
+		{
+			return;
+		}; // Dummy
+		void close_AVInput_Device(void)
+		{
+			return;
+		};    // Dummy
+
+		void setAVInput(int val);
+
+		void *GetTVEnc()
+		{
+			return NULL;
+		};
+		void *GetTVEncSD()
+		{
+			return NULL;
+		};
 
 		/* aspect ratio */
 		int getAspectRatio(void);
@@ -190,33 +184,56 @@
 		/* get video system infos */
 		int GetVideoSystem(void);
 		/* when system = -1 then use current video system */
-		void GetVideoSystemFormatName(cs_vs_format_t* format, int system = -1);
+		void GetVideoSystemFormatName(cs_vs_format_t *format, int system = -1);
 
 		/* set video_system */
 		int SetVideoSystem(int video_system, bool remember = true);
 		int SetStreamType(VIDEO_FORMAT type);
 		void SetSyncMode(AVSYNC_TYPE mode);
-		bool SetCECMode(VIDEO_HDMI_CEC_MODE) { return true; };
-		void SetCECAutoView(bool) { return; };
-		void SetCECAutoStandby(bool) { return; };
-		void ShowPicture(const char * fname, const char *_destname = NULL);
+		bool SetCECMode(VIDEO_HDMI_CEC_MODE)
+		{
+			return true;
+		};
+		void SetCECAutoView(bool)
+		{
+			return;
+		};
+		void SetCECAutoStandby(bool)
+		{
+			return;
+		};
+		bool ShowPicture(const char *fname, const char *_destname = NULL);
 		void StopPicture();
 		void Standby(unsigned int bOn);
+		void ShowPig(int _x);
 		void Pig(int x, int y, int w, int h, int osd_w = 1064, int osd_h = 600, int startx = 0, int starty = 0, int endx = 1279, int endy = 719);
 		void SetControl(int, int);
 		void VideoParamWatchdog(void);
 		void setContrast(int val);
-		void SetVideoMode(analog_mode_t mode);
-		void SetDBDR(int) { return; };
-		void SetAudioHandle(void *) { return; };
-		void SetAutoModes(int [VIDEO_STD_MAX]) { return; };
-		int  OpenVBI(int) { return 0; };
-		int  CloseVBI(void) { return 0; };
-		int  StartVBI(unsigned short) { return 0; };
-		int  StopVBI(void) { return 0; };
+
+		void SetAudioHandle(void *)
+		{
+			return;
+		};
+		int  OpenVBI(int)
+		{
+			return 0;
+		};
+		int  CloseVBI(void)
+		{
+			return 0;
+		};
+		int  StartVBI(unsigned short)
+		{
+			return 0;
+		};
+		int  StopVBI(void)
+		{
+			return 0;
+		};
 		void SetDemux(cDemux *dmx);
 		void SetColorFormat(COLOR_FORMAT color_format);
-		bool GetScreenImage(unsigned char * &data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
+		bool GetScreenImage(unsigned char*&data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
 };
 
 #endif // __VIDEO_LIB_H__
diff -Nur libstb-hal-ddt.git.orig/libtest.cpp libstb-hal-ddt.git/libtest.cpp
--- libstb-hal-ddt.git.orig/libtest.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtest.cpp	2022-07-23 18:18:31.543772226 +0200
@@ -16,18 +16,19 @@
 #define fb_pixel_t uint32_t
 #endif
 
-int main(int argc __attribute__((unused)), char ** argv __attribute__((unused)))
+int main(int argc __attribute__((unused)), char **argv __attribute__((unused)))
 {
 	hal_api_init();
 #if HAVE_GENERIC_HARDWARE
 	int available = glfb->getOSDBuffer()->size(); /* allocated in glfb constructor */
-	fb_pixel_t *lfb = reinterpret_cast<fb_pixel_t*>(glfb->getOSDBuffer()->data());
+	fb_pixel_t *lfb = reinterpret_cast<fb_pixel_t *>(glfb->getOSDBuffer()->data());
 
 	int x = 0;
 #endif
-	while (1) {
+	while (1)
+	{
 #if HAVE_GENERIC_HARDWARE
-		fb_pixel_t c = (0xff << (8 * x))|0xff000000;
+		fb_pixel_t c = (0xff << (8 * x)) | 0xff000000;
 		x++;
 		if (x > 3) x = 0;
 		for (int i = 0; i < available / 4; i++)
diff -Nur libstb-hal-ddt.git.orig/libtriple/audio_td.cpp libstb-hal-ddt.git/libtriple/audio_td.cpp
--- libstb-hal-ddt.git.orig/libtriple/audio_td.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/audio_td.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,414 +0,0 @@
-#include <cstdio>
-#include <cstdlib>
-#include <sys/fcntl.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-
-
-#include <hardware/tddevices.h>
-#include <avs/avs_inf.h>
-#define AUDIO_DEVICE "/dev/" DEVICE_NAME_AUDIO
-#include "audio_td.h"
-#include "hal_debug.h"
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_AUDIO, this, args)
-#define hal_info(args...) _hal_info(HAL_DEBUG_AUDIO, this, args)
-
-#include <linux/soundcard.h>
-
-cAudio * audioDecoder = NULL;
-
-cAudio::cAudio(void *, void *, void *)
-{
-	fd = -1;
-	clipfd = -1;
-	mixer_fd = -1;
-	openDevice();
-	Muted = false;
-}
-
-cAudio::~cAudio(void)
-{
-	closeDevice();
-}
-
-void cAudio::openDevice(void)
-{
-	if (fd < 0)
-	{
-		if ((fd = open(AUDIO_DEVICE, O_RDWR)) < 0)
-			hal_info("openDevice: open failed (%m)\n");
-		fcntl(fd, F_SETFD, FD_CLOEXEC);
-		do_mute(true, false);
-	}
-	else
-		hal_info("openDevice: already open (fd = %d)\n", fd);
-}
-
-void cAudio::closeDevice(void)
-{
-	if (fd >= 0)
-		close(fd);
-	fd = -1;
-	if (clipfd >= 0)
-		close(clipfd);
-	clipfd = -1;
-	if (mixer_fd >= 0)
-		close(mixer_fd);
-	mixer_fd = -1;
-}
-
-int cAudio::do_mute(bool enable, bool remember)
-{
-	hal_debug("%s(%d, %d)\n", __FUNCTION__, enable, remember);
-	int avsfd;
-	int ret;
-	if (remember)
-		Muted = enable;
-	ret = ioctl(fd, MPEG_AUD_SET_MUTE, enable);
-	if (ret < 0)
-		hal_info("%s(%d) failed (%m)\n", __FUNCTION__, (int)enable);
-
-	/* are we using alternative DSP / mixer? */
-	if (clipfd != -1 || mixer_fd != -1)
-		setVolume(volume,volume); /* considers "Muted" variable, "remember"
-					     is basically always true in this context */
-	avsfd = open("/dev/stb/tdsystem", O_RDONLY);
-	if (avsfd >= 0)
-	{
-		if (enable)
-			ioctl(avsfd, IOC_AVS_SET_VOLUME, 31);
-		else
-			ioctl(avsfd, IOC_AVS_SET_VOLUME, 0);
-		close(avsfd);
-	}
-	return ret;
-}
-
-int map_volume(const int volume)
-{
-	unsigned char vol = volume;
-	if (vol > 100)
-		vol = 100;
-
-//	vol = (invlog63[volume] + 1) / 2;
-	vol = 31 - vol * 31 / 100;
-	return vol;
-}
-
-int cAudio::setVolume(unsigned int left, unsigned int right)
-{
-//	int avsfd;
-	int ret;
-	int vl = map_volume(left);
-	int vr = map_volume(right);
-	volume = (left + right) / 2;
-	int v = map_volume(volume);
-	if (clipfd != -1 && mixer_fd != -1) {
-		int tmp = 0;
-		/* not sure if left / right is correct here, but it is always the same anyways ;-) */
-		if (! Muted)
-			tmp = left << 8 | right;
-		ret = ioctl(mixer_fd, MIXER_WRITE(mixer_num), &tmp);
-		if (ret == -1)
-			hal_info("%s: MIXER_WRITE(%d),%04x: %m\n", __func__, mixer_num, tmp);
-		return ret;
-	}
-//	if (settings.volume_type == CControld::TYPE_OST || forcetype == (int)CControld::TYPE_OST)
-	{
-		AUDVOL vol;
-		vol.frontleft  = vl;
-		vol.frontright = vr;
-		vol.rearleft   = vl;
-		vol.rearright  = vr;
-		vol.center     = v;
-		vol.lfe        = v;
-		ret = ioctl(fd, MPEG_AUD_SET_VOL, &vol);
-		if (ret < 0)
-			hal_info("setVolume MPEG_AUD_SET_VOL failed (%m)\n");
-		return ret;
-	}
-#if 0
-	else if (settings.volume_type == CControld::TYPE_AVS || forcetype == (int)CControld::TYPE_AVS)
-	{
-		if ((avsfd = open(AVS_DEVICE, O_RDWR)) < 0)
-			perror("[controld] " AVS_DEVICE);
-		else {
-			if (ioctl(avsfd, IOC_AVS_SET_VOLUME, v))
-				perror("[controld] IOC_AVS_SET_VOLUME");
-			close(avsfd);
-			return 0;
-		}
-	}
-	fprintf(stderr, "CAudio::setVolume: invalid settings.volume_type = %d\n", settings.volume_type);
-	return -1;
-#endif
-}
-
-int cAudio::Start(void)
-{
-	int ret;
-	ret = ioctl(fd, MPEG_AUD_PLAY);
-	/* this seems to be not strictly necessary since neutrino
-	   re-mutes all the time, but is certainly more correct */
-	ioctl(fd, MPEG_AUD_SET_MUTE, Muted);
-	return ret;
-}
-
-int cAudio::Stop(void)
-{
-	return ioctl(fd, MPEG_AUD_STOP);
-}
-
-bool cAudio::Pause(bool /*Pcm*/)
-{
-	return true;
-};
-
-void cAudio::SetSyncMode(AVSYNC_TYPE Mode)
-{
-	hal_debug("%s %d\n", __FUNCTION__, Mode);
-	switch (Mode)
-	{
-		case 0:
-			ioctl(fd, MPEG_AUD_SYNC_OFF);
-			break;
-		default:
-			ioctl(fd, MPEG_AUD_SYNC_ON);
-			break;
-	}
-};
-
-void cAudio::SetStreamType(AUDIO_FORMAT type)
-{
-	int bypass_disable;
-	hal_debug("%s %d\n", __FUNCTION__, type);
-	StreamType = type;
-
-	if (StreamType != AUDIO_FMT_DOLBY_DIGITAL && StreamType != AUDIO_FMT_MPEG && StreamType != AUDIO_FMT_MPG1)
-		hal_info("%s unhandled AUDIO_FORMAT %d\n", __FUNCTION__, StreamType);
-
-	bypass_disable = (StreamType != AUDIO_FMT_DOLBY_DIGITAL);
-	setBypassMode(bypass_disable);
-
-	if (StreamType == AUDIO_FMT_MPEG)
-		ioctl(fd, MPEG_AUD_SET_STREAM_TYPE, AUD_STREAM_TYPE_PES);
-	if (StreamType == AUDIO_FMT_MPG1)
-		ioctl(fd, MPEG_AUD_SET_STREAM_TYPE, AUD_STREAM_TYPE_MPEG1);
-};
-
-int cAudio::setChannel(int channel)
-{
-	hal_debug("%s %d\n", __FUNCTION__, channel);
-	return 0;
-};
-
-int cAudio::PrepareClipPlay(int ch, int srate, int bits, int little_endian)
-{
-	int fmt;
-	unsigned int devmask, stereo, usable;
-	const char *dsp_dev = getenv("DSP_DEVICE");
-	const char *mix_dev = getenv("MIX_DEVICE");
-	hal_debug("%s ch %d srate %d bits %d le %d\n", __FUNCTION__, ch, srate, bits, little_endian);
-	if (clipfd >= 0) {
-		hal_info("%s: clipfd already opened (%d)\n", __FUNCTION__, clipfd);
-		return -1;
-	}
-	mixer_num = -1;
-	mixer_fd = -1;
-	/* a different DSP device can be given with DSP_DEVICE and MIX_DEVICE
-	 * if this device cannot be opened, we fall back to the internal TD OSS device
-	 * Example:
-	 *   modprobe ohci-hcd
-	 *   modprobe audio
-	 *   export DSP_DEVICE=/dev/sound/dsp1
-	 *   export MIX_DEVICE=/dev/sound/mixer1
-	 *   neutrino
-	 */
-	if ((!dsp_dev) || (access(dsp_dev, W_OK))) {
-		if (dsp_dev)
-			hal_info("%s: DSP_DEVICE is set (%s) but cannot be opened,"
-				" fall back to /dev/sound/dsp\n", __func__, dsp_dev);
-		dsp_dev = "/dev/sound/dsp";
-	}
-	hal_info("%s: dsp_dev %s mix_dev %s\n", __func__, dsp_dev, mix_dev); /* NULL mix_dev is ok */
-	/* the tdoss dsp driver seems to work only on the second open(). really. */
-	clipfd = open(dsp_dev, O_WRONLY);
-	close(clipfd);
-	clipfd = open(dsp_dev, O_WRONLY);
-	if (clipfd < 0) {
-		hal_info("%s open %s: %m\n", dsp_dev, __FUNCTION__);
-		return -1;
-	}
-	fcntl(clipfd, F_SETFD, FD_CLOEXEC);
-	/* no idea if we ever get little_endian == 0 */
-	if (little_endian)
-		fmt = AFMT_S16_BE;
-	else
-		fmt = AFMT_S16_LE;
-	if (ioctl(clipfd, SNDCTL_DSP_SETFMT, &fmt))
-		perror("SNDCTL_DSP_SETFMT");
-	if (ioctl(clipfd, SNDCTL_DSP_CHANNELS, &ch))
-		perror("SNDCTL_DSP_CHANNELS");
-	if (ioctl(clipfd, SNDCTL_DSP_SPEED, &srate))
-		perror("SNDCTL_DSP_SPEED");
-	if (ioctl(clipfd, SNDCTL_DSP_RESET))
-		perror("SNDCTL_DSP_RESET");
-
-	if (!mix_dev)
-		return 0;
-
-	mixer_fd = open(mix_dev, O_RDWR);
-	if (mixer_fd < 0) {
-		hal_info("%s: open mixer %s failed (%m)\n", __func__, mix_dev);
-		/* not a real error */
-		return 0;
-	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_DEVMASK, &devmask) == -1) {
-		hal_info("%s: SOUND_MIXER_READ_DEVMASK %m\n", __func__);
-		devmask = 0;
-	}
-	if (ioctl(mixer_fd, SOUND_MIXER_READ_STEREODEVS, &stereo) == -1) {
-		hal_info("%s: SOUND_MIXER_READ_STEREODEVS %m\n", __func__);
-		stereo = 0;
-	}
-	usable = devmask & stereo;
-	if (usable == 0) {
-		hal_info("%s: devmask: %08x stereo: %08x, no usable dev :-(\n",
-			__func__, devmask, stereo);
-		close(mixer_fd);
-		mixer_fd = -1;
-		return 0; /* TODO: should we treat this as error? */
-	}
-	/* __builtin_popcount needs GCC, it counts the set bits... */
-	if (__builtin_popcount (usable) != 1) {
-		/* TODO: this code is not yet tested as I have only single-mixer devices... */
-		hal_info("%s: more than one mixer control: devmask %08x stereo %08x\n"
-			"%s: querying MIX_NUMBER environment variable...\n",
-			__func__, devmask, stereo, __func__);
-		const char *tmp = getenv("MIX_NUMBER");
-		if (tmp)
-			mixer_num = atoi(tmp);
-		hal_info("%s: mixer_num is %d -> device %08x\n",
-			__func__, (mixer_num >= 0) ? (1 << mixer_num) : 0);
-		/* no error checking, you'd better know what you are doing... */
-	} else {
-		mixer_num = 0;
-		while (!(usable & 0x01)) {
-			mixer_num++;
-			usable >>= 1;
-		}
-	}
-	setVolume(volume, volume);
-
-	return 0;
-};
-
-int cAudio::WriteClip(unsigned char *buffer, int size)
-{
-	int ret;
-	// hal_debug("cAudio::%s\n", __FUNCTION__);
-	if (clipfd <= 0) {
-		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
-		return -1;
-	}
-	ret = write(clipfd, buffer, size);
-	if (ret < 0)
-		hal_info("%s: write error (%m)\n", __FUNCTION__);
-	return ret;
-};
-
-int cAudio::StopClip()
-{
-	hal_debug("%s\n", __FUNCTION__);
-	if (clipfd <= 0) {
-		hal_info("%s: clipfd not yet opened\n", __FUNCTION__);
-		return -1;
-	}
-	close(clipfd);
-	clipfd = -1;
-	if (mixer_fd >= 0)
-		close(mixer_fd);
-	mixer_fd = -1;
-	setVolume(volume, volume);
-	return 0;
-};
-
-void cAudio::getAudioInfo(int &type, int &layer, int &freq, int &bitrate, int &mode)
-{
-	hal_debug("%s\n", __FUNCTION__);
-	unsigned int atype;
-	static const int freq_mpg[] = {44100, 48000, 32000, 0};
-	static const int freq_ac3[] = {48000, 44100, 32000, 0};
-	scratchl2 i;
-	if (ioctl(fd, MPEG_AUD_GET_DECTYP, &atype) < 0)
-		perror("cAudio::getAudioInfo MPEG_AUD_GET_DECTYP");
-	if (ioctl(fd, MPEG_AUD_GET_STATUS, &i) < 0)
-		perror("cAudio::getAudioInfo MPEG_AUD_GET_STATUS");
-
-	type = atype;
-#if 0
-/* this does not work, some of the values are negative?? */
-	AMPEGStatus A;
-	memcpy(&A, &i.word00, sizeof(i.word00));
-	layer   = A.audio_mpeg_layer;
-	mode    = A.audio_mpeg_mode;
-	bitrate = A.audio_mpeg_bitrate;
-	switch(A.audio_mpeg_frequency)
-#endif
-	/* layer and bitrate are not used anyway... */
-	layer   = 0; //(i.word00 >> 17) & 3;
-	bitrate = 0; //(i.word00 >> 12) & 3;
-	switch (type)
-	{
-		case 0:	/* MPEG */
-			mode = (i.word00 >> 6) & 3;
-			freq = freq_mpg[(i.word00 >> 10) & 3];
-			break;
-		case 1:	/* AC3 */
-			mode = (i.word00 >> 28) & 7;
-			freq = freq_ac3[(i.word00 >> 16) & 3];
-			break;
-		default:
-			mode = 0;
-			freq = 0;
-	}
-	//fprintf(stderr, "type: %d layer: %d freq: %d bitrate: %d mode: %d\n", type, layer, freq, bitrate, mode);
-};
-
-void cAudio::SetSRS(int /*iq_enable*/, int /*nmgr_enable*/, int /*iq_mode*/, int /*iq_level*/)
-{
-	hal_debug("%s\n", __FUNCTION__);
-};
-
-void cAudio::SetSpdifDD(bool enable)
-{
-	hal_debug("%s %d\n", __FUNCTION__, enable);
-};
-
-void cAudio::ScheduleMute(bool On)
-{
-	hal_debug("%s %d\n", __FUNCTION__, On);
-};
-
-void cAudio::EnableAnalogOut(bool enable)
-{
-	hal_debug("%s %d\n", __FUNCTION__, enable);
-};
-
-void cAudio::setBypassMode(bool disable)
-{
-	hal_debug("%s %d\n", __FUNCTION__, disable);
-	/* disable = true: audio is MPEG, disable = false: audio is AC3 */
-	if (disable)
-	{
-		ioctl(fd, MPEG_AUD_SET_MODE, AUD_MODE_MPEG);
-		return;
-	}
-	/* dvb2001 does always set AUD_MODE_DTS before setting AUD_MODE_AC3,
-	   this might be some workaround, so we do the same... */
-	ioctl(fd, MPEG_AUD_SET_MODE, AUD_MODE_DTS);
-	ioctl(fd, MPEG_AUD_SET_MODE, AUD_MODE_AC3);
-	return;
-	/* all those ioctl aways return "invalid argument", but they seem to
-	   work anyway, so there's no use in checking the return value */
-}
diff -Nur libstb-hal-ddt.git.orig/libtriple/audio_td.h libstb-hal-ddt.git/libtriple/audio_td.h
--- libstb-hal-ddt.git.orig/libtriple/audio_td.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/audio_td.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-/* public header file */
-
-#ifndef __AUDIO_TD_H__
-#define __AUDIO_TD_H__
-
-#include <hardware/aud/aud_inf.h>
-#include "cs_types.h"
-
-typedef enum
-{
-  AUDIO_SYNC_WITH_PTS,
-  AUDIO_NO_SYNC,
-  AUDIO_SYNC_AUDIO_MASTER
-} AUDIO_SYNC_MODE;
-
-typedef enum {
-	HDMI_ENCODED_OFF,
-	HDMI_ENCODED_AUTO,
-	HDMI_ENCODED_FORCED
-} HDMI_ENCODED_MODE;
-
-typedef enum
-{
-   AUDIO_FMT_AUTO = 0,
-   AUDIO_FMT_MPEG,
-   AUDIO_FMT_MP3,
-   AUDIO_FMT_DOLBY_DIGITAL,
-   AUDIO_FMT_BASIC = AUDIO_FMT_DOLBY_DIGITAL,
-   AUDIO_FMT_AAC,
-   AUDIO_FMT_AAC_PLUS,
-   AUDIO_FMT_DD_PLUS,
-   AUDIO_FMT_DTS,
-   AUDIO_FMT_AVS,
-   AUDIO_FMT_MLP,
-   AUDIO_FMT_WMA,
-   AUDIO_FMT_MPG1, // TD only. For Movieplayer / cPlayback
-   AUDIO_FMT_ADVANCED = AUDIO_FMT_MLP
-} AUDIO_FORMAT;
-
-class cAudio
-{
-	friend class cPlayback;
-	private:
-		int fd;
-		bool Muted;
-
-		int clipfd; /* for pcm playback */
-		int mixer_fd;  /* if we are using the OSS mixer */
-		int mixer_num; /* oss mixer to use, if any */
-
-		AUDIO_FORMAT	StreamType;
-		AUDIO_SYNC_MODE    SyncMode;
-		bool started;
-
-		int volume;
-
-		void openDevice(void);
-		void closeDevice(void);
-
-		int do_mute(bool enable, bool remember);
-		void setBypassMode(bool disable);
-	public:
-		/* construct & destruct */
-		cAudio(void *, void *, void *);
-		~cAudio(void);
-
-		void *GetHandle() { return NULL; };
-		/* shut up */
-		int mute(bool remember = true) { return do_mute(true, remember); };
-		int unmute(bool remember = true) { return do_mute(false, remember); };
-
-		/* volume, min = 0, max = 255 */
-		int setVolume(unsigned int left, unsigned int right);
-		int getVolume(void) { return volume;}
-		bool getMuteStatus(void) { return Muted; };
-
-		/* start and stop audio */
-		int Start(void);
-		int Stop(void);
-		bool Pause(bool Pcm = true);
-		void SetStreamType(AUDIO_FORMAT type);
-		void SetSyncMode(AVSYNC_TYPE Mode);
-
-		/* select channels */
-		int setChannel(int channel);
-		int PrepareClipPlay(int uNoOfChannels, int uSampleRate, int uBitsPerSample, int bLittleEndian);
-		int WriteClip(unsigned char * buffer, int size);
-		int StopClip();
-		void getAudioInfo(int &type, int &layer, int& freq, int &bitrate, int &mode);
-		void SetSRS(int iq_enable, int nmgr_enable, int iq_mode, int iq_level);
-		bool IsHdmiDDSupported() { return false; };
-		void SetHdmiDD(bool) { return; };
-		void SetSpdifDD(bool enable);
-		void ScheduleMute(bool On);
-		void EnableAnalogOut(bool enable);
-};
-
-#endif // __AUDIO_TD_H__
diff -Nur libstb-hal-ddt.git.orig/libtriple/dmx_td.cpp libstb-hal-ddt.git/libtriple/dmx_td.cpp
--- libstb-hal-ddt.git.orig/libtriple/dmx_td.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/dmx_td.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,654 +0,0 @@
-/*
- * cDemux implementation for the Tripledragon dbs3000 receiver
- *
- * (C) 2010-2013 Stefan Seyfried
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <config.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <poll.h>
-#include <sys/ioctl.h>
-#include <errno.h>
-#include <inttypes.h>
-#include <unistd.h>
-
-#include <cstring>
-#include <cstdio>
-#include <string>
-#include <hardware/tddevices.h>
-#include "dmx_hal.h"
-#include "hal_debug.h"
-
-/* Ugh... see comment in destructor for details... */
-#include "video_td.h"
-extern cVideo *videoDecoder;
-
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_DEMUX, this, args)
-#define hal_info(args...) _hal_info(HAL_DEBUG_DEMUX, this, args)
-
-#define dmx_err(_errfmt, _errstr, _revents) do { \
-	hal_info("%s " _errfmt " fd:%d, ev:0x%x %s pid:0x%04hx flt:0x%02hx\n", \
-		__func__, _errstr, fd, _revents, DMX_T[dmx_type], pid, flt); \
-} while(0);
-
-cDemux *videoDemux = NULL;
-cDemux *audioDemux = NULL;
-//cDemux *pcrDemux = NULL;
-
-static const char *DMX_T[] = {
-	"DMX_INVALID",
-	"DMX_VIDEO",
-	"DMX_AUDIO",
-	"DMX_PES",
-	"DMX_PSI",
-	"DMX_PIP",
-	"DMX_TP",
-	"DMX_PCR"
-};
-
-/* map the device numbers as used to the TD devices */
-static const char *devname[] = {
-	"/dev/" DEVICE_NAME_DEMUX "0",
-	"/dev/" DEVICE_NAME_DEMUX "1",
-	"/dev/" DEVICE_NAME_DEMUX "2",
-};
-
-/* uuuugly */
-static int dmx_tp_count = 0;
-#define MAX_TS_COUNT 1
-
-typedef struct dmx_pdata {
-	bool measure;
-	int last_measure;
-	int last_data;
-	int devnum;
-	bool running;
-} dmx_pdata;
-#define P ((dmx_pdata *)pdata)
-
-cDemux::cDemux(int n)
-{
-	if (n < 0 || n > 2)
-	{
-		hal_info("%s ERROR: n invalid (%d)\n", __FUNCTION__, n);
-		num = 0;
-	}
-	else
-		num = n;
-	fd = -1;
-	pdata = calloc(1, sizeof(dmx_pdata));
-	P->measure = false;
-	P->last_measure = 0;
-	P->last_data = 0;
-	P->running = false;
-}
-
-cDemux::~cDemux()
-{
-	hal_debug("%s #%d fd: %d\n", __FUNCTION__, num, fd);
-	Close();
-	free(pdata);
-	pdata = NULL;
-}
-
-bool cDemux::Open(DMX_CHANNEL_TYPE pes_type, void * /*hVideoBuffer*/, int uBufferSize)
-{
-	P->devnum = num;
-	int flags = O_RDWR;
-	if (fd > -1)
-		hal_info("%s FD ALREADY OPENED? fd = %d\n", __FUNCTION__, fd);
-	if (pes_type == DMX_TP_CHANNEL)
-	{
-		/* see neutrino's src/gui/streaminfo2.cpp for the buffer size */
-		if (num == 0 && uBufferSize == 3 * 3008 * 62) /* streaminfo measurement, let's cheat... */
-		{
-			hal_info("%s num=0 and DMX_TP_CHANNEL => measurement demux\n", __func__);
-			P->devnum = 2; /* demux 0 is used for live, demux 1 for recording */
-			P->measure = true;
-			P->last_measure = 0;
-			P->last_data = 0;
-			flags |= O_NONBLOCK;
-		}
-		else
-		{
-			/* it looks like the drivers can only do one TS at a time */
-			if (dmx_tp_count >= MAX_TS_COUNT)
-			{
-				hal_info("%s too many DMX_TP_CHANNEL requests :-(\n", __FUNCTION__);
-				dmx_type = DMX_INVALID;
-				fd = -1;
-				return false;
-			}
-			dmx_tp_count++;
-			P->devnum = dmx_tp_count;
-		}
-	}
-	fd = open(devname[P->devnum], flags);
-	if (fd < 0)
-	{
-		hal_info("%s %s: %m\n", __FUNCTION__, devname[P->devnum]);
-		return false;
-	}
-	fcntl(fd, F_SETFD, FD_CLOEXEC);
-	hal_debug("%s #%d pes_type: %s(%d), uBufferSize: %d dev:%s fd: %d\n", __func__,
-		 num, DMX_T[pes_type], pes_type, uBufferSize, devname[P->devnum] + strlen("/dev/stb/"), fd);
-
-	dmx_type = pes_type;
-
-	if (!pesfds.empty())
-	{
-		hal_info("%s ERROR! pesfds not empty!\n", __FUNCTION__); /* TODO: error handling */
-		return false;
-	}
-	if (pes_type == DMX_TP_CHANNEL)
-	{
-		if (P->measure)
-			return true;
-		struct demux_bucket_para bp;
-		bp.unloader.unloader_type = UNLOADER_TYPE_TRANSPORT;
-		bp.unloader.threshold     = 128;
-		ioctl(fd, DEMUX_SELECT_SOURCE, INPUT_FROM_CHANNEL0);
-		ioctl(fd, DEMUX_SET_BUFFER_SIZE, 230400);
-		ioctl(fd, DEMUX_FILTER_BUCKET_SET, &bp);
-		return true;
-	}
-	if (uBufferSize > 0)
-	{
-		/* probably uBufferSize == 0 means "use default size". TODO: find a reasonable default */
-		if (ioctl(fd, DEMUX_SET_BUFFER_SIZE, uBufferSize) < 0)
-			hal_info("%s DEMUX_SET_BUFFER_SIZE failed (%m)\n", __FUNCTION__);
-	}
-	buffersize = uBufferSize;
-
-	return true;
-}
-
-void cDemux::Close(void)
-{
-	hal_debug("%s #%d, fd = %d\n", __FUNCTION__, num, fd);
-	if (fd < 0)
-	{
-		hal_info("%s #%d: not open!\n", __FUNCTION__, num);
-		return;
-	}
-
-	for (std::vector<pes_pids>::const_iterator i = pesfds.begin(); i != pesfds.end(); ++i)
-	{
-		hal_debug("%s stopping and closing demux fd %d pid 0x%04x\n", __FUNCTION__, (*i).fd, (*i).pid);
-		if (ioctl((*i).fd, DEMUX_STOP) < 0)
-			perror("DEMUX_STOP");
-		if (close((*i).fd) < 0)
-			perror("close");
-	}
-	pesfds.clear();
-	ioctl(fd, DEMUX_STOP);
-	close(fd);
-	fd = -1;
-	if (P->measure)
-		return;
-	if (dmx_type == DMX_TP_CHANNEL)
-	{
-		dmx_tp_count--;
-		if (dmx_tp_count < 0)
-		{
-			hal_info("%s dmx_tp_count < 0!!\n", __func__);
-			dmx_tp_count = 0;
-		}
-	}
-}
-
-bool cDemux::Start(bool)
-{
-	if (fd < 0)
-	{
-		hal_info("%s #%d: not open!\n", __FUNCTION__, num);
-		return false;
-	}
-
-	for (std::vector<pes_pids>::const_iterator i = pesfds.begin(); i != pesfds.end(); ++i)
-	{
-		hal_debug("%s starting demux fd %d pid 0x%04x\n", __FUNCTION__, (*i).fd, (*i).pid);
-		if (ioctl((*i).fd, DEMUX_START) < 0)
-			perror("DEMUX_START");
-	}
-	ioctl(fd, DEMUX_START);
-	P->running = true;
-	return true;
-}
-
-bool cDemux::Stop(void)
-{
-	if (fd < 0)
-	{
-		hal_info("%s #%d: not open!\n", __FUNCTION__, num);
-		return false;
-	}
-	for (std::vector<pes_pids>::const_iterator i = pesfds.begin(); i != pesfds.end(); ++i)
-	{
-		hal_debug("%s stopping demux fd %d pid 0x%04x\n", __FUNCTION__, (*i).fd, (*i).pid);
-		if (ioctl((*i).fd, DEMUX_STOP) < 0)
-			perror("DEMUX_STOP");
-	}
-	ioctl(fd, DEMUX_STOP);
-	P->running = false;
-	return true;
-}
-
-int cDemux::Read(unsigned char *buff, int len, int timeout)
-{
-#if 0
-	if (len != 4095 && timeout != 10)
-		fprintf(stderr, "cDemux::%s #%d fd: %d type: %s len: %d timeout: %d\n",
-			__FUNCTION__, num, fd, DMX_T[dmx_type], len, timeout);
-#endif
-	int rc;
-	struct pollfd ufds;
-	ufds.fd = fd;
-	ufds.events = POLLIN;
-	ufds.revents = 0;
-
-	if (dmx_type == DMX_INVALID)	/* happens, if too many DMX_TP are requested, because */
-	{				/* nobody checks the return value of Open or Start... */
-		hal_debug("%s #%d: DMX_INVALID\n", __func__, num);
-		usleep(timeout * 1000);	/* rate-limit the debug message */
-		errno = EINVAL;
-		return -1;
-	}
-
-	if (P->measure)
-	{
-		if (timeout)
-			usleep(timeout * 1000);
-		uint64_t now;
-		struct timespec t;
-		clock_gettime(CLOCK_MONOTONIC, &t);
-		now = t.tv_sec * 1000;
-		now += t.tv_nsec / 1000000;
-		if (now - P->last_measure < 333)
-			return 0;
-		unsigned char dummy[12];
-		unsigned long long bit_s = 0;
-		S_STREAM_MEASURE m;
-		ioctl(fd, DEMUX_STOP);
-		rc = read(fd, dummy, 12);
-		hal_debug("%s measure read: %d\n", __func__, rc);
-		if (rc == 12)
-		{
-			ioctl(fd, DEMUX_GET_MEASURE_TIMING, &m);
-			if (m.rx_bytes > 0 && m.rx_time_us > 0)
-			{
-				// -- current bandwidth in kbit/sec
-				// --- cast to unsigned long long so it doesn't overflow as
-				// --- early, add time / 2 before division for correct rounding
-				/* the correction factor is found out like that:
-				   - with 8000 (guessed), a 256 kbit radio stream shows as 262kbit...
-				   - 8000*256/262 = 7816.793131
-				   BUT! this is only true for some Radio stations (DRS3 for example), for
-				        others (DLF) 8000 does just fine.
-				bit_s = (m.rx_bytes * 7816793ULL + (m.rx_time_us / 2ULL)) / m.rx_time_us;
-				 */
-				bit_s = (m.rx_bytes * 8000ULL + (m.rx_time_us / 2ULL)) / m.rx_time_us;
-				if (now - P->last_data < 5000)
-					rc = bit_s * (now - P->last_data) / 8ULL;
-				else
-					rc = 0;
-				hal_debug("%s measure bit_s: %llu rc: %d timediff: %lld\n",
-					  __func__, bit_s, rc, (now - P->last_data));
-				P->last_data = now;
-			} else
-				rc = 0;
-		}
-		P->last_measure = now;
-		ioctl(fd, DEMUX_START);
-		return rc;
-	}
-	if (timeout > 0)
-	{
- retry:
-		rc = ::poll(&ufds, 1, timeout);
-		if (!rc)
-			return 0; // timeout
-		else if (rc < 0)
-		{
-			dmx_err("poll: %s,", strerror(errno), 0)
-			//hal_info("%s poll: %m\n", __FUNCTION__);
-			/* happens, when running under gdb... */
-			if (errno == EINTR)
-				goto retry;
-			return -1;
-		}
-		if (ufds.revents & POLLERR) /* POLLERR means buffer error, i.e. buffer overflow */
-		{
-			dmx_err("received %s,", "POLLERR", ufds.revents);
-			/* this seems to happen sometimes at recording start, without bad effects */
-			return 0;
-		}
-		if (ufds.revents & POLLHUP) /* we get POLLHUP if e.g. a too big DMX_BUFFER_SIZE was set */
-		{
-			dmx_err("received %s,", "POLLHUP", ufds.revents);
-			return -1;
-		}
-		if (!(ufds.revents & POLLIN)) /* we requested POLLIN but did not get it? */
-		{
-			dmx_err("received %s, please report!", "POLLIN", ufds.revents);
-			return 0;
-		}
-	}
-
-	rc = ::read(fd, buff, len);
-	//fprintf(stderr, "fd %d ret: %d\n", fd, rc);
-	if (rc < 0)
-		dmx_err("read: %s", strerror(errno), 0);
-
-	return rc;
-}
-
-bool cDemux::sectionFilter(unsigned short _pid, const unsigned char * const filter,
-			   const unsigned char * const mask, int len, int timeout,
-			   const unsigned char * const negmask)
-{
-	int length;
-	struct demux_filter_para s_flt;
-	memset(&s_flt, 0, sizeof(s_flt));
-	pid = _pid;
-	if (len > FILTER_LENGTH - 2)
-		hal_info("%s #%d: len too long: %d, FILTER_LENGTH: %d\n", __func__, num, len, FILTER_LENGTH);
-	if (len < 1) /* memcpy below will be unhappy */
-		hal_info("%s #%d: len too small: %d\n", __func__, num, len);
-
-	length = (len + 2 + 1) & 0xfe;	/* reportedly, the TD drivers don't handle odd filter  */
-	if (length > FILTER_LENGTH)	/* lengths well. So make sure the length is a multiple */
-		length = FILTER_LENGTH;	/* of 2. The unused mask is zeroed anyway.             */
-	flt = filter[0];
-	s_flt.pid = pid;
-	s_flt.filter_length = length;
-	s_flt.filter[0] = filter[0];
-	s_flt.mask[0] = mask[0];
-	s_flt.timeout = timeout;
-	memcpy(&s_flt.filter[3], &filter[1], len - 1);
-	memcpy(&s_flt.mask[3],   &mask[1],   len - 1);
-	if (negmask != NULL)
-	{
-		s_flt.positive[0] = negmask[0];
-		memcpy(&s_flt.positive[3], &negmask[1], len - 1);
-	}
-
-	s_flt.flags = XPDF_IMMEDIATE_START;
-
-	int to = 0;
-	switch (filter[0]) {
-	case 0x00: /* program_association_section */
-		to = 2000;
-		break;
-	case 0x01: /* conditional_access_section */
-		to = 6000;
-		break;
-	case 0x02: /* program_map_section */
-		to = 1500;
-		break;
-	case 0x03: /* transport_stream_description_section */
-		to = 10000;
-		break;
-	/* 0x04 - 0x3F: reserved */
-	case 0x40: /* network_information_section - actual_network */
-		to = 10000;
-		break;
-	case 0x41: /* network_information_section - other_network */
-		to = 15000;
-		break;
-	case 0x42: /* service_description_section - actual_transport_stream */
-		to = 10000;
-		break;
-	/* 0x43 - 0x45: reserved for future use */
-	case 0x46: /* service_description_section - other_transport_stream */
-		to = 10000;
-		break;
-	/* 0x47 - 0x49: reserved for future use */
-	case 0x4A: /* bouquet_association_section */
-		to = 11000;
-		break;
-	/* 0x4B - 0x4D: reserved for future use */
-	case 0x4E: /* event_information_section - actual_transport_stream, present/following */
-		to = 2000;
-		break;
-	case 0x4F: /* event_information_section - other_transport_stream, present/following */
-		to = 10000;
-		break;
-	/* 0x50 - 0x5F: event_information_section - actual_transport_stream, schedule */
-	/* 0x60 - 0x6F: event_information_section - other_transport_stream, schedule */
-	case 0x70: /* time_date_section */
-		s_flt.flags  |= (XPDF_NO_CRC); /* section has no CRC */
-		//s_flt.pid     = 0x0014;
-		to = 30000;
-		break;
-	case 0x71: /* running_status_section */
-		s_flt.flags  |= (XPDF_NO_CRC); /* section has no CRC */
-		to = 0;
-		break;
-	case 0x72: /* stuffing_section */
-		s_flt.flags  |= (XPDF_NO_CRC); /* section has no CRC */
-		to = 0;
-		break;
-	case 0x73: /* time_offset_section */
-		//s_flt.pid     = 0x0014;
-		to = 30000;
-		break;
-	/* 0x74 - 0x7D: reserved for future use */
-	case 0x7E: /* discontinuity_information_section */
-		s_flt.flags  |= (XPDF_NO_CRC); /* section has no CRC */
-		to = 0;
-		break;
-	case 0x7F: /* selection_information_section */
-		to = 0;
-		break;
-	/* 0x80 - 0x8F: ca_message_section */
-	/* 0x90 - 0xFE: user defined */
-	/*        0xFF: reserved */
-	default:
-		break;
-//		return -1;
-	}
-	if (timeout == 0)
-		s_flt.timeout = to;
-
-	hal_debug("%s #%d pid:0x%04hx fd:%d type:%s len:%d/%d to:%d flags:%x flt[0]:%02x\n", __func__, num,
-		pid, fd, DMX_T[dmx_type], len,s_flt.filter_length, s_flt.timeout,s_flt.flags, s_flt.filter[0]);
-#if 0
-	fprintf(stderr,"filt: ");for(int i=0;i<FILTER_LENGTH;i++)fprintf(stderr,"%02hhx ",s_flt.filter[i]);fprintf(stderr,"\n");
-	fprintf(stderr,"mask: ");for(int i=0;i<FILTER_LENGTH;i++)fprintf(stderr,"%02hhx ",s_flt.mask  [i]);fprintf(stderr,"\n");
-	fprintf(stderr,"posi: ");for(int i=0;i<FILTER_LENGTH;i++)fprintf(stderr,"%02hhx ",s_flt.positive[i]);fprintf(stderr,"\n");
-#endif
-	ioctl (fd, DEMUX_STOP);
-	if (ioctl(fd, DEMUX_FILTER_SET, &s_flt) < 0)
-		return false;
-
-	P->running = true;
-	return true;
-}
-
-bool cDemux::pesFilter(const unsigned short _pid)
-{
-	demux_pes_para p_flt;
-	pid = _pid;
-	flt = 0;
-	/* allow PID 0 for web streaming e.g.
-	 * this check originally is from tuxbox cvs but I'm not sure
-	 * what it is good for...
-	if (pid <= 0x0001 && dmx_type != DMX_PCR_ONLY_CHANNEL)
-		return false;
-	 */
-	if ((pid >= 0x0002 && pid <= 0x000f) || pid >= 0x1fff)
-		return false;
-
-	hal_debug("%s #%d pid: 0x%04hx fd: %d type: %s\n", __FUNCTION__, num, pid, fd, DMX_T[dmx_type]);
-
-	if (dmx_type == DMX_TP_CHANNEL && !P->measure)
-	{
-		unsigned int n = pesfds.size();
-		addPid(pid);
-		return (n != pesfds.size());
-	}
-	memset(&p_flt, 0, sizeof(p_flt));
-	p_flt.pid = pid;
-	p_flt.output = OUT_DECODER;
-	switch (dmx_type) {
-	case DMX_PCR_ONLY_CHANNEL:
-		p_flt.pesType = DMX_PES_PCR;
-		break;
-	case DMX_AUDIO_CHANNEL:
-		p_flt.pesType = DMX_PES_AUDIO;
-		break;
-	case DMX_VIDEO_CHANNEL:
-		p_flt.pesType = DMX_PES_VIDEO;
-		break;
-	case DMX_PES_CHANNEL:
-		p_flt.unloader.unloader_type = UNLOADER_TYPE_PAYLOAD;
-		if (buffersize <= 0x10000) // dvbsubtitle, instant delivery...
-			p_flt.unloader.threshold = 1;
-		else
-			p_flt.unloader.threshold = 8; // 1k, teletext
-		p_flt.pesType = DMX_PES_OTHER;
-		p_flt.output  = OUT_MEMORY;
-		break;
-	case DMX_TP_CHANNEL:
-		/* must be measure == true or we would have returned above */
-		p_flt.output = OUT_MEMORY;
-		p_flt.pesType = DMX_PES_OTHER;
-		p_flt.unloader.threshold = 1;
-		p_flt.unloader.unloader_type = UNLOADER_TYPE_MEASURE_DUMMY;
-		ioctl(fd, DEMUX_SET_MEASURE_TIME, 250000);
-		break;
-	default:
-		p_flt.pesType = DMX_PES_OTHER;
-	}
-	return (ioctl(fd, DEMUX_FILTER_PES_SET, &p_flt) >= 0);
-}
-
-void cDemux::SetSyncMode(AVSYNC_TYPE /*mode*/)
-{
-	hal_debug("%s #%d\n", __FUNCTION__, num);
-}
-
-void *cDemux::getBuffer()
-{
-	hal_debug("%s #%d\n", __FUNCTION__, num);
-	if (P->running)
-		return (void *)1;
-	return NULL;
-}
-
-void *cDemux::getChannel()
-{
-	hal_debug("%s #%d\n", __FUNCTION__, num);
-	return NULL;
-}
-
-bool cDemux::addPid(unsigned short Pid)
-{
-	pes_pids pfd;
-	int ret;
-	struct demux_pes_para p;
-	if (dmx_type != DMX_TP_CHANNEL)
-	{
-		hal_info("%s pes_type %s not implemented yet! pid=%hx\n", __FUNCTION__, DMX_T[dmx_type], Pid);
-		return false;
-	}
-	if (P->measure)
-	{
-		hal_info("%s measurement demux -> skipping\n", __func__);
-		return true;
-	}
-	if (fd == -1)
-		hal_info("%s bucketfd not yet opened? pid=%hx\n", __FUNCTION__, Pid);
-	pfd.fd = open(devname[P->devnum], O_RDWR);
-	if (pfd.fd < 0)
-	{
-		hal_info("%s #%d Pid = %hx open failed (%m)\n", __FUNCTION__, num, Pid);
-		return false;
-	}
-	fcntl(pfd.fd, F_SETFD, FD_CLOEXEC);
-	hal_debug("%s #%d Pid = %hx pfd = %d\n", __FUNCTION__, num, Pid, pfd.fd);
-
-	p.pid = Pid;
-	p.pesType = DMX_PES_OTHER;
-	p.output  = OUT_NOTHING;
-	p.flags   = 0;
-	p.unloader.unloader_type = UNLOADER_TYPE_BUCKET;
-	p.unloader.threshold     = 128;
-
-	ioctl(pfd.fd, DEMUX_SELECT_SOURCE, INPUT_FROM_CHANNEL0);
-	ret = ioctl(pfd.fd, DEMUX_SET_BUFFER_SIZE, 0x10000); // 64k
-	if (ret == -1)
-		perror("DEMUX_SET_BUFFER_SIZE");
-	else
-	{
-		ret = ioctl(pfd.fd, DEMUX_FILTER_PES_SET, &p);
-		if (ret == -1)
-			perror("DEMUX_FILTER_PES_SET");
-	}
-	pfd.pid = Pid;
-	if (ret != -1)
-		/* success! */
-		pesfds.push_back(pfd);
-	else
-		/* error! */
-		close(pfd.fd);
-	return (ret != -1);
-}
-
-void cDemux::removePid(unsigned short Pid)
-{
-	if (dmx_type != DMX_TP_CHANNEL)
-	{
-		hal_info("%s pes_type %s not implemented yet! pid=%hx\n", __FUNCTION__, DMX_T[dmx_type], Pid);
-		return;
-	}
-	for (std::vector<pes_pids>::iterator i = pesfds.begin(); i != pesfds.end(); ++i)
-	{
-		if ((*i).pid == Pid) {
-			hal_debug("removePid: removing demux fd %d pid 0x%04x\n", (*i).fd, Pid);
-			if (ioctl((*i).fd, DEMUX_STOP) < 0)
-				perror("DEMUX_STOP");
-			if (close((*i).fd) < 0)
-				perror("close");
-			pesfds.erase(i);
-			return; /* TODO: what if the same PID is there multiple times */
-		}
-	}
-	hal_info("%s pid 0x%04x not found\n", __FUNCTION__, Pid);
-}
-
-void cDemux::getSTC(int64_t * STC)
-{
-	hal_debug("%s #%d\n", __FUNCTION__, num);
-	/* this is a guess, but seems to work... int32_t gives errno 515... */
-#define STC_TYPE uint64_t
-	STC_TYPE stc;
-	if (ioctl(fd, DEMUX_GET_CURRENT_STC, &stc))
-		perror("cDemux::getSTC DEMUX_GET_CURRENT_STC");
-	*STC = (stc >> 32);
-}
-
-int cDemux::getUnit(void)
-{
-	hal_debug("%s #%d\n", __FUNCTION__, num);
-	/* just guessed that this is the right thing to do.
-	   right now this is only used by the CA code which is stubbed out
-	   anyway */
-	return num;
-}
diff -Nur libstb-hal-ddt.git.orig/libtriple/hardware_caps.c libstb-hal-ddt.git/libtriple/hardware_caps.c
--- libstb-hal-ddt.git.orig/libtriple/hardware_caps.c	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/hardware_caps.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
-/*
- * determine the capabilities of the hardware.
- * part of libstb-hal
- *
- * (C) 2010-2012 Stefan Seyfried
- *
- * License: GPL v2 or later
- */
-
-#include "hardware_caps.h"
-
-static hw_caps_t caps = {
-	.has_fan = 0,
-	.has_SCART = 1,
-	.has_SCART_input = 1,
-	.has_HDMI = 0,
-	.has_YUV_cinch = 0,
-	.can_shutdown = 0,
-	.can_cec = 0,
-	.display_type = HW_DISPLAY_GFX,
-	.display_xres = 128,
-	.display_yres = 64,
-	.display_can_deepstandby = 0;
-	.display_has_statusline = 0;
-	.boxvendor = "Armas",
-	.boxname = "TripleDragon"
-};
-
-hw_caps_t *get_hwcaps(void)
-{
-	return &caps;
-}
diff -Nur libstb-hal-ddt.git.orig/libtriple/init_td.cpp libstb-hal-ddt.git/libtriple/init_td.cpp
--- libstb-hal-ddt.git.orig/libtriple/init_td.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/init_td.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,159 +0,0 @@
-#include <stdio.h>
-
-#include "init.h"
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <directfb.h>
-
-extern "C" {
-#include <tdpanel/ir_ruwido.h>
-#include <hardware/avs/avs_inf.h>
-#include <hardware/avs/bios_system_config.h>
-}
-#include "lt_dfbinput.h"
-#include "pwrmngr.h"
-
-#include "hal_debug.h"
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_INIT, NULL, args)
-#define hal_info(args...) _hal_info(HAL_DEBUG_INIT, NULL, args)
-
-static bool initialized = false;
-
-/* the super interface */
-IDirectFB *dfb;
-/* the primary surface */
-static IDirectFBSurface *primary;
-IDirectFBSurface *dfbdest;
-static IDirectFBDisplayLayer *layer;
-int gfxfd = -1;
-
-#define DFBCHECK(x...)                                                \
-	err = x;                                                      \
-	if (err != DFB_OK) {                                          \
-		fprintf(stderr, "init_td.cpp:%d:\n\t", __LINE__);     \
-		DirectFBErrorFatal(#x, err );                         \
-	}
-
-static void dfb_init()
-{
-	int argc = 0;
-	DFBResult err;
-	DFBSurfaceDescription dsc;
-	DFBSurfacePixelFormat pixelformat;
-	int SW, SH;
-
-	DFBCHECK(DirectFBInit(&argc, NULL));
-	/* neutrino does its own VT handling */
-	DirectFBSetOption("no-vt-switch", NULL);
-	DirectFBSetOption("no-vt", NULL);
-	/* signal handling seems to interfere with neutrino */
-	DirectFBSetOption("no-sighandler", NULL);
-	/* if DirectFB grabs the remote, neutrino does not get events */
-	/* now we handle the input via a DFB thread and push it to
-	 * neutrino via uinput, so reenable tdremote module
-	DirectFBSetOption("disable-module", "tdremote");
-	 */
-	DirectFBSetOption("disable-module", "keyboard");
-	DirectFBSetOption("disable-module", "linux_input");
-	DFBCHECK(DirectFBCreate(&dfb));
-
-	err = dfb->SetCooperativeLevel(dfb, DFSCL_FULLSCREEN);
-	if (err)
-		DirectFBError("Failed to get exclusive access", err);
-
-	dsc.flags = DSDESC_CAPS;
-	dsc.caps = DSCAPS_PRIMARY;
-
-	DFBCHECK(dfb->CreateSurface( dfb, &dsc, &primary ));
-	/* set pixel alpha mode */
-	dfb->GetDisplayLayer(dfb, DLID_PRIMARY, &layer);
-	DFBCHECK(layer->SetCooperativeLevel(layer, DLSCL_EXCLUSIVE));
-	DFBDisplayLayerConfig conf;
-	DFBCHECK(layer->GetConfiguration(layer, &conf));
-	conf.flags   = DLCONF_OPTIONS;
-	conf.options = (DFBDisplayLayerOptions)((conf.options & ~DLOP_OPACITY) | DLOP_ALPHACHANNEL);
-	DFBCHECK(layer->SetConfiguration(layer, &conf));
-
-	primary->GetPixelFormat(primary, &pixelformat);
-	primary->GetSize(primary, &SW, &SH);
-	primary->Clear(primary, 0, 0, 0, 0);
-	primary->GetSubSurface(primary, NULL, &dfbdest);
-	dfbdest->Clear(dfbdest, 0, 0, 0, 0);
-
-	start_input_thread(dfb);
-}
-
-static void dfb_deinit()
-{
-	stop_input_thread();
-	dfbdest->Release(dfbdest);
-	primary->Release(primary);
-	layer->Release(layer);
-	dfb->Release(dfb);
-}
-
-static void rc_init()
-{
-	/* set remote control address from bootloader config */
-	int fd = open("/dev/stb/tdsystem", O_RDWR);
-	struct BIOS_CONFIG_AREA bca;
-	unsigned short rc_addr = 0xff;
-	if (ioctl(fd, IOC_AVS_GET_LOADERCONFIG, &bca) != 0)
-		fprintf(stderr, "%s: IOC_AVS_GET_LOADERCONFIG failed: %m\n", __FUNCTION__);
-	else
-		rc_addr = bca.ir_adrs;
-	close(fd);
-	fd = open("/dev/stb/tdremote", O_RDWR);
-	if (ioctl(fd, IOC_IR_SET_ADDRESS, rc_addr) < 0)
-		fprintf(stderr, "%s: IOC_IR_SET_ADDRESS %d failed: %m\n", __FUNCTION__, rc_addr);
-	/* short delay in the driver improves responsiveness and reduces spurious
-	   "key up" events during zapping */
-	//ioctl(fd, IOC_IR_SET_DELAY, 1);  TODO: needs more work in rcinput
-	close(fd);
-	hal_info("%s rc_addr=0x%02hx\n", __FUNCTION__, rc_addr);
-}
-
-void hal_api_init()
-{
-	if (!initialized)
-		hal_debug_init();
-	hal_info("%s begin, initialized=%d, debug=0x%02x\n", __FUNCTION__, (int)initialized, debuglevel);
-	if (!initialized)
-	{
-		/* leave standby early, this avoids popping noise on audio device */
-		cCpuFreqManager f;
-		f.SetCpuFreq(0);	/* CPUFREQ == 0 is the trigger for leaving standby */
-		/* DirectFB does setpgid(0,0), which disconnects us from controlling terminal
-		   and thus disables e.g. ctrl-C. work around that. */
-		pid_t pid = getpgid(0);
-		dfb_init();
-		if (setpgid(0, pid))
-			perror("setpgid");
-		rc_init();
-		gfxfd = open("/dev/stb/tdgfx", O_RDWR);
-		if (gfxfd < 0)
-			perror("open /dev/stb/tdgfx");
-		fcntl(gfxfd, F_SETFD, FD_CLOEXEC);
-	}
-	/* load the module which converts the TD tuner to a Linux-DVB frontend... */
-	system("/sbin/modprobe td-dvb-frontend");
-	initialized = true;
-	hal_info("%s end\n", __FUNCTION__);
-}
-
-void hal_api_exit()
-{
-	hal_info("%s, initialized = %d\n", __FUNCTION__, (int)initialized);
-	if (initialized)
-		dfb_deinit();
-	if (gfxfd > -1)
-		close(gfxfd);
-	gfxfd = -1;
-	initialized = false;
-}
diff -Nur libstb-hal-ddt.git.orig/libtriple/lt_dfbinput.cpp libstb-hal-ddt.git/libtriple/lt_dfbinput.cpp
--- libstb-hal-ddt.git.orig/libtriple/lt_dfbinput.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/lt_dfbinput.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,367 +0,0 @@
-/*
- * Simulate a linux input device via uinput
- * Get td remote events via DirectFB and inject them via uinput
- *
- * (C) 2012 Stefan Seyfried
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-/* the C++ compiler does not like this code, so let's put it into a
- * separate file and compile with gcc insead of g++...
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <pthread.h>
-
-#include <linux/ioctl.h>
-#include <linux/input.h>
-#include <linux/uinput.h>
-
-#include <directfb.h>
-#include "lt_dfbinput.h"
-
-/* needed for videodecoder watchdog */
-#include "video_td.h"
-extern cVideo *videoDecoder;
-
-/* same defines as in neutrino's rcinput.h */
-#define KEY_TTTV	KEY_FN_1
-#define KEY_TTZOOM	KEY_FN_2
-#define KEY_REVEAL	KEY_FN_D
-/* only defined in newer kernels / headers... */
-#ifndef KEY_ZOOMIN
-#define KEY_ZOOMIN	KEY_FN_E
-#endif
-#ifndef KEY_ZOOMOUT
-#define KEY_ZOOMOUT	KEY_FN_F
-#endif
-
-#define DFBCHECK(x...)                                                \
-	err = x;                                                      \
-	if (err != DFB_OK) {                                          \
-		fprintf(stderr, "lt_dfbinput.cpp:%d:\n\t", __LINE__); \
-		DirectFBErrorFatal(#x, err );                         \
-	}
-
-typedef struct _DeviceInfo DeviceInfo;
-struct _DeviceInfo {
-	DFBInputDeviceID           device_id;
-	DFBInputDeviceDescription  desc;
-	DeviceInfo                *next;
-};
-
-static const int key_list[] = {
-	KEY_0,
-	KEY_1,
-	KEY_2,
-	KEY_3,
-	KEY_4,
-	KEY_5,
-	KEY_6,
-	KEY_7,
-	KEY_8,
-	KEY_9,
-	KEY_OK,
-	KEY_TIME,
-	KEY_FAVORITES,
-	KEY_ZOOMOUT,
-	KEY_ZOOMIN,
-	KEY_NEXT,
-	KEY_POWER,
-	KEY_MUTE,
-	KEY_MENU,
-	KEY_EPG,
-	KEY_INFO,
-	KEY_EXIT,
-	KEY_PAGEUP,
-	KEY_PAGEDOWN,
-	KEY_LEFT,
-	KEY_RIGHT,
-	KEY_UP,
-	KEY_DOWN,
-	KEY_VOLUMEUP,
-	KEY_VOLUMEDOWN,
-	KEY_RED,
-	KEY_GREEN,
-	KEY_YELLOW,
-	KEY_BLUE,
-	KEY_TV,
-	KEY_VIDEO,
-	KEY_AUDIO,
-	KEY_AUX,
-	KEY_TEXT,
-	KEY_TTTV,
-	KEY_TTZOOM,
-	KEY_REVEAL,
-	KEY_REWIND,
-	KEY_STOP,
-	KEY_PAUSE,
-	KEY_FORWARD,
-/*	KEY_PREV, */
-	KEY_EJECTCD,
-	KEY_RECORD,
-/*	KEY_NEXT, */
-	-1
-};
-
-static IDirectFBEventBuffer *events;
-static DeviceInfo *inputs = NULL;
-
-static pthread_t thread;
-static int thread_running;
-
-static DFBEnumerationResult enum_input_device(DFBInputDeviceID device_id,
-					      DFBInputDeviceDescription desc,
-					      void *data)
-{
-	DeviceInfo **devices = (DeviceInfo **)data;
-	DeviceInfo  *device;
-
-	device = (DeviceInfo *)malloc(sizeof(DeviceInfo));
-
-	device->device_id = device_id;
-	device->desc      = desc;
-	device->next      = *devices;
-
-	*devices = device;
-
-	return DFENUM_OK;
-}
-
-static void *input_thread(void *data)
-{
-	int uinput;
-	int i;
-	struct input_event u;
-	struct uinput_user_dev ud;
-	FILE *f;
-
-	DFBResult err;
-	IDirectFB *dfb = (IDirectFB *)data;
-	fprintf(stderr, "DFB input converter thread starting...\n");
-
-	/* modprobe does not complain if the module is already loaded... */
-	system("/sbin/modprobe uinput");
-	system("/sbin/modprobe evdev");
-	uinput = open("/dev/misc/uinput", O_WRONLY|O_NDELAY);
-	if (uinput < 0)
-	{
-		fprintf(stderr, "DFB input thread: unable to open /dev/misc/uinput (%m)\n");
-		return NULL;
-	}
-
-	memset(&u, 0, sizeof(u));
-	fcntl(uinput, F_SETFD, FD_CLOEXEC);
-
-	/* configure the device */
-	memset(&ud, 0, sizeof(ud));
-	strncpy(ud.name, "Neutrino TD to Input Device converter", UINPUT_MAX_NAME_SIZE);
-	ud.id.version = 0x42;
-	ud.id.vendor  = 0x1234;
-	ud.id.product = 0x5678;
-	ud.id.bustype = BUS_I2C; /* ?? */
-	write(uinput, &ud, sizeof(ud));
-	ioctl(uinput, UI_SET_EVBIT, EV_KEY);
-	ioctl(uinput, UI_SET_EVBIT, EV_REP);
-	/* register keys */
-	for (i = 0; key_list[i] != -1; i++)
-		ioctl(uinput, UI_SET_KEYBIT, key_list[i]);
-
-	if (ioctl(uinput, UI_DEV_CREATE))
-	{
-		perror("DFB input thread UI_DEV_CREATE");
-		close(uinput);
-		return NULL;
-	}
-
-	/* this is ugly: parse the new input device from /proc/...devices
-	 * and symlink it to /dev/input/nevis_ir... */
-#define DEVLINE "I: Bus=0018 Vendor=1234 Product=5678 Version=0042"
-	f = fopen("/proc/bus/input/devices", "r");
-	if (f)
-	{
-		int found = 0;
-		int evdev = -1;
-		size_t n = 0;
-		char *line = NULL;
-		char *p;
-		char newdev[20];
-		while (getline(&line, &n, f) != -1)
-		{
-			switch(line[0])
-			{
-				case 'I':
-					if (strncmp(line, DEVLINE, strlen(DEVLINE)) == 0)
-						found = 1;
-					break;
-				case 'H':
-					if (! found)
-						break;
-					p = strstr(line, " event");
-					if (! p)
-					{
-						evdev = -1;
-						break;
-					}
-					evdev = atoi(p + 6);
-					sprintf(newdev, "event%d", evdev);
-					fprintf(stderr, "DFB input thread: symlink /dev/input/nevis_ir to %s\n", newdev);
-					unlink("/dev/input/nevis_ir");
-					symlink(newdev, "/dev/input/nevis_ir");
-					break;
-				default:
-					break;
-			}
-			if (evdev != -1)
-				break;
-		}
-		fclose(f);
-		free(line);
-	}
-
-	u.type = EV_KEY;
-	u.value = 0; /* initialize: first event wil be a key press */
-
-	dfb->EnumInputDevices(dfb, enum_input_device, &inputs);
-	DFBCHECK(dfb->CreateInputEventBuffer(dfb, DICAPS_ALL, DFB_FALSE, &events));
-
-	thread_running = 1;
-	while (thread_running)
-	{
-		/* check every 250ms (if a key is pressed on remote, we might
-		 * even check earlier, but it does not really hurt... */
-		if (videoDecoder)
-			videoDecoder->VideoParamWatchdog();
-
-		if (events->WaitForEventWithTimeout(events, 0, 250) == DFB_TIMEOUT)
-			continue;
-		DFBInputEvent e;
-		while (events->GetEvent(events, DFB_EVENT(&e)) == DFB_OK)
-		{
-#if 0
-			fprintf(stderr, "type: %x devid: %x flags: %03x "
-					"key_id: %4x key_sym: %4x keycode: %d\n",
-					e.type, e.device_id, e.flags,
-					e.key_id, e.key_symbol, e.key_code);
-#endif
-			switch (e.key_symbol)
-			{
-				/* will a lookup table be more efficient? */
-				case 0x0030: u.code = KEY_0;		break;
-				case 0x0031: u.code = KEY_1;		break;
-				case 0x0032: u.code = KEY_2;		break;
-				case 0x0033: u.code = KEY_3;		break;
-				case 0x0034: u.code = KEY_4;		break;
-				case 0x0035: u.code = KEY_5;		break;
-				case 0x0036: u.code = KEY_6;		break;
-				case 0x0037: u.code = KEY_7;		break;
-				case 0x0038: u.code = KEY_8;		break;
-				case 0x0039: u.code = KEY_9;		break;
-				case 0x000d: u.code = KEY_OK;		break;
-				case 0xf504: u.code = KEY_TIME;		break;
-				case 0xf01a: u.code = KEY_FAVORITES;	break; /* blue heart */
-				case 0xf021: u.code = KEY_ZOOMOUT;	break;
-				case 0xf022: u.code = KEY_ZOOMIN;	break;
-				case 0xf505: u.code = KEY_NEXT;		break; /* red hand */
-				case 0xf00f: u.code = KEY_POWER;	break;
-				case 0xf04e: u.code = KEY_MUTE;		break;
-				case 0xf012: u.code = KEY_MENU;		break;
-				case 0xf01b: u.code = KEY_EPG;		break;
-				case 0xf014: u.code = KEY_INFO;		break;
-				case 0x001b: u.code = KEY_EXIT;		break;
-				case 0xf046: u.code = KEY_PAGEUP;	break;
-				case 0xf047: u.code = KEY_PAGEDOWN;	break;
-				case 0xf000: u.code = KEY_LEFT;		break;
-				case 0xf001: u.code = KEY_RIGHT;	break;
-				case 0xf002: u.code = KEY_UP;		break;
-				case 0xf003: u.code = KEY_DOWN;		break;
-				case 0xf04c: u.code = KEY_VOLUMEUP;	break;
-				case 0xf04d: u.code = KEY_VOLUMEDOWN;	break;
-				case 0xf042: u.code = KEY_RED;		break;
-				case 0xf043: u.code = KEY_GREEN;	break;
-				case 0xf044: u.code = KEY_YELLOW;	break;
-				case 0xf045: u.code = KEY_BLUE;		break;
-				case 0xf027: u.code = KEY_TV;		break;
-				case 0xf035: u.code = KEY_VIDEO;	break;
-				case 0xf033: u.code = KEY_AUDIO;	break;
-				case 0xf034: u.code = KEY_AUX;		break;
-				case 0xf032: u.code = KEY_TEXT;		break;
-				case 0xf501: u.code = KEY_TTTV;		break;
-				case 0xf502: u.code = KEY_TTZOOM;	break;
-				case 0xf503: u.code = KEY_REVEAL;	break;
-				case 0xf059: u.code = KEY_REWIND;	break;
-				case 0xf052: u.code = KEY_STOP;		break;
-				case 0xf051: u.code = KEY_PAUSE;	break;
-				case 0xf05a: u.code = KEY_FORWARD;	break;
-			/*	case 0xf05b: u.code = KEY_PREV;		break; */
-				case 0xf057: u.code = KEY_EJECTCD;	break;
-				case 0xf056: u.code = KEY_RECORD;	break;
-			/*	case 0xf05c: u.code = KEY_NEXT;		break; */
-				/* front panel left / right */
-				case 0xf506: u.code = KEY_LEFT;		break;
-				case 0xf507: u.code = KEY_RIGHT;	break;
-				default:
-					continue;
-			}
-			switch (e.type)
-			{
-				case 1: u.value = 1; break;	/* 1 = key press */
-				case 2: u.value = 0; break;	/* 0 = key release */
-								/* 2 = key repeat (not used) */
-				default:
-					continue;
-			}
-			// fprintf(stderr, "uinput write: value: %d code: %d\n", u.value, u.code);
-			write(uinput, &u, sizeof(u));
-		}
-	}
-	/* clean up */
-	ioctl(uinput, UI_DEV_DESTROY);
-	while (inputs) {
-		DeviceInfo *next = inputs->next;
-		free(inputs);
-		inputs = next;
-	}
-	events->Release(events);
-	return NULL;
-}
-
-void start_input_thread(IDirectFB *dfb)
-{
-	if (pthread_create(&thread, 0, input_thread, dfb) != 0)
-	{
-		perror("DFB input thread pthread_create");
-		thread_running = 0;
-		return;
-	}
-	/* wait until the device is created before continuing */
-	while (! thread_running)
-		usleep(1000);
-}
-
-void stop_input_thread(void)
-{
-	if (! thread_running)
-		return;
-	thread_running = 0;
-	pthread_join(thread, NULL);
-}
diff -Nur libstb-hal-ddt.git.orig/libtriple/lt_dfbinput.h libstb-hal-ddt.git/libtriple/lt_dfbinput.h
--- libstb-hal-ddt.git.orig/libtriple/lt_dfbinput.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/lt_dfbinput.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,7 +0,0 @@
-/* functions from lt_dfbinput.c */
-
-#ifndef __LT_DFB_INPUT_H_
-#define __LT_DFB_INPUT_H_
-void start_input_thread(IDirectFB *dfb);
-void stop_input_thread(void);
-#endif
diff -Nur libstb-hal-ddt.git.orig/libtriple/Makefile.am libstb-hal-ddt.git/libtriple/Makefile.am
--- libstb-hal-ddt.git.orig/libtriple/Makefile.am	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/Makefile.am	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
-noinst_LTLIBRARIES = libtriple.la
-
-AM_CPPFLAGS = \
-	-I$(top_srcdir)/common \
-	-I$(top_srcdir)/include \
-	@DIRECTFB_CFLAGS@
-
-AM_CXXFLAGS = -fno-rtti -fno-exceptions -fno-strict-aliasing
-AM_LDFLAGS = \
-	-lrt \
-	@DIRECTFB_LIBS@
-
-libtriple_la_SOURCES = \
-	hardware_caps.c \
-	lt_dfbinput.cpp \
-	dmx_td.cpp \
-	video_td.cpp \
-	audio_td.cpp \
-	init_td.cpp \
-	playback_td.cpp \
-	pwrmngr.cpp \
-	record_td.cpp
diff -Nur libstb-hal-ddt.git.orig/libtriple/playback_td.cpp libstb-hal-ddt.git/libtriple/playback_td.cpp
--- libstb-hal-ddt.git.orig/libtriple/playback_td.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/playback_td.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,1506 +0,0 @@
-#include <config.h>
-
-#include <stdio.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <unistd.h>
-
-#include <cstring>
-#include <map>
-
-#include "playback_td.h"
-#include "dmx_hal.h"
-#include "audio_td.h"
-#include "video_td.h"
-#include "hal_debug.h"
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_PLAYBACK, this, args)
-#define hal_info(args...)  _hal_info(HAL_DEBUG_PLAYBACK, this, args)
-#define hal_info_c(args...) _hal_info(HAL_DEBUG_PLAYBACK, NULL, args)
-
-#include <tddevices.h>
-#define DVR	"/dev/" DEVICE_NAME_PVR
-
-static int mp_syncPES(uint8_t *, int, bool quiet = false);
-static int sync_ts(uint8_t *, int);
-static inline uint16_t get_pid(uint8_t *buf);
-static void *start_playthread(void *c);
-static void playthread_cleanup_handler(void *);
-
-static pthread_cond_t playback_ready_cond = PTHREAD_COND_INITIALIZER;
-static pthread_mutex_t playback_ready_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-static pthread_mutex_t currpos_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t inbufpos_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-static int dvrfd = -1;
-static int streamtype;
-
-extern cDemux *videoDemux;
-extern cDemux *audioDemux;
-extern cVideo *videoDecoder;
-extern cAudio *audioDecoder;
-
-static const char *FILETYPE[] = {
-	"FILETYPE_UNKNOWN",
-	"FILETYPE_TS",
-	"FILETYPE_MPG",
-	"FILETYPE_VDR"
-};
-
-cPlayback::cPlayback(int)
-{
-	hal_debug("%s\n", __FUNCTION__);
-	thread_started = false;
-	inbuf = NULL;
-	pesbuf = NULL;
-	filelist.clear();
-	curr_fileno = -1;
-	in_fd = -1;
-	streamtype = 0;
-}
-
-cPlayback::~cPlayback()
-{
-	hal_debug("%s\n", __FUNCTION__);
-	Close();
-}
-
-
-bool cPlayback::Open(playmode_t mode)
-{
-	static const char *PMODE[] = {
-		"PLAYMODE_TS",
-		"PLAYMODE_FILE"
-	};
-
-	hal_debug("%s: PlayMode = %s\n", __FUNCTION__, PMODE[mode]);
-	thread_started = false;
-	playMode = mode;
-	filetype = FILETYPE_TS;
-	playback_speed = 0;
-	last_size = 0;
-	_pts_end = 0;
-	astreams.clear();
-	memset(&cc, 0, 256);
-	return true;
-}
-
-//Used by Fileplay
-void cPlayback::Close(void)
-{
-	hal_info("%s\n", __FUNCTION__);
-	playstate = STATE_STOP;
-	if (thread_started)
-	{
-		hal_info("%s: before pthread_join\n", __FUNCTION__);
-		pthread_join(thread, NULL);
-	}
-	thread_started = false;
-	hal_info("%s: after pthread_join\n", __FUNCTION__);
-	mf_close();
-	filelist.clear();
-
-	if (inbuf)
-		free(inbuf);
-	inbuf = NULL;
-	if (pesbuf)
-		free(pesbuf);
-	pesbuf = NULL;
-
-	/* don't crash */
-	if (audioDecoder)
-		audioDecoder->do_mute(audioDecoder->Muted, false);
-}
-
-bool cPlayback::Start(char *filename, unsigned short vp, int vtype, unsigned short ap, int _ac3, unsigned int)
-{
-	struct stat s;
-	off_t r;
-	vpid = vp;
-	apid = ap;
-	ac3 = _ac3;
-	hal_info("%s name = '%s' vpid 0x%04hx vtype %d apid 0x%04hx ac3 %d filelist.size: %u\n",
-		__FUNCTION__, filename, vpid, vtype, apid, ac3, filelist.size());
-	if (!filelist.empty())
-	{
-		hal_info("filelist not empty?\n");
-		return false;
-	}
-	if (stat(filename, &s))
-	{
-		hal_info("filename does not exist? (%m)\n");
-		return false;
-	}
-	if (!inbuf)
-		inbuf = (uint8_t *)malloc(INBUF_SIZE); /* 256 k */
-	if (!inbuf)
-	{
-		hal_info("allocating input buffer failed (%m)\n");
-		return false;
-	}
-	if (!pesbuf)
-		pesbuf = (uint8_t *)malloc(PESBUF_SIZE); /* 128 k */
-	if (!pesbuf)
-	{
-		hal_info("allocating PES buffer failed (%m)\n");
-		return false;
-	}
-	filelist_t file;
-	file.Name = std::string(filename);
-	file.Size = s.st_size;
-	if (file.Name.rfind(".ts") == file.Name.length() - 3 ||
-	    file.Name.rfind(".TS") == file.Name.length() - 3)
-		filetype = FILETYPE_TS;
-	else
-	{
-		if (file.Name.rfind(".vdr") == file.Name.length() - 4)
-		{
-			filetype = FILETYPE_VDR;
-			std::string::size_type p = file.Name.rfind("info.vdr");
-			if (p == std::string::npos)
-				p = file.Name.rfind("index.vdr");
-			if (p != std::string::npos)
-			{
-				file.Name.replace(p, std::string::npos, "001.vdr");
-				hal_info("replaced filename with '%s'\n", file.Name.c_str());
-				if (stat(file.Name.c_str(), &s))
-				{
-					hal_info("filename does not exist? (%m)\n");
-					return false;
-				}
-				file.Size = s.st_size;
-			}
-		}
-		else
-			filetype = FILETYPE_MPG;
-		vpid = 0x40;
-	}
-
-	hal_info("detected (ok, guessed) filetype: %s\n", FILETYPE[filetype]);
-
-	filelist.push_back(file);
-	filelist_auto_add();
-	if (mf_open(0) < 0)
-		return false;
-
-	pts_start = pts_end = pts_curr = -1;
-	pesbuf_pos = 0;
-	curr_pos = 0;
-	inbuf_pos = 0;
-	inbuf_sync = 0;
-	r = mf_getsize();
-
-	if (r > INBUF_SIZE)
-	{
-		if (mp_seekSync(r - INBUF_SIZE) < 0)
-			return false;
-		while(true) {
-			if (inbuf_read() <= 0)
-				break; // EOF
-			if (curr_pos >= r) //just to make sure...
-				break;
-		}
-		if (filetype == FILETYPE_TS)
-			for (r = (inbuf_pos / 188) * 188; r > 0; r -= 188)
-			{
-				pts_end = get_pts(inbuf + r, false, inbuf_pos - r);
-				if (pts_end > -1)
-					break;
-			}
-		else
-			pts_end = pts_curr;
-	}
-	else
-		pts_end = -1; /* unknown */
-
-	if (mp_seekSync(0) < 0)
-		return false;
-
-	pesbuf_pos = 0;
-	inbuf_pos = 0;
-	inbuf_sync = 0;
-	while (inbuf_pos < INBUF_SIZE / 2 && inbuf_read() > 0) {};
-	for (r = 0; r < inbuf_pos - 188; r += 188)
-	{
-		pts_start = get_pts(inbuf + r, false, inbuf_pos - r);
-		if (pts_start > -1)
-			break;
-	}
-	pts_curr = pts_start;
-	bytes_per_second = -1;
-	if (pts_end != -1 && pts_start > pts_end) /* PTS overflow during this file */
-		pts_end += 0x200000000ULL;
-	int duration = (pts_end - pts_start) / 90000;
-	if (duration > 0)
-		bytes_per_second = mf_getsize() / duration;
-	hal_info("start: %lld end %lld duration %d bps %lld\n", pts_start, pts_end, duration, bytes_per_second);
-	/* yes, we start in pause mode... */
-	playback_speed = 0;
-	if (pts_start == -1)
-		playstate = STATE_INIT;
-	else
-		playstate = STATE_PAUSE;
-	pthread_mutex_lock(&playback_ready_mutex);
-	if (pthread_create(&thread, 0, start_playthread, this) != 0)
-		hal_info("pthread_create failed\n");
-	else
-		pthread_cond_wait(&playback_ready_cond, &playback_ready_mutex);
-	pthread_mutex_unlock(&playback_ready_mutex);
-	return true;
-}
-
-static void *start_playthread(void *c)
-{
-	cPlayback *obj = (cPlayback *)c;
-	obj->playthread();
-	return NULL;
-}
-
-void cPlayback::playthread(void)
-{
-	thread_started = true;
-	int ret, towrite;
-	dvrfd = open(DVR, O_WRONLY);
-	if (dvrfd < 0)
-	{
-		hal_info("%s open tdpvr failed: %m\n", __FUNCTION__);
-		pthread_exit(NULL);
-	}
-	fcntl(dvrfd, F_SETFD, FD_CLOEXEC);
-
-	pthread_cleanup_push(playthread_cleanup_handler, 0);
-
-	ioctl(audioDemux->getFD(), DEMUX_SELECT_SOURCE, INPUT_FROM_PVR);
-	if (ac3)
-		audioDecoder->SetStreamType(AUDIO_FMT_DOLBY_DIGITAL);
-	else
-	{
-		if (streamtype == 1) /* mpeg 1 */
-			audioDecoder->SetStreamType(AUDIO_FMT_MPG1);
-		else /* default */
-			audioDecoder->SetStreamType(AUDIO_FMT_MPEG);
-	}
-
-	audioDemux->pesFilter(apid);
-	videoDemux->pesFilter(vpid);
-
-//	audioDemux->Start();
-	videoDemux->Start();
-
-//	videoDecoder->setBlank(1);
-//	videoDecoder->Start();
-//	audioDecoder->Start();
-	/* everything is set up now, signal ::Start() that it can return */
-	pthread_mutex_lock(&playback_ready_mutex);
-	pthread_cond_broadcast(&playback_ready_cond);
-	pthread_mutex_unlock(&playback_ready_mutex);
-
-	while (playstate != STATE_STOP)
-	{
-		if (playstate == STATE_INIT)
-		{
-			/* hack for timeshift to determine start PTS */
-			pthread_mutex_lock(&inbufpos_mutex);
-			ret = inbuf_read();
-			pthread_mutex_unlock(&inbufpos_mutex);
-			if (ret < 0)
-				break;
-			usleep(100000);
-			if (pts_start == -1)
-				continue;
-		}
-
-		if (playback_speed == 0)
-		{
-			playstate = STATE_PAUSE;
-			usleep(1);
-			continue;
-		}
-		pthread_mutex_lock(&inbufpos_mutex);
-		ret = inbuf_read();
-		pthread_mutex_unlock(&inbufpos_mutex);
-		if (ret < 0)
-			break;
-
-		/* autoselect PID for PLAYMODE_FILE */
-		if (apid == 0 && astreams.size() > 0)
-		{
-			for (std::map<uint16_t, AStream>::iterator aI = astreams.begin(); aI != astreams.end(); aI++)
-			{
-				if (!aI->second.ac3)
-				{
-					apid = aI->first;
-					hal_info("%s setting Audio pid to 0x%04hx\n", __FUNCTION__, apid);
-					SetAPid(apid, 0);
-					break;
-				}
-			}
-		}
-
-		pthread_mutex_lock(&inbufpos_mutex);
-		towrite = inbuf_pos / 188 * 188; /* TODO: smaller chunks? */
-		if (towrite == 0)
-		{
-			pthread_mutex_unlock(&inbufpos_mutex);
-			continue;
-		}
- retry:
-		ret = write(dvrfd, inbuf, towrite);
-		if (ret < 0)
-		{
-			if (errno == EAGAIN && playstate != STATE_STOP)
-				goto retry;
-			hal_info("%s write dvr failed: %m\n", __FUNCTION__);
-			break;
-		}
-		memmove(inbuf, inbuf + ret, inbuf_pos - ret);
-		inbuf_pos -= ret;
-		pthread_mutex_unlock(&inbufpos_mutex);
-	}
-
-	pthread_cleanup_pop(1);
-	pthread_exit(NULL);
-}
-
-static void playthread_cleanup_handler(void *)
-{
-	hal_info_c("%s\n", __FUNCTION__);
-	ioctl(audioDemux->getFD(), DEMUX_SELECT_SOURCE, INPUT_FROM_CHANNEL0);
-	audioDemux->Stop();
-	videoDemux->Stop();
-	audioDecoder->Stop();
-	videoDecoder->Stop();
-	close(dvrfd);
-	dvrfd = -1;
-}
-
-bool cPlayback::SetAPid(unsigned short pid, int _ac3)
-{
-	hal_info("%s pid: 0x%04hx ac3: %d\n", __FUNCTION__, pid, _ac3);
-	apid = pid;
-	ac3 = _ac3;
-
-	audioDemux->Stop();
-	audioDecoder->Stop();
-	videoDemux->Stop();
-	videoDecoder->Stop(false);
-
-	if (ac3)
-		audioDecoder->SetStreamType(AUDIO_FMT_DOLBY_DIGITAL);
-	else
-	{
-		if (streamtype == 1) /* mpeg 1 */
-			audioDecoder->SetStreamType(AUDIO_FMT_MPG1);
-		else /* default */
-			audioDecoder->SetStreamType(AUDIO_FMT_MPEG);
-	}
-	audioDemux->pesFilter(apid);
-
-	videoDemux->Start();
-	audioDemux->Start();
-	audioDecoder->Start();
-	videoDecoder->Start();
-	return true;
-}
-
-bool cPlayback::SetSpeed(int speed)
-{
-	hal_info("%s speed = %d\n", __FUNCTION__, speed);
-	if (speed < 0)
-		speed = 1; /* fast rewind not yet implemented... */
-	if (speed == 1 && playback_speed != 1)
-	{
-		if (playback_speed == 0)
-		{
-			videoDemux->Stop();
-			videoDemux->Start();
-			audioDemux->Start();
-		}
-		else
-		{
-			audioDecoder->Stop();
-			videoDecoder->Stop();
-		}
-		audioDecoder->Start();
-		videoDecoder->Start();
-		playstate = STATE_PLAY;
-		/* cPlayback is a friend of cAudio and can use private methods */
-		audioDecoder->do_mute(audioDecoder->Muted, false);
-	}
-	if (playback_speed == 1 && speed > 1)
-	{
-		audioDecoder->mute(false);
-		videoDecoder->FastForwardMode();
-	}
-	playback_speed = speed;
-	if (playback_speed == 0)
-	{
-		audioDecoder->Stop();
-		audioDemux->Stop();
-		videoDecoder->Stop(false);
-	}
-	return true;
-}
-
-bool cPlayback::GetSpeed(int &speed) const
-{
-	hal_debug("%s\n", __FUNCTION__);
-	speed = playback_speed;
-	return true;
-}
-
-// in milliseconds
-bool cPlayback::GetPosition(int &position, int &duration)
-{
-	int64_t tmppts;
-	hal_debug("%s\n", __FUNCTION__);
-	off_t currsize = mf_getsize();
-	bool update = false;
-	/* handle a growing file, e.g. for timeshift.
-	   this might be pretty expensive... */
-	if (filetype == FILETYPE_TS && filelist.size() == 1)
-	{
-		off_t tmppos = currsize - PESBUF_SIZE;
-		if (currsize > last_size && (currsize - last_size) < 10485760 &&
-		    bytes_per_second > 0 && _pts_end > 0)
-		{
-			/* guess the current endpts... */
-			tmppts = (currsize - last_size) * 90000 / bytes_per_second;
-			pts_end = _pts_end + tmppts;
-		}
-		else if (currsize != last_size && tmppos > 0)
-		{
-			pthread_mutex_lock(&currpos_mutex);
-			off_t oldpos = curr_pos;
-			ssize_t n, r;
-			int s;
-			mf_lseek(tmppos);
-			n = read(in_fd, pesbuf, PESBUF_SIZE); /* abuse the pesbuf... */
-			s = sync_ts(pesbuf, n);
-			if (s >= 0)
-			{
-				n -= s;
-				for (r = (n / 188) * 188; r > 0; r -= 188)
-				{
-					tmppts = get_pts(pesbuf + r + s, false, n - r);
-					if (tmppts > -1)
-					{
-						hal_debug("n: %d s: %d endpts %lld size: %lld\n", n, s, tmppts, currsize);
-						pts_end = tmppts;
-						_pts_end = tmppts;
-						update = true;
-						/* file size has changed => update endpts */
-						last_size = currsize;
-						break;
-					}
-				}
-			}
-			mf_lseek(oldpos);
-			pthread_mutex_unlock(&currpos_mutex);
-		}
-	}
-	if (pts_end != -1 && pts_start > pts_end) /* should trigger only once ;) */
-	{
-		pts_end += 0x200000000ULL;
-		update = true;
-	}
-
-	if (pts_curr != -1 && pts_curr < pts_start)
-		tmppts = pts_curr + 0x200000000ULL - pts_start;
-	else
-		tmppts = pts_curr - pts_start;
-	if (pts_end != -1 && pts_curr != -1)
-	{
-		position = tmppts / 90;
-		duration = (pts_end - pts_start) / 90;
-		if (update && duration >= 4000)
-		{
-			bytes_per_second = currsize / (duration / 1000);
-			hal_debug("%s: updated bps: %lld size: %lld duration %d\n",
-					__FUNCTION__, bytes_per_second, currsize, duration);
-		}
-		return true;
-	}
-	position = 0;
-	duration = 0;
-	return false;
-}
-
-bool cPlayback::SetPosition(int position, bool absolute)
-{
-	hal_info("%s pos = %d abs = %d\n", __FUNCTION__, position, absolute);
-	int currpos, target, duration, oldspeed;
-	bool ret;
-
-	if (absolute)
-		target = position;
-	else
-	{
-		GetPosition(currpos, duration);
-		target = currpos + position;
-		hal_info("current position %d target %d\n", currpos, target);
-	}
-
-	oldspeed = playback_speed;
-//	if (oldspeed != 0)
-		SetSpeed(0);		/* request pause */
-
-	while (playstate == STATE_PLAY)	/* playthread did not acknowledge pause */
-		usleep(1);
-	if (playstate == STATE_STOP)	/* we did get stopped by someone else */
-		return false;
-
-	ret = (seek_to_pts(target * 90) > 0);
-
-	if (oldspeed != 0)
-	{
-		SetSpeed(oldspeed);
-		/* avoid ugly artifacts */
-		videoDecoder->Stop();
-		videoDecoder->Start();
-	}
-	return ret;
-}
-
-void cPlayback::FindAllPids(uint16_t *apids, unsigned short *ac3flags, uint16_t *numpida, std::string *language)
-{
-	hal_info("%s\n", __FUNCTION__);
-	int i = 0;
-	for (std::map<uint16_t, AStream>::iterator aI = astreams.begin(); aI != astreams.end(); aI++)
-	{
-		apids[i] = aI->first;
-		ac3flags[i] = aI->second.ac3 ? 1 : 0;
-		language[i] = aI->second.lang;
-		i++;
-		if (i > 10)	/* REC_MAX_APIDS in vcrcontrol.h */
-			break;
-	}
-	*numpida = i;
-}
-
-/* it is unlikely that subtitle support will be implemented soon */
-void cPlayback::FindAllSubs(uint16_t *, unsigned short *, uint16_t *num, std::string *)
-{
-	*num = 0;
-}
-
-bool cPlayback::SelectSubtitles(int)
-{
-	return false;
-}
-
-/* DVD support is also unlikely... */
-void cPlayback::GetChapters(std::vector<int> &positions, std::vector<std::string> &titles)
-{
-	positions.clear();
-	titles.clear();
-}
-
-off_t cPlayback::seek_to_pts(int64_t pts)
-{
-	off_t newpos = curr_pos;
-	int64_t tmppts, ptsdiff;
-	int count = 0;
-	if (pts_start < 0 || pts_end < 0 || bytes_per_second < 0)
-	{
-		hal_info("%s pts_start (%lld) or pts_end (%lld) or bytes_per_second (%lld) not initialized\n",
-			__FUNCTION__, pts_start, pts_end, bytes_per_second);
-		return -1;
-	}
-	/* sanity check: buffer is without locking, so we must only seek while in pause mode */
-	if (playstate != STATE_PAUSE)
-	{
-		hal_info("%s playstate (%d) != STATE_PAUSE, not seeking\n", __FUNCTION__, playstate);
-		return -1;
-	}
-
-	/* tmppts is normalized current pts */
-	if (pts_curr < pts_start)
-		tmppts = pts_curr + 0x200000000ULL - pts_start;
-	else
-		tmppts = pts_curr - pts_start;
-	while (abs(pts - tmppts) > 90000LL && count < 10)
-	{
-		count++;
-		ptsdiff = pts - tmppts;
-		newpos += ptsdiff * bytes_per_second / 90000;
-		hal_info("%s try #%d seek from %lldms to %lldms dt %lldms pos %lldk newpos %lldk kB/s %lld\n",
-			__FUNCTION__, count, tmppts / 90, pts / 90, ptsdiff / 90, curr_pos / 1024, newpos / 1024, bytes_per_second / 1024);
-		if (newpos < 0)
-			newpos = 0;
-		newpos = mp_seekSync(newpos);
-		if (newpos < 0)
-			return newpos;
-		pthread_mutex_lock(&inbufpos_mutex);
-		inbuf_pos = 0;
-		inbuf_sync = 0;
-		while (inbuf_pos < INBUF_SIZE * 8 / 10) {
-			if (inbuf_read() <= 0)
-				break; // EOF
-		}
-		pthread_mutex_unlock(&inbufpos_mutex);
-		if (pts_curr < pts_start)
-			tmppts = pts_curr + 0x200000000ULL - pts_start;
-		else
-			tmppts = pts_curr - pts_start;
-	}
-	hal_info("%s end after %d tries, ptsdiff now %lld sec\n", __FUNCTION__, count, (pts - tmppts) / 90000);
-	return newpos;
-}
-
-bool cPlayback::filelist_auto_add()
-{
-	if (filelist.size() != 1)
-		return false;
-
-	const char *filename = filelist[0].Name.c_str();
-	const char *ext;
-	ext = strrchr(filename, '.');	// FOO-xxx-2007-12-31.001.ts <- the dot before "ts"
-					// 001.vdr <- the dot before "vdr"
-	// check if there is something to do...
-	if (! ext)
-		return false;
-	if (!((ext - 7 >= filename && !strcmp(ext, ".ts") && *(ext - 4) == '.') ||
-	      (ext - 4 >= filename && !strcmp(ext, ".vdr"))))
-		return false;
-
-	int num = 0;
-	struct stat s;
-	size_t numpos = strlen(filename) - strlen(ext) - 3;
-	sscanf(filename + numpos, "%d", &num);
-	do {
-		num++;
-		char nextfile[strlen(filename) + 1]; /* todo: use fixed buffer? */
-		memcpy(nextfile, filename, numpos);
-		sprintf(nextfile + numpos, "%03d%s", num, ext);
-		if (stat(nextfile, &s))
-			break; // file does not exist
-		filelist_t file;
-		file.Name = std::string(nextfile);
-		file.Size = s.st_size;
-		hal_info("%s auto-adding '%s' to playlist\n", __FUNCTION__, nextfile);
-		filelist.push_back(file);
-	} while (true && num < 999);
-
-	return (filelist.size() > 1);
-}
-
-/* the mf_* functions are wrappers for multiple-file I/O */
-int cPlayback::mf_open(int fileno)
-{
-	if (filelist.empty())
-		return -1;
-
-	if (fileno >= (int)filelist.size())
-		return -1;
-
-	mf_close();
-
-	in_fd = open(filelist[fileno].Name.c_str(), O_RDONLY);
-	fcntl(in_fd, F_SETFD, FD_CLOEXEC);
-	if (in_fd != -1)
-		curr_fileno = fileno;
-
-	return in_fd;
-}
-
-int cPlayback::mf_close(void)
-{
-	int ret = 0;
-	hal_info("%s in_fd = %d curr_fileno = %d\n", __FUNCTION__, in_fd, curr_fileno);
-	if (in_fd != -1)
-		ret = close(in_fd);
-	in_fd = curr_fileno = -1;
-
-	return ret;
-}
-
-off_t cPlayback::mf_getsize(void)
-{
-	off_t ret = 0;
-	if (filelist.size() == 1 && in_fd != -1)
-	{
-		/* for timeshift, we need to deal with a growing file... */
-		struct stat st;
-		if (fstat(in_fd, &st) == 0)
-			return st.st_size;
-		/* else, fallback to filelist.size() */
-	}
-	for (unsigned int i = 0; i < filelist.size(); i++)
-		ret += filelist[i].Size;
-	return ret;
-}
-
-off_t cPlayback::mf_lseek(off_t pos)
-{
-	off_t offset = 0, lpos = pos, ret;
-	unsigned int fileno;
-	/* this is basically needed for timeshifting - to allow
-	   growing files to be handled... */
-	if (filelist.size() == 1 && filetype == FILETYPE_TS)
-	{
-		if (lpos > mf_getsize())
-			return -2;
-		fileno = 0;
-	}
-	else
-	{
-		for (fileno = 0; fileno < filelist.size(); fileno++)
-		{
-			if (lpos < filelist[fileno].Size)
-				break;
-			offset += filelist[fileno].Size;
-			lpos   -= filelist[fileno].Size;
-		}
-		if (fileno == filelist.size())
-			return -2;	// EOF
-	}
-
-	if ((int)fileno != curr_fileno)
-	{
-		hal_info("%s old fileno: %d new fileno: %d, offset: %lld\n", __FUNCTION__, curr_fileno, fileno, (long long)lpos);
-		in_fd = mf_open(fileno);
-		if (in_fd < 0)
-		{
-			hal_info("cannot open file %d:%s (%m)\n", fileno, filelist[fileno].Name.c_str());
-			return -1;
-		}
-	}
-
-	ret = lseek(in_fd, lpos, SEEK_SET);
-	if (ret < 0)
-		return ret;
-
-	curr_pos = offset + ret;
-	return curr_pos;
-}
-
-/* gets the PTS at a specific file position from a PES
-   ATTENTION! resets buf!  */
-int64_t cPlayback::get_PES_PTS(uint8_t *buf, int len, bool last)
-{
-	int64_t pts = -1;
-	int off, plen;
-	uint8_t *p;
-
-	off = mp_syncPES(buf, len);
-
-	if (off < 0)
-		return off;
-
-	p = buf + off;
-	while (off < len - 14 && (pts == -1 || last))
-	{
-		plen = ((p[4] << 8) | p[5]) + 6;
-
-		switch(p[3])
-		{
-			int64_t tmppts;
-			case 0xe0 ... 0xef:	// video!
-				tmppts = get_pts(p, true, len - off);
-				if (tmppts >= 0)
-					pts = tmppts;
-				break;
-			case 0xbb:
-			case 0xbe:
-			case 0xbf:
-			case 0xf0 ... 0xf3:
-			case 0xff:
-			case 0xc0 ... 0xcf:
-			case 0xd0 ... 0xdf:
-				break;
-			case 0xb9:
-			case 0xba:
-			case 0xbc:
-			default:
-				plen = 1;
-				break;
-		}
-		p += plen;
-		off += plen;
-	}
-	return pts;
-}
-
-/* needs to be called with inbufpos_mutex locked! */
-ssize_t cPlayback::inbuf_read()
-{
-	if (filetype == FILETYPE_UNKNOWN)
-		return -1;
-	if (filetype == FILETYPE_TS)
-		return read_ts();
-	/* FILETYPE_MPG or FILETYPE_VDR */
-	return read_mpeg();
-}
-
-ssize_t cPlayback::read_ts()
-{
-	ssize_t toread, ret = 0, sync, off;
-	toread = INBUF_SIZE - inbuf_pos;
-	bool retry = true;
-	uint8_t *buf;
-	/* fprintf(stderr, "%s:%d curr_pos %lld, inbuf_pos: %ld, toread: %ld\n",
-		__FUNCTION__, __LINE__, (long long)curr_pos, (long)inbuf_pos, (long)toread); */
-
-	if (playback_speed > 1)
-	{
-		sync = 0;
-		ssize_t tmpread = PESBUF_SIZE / 188 * 188;
-		int n, skipped = 0;
-		bool skip = false;
-		bool eof = true;
-		pthread_mutex_lock(&currpos_mutex);
-		while (toread > 0)
-		{
-			ssize_t done = 0;
-			while (done < tmpread)
-			{
-				ret = read(in_fd, pesbuf, tmpread - done);
-				if (ret == 0 && retry) /* EOF */
-				{
-					mf_lseek(curr_pos);
-					retry = false;
-					continue;
-				}
-				if (ret < 0)
-				{
-					hal_info("%s failed1: %m\n", __FUNCTION__);
-					pthread_mutex_unlock(&currpos_mutex);
-					return ret;
-				}
-				if (ret == 0 && eof)
-					goto out;
-				eof = false;
-				done += ret;
-				curr_pos += ret;
-			}
-			sync = sync_ts(pesbuf, ret);
-			if (sync != 0)
-			{
-				hal_info("%s out of sync: %d\n", __FUNCTION__, sync);
-				if (sync < 0)
-				{
-					pthread_mutex_unlock(&currpos_mutex);
-					return -1;
-				}
-				memmove(pesbuf, pesbuf + sync, ret - sync);
-				if (pesbuf[0] != 0x47)
-					hal_info("%s:%d??????????????????????????????\n", __FUNCTION__, __LINE__);
-			}
-			for (n = 0; n < done / 188 * 188; n += 188)
-			{
-				buf = pesbuf + n;
-				if (buf[1] & 0x40) // PUSI
-				{
-					/* only video packets... */
-					int of = 4;
-					if (buf[3] & 0x20) // adaptation field
-						of += buf[4] + 1;
-					if ((buf[of + 3] & 0xF0) == 0xE0 && // Video stream
-					    buf[of + 2] == 0x01 && buf[of + 1] == 0x00 && buf[of] == 0x00) // PES
-					{
-						skip = true;
-						skipped++;
-						if (skipped >= playback_speed)
-						{
-							skipped = 0;
-							skip = false;
-						}
-					}
-				}
-				if (! skip)
-				{
-					memcpy(inbuf + inbuf_pos, buf, 188);
-					inbuf_pos += 188;
-					toread -= 188;
-					if (toread <= 0)
-					{
-						/* the output buffer is full, discard the input :-( */
-						if (done - n > 0)
-						{
-							hal_debug("%s not done: %d, resetting filepos\n",
-								__FUNCTION__, done - n);
-							mf_lseek(curr_pos - (done - n));
-						}
-						break;
-					}
-				}
-			}
-		}
- out:
-		pthread_mutex_unlock(&currpos_mutex);
-		if (eof)
-			return 0;
-	}
-	else
-	{
-		pthread_mutex_lock(&currpos_mutex);
-		while(true)
-		{
-			ret = read(in_fd, inbuf + inbuf_pos, toread);
-			if (ret == 0 && retry) /* EOF */
-			{
-				mf_lseek(curr_pos);
-				retry = false;
-				continue;
-			}
-			break;
-		}
-		if (ret <= 0)
-		{
-			pthread_mutex_unlock(&currpos_mutex);
-			if (ret < 0)
-				hal_info("%s failed2: %m\n", __FUNCTION__);
-			return ret;
-		}
-		inbuf_pos += ret;
-		curr_pos += ret;
-		pthread_mutex_unlock(&currpos_mutex);
-
-		sync = sync_ts(inbuf + inbuf_sync, INBUF_SIZE - inbuf_sync);
-		if (sync < 0)
-		{
-			hal_info("%s cannot sync\n", __FUNCTION__);
-			return ret;
-		}
-		inbuf_sync += sync;
-	}
-	/* check for A/V PIDs */
-	uint16_t pid;
-	int i;
-	int64_t pts;
-	//fprintf(stderr, "inbuf_pos: %ld - sync: %ld, inbuf_syc: %ld\n", (long)inbuf_pos, (long)sync, (long)inbuf_sync);
-	int synccnt = 0;
-	for (i = 0; i < inbuf_pos - inbuf_sync - 13;) {
-		buf = inbuf + inbuf_sync + i;
-		if (*buf != 0x47)
-		{
-			synccnt++;
-			i++;
-			continue;
-		}
-		if (synccnt)
-			hal_info("%s TS went out of sync %d\n", __FUNCTION__, synccnt);
-		synccnt = 0;
-		if (!(buf[1] & 0x40))	/* PUSI */
-		{
-			i += 188;
-			continue;
-		}
-		off = 0;
-		if (buf[3] & 0x20)	/* adaptation field? */
-			off = buf[4] + 1;
-		pid = get_pid(buf + 1);
-		/* PES signature is at buf + 4, streamtype is after 00 00 01 */
-		switch (buf[4 + 3 + off])
-		{
-		case 0xe0 ... 0xef:	/* video stream */
-			if (vpid == 0)
-				vpid = pid;
-			pts = get_pts(buf + 4 + off, true, inbuf_pos - inbuf_sync - i - off - 4);
-			if (pts < 0)
-				break;
-			pts_curr = pts;
-			if (pts_start < 0)
-			{
-				hal_info("%s updating pts_start to %lld ", __FUNCTION__, pts);
-				pts_start = pts;
-				if (pts_end > -1)
-				{
-					if (pts_end < pts_start)
-					{
-						pts_end += 0x200000000ULL;
-						fprintf(stderr, "pts_end to %lld ", pts_end);
-					}
-					int duration = (pts_end - pts_start) / 90000;
-					if (duration > 0)
-					{
-						bytes_per_second = (mf_getsize() - curr_pos) / duration;
-						fprintf(stderr, "bytes_per_second to %lldk duration to %ds at %lldk",
-						bytes_per_second / 1024, duration, curr_pos / 1024);
-					}
-				}
-				fprintf(stderr, "\n");
-			}
-			break;
-		case 0xbd:		/* private stream 1 - ac3 */
-		case 0xc0 ... 0xdf:	/* audio stream */
-			if (astreams.find(pid) != astreams.end())
-				break;
-			AStream tmp;
-			if (buf[7 + off] == 0xbd)
-			{
-				if (buf[12 + off] == 0x24)	/* 0x24 == TTX */
-					break;
-				tmp.ac3 = true;
-			}
-			else
-				tmp.ac3 = false;
-			tmp.lang = "";
-			astreams.insert(std::make_pair(pid, tmp));
-			hal_info("%s found apid #%d 0x%04hx ac3:%d\n", __func__, astreams.size(), pid, tmp.ac3);
-			break;
-		}
-		i += 188;
-	}
-
-	// fprintf(stderr, "%s:%d ret %ld\n", __FUNCTION__, __LINE__, (long long)ret);
-	return ret;
-}
-
-ssize_t cPlayback::read_mpeg()
-{
-	ssize_t toread, ret, sync;
-	//toread = PESBUF_SIZE - pesbuf_pos;
-	/* experiments found, that 80kB is the best buffer size, otherwise a/v sync seems
-	   to suffer and / or audio stutters */
-	toread = 80 * 1024 - pesbuf_pos;
-	bool retry = true;
-
-	if (INBUF_SIZE - inbuf_pos < toread)
-	{
-		hal_info("%s inbuf full, setting toread to %d (old: %zd)\n", __FUNCTION__, INBUF_SIZE - inbuf_pos, toread);
-		toread = INBUF_SIZE - inbuf_pos;
-	}
-	pthread_mutex_lock(&currpos_mutex);
-	while(true)
-	{
-		ret = read(in_fd, pesbuf + pesbuf_pos, toread);
-		if (ret == 0 && retry) /* EOF */
-		{
-			mf_lseek(curr_pos);
-			retry = false;
-			continue;
-		}
-		break;
-	}
-	if (ret < 0)
-	{
-		pthread_mutex_unlock(&currpos_mutex);
-		hal_info("%s failed: %m, pesbuf_pos: %zd, toread: %zd\n", __FUNCTION__, pesbuf_pos, toread);
-		return ret;
-	}
-	pesbuf_pos += ret;
-	curr_pos += ret;
-	pthread_mutex_unlock(&currpos_mutex);
-
-	int count = 0;
-	uint16_t pid = 0;
-	bool resync = true;
-	while (count < pesbuf_pos - 10)
-	{
-		if (resync)
-		{
-			sync = mp_syncPES(pesbuf + count, pesbuf_pos - count - 10);
-			if (sync < 0)
-			{
-				if (pesbuf_pos - count - 10 > 4)
-					hal_info("%s cannot sync (count=%d, pesbuf_pos=%zd)\n",
-						__FUNCTION__, count, pesbuf_pos);
-				break;
-			}
-			if (sync)
-				hal_info("%s needed sync %zd\n", __FUNCTION__, sync);
-			count += sync;
-		}
-		uint8_t *ppes = pesbuf + count;
-		int av = 0; // 1 = video, 2 = audio
-		int64_t pts;
-		switch(ppes[3])
-		{
-			case 0xba: //pack header;
-				// fprintf(stderr, "pack start code, 0x%02x\n", ppes[4]);
-				if ((ppes[4] & 0xf0) == 0x20)		/* mpeg 1 */
-				{
-					streamtype = 1;	/* for audio setup */
-					count += 12;
-				}
-				else if ((ppes[4] & 0xc0) == 0x40)	/* mpeg 2 */
-				{
-					streamtype = 0;
-					count += 14; /* correct: 14 + (ppes[13] & 0x07) */
-				}
-				else
-				{
-					hal_info("%s weird pack header: 0x%2x\n", __FUNCTION__, ppes[4]);
-					count++;
-				}
-				resync = true;
-				continue;
-				break;
-			case 0xbd: // AC3
-			{
-				int off = ppes[8] + 8 + 1; // ppes[8] is often 0
-				if (count + off >= pesbuf_pos)
-					break;
-				uint16_t subid = ppes[off];
-				// if (offset == 0x24 && subid == 0x10 ) // TTX?
-				if (subid < 0x80 || subid > 0x87)
-					break;
-				hal_debug("AC3: ofs 0x%02x subid 0x%02x\n", off, subid);
-				//subid -= 0x60; // normalize to 32...39 (hex 0x20..0x27)
-
-				if (astreams.find(subid) == astreams.end())
-				{
-					AStream tmp;
-					tmp.ac3 = true;
-					tmp.lang = "";
-					astreams.insert(std::make_pair(subid, tmp));
-					hal_info("%s found aid: %02x\n", __FUNCTION__, subid);
-				}
-				pid = subid;
-				av = 2;
-				break;
-			}
-			case 0xbb:
-			case 0xbe:
-			case 0xbf:
-			case 0xf0 ... 0xf3:
-			case 0xff:
-				//skip = (ppes[4] << 8 | ppes[5]) + 6;
-				//DBG("0x%02x header, skip = %d\n", ppes[3], skip);
-				break;
-			case 0xc0 ... 0xcf:
-			case 0xd0 ... 0xdf:
-			{
-				// fprintf(stderr, "audio stream 0x%02x\n", ppes[3]);
-				uint16_t id = ppes[3];
-				if (astreams.find(id) == astreams.end())
-				{
-					AStream tmp;
-					tmp.ac3 = false;
-					tmp.lang = "";
-					astreams.insert(std::make_pair(id, tmp));
-					hal_info("%s found aid: %02x\n", __FUNCTION__, id);
-				}
-				pid = id;
-				av = 2;
-				break;
-			}
-			case 0xe0 ... 0xef:
-				// fprintf(stderr, "video stream 0x%02x, %02x %02x \n", ppes[3], ppes[4], ppes[5]);
-				pid = 0x40;
-				av = 1;
-				pts = get_pts(ppes, true, pesbuf_pos - count);
-				if (pts < 0)
-					break;
-				pts_curr = pts;
-				if (pts_start < 0)
-					pts_start = pts;
-				break;
-			case 0xb9:
-			case 0xbc:
-				hal_debug("%s:%d %s\n", __FUNCTION__, __LINE__,
-					(ppes[3] == 0xb9) ? "program_end_code" : "program_stream_map");
-				//resync = true;
-				// fallthrough. TODO: implement properly.
-			default:
-				//if (! resync)
-				//	DBG("Unknown stream id: 0x%X.\n", ppes[3]);
-				count++;
-				resync = true;
-				continue;
-				break;
-		}
-
-		int pesPacketLen = ((ppes[4] << 8) | ppes[5]) + 6;
-		if (count + pesPacketLen >= pesbuf_pos)
-		{
-			hal_debug("buffer len: %ld, pesPacketLen: %d :-(\n", pesbuf_pos - count, pesPacketLen);
-			break;
-		}
-
-		int tsPacksCount = pesPacketLen / 184;
-		if ((tsPacksCount + 1) * 188 > INBUF_SIZE - inbuf_pos)
-		{
-			hal_info("not enough size in inbuf (needed %d, got %d)\n", (tsPacksCount + 1) * 188, INBUF_SIZE - inbuf_pos);
-			break;
-		}
-
-		if (av)
-		{
-			int rest = pesPacketLen % 184;
-
-			// divide PES packet into small TS packets
-			uint8_t pusi = 0x40;
-			int j;
-			uint8_t *ts = inbuf + inbuf_pos;
-			for (j = 0; j < tsPacksCount; j++)
-			{
-				ts[0] = 0x47;				// SYNC Byte
-				ts[1] = pusi;				// Set PUSI if first packet
-				ts[2] = pid;				// PID (low)
-				ts[3] = 0x10 | (cc[pid] & 0x0F);	// No adaptation field, payload only, continuity counter
-				cc[pid]++;
-				memcpy(ts + 4, ppes + j * 184, 184);
-				pusi = 0x00;				// clear PUSI
-				ts += 188;
-				inbuf_pos += 188;
-			}
-
-			if (rest > 0)
-			{
-				ts[0] = 0x47;				// SYNC Byte
-				ts[1] = pusi;				// Set PUSI or
-				ts[2] = pid;				// PID (low)
-				ts[3] = 0x30 | (cc[pid] & 0x0F);	// adaptation field, payload, continuity counter
-				cc[pid]++;
-				ts[4] = 183 - rest;
-				if (ts[4] > 0)
-				{
-					ts[5] = 0x00;
-					memset(ts + 6, 0xFF, ts[4] - 1);
-				}
-				memcpy(ts + 188 - rest, ppes + j * 184, rest);
-				inbuf_pos += 188;
-			}
-		} //if (av)
-
-		count += pesPacketLen;
-	}
-	memmove(pesbuf, pesbuf + count, pesbuf_pos - count);
-	pesbuf_pos -= count;
-	return ret;
-}
-
-//== seek to pos with sync to next proper TS packet ==
-//== returns offset to start of TS packet or actual ==
-//== pos on failure.                                ==
-//====================================================
-off_t cPlayback::mp_seekSync(off_t pos)
-{
-	off_t npos = pos;
-	off_t ret;
-	uint8_t pkt[1024];
-
-	pthread_mutex_lock(&currpos_mutex);
-	ret = mf_lseek(npos);
-	if (ret < 0)
-		hal_info("%s:%d lseek ret < 0 (%m)\n", __FUNCTION__, __LINE__);
-
-	if (filetype != FILETYPE_TS)
-	{
-		int offset = 0;
-		int s;
-		ssize_t r;
-		bool retry = false;
-		while (true)
-		{
-			r = read(in_fd, &pkt[offset], 1024 - offset);
-			if (r < 0)
-			{
-				hal_info("%s read failed: %m\n", __FUNCTION__);
-				break;
-			}
-			if (r == 0) // EOF?
-			{
-				if (retry)
-					break;
-				if (mf_lseek(npos) < 0) /* next file in list? */
-				{
-					hal_info("%s:%d lseek ret < 0 (%m)\n", __FUNCTION__, __LINE__);
-					break;
-				}
-				retry = true;
-				continue;
-			}
-			s = mp_syncPES(pkt, r + offset, true);
-			if (s < 0)
-			{
-				/* if the last 3 bytes of the buffer were 00 00 01, then
-				   mp_sync_PES would not find it. So keep them and check
-				   again in the next iteration */
-				memmove(pkt, &pkt[r + offset - 3], 3);
-				npos += r;
-				offset = 3;
-			}
-			else
-			{
-				npos += s;
-				hal_info("%s sync after %lld\n", __FUNCTION__, npos - pos);
-				ret = mf_lseek(npos);
-				pthread_mutex_unlock(&currpos_mutex);
-				if (ret < 0)
-					hal_info("%s:%d lseek ret < 0 (%m)\n", __FUNCTION__, __LINE__);
-				return ret;
-			}
-			if (npos > (pos + 0x20000)) /* 128k enough? */
-				break;
-		}
-		hal_info("%s could not sync to PES offset: %d r: %zd\n", __FUNCTION__, offset, r);
-		ret = mf_lseek(pos);
-		pthread_mutex_unlock(&currpos_mutex);
-		return ret;
-	}
-
-	/* TODO: use bigger buffer here, too and handle EOF / next splitfile */
-	while (read(in_fd, pkt, 1) > 0)
-	{
-		//-- check every byte until sync word reached --
-		npos++;
-		if (*pkt == 0x47)
-		{
-			//-- if found double check for next sync word --
-			if (read(in_fd, pkt, 188) == 188)
-			{
-				if(pkt[188-1] == 0x47)
-				{
-					ret = mf_lseek(npos - 1); // assume sync ok
-					pthread_mutex_unlock(&currpos_mutex);
-					if (ret < 0)
-						hal_info("%s:%d lseek ret < 0 (%m)\n", __FUNCTION__, __LINE__);
-					return ret;
-				}
-				else
-				{
-					ret = mf_lseek(npos); // oops, next pkt doesn't start with sync
-					if (ret < 0)
-						hal_info("%s:%d lseek ret < 0 (%m)\n", __FUNCTION__, __LINE__);
-				}
-			}
-		}
-
-		//-- check probe limits --
-		if (npos > (pos + 100 * 188))
-			break;
-	}
-
-	//-- on error stay on actual position --
-	ret = mf_lseek(pos);
-	pthread_mutex_unlock(&currpos_mutex);
-	return ret;
-}
-
-static int sync_ts(uint8_t *p, int len)
-{
-	int count;
-	if (len < 189)
-		return -1;
-
-	count = 0;
-	while (*p != 0x47 || *(p + 188) != 0x47)
-	{
-		count++;
-		p++;
-		if (count + 188 > len)
-			return -1;
-	}
-	return count;
-}
-
-/* get the pts value from a TS or PES packet
-   pes == true selects PES mode. */
-int64_t cPlayback::get_pts(uint8_t *p, bool pes, int bufsize)
-{
-	const uint8_t *end = p + bufsize; /* check for overflow */
-	if (bufsize < 14)
-		return -1;
-	if (!pes)
-	{
-		if (p[0] != 0x47)
-			return -1;
-		if (!(p[1] & 0x40))
-			return -1;
-		if (get_pid(p + 1) != vpid)
-			return -1;
-		if (!(p[3] & 0x10))
-			return -1;
-
-		if (p[3] & 0x20)
-			p += p[4] + 4 + 1;
-		else
-			p += 4;
-
-		if (p + 13 > end)
-			return -1;
-		/* p is now pointing at the PES header. hopefully */
-		if (p[0] || p[1] || (p[2] != 1))
-			return -1;
-	}
-
-	if ((p[6] & 0xC0) != 0x80) // MPEG1
-	{
-		p += 6;
-		while (*p == 0xff)
-		{
-			p++;
-			if (p > end)
-				return -1;
-		}
-		if ((*p & 0xc0) == 0x40)
-			p += 2;
-		p -= 9; /* so that the p[9]...p[13] matches the below */
-		if (p + 13 > end)
-			return -1;
-	}
-	else
-	{
-		/* MPEG2 */
-		if ((p[7] & 0x80) == 0) // packets with both pts, don't care for dts
-		// if ((p[7] & 0xC0) != 0x80) // packets with only pts
-		// if ((p[7] & 0xC0) != 0xC0) // packets with pts and dts
-			return -1;
-		if (p[8] < 5)
-			return -1;
-	}
-
-	if (!(p[9] & 0x20))
-		return -1;
-
-	int64_t pts =
-		((p[ 9] & 0x0EULL) << 29) |
-		((p[10] & 0xFFULL) << 22) |
-		((p[11] & 0xFEULL) << 14) |
-		((p[12] & 0xFFULL) << 7) |
-		((p[13] & 0xFEULL) >> 1);
-
-	//int msec = pts / 90;
-	//INFO("time: %02d:%02d:%02d\n", msec / 3600000, (msec / 60000) % 60, (msec / 1000) % 60);
-	return pts;
-}
-
-/* returns: 0 == was already synchronous, > 0 == is now synchronous, -1 == could not sync */
-static int mp_syncPES(uint8_t *buf, int len, bool quiet)
-{
-	int ret = 0;
-	while (ret < len - 4)
-	{
-		if (buf[ret + 2] != 0x01)
-		{
-			ret++;
-			continue;
-		}
-		if (buf[ret + 1] != 0x00)
-		{
-			ret += 2;
-			continue;
-		}
-		if (buf[ret] != 0x00)
-		{
-			ret += 3;
-			continue;
-		}
-		/* all stream IDs are > 0x80 */
-		if ((buf[ret + 3] & 0x80) != 0x80)
-		{
-			/* we already checked for 00 00 01, if the stream ID
-			   is not valid, we can skip those 3 bytes */
-			ret += 3;
-			continue;
-		}
-		return ret;
-	}
-
-	if (!quiet && len > 5) /* only warn if enough space was available... */
-		hal_info_c("%s No valid PES signature found. %d Bytes deleted.\n", __FUNCTION__, ret);
-	return -1;
-}
-
-static inline uint16_t get_pid(uint8_t *buf)
-{
-	return (*buf & 0x1f) << 8 | *(buf + 1);
-}
-
diff -Nur libstb-hal-ddt.git.orig/libtriple/playback_td.h libstb-hal-ddt.git/libtriple/playback_td.h
--- libstb-hal-ddt.git.orig/libtriple/playback_td.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/playback_td.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,129 +0,0 @@
-#ifndef __PLAYBACK_TD_H__
-#define __PLAYBACK_TD_H__
-
-#include <inttypes.h>
-#include <string>
-#include <map>
-#include <vector>
-
-/* almost 256kB */
-#define INBUF_SIZE (1394 * 188)
-#define PESBUF_SIZE (128 * 1024)
-
-typedef enum {
-	PLAYMODE_TS = 0,
-	PLAYMODE_FILE,
-} playmode_t;
-
-typedef enum {
-	FILETYPE_UNKNOWN,
-	FILETYPE_TS,
-	FILETYPE_MPG,
-	FILETYPE_VDR
-} filetype_t;
-
-typedef enum {
-	STATE_STOP,
-	STATE_PLAY,
-	STATE_PAUSE,
-	STATE_FF,
-	STATE_REW,
-	STATE_INIT
-} playstate_t;
-
-typedef struct {
-	std::string Name;
-	off_t Size;
-} filelist_t;
-
-class cPlayback
-{
-	private:
-		uint8_t *inbuf;
-		ssize_t inbuf_pos;
-		ssize_t inbuf_sync;
-		uint8_t *pesbuf;
-		ssize_t pesbuf_pos;
-		ssize_t inbuf_read(void);
-		ssize_t read_ts(void);
-		ssize_t read_mpeg(void);
-
-		uint8_t cc[256];
-
-		int in_fd;
-
-		int video_type;
-		int playback_speed;
-		int mSpeed;
-		playmode_t playMode;
-		std::vector<filelist_t> filelist; /* for multi-file playback */
-
-		bool filelist_auto_add(void);
-		int mf_open(int fileno);
-		int mf_close(void);
-		off_t mf_lseek(off_t pos);
-		off_t mf_getsize(void);
-		int curr_fileno;
-		off_t curr_pos;
-		off_t last_size;
-		off_t bytes_per_second;
-
-		uint16_t vpid;
-		uint16_t apid;
-		bool ac3;
-		struct AStream {
-			// uint16_t pid;
-			bool ac3;
-			std::string lang; /* not yet really used */
-		};
-		std::map<uint16_t, AStream> astreams; /* stores AStream sorted by pid */
-
-		int64_t pts_start;
-		int64_t pts_end;
-		int64_t _pts_end; /* last good endpts */
-		int64_t pts_curr;
-		int64_t get_pts(uint8_t *p, bool pes, int bufsize);
-
-		filetype_t filetype;
-		playstate_t playstate;
-
-		off_t seek_to_pts(int64_t pts);
-		off_t mp_seekSync(off_t pos);
-		int64_t get_PES_PTS(uint8_t *buf, int len, bool until_eof);
-
-		pthread_t thread;
-		bool thread_started;
-	public:
-		cPlayback(int num = 0);
-		~cPlayback();
-
-		void playthread();
-
-		bool Open(playmode_t PlayMode);
-		void Close(void);
-		bool Start(char *filename, unsigned short vpid, int vtype, unsigned short apid,
-			   int ac3, unsigned int duration);
-		bool SetAPid(unsigned short pid, int ac3);
-		bool SetSpeed(int speed);
-		bool GetSpeed(int &speed) const;
-		bool GetPosition(int &position, int &duration);	/* pos: current time in ms, dur: file length in ms */
-		bool SetPosition(int position, bool absolute = false);	/* position: jump in ms */
-		void FindAllPids(uint16_t *apids, unsigned short *ac3flags, uint16_t *numpida, std::string *language);
-		void FindAllSubs(uint16_t *pids, unsigned short *supported, uint16_t *numpida, std::string *language);
-		bool SelectSubtitles(int pid);
-		void GetChapters(std::vector<int> &positions, std::vector<std::string> &titles);
-#if 0
-		// Functions that are not used by movieplayer.cpp:
-		bool Stop(void);
-		bool GetOffset(off64_t &offset);
-		bool IsPlaying(void) const { return playing; }
-		bool IsEnabled(void) const { return enabled; }
-		void * GetHandle(void);
-		void * GetDmHandle(void);
-		int GetCurrPlaybackSpeed(void) const { return nPlaybackSpeed; }
-		void PlaybackNotify (int  Event, void *pData, void *pTag);
-		void DMNotify(int Event, void *pTsBuf, void *Tag);
-#endif
-};
-
-#endif // __PLAYBACK_TD_H__
diff -Nur libstb-hal-ddt.git.orig/libtriple/README.libtriple libstb-hal-ddt.git/libtriple/README.libtriple
--- libstb-hal-ddt.git.orig/libtriple/README.libtriple	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/README.libtriple	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-libtriple reimplements the interfaces of the libcoolstrem library for
-the Tripledragon receiver.
-
-There are a few debugging or configuration helpers which affect the
-way libtriple does some things. They are all configured by exporting
-environment variables, which are described here:
-
-TRIPLE_NOSCART=1 - makes neutrino *not* do any voltage switching on
-	SCART pin 8, probably not useful for anyone but me
-
-TRIPLE_LCDBACKLIGHT=1 - makes the LCD backlight stay on in standby,
-			may disturb others
-
-HAL_DEBUG=... - controls various debugging levels in libtriple
-	valid values for the different component:
-		audio   0x01
-		video   0x02
-		demux   0x04
-		play    0x08
-		power   0x10
-		init    0x20
-		ca      0x40
-		record  0x80
-		all     0xff
-	multiple levels are added / ORed together, so if you want to
-	debug record and playback code, do "export HAL_DEBUG=0x88"
-	for audio & video use HAL_DEBUG=0x3
-
-DSP_DEVICE
-MIX_DEVICE - alternative audio devices for the audioplayer and internet 
-	radio. Those are used to output music to e.g. USB audio devices.
-	Here is what you need to do:
-	* look in /dev/sound which devices are already there. Probably
-	  /dev/sound/dsp and /dev/sound/mixer, created by the tdoss driver
-	* make sure that the USB HC driver is loaded:
-		modprobe ohci-hcd
-	* load the USB audio driver:
-		modprobe audio
-	* plug in your USB audio device, check with "dmesg" that it is
-	  recognised by the kernel
-	* look in /dev/sound which new devices are there. Probably it's
-	  /dev/sound/dsp1 and /dev/sound/mixer1. If there are more - well
-	  it's time to experiment ;)
-	* export DSP_DEVICE=/dev/sound/dsp1 and MIX_DEVICE=/dev/sound/mixer1
-	  (of course the devices you found in the last step)
-	* from the same shell you exported the variables, start neutrino
-	  (make sure that an already running neutrino is stopped before you
-	  do that)
-	* start the audioplayer, play a track. Look for log lines like
-	  [LT:106b5788:audio ] PrepareClipPlay: dsp_dev /dev/sound/dsp1 mix_dev /dev/sound/mixer1
-	* if it works - fine :-)
-	* if it does not work, look for:
-	  PrepareClipPlay: DSP_DEVICE is set (/dev/sound/dsp1) but cannot be opened, fall back to /dev/sound/dsp
-	  PrepareClipPlay: dsp_dev /dev/sound/dsp mix_dev /dev/sound/mixer1
-	  PrepareClipPlay: open mixer /dev/sound/mixer1 failed (No such file or directory)
-	* this basically means that the device is not there. Different errors
-	  will get different messages - I cannot trigger those now, so you'll
-	  need to find them out by yourself ;)
-	* another possible messag you may get is:
-	  PrepareClipPlay: more than one mixer control: devmask 00000021 stereo 00000021
-	  This means that your device has more than one mixer. The set bit
-	  numbers in the devmask are the different mixers, in this case
-	  it would be number 0 and 5. To select one of those, export
-	  MIX_NUMBER=5 or MIX_NUMBER=0 (this code is untested, there may
-	  be bugs)
-
-	So now I found out what devices to use, but how do I make that permanent?
-	That's easy:
-	* create or extend /etc/rcS.local with
-	  modprobe ohci-hcd
-	  modprobe audio
-	* create or extend /etc/profile.local with
-	  export DSP_DEVICE=/dev/sound/dsp1
-	  export MIX_DEVICE=/dev/sound/mixer1
-	* reboot. Enjoy.
diff -Nur libstb-hal-ddt.git.orig/libtriple/record_td.cpp libstb-hal-ddt.git/libtriple/record_td.cpp
--- libstb-hal-ddt.git.orig/libtriple/record_td.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/record_td.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,275 +0,0 @@
-#include <errno.h>
-#include <fcntl.h>
-#include <malloc.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <inttypes.h>
-#include <cstdio>
-#include <cstring>
-
-#include <pthread.h>
-
-#include "record_td.h"
-#include "dmx_hal.h"
-#include "hal_debug.h"
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_RECORD, this, args)
-#define hal_info(args...) _hal_info(HAL_DEBUG_RECORD, this, args)
-
-/* helper function to call the cpp thread loop */
-void *execute_record_thread(void *c)
-{
-	cRecord *obj = (cRecord *)c;
-	obj->RecordThread();
-	return NULL;
-}
-
-cRecord::cRecord(int /*num*/)
-{
-	hal_info("%s\n", __func__);
-	dmx = NULL;
-	record_thread_running = false;
-	file_fd = -1;
-	exit_flag = RECORD_STOPPED;
-}
-
-cRecord::~cRecord()
-{
-	hal_info("%s: calling ::Stop()\n", __func__);
-	Stop();
-	hal_info("%s: end\n", __func__);
-}
-
-bool cRecord::Open(void)
-{
-	hal_info("%s\n", __func__);
-	exit_flag = RECORD_STOPPED;
-	return true;
-}
-
-#if 0
-// unused
-void cRecord::Close(void)
-{
-	hal_info("%s: \n", __func__);
-}
-#endif
-
-bool cRecord::Start(int fd, unsigned short vpid, unsigned short *apids, int numpids, uint64_t)
-{
-	hal_info("%s: fd %d, vpid 0x%03x\n", __func__, fd, vpid);
-	int i;
-
-	if (!dmx)
-		dmx = new cDemux(1);
-
-	dmx->Open(DMX_TP_CHANNEL, NULL, 0);
-	dmx->pesFilter(vpid);
-
-	for (i = 0; i < numpids; i++)
-		dmx->addPid(apids[i]);
-
-	file_fd = fd;
-	exit_flag = RECORD_RUNNING;
-	if (posix_fadvise(file_fd, 0, 0, POSIX_FADV_DONTNEED))
-		perror("posix_fadvise");
-
-	i = pthread_create(&record_thread, 0, execute_record_thread, this);
-	if (i != 0)
-	{
-		exit_flag = RECORD_FAILED_READ;
-		errno = i;
-		hal_info("%s: error creating thread! (%m)\n", __func__);
-		delete dmx;
-		dmx = NULL;
-		return false;
-	}
-	record_thread_running = true;
-	return true;
-}
-
-bool cRecord::Stop(void)
-{
-	hal_info("%s\n", __func__);
-
-	if (exit_flag != RECORD_RUNNING)
-		hal_info("%s: status not RUNNING? (%d)\n", __func__, exit_flag);
-
-	exit_flag = RECORD_STOPPED;
-	if (record_thread_running)
-		pthread_join(record_thread, NULL);
-	record_thread_running = false;
-
-	/* We should probably do that from the destructor... */
-	if (!dmx)
-		hal_info("%s: dmx == NULL?\n", __func__);
-	else
-		delete dmx;
-	dmx = NULL;
-
-	if (file_fd != -1)
-		close(file_fd);
-	else
-		hal_info("%s: file_fd not open??\n", __func__);
-	file_fd = -1;
-	return true;
-}
-
-bool cRecord::ChangePids(unsigned short /*vpid*/, unsigned short *apids, int numapids)
-{
-	std::vector<pes_pids> pids;
-	int j;
-	bool found;
-	unsigned short pid;
-	hal_info("%s\n", __func__);
-	if (!dmx) {
-		hal_info("%s: DMX = NULL\n", __func__);
-		return false;
-	}
-	pids = dmx->pesfds;
-	/* the first PID is the video pid, so start with the second PID... */
-	for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
-		found = false;
-		pid = (*i).pid;
-		for (j = 0; j < numapids; j++) {
-			if (pid == apids[j]) {
-				found = true;
-				break;
-			}
-		}
-		if (!found)
-			dmx->removePid(pid);
-	}
-	for (j = 0; j < numapids; j++) {
-		found = false;
-		for (std::vector<pes_pids>::const_iterator i = pids.begin() + 1; i != pids.end(); ++i) {
-			if ((*i).pid == apids[j]) {
-				found = true;
-				break;
-			}
-		}
-		if (!found)
-			dmx->addPid(apids[j]);
-	}
-	return true;
-}
-
-bool cRecord::AddPid(unsigned short pid)
-{
-	std::vector<pes_pids> pids;
-	hal_info("%s: \n", __func__);
-	if (!dmx) {
-		hal_info("%s: DMX = NULL\n", __func__);
-		return false;
-	}
-	pids = dmx->pesfds;
-	for (std::vector<pes_pids>::const_iterator i = pids.begin(); i != pids.end(); ++i) {
-		if ((*i).pid == pid)
-			return true; /* or is it an error to try to add the same PID twice? */
-	}
-	return dmx->addPid(pid);
-}
-
-void cRecord::RecordThread()
-{
-	hal_info("%s: begin\n", __func__);
-#define BUFSIZE (1 << 19) /* 512 kB */
-	ssize_t r = 0;
-	int buf_pos = 0;
-	uint8_t *buf;
-	buf = (uint8_t *)malloc(BUFSIZE);
-
-	if (!buf)
-	{
-		exit_flag = RECORD_FAILED_MEMORY;
-		hal_info("%s: unable to allocate buffer! (out of memory)\n", __func__);
-	}
-
-	dmx->Start();
-	while (exit_flag == RECORD_RUNNING)
-	{
-		if (buf_pos < BUFSIZE)
-		{
-			r = dmx->Read(buf + buf_pos, BUFSIZE - 1 - buf_pos, 100);
-			hal_debug("%s: buf_pos %6d r %6d / %6d\n", __func__,
-				buf_pos, (int)r, BUFSIZE - 1 - buf_pos);
-			if (r < 0)
-			{
-				if (errno != EAGAIN)
-				{
-					hal_info("%s: read failed: %m\n", __func__);
-					exit_flag = RECORD_FAILED_READ;
-					break;
-				}
-				hal_info("%s: EAGAIN\n", __func__);
-			}
-			else
-				buf_pos += r;
-		}
-		else
-			hal_info("%s: buffer full! Overflow?\n", __func__);
-		if (buf_pos > (BUFSIZE / 3)) /* start writeout */
-		{
-			size_t towrite = BUFSIZE / 2;
-			if (buf_pos < BUFSIZE / 2)
-				towrite = buf_pos;
-			r = write(file_fd, buf, towrite);
-			if (r < 0)
-			{
-				exit_flag = RECORD_FAILED_FILE;
-				hal_info("%s: write error: %m\n", __func__);
-				break;
-			}
-			buf_pos -= r;
-			memmove(buf, buf + r, buf_pos);
-			hal_debug("%s: buf_pos %6d w %6d / %6d\n", __func__, buf_pos, (int)r, (int)towrite);
-#if 0
-			if (fdatasync(file_fd))
-				perror("cRecord::FileThread() fdatasync");
-#endif
-			if (posix_fadvise(file_fd, 0, 0, POSIX_FADV_DONTNEED))
-				perror("posix_fadvise");
-		}
-	}
-	dmx->Stop();
-	while (buf_pos > 0) /* write out the unwritten buffer content */
-	{
-		r = write(file_fd, buf, buf_pos);
-		if (r < 0)
-		{
-			exit_flag = RECORD_FAILED_FILE;
-			hal_info("%s: write error: %m\n", __func__);
-			break;
-		}
-		buf_pos -= r;
-		memmove(buf, buf + r, buf_pos);
-	}
-	free(buf);
-
-#if 0
-	// TODO: do we need to notify neutrino about failing recording?
-	CEventServer eventServer;
-	eventServer.registerEvent2(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, "/tmp/neutrino.sock");
-	stream2file_status2_t s;
-	s.status = exit_flag;
-	strncpy(s.filename,basename(myfilename),512);
-	s.filename[511] = '\0';
-	strncpy(s.dir,dirname(myfilename),100);
-	s.dir[99] = '\0';
-	eventServer.sendEvent(NeutrinoMessages::EVT_RECORDING_ENDED, CEventServer::INITID_NEUTRINO, &s, sizeof(s));
-	printf("[stream2file]: pthreads exit code: %i, dir: '%s', filename: '%s' myfilename: '%s'\n", exit_flag, s.dir, s.filename, myfilename);
-#endif
-
-	hal_info("%s: end", __func__);
-	pthread_exit(NULL);
-}
-
-int cRecord::GetStatus()
-{
-	/* dummy for now */
-	return REC_STATUS_OK;
-}
-
-void cRecord::ResetStatus()
-{
-	return;
-}
diff -Nur libstb-hal-ddt.git.orig/libtriple/record_td.h libstb-hal-ddt.git/libtriple/record_td.h
--- libstb-hal-ddt.git.orig/libtriple/record_td.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/record_td.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-#ifndef __RECORD_TD_H__
-#define __RECORD_TD_H__
-
-#include <pthread.h>
-#include "dmx_hal.h"
-
-#define REC_STATUS_OK 0
-#define REC_STATUS_SLOW 1
-#define REC_STATUS_OVERFLOW 2
-
-typedef enum {
-	RECORD_RUNNING,
-	RECORD_STOPPED,
-	RECORD_FAILED_READ,	/* failed to read from DMX */
-	RECORD_FAILED_OVERFLOW,	/* cannot write fast enough */
-	RECORD_FAILED_FILE,	/* cannot write to file */
-	RECORD_FAILED_MEMORY	/* out of memory */
-} record_state_t;
-
-class cRecord
-{
-	private:
-		int file_fd;
-		cDemux *dmx;
-		pthread_t record_thread;
-		bool record_thread_running;
-		record_state_t exit_flag;
-		int state;
-	public:
-		cRecord(int num = 0);
-		~cRecord();
-
-		bool Open();
-		bool Start(int fd, unsigned short vpid, unsigned short *apids, int numapids, uint64_t ch = 0);
-		bool Stop(void);
-		bool AddPid(unsigned short pid);
-		int  GetStatus();
-		void ResetStatus();
-		bool ChangePids(unsigned short vpid, unsigned short *apids, int numapids);
-
-		void RecordThread();
-};
-
-#endif // __RECORD_TD_H__
diff -Nur libstb-hal-ddt.git.orig/libtriple/td-compat/td-audio-compat.h libstb-hal-ddt.git/libtriple/td-compat/td-audio-compat.h
--- libstb-hal-ddt.git.orig/libtriple/td-compat/td-audio-compat.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/td-compat/td-audio-compat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,38 +0,0 @@
-/*
- * compatibility stuff for Tripledragon audio API
- *
- * (C) 2009 Stefan Seyfried
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#ifndef __td_audio_compat_h__
-#define __td_audio_compat_h__
-
-#include <aud/aud_inf.h>
-// types
-typedef enum {
-	AUDIO_SOURCE_DEMUX = AUD_SOURCE_DEMUX,
-	AUDIO_SOURCE_MEMORY = AUD_SOURCE_MEMORY
-} audio_stream_source_t;
-#define audio_channel_select_t	audChannel_t
-// ioctls
-#define AUDIO_CHANNEL_SELECT	MPEG_AUD_SELECT_CHANNEL
-#define AUDIO_SELECT_SOURCE	MPEG_AUD_SELECT_SOURCE
-#define AUDIO_PLAY		MPEG_AUD_PLAY
-#define AUDIO_STOP		MPEG_AUD_STOP
-#define AUDIO_SET_MUTE		MPEG_AUD_SET_MUTE
-
-#endif /* __td_audio_compat_h__ */
diff -Nur libstb-hal-ddt.git.orig/libtriple/td-compat/td-demux-compat.h libstb-hal-ddt.git/libtriple/td-compat/td-demux-compat.h
--- libstb-hal-ddt.git.orig/libtriple/td-compat/td-demux-compat.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/td-compat/td-demux-compat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
-/*
- * compatibility stuff for Tripledragon demux API
- *
- * (C) 2009 Stefan Seyfried
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#ifndef __td_demux_compat_h__
-#define __td_demux_compat_h__
-
-#include <sys/types.h>
-#include <xp/xp_osd_user.h>
-// types
-#define dmx_output_t		OutDevice
-#define dmx_pes_type_t		PesType
-#define dmx_sct_filter_params	demux_filter_para
-#define dmx_pes_filter_params	demux_pes_para
-#define pes_type		pesType
-// defines
-#define DMX_FILTER_SIZE		FILTER_LENGTH
-#define DMX_ONESHOT		XPDF_ONESHOT
-#define DMX_CHECK_CRC		0			// TD checks CRC by default
-#define DMX_IMMEDIATE_START	XPDF_IMMEDIATE_START
-#define DMX_OUT_DECODER		OUT_DECODER
-// ioctls
-#define DMX_SET_FILTER		DEMUX_FILTER_SET
-#define DMX_SET_PES_FILTER	DEMUX_FILTER_PES_SET
-#define DMX_START		DEMUX_START
-#define DMX_STOP		DEMUX_STOP
-#define DMX_SET_BUFFER_SIZE	DEMUX_SET_BUFFER_SIZE
-
-#endif /* __td_demux_compat_h__ */
diff -Nur libstb-hal-ddt.git.orig/libtriple/td-compat/td-frontend-compat.h libstb-hal-ddt.git/libtriple/td-compat/td-frontend-compat.h
--- libstb-hal-ddt.git.orig/libtriple/td-compat/td-frontend-compat.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/td-compat/td-frontend-compat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-/*
- * compatibility stuff for Tripledragon frontend API
- *
- * (C) 2009 Stefan Seyfried
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#ifndef __td_frontend_compat_h__
-#define __td_frontend_compat_h__
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-	#include <tdtuner/tuner_inf.h>
-#ifdef __cplusplus
-}
-#endif
-
-/* I know that those are different. But functions that get a
-   dvb_frontend_parameters struct passed on dbox/dreambox will most likely
-   get a tunersetup struct on TD, so it keeps the differences in headers
-   and function prototypes small. Of course, the functions itself will have
-   #ifdef TRIPLEDRAGON or similar... */
-#define dvb_frontend_parameters tunersetup
-
-/* compat stuff for settings.cpp */
-enum {
-	INVERSION_OFF,
-	INVERSION_ON,
-	INVERSION_AUTO
-};
-typedef enum fe_code_rate {
-	FEC_NONE = 0,
-	FEC_1_2,
-	FEC_2_3,
-	FEC_3_4,
-	FEC_4_5,
-	FEC_5_6,
-	FEC_6_7,
-	FEC_7_8,
-	FEC_8_9,
-	FEC_AUTO
-} fe_code_rate_t;
-
-enum td_code_rate {
-	TD_FEC_AUTO = 0,
-	TD_FEC_1_2,
-	TD_FEC_2_3,
-	TD_FEC_3_4,
-	TD_FEC_5_6,
-	TD_FEC_7_8
-};
-
-typedef enum fe_sec_tone_mode {
-	SEC_TONE_ON,
-	SEC_TONE_OFF
-} fe_sec_tone_mode_t;
-
-typedef enum fe_sec_voltage {
-	SEC_VOLTAGE_13,
-	SEC_VOLTAGE_18,
-	SEC_VOLTAGE_OFF
-} fe_sec_voltage_t;
-
-typedef enum fe_sec_mini_cmd {
-	SEC_MINI_A,
-	SEC_MINI_B
-} fe_sec_mini_cmd_t;
-
-struct dvb_diseqc_master_cmd {
-	unsigned char msg [6];   /*  { framing, address, command, data [3] } */
-	unsigned char msg_len;   /*  valid values are 3...6  */
-};
-
-typedef enum fe_type {
-	FE_QPSK,
-	FE_QAM,
-	FE_OFDM,
-	FE_ATSC
-} fe_type_t;
-
-struct dvb_frontend_info {
-//	char       name[128];
-	fe_type_t  type;
-#if 0
-	__u32      frequency_min;
-	__u32      frequency_max;
-	__u32      frequency_stepsize;
-	__u32      frequency_tolerance;
-	__u32      symbol_rate_min;
-	__u32      symbol_rate_max;
-	__u32      symbol_rate_tolerance;	/* ppm */
-	__u32      notifier_delay;		/* DEPRECATED */
-	fe_caps_t  caps;
-#endif
-};
-
-struct dvb_frontend_event {
-	fe_status_t status;
-	tunersetup parameters;
-};
-
-#ifdef _DVBFRONTEND_H_
-#error _DVBFRONTEND_H_ included
-#endif
-
-#endif /* __td_frontend_compat_h__ */
diff -Nur libstb-hal-ddt.git.orig/libtriple/td-compat/td-value-compat.h libstb-hal-ddt.git/libtriple/td-compat/td-value-compat.h
--- libstb-hal-ddt.git.orig/libtriple/td-compat/td-value-compat.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/td-compat/td-value-compat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,93 +0,0 @@
-/*
- * compatibility stuff for conversion of Tripledragon API values to DVB API
- * and vice versa
- *
- * (C) 2009 Stefan Seyfried
- *
- * Released under the GPL V2.
- */
-
-#ifndef _td_value_compat_
-#define _td_value_compat_
-
-#undef FE_GET_INFO
-#undef FE_READ_BER
-#undef FE_READ_SIGNAL_STRENGTH
-#undef FE_READ_SNR
-#undef FE_READ_UNCORRECTED_BLOCKS
-#undef FE_GET_EVENT
-#undef FE_READ_STATUS
-#undef FE_SET_PROPERTY
-#undef FE_GET_EVENT
-#undef FE_GET_EVENT
-#undef FE_SET_PROPERTY
-#undef FE_SET_TONE
-#undef FE_ENABLE_HIGH_LNB_VOLTAGE
-#undef FE_SET_VOLTAGE
-#undef FE_DISEQC_SEND_MASTER_CMD
-#undef FE_DISEQC_SEND_BURST
-/* hack, linux/dvb/frontend.h already defines fe_status */
-#define fe_status	td_fe_status
-#define fe_status_t	td_fe_status_t
-#define FE_HAS_SIGNAL	TD_FE_HAS_SIGNAL
-#define FE_HAS_CARRIER	TD_FE_HAS_CARRIER
-#define FE_HAS_VITERBI	TD_FE_HAS_VITERBI
-#define FE_HAS_SYNC	TD_FE_HAS_SYNC
-#define FE_HAS_LOCK	TD_FE_HAS_LOCK
-#define FE_TIMEDOUT	TD_FE_TIMEDOUT
-#define FE_REINIT	TD_FE_REINIT
-#include <tdtuner/tuner_inf.h>
-#undef fe_status
-#undef fe_status_t
-#undef FE_HAS_SIGNAL
-#undef FE_HAS_CARRIER
-#undef FE_HAS_VITERBI
-#undef FE_HAS_SYNC
-#undef FE_HAS_LOCK
-#undef FE_TIMEDOUT
-#undef FE_REINIT
-enum td_code_rate {
-        TD_FEC_AUTO = 0,
-        TD_FEC_1_2,
-        TD_FEC_2_3,
-        TD_FEC_3_4,
-        TD_FEC_5_6,
-        TD_FEC_7_8
-};
-
-static inline unsigned int dvbfec2tdfec(fe_code_rate_t fec)
-{
-	switch (fec) {
-	case FEC_1_2: // FEC_1_2 ... FEC_3_4 are equal to TD_FEC_1_2 ... TD_FEC_3_4
-	case FEC_2_3:
-	case FEC_3_4:
-		return (unsigned int)fec;
-	case FEC_5_6:
-		return TD_FEC_5_6;
-	case FEC_7_8:
-		return TD_FEC_7_8;
-	default:
-		break;
-	}
-	return TD_FEC_AUTO;
-}
-
-static inline fe_code_rate_t tdfec2dvbfec(unsigned int tdfec)
-{
-	switch (tdfec)
-	{
-	case TD_FEC_1_2:
-	case TD_FEC_2_3:
-	case TD_FEC_3_4:
-		return (fe_code_rate_t)tdfec;
-	case TD_FEC_5_6:
-		return FEC_5_6;
-	case TD_FEC_7_8:
-		return FEC_7_8;
-	default:
-		break;
-	}
-	return FEC_AUTO;
-}
-
-#endif /* _td_value_compat_ */
diff -Nur libstb-hal-ddt.git.orig/libtriple/td-compat/td-video-compat.h libstb-hal-ddt.git/libtriple/td-compat/td-video-compat.h
--- libstb-hal-ddt.git.orig/libtriple/td-compat/td-video-compat.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/td-compat/td-video-compat.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
-/*
- * compatibility stuff for Tripledragon video API
- *
- * (C) 2009 Stefan Seyfried
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifndef __td_video_compat_h__
-#define __td_video_compat_h__
-
-#include <vid/vid_inf.h>
-// types
-#define video_format_t		vidDispSize_t
-#define video_displayformat_t	vidDispMode_t
-typedef enum {
-	VIDEO_SOURCE_DEMUX = VID_SOURCE_DEMUX,
-	VIDEO_SOURCE_MEMORY = VID_SOURCE_MEMORY
-} video_stream_source_t;
-typedef enum {
-	VIDEO_STOPPED, /* Video is stopped */
-	VIDEO_PLAYING, /* Video is currently playing */
-	VIDEO_FREEZED  /* Video is freezed */
-} video_play_state_t;
-//#define video_play_state_t	vidState_t
-// ioctls
-#define VIDEO_SET_SYSTEM		MPEG_VID_SET_DISPFMT
-#define VIDEO_SET_FORMAT		MPEG_VID_SET_DISPSIZE
-#define VIDEO_SET_DISPLAY_FORMAT	MPEG_VID_SET_DISPMODE
-#define VIDEO_SELECT_SOURCE		MPEG_VID_SELECT_SOURCE
-#define VIDEO_PLAY			MPEG_VID_PLAY
-#define VIDEO_STOP			MPEG_VID_STOP
-#define VIDEO_SET_BLANK			MPEG_VID_SET_BLANK
-
-#endif /* __td_video_compat_h__ */
diff -Nur libstb-hal-ddt.git.orig/libtriple/video_td.cpp libstb-hal-ddt.git/libtriple/video_td.cpp
--- libstb-hal-ddt.git.orig/libtriple/video_td.cpp	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/video_td.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,1105 +0,0 @@
-/*
- * (C) 2002-2003 Andreas Oberritter <obi@tuxbox.org>
- * (C) 2010-2013 Stefan Seyfried
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <fcntl.h>
-#include <stdint.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <utime.h>
-
-#include <cstring>
-#include <cstdio>
-#include <cstdlib>
-
-#include <pthread.h>
-
-#include <avs/avs_inf.h>
-#include <clip/clipinfo.h>
-#include <hw/hardware.h>
-#include "video_td.h"
-#include <hardware/tddevices.h>
-#define VIDEO_DEVICE "/dev/" DEVICE_NAME_VIDEO
-#include "hal_debug.h"
-#define hal_debug(args...) _hal_debug(HAL_DEBUG_VIDEO, this, args)
-#define hal_info(args...) _hal_info(HAL_DEBUG_VIDEO, this, args)
-
-#define fop(cmd, args...) ({				\
-	int _r;						\
-	if (fd >= 0) { 					\
-		if ((_r = ::cmd(fd, args)) < 0)		\
-			hal_info(#cmd"(fd, "#args")\n");	\
-		else					\
-			hal_debug(#cmd"(fd, "#args")\n");\
-	}						\
-	else { _r = fd; } 				\
-	_r;						\
-})
-
-cVideo * videoDecoder = NULL;
-int system_rev = 0;
-
-#if 0
-/* this would be necessary for the DirectFB implementation of ShowPicture */
-#include <directfb.h>
-#include <tdgfx/stb04gfx.h>
-extern IDirectFB *dfb;
-extern IDirectFBSurface *dfbdest;
-#endif
-
-extern struct Ssettings settings;
-static pthread_mutex_t stillp_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-/* debugging hacks */
-static bool noscart = false;
-
-cVideo::cVideo(int, void *, void *, unsigned int)
-{
-	hal_debug("%s\n", __FUNCTION__);
-	if ((fd = open(VIDEO_DEVICE, O_RDWR)) < 0)
-		hal_info("%s cannot open %s: %m\n", __FUNCTION__, VIDEO_DEVICE);
-	fcntl(fd, F_SETFD, FD_CLOEXEC);
-
-	playstate = VIDEO_STOPPED;
-	croppingMode = VID_DISPMODE_NORM;
-	outputformat = VID_OUTFMT_RGBC_SVIDEO;
-	scartvoltage = -1;
-	z[0] = 100;
-	z[1] = 100;
-	zoomvalue = &z[0];
-	const char *blanknames[2] = { "/share/tuxbox/blank_576.mpg", "/share/tuxbox/blank_480.mpg" };
-	int blankfd;
-	struct stat st;
-
-	for (int i = 0; i < 2; i++)
-	{
-		blank_data[i] = NULL; /* initialize */
-		blank_size[i] = 0;
-		blankfd = open(blanknames[i], O_RDONLY);
-		if (blankfd < 0)
-		{
-			hal_info("%s cannot open %s: %m", __FUNCTION__, blanknames[i]);
-			continue;
-		}
-		if (fstat(blankfd, &st) != -1 && st.st_size > 0)
-		{
-			blank_size[i] = st.st_size;
-			blank_data[i] = malloc(blank_size[i]);
-			if (! blank_data[i])
-				hal_info("%s malloc failed (%m)\n", __FUNCTION__);
-			else if (read(blankfd, blank_data[i], blank_size[i]) != blank_size[i])
-			{
-				hal_info("%s short read (%m)\n", __FUNCTION__);
-				free(blank_data[i]); /* don't leak... */
-				blank_data[i] = NULL;
-			}
-			else
-			{	/* set framerate to 24fps... see getBlank() */
-				((char *)blank_data[i])[7] &= 0xF0;
-				((char *)blank_data[i])[7] += 2;
-			}
-		}
-		close(blankfd);
-	}
-	video_standby = 0;
-	noscart = (getenv("TRIPLE_NOSCART") != NULL);
-	if (noscart)
-		hal_info("%s TRIPLE_NOSCART variable prevents SCART switching\n", __FUNCTION__);
-}
-
-cVideo::~cVideo(void)
-{
-	playstate = VIDEO_STOPPED;
-	for (int i = 0; i < 2; i++)
-	{
-		if (blank_data[i])
-			free(blank_data[i]);
-		blank_data[i] = NULL;
-	}
-	/* disable DACs and SCART voltage */
-	Standby(true);
-	if (fd >= 0)
-		close(fd);
-}
-
-int cVideo::setAspectRatio(int aspect, int mode)
-{
-	static int _mode = -1;
-	static int _aspect = -1;
-	vidDispSize_t dsize = VID_DISPSIZE_UNKNOWN;
-	vidDispMode_t dmode = VID_DISPMODE_NORM;
-	/* 1 = 4:3, 3 = 16:9, 4 = 2.21:1, 0 = unknown */
-	int v_ar = getAspectRatio();
-
-	if (aspect != -1)
-		_aspect = aspect;
-	if (mode != -1)
-		_mode = mode;
-	hal_info("%s(%d, %d)_(%d, %d) v_ar %d\n", __FUNCTION__, aspect, mode, _aspect, _mode, v_ar);
-
-	/* values are hardcoded in neutrino_menue.cpp, "2" is 14:9 -> not used */
-	if (_aspect != -1)
-	{
-		switch(_aspect)
-		{
-		case 1:
-			dsize = VID_DISPSIZE_4x3;
-			scartvoltage = 12;
-			break;
-		case 3:
-			dsize = VID_DISPSIZE_16x9;
-			scartvoltage = 6;
-			break;
-		default:
-			break;
-		}
-	}
-	if (_mode != -1)
-	{
-		int zoom = 100 * 16 / 14; /* 16:9 vs 14:9 */
-		switch(_mode)
-		{
-		case DISPLAY_AR_MODE_NONE:
-			if (v_ar < 3)
-				dsize = VID_DISPSIZE_4x3;
-			else
-				dsize = VID_DISPSIZE_16x9;
-			break;
-		case DISPLAY_AR_MODE_LETTERBOX:
-			dmode = VID_DISPMODE_LETTERBOX;
-			break;
-		case DISPLAY_AR_MODE_PANSCAN:
-			zoom = 100 * 5 / 4;
-		case DISPLAY_AR_MODE_PANSCAN2:
-			if ((v_ar < 3 && _aspect == 3) || (v_ar >= 3 && _aspect == 1))
-			{
-				/* unfortunately, this partly reimplements the setZoom code... */
-				dsize = VID_DISPSIZE_UNKNOWN;
-				dmode = VID_DISPMODE_SCALE;
-				SCALEINFO s;
-				memset(&s, 0, sizeof(s));
-				if (v_ar < 3) { /* 4:3 */
-					s.src.hori_size = 720;
-					s.src.vert_size = 2 * 576 - 576 * zoom / 100;
-					s.des.hori_size = zoom * 720 * 3/4 / 100;
-					s.des.vert_size = 576;
-				} else {
-					s.src.hori_size = 2 * 720 - 720 * zoom / 100;
-					s.src.vert_size = 576;
-					s.des.hori_size = 720;
-					s.des.vert_size = zoom * 576 * 3/4 / 100;
-				}
-				s.des.vert_off = (576 - s.des.vert_size) / 2;
-				s.des.hori_off = (720 - s.des.hori_size) / 2;
-				hal_debug("PANSCAN2: %d%% src: %d:%d:%d:%d dst: %d:%d:%d:%d\n", zoom,
-					s.src.hori_off,s.src.vert_off,s.src.hori_size,s.src.vert_size,
-					s.des.hori_off,s.des.vert_off,s.des.hori_size,s.des.vert_size);
-				fop(ioctl, MPEG_VID_SCALE_ON);
-				fop(ioctl, MPEG_VID_SET_SCALE_POS, &s);
-			}
-		default:
-			break;
-		}
-		if (dmode != VID_DISPMODE_SCALE)
-			fop(ioctl, MPEG_VID_SCALE_OFF);
-		setCroppingMode(dmode);
-	}
-	const char *ds[] = { "4x3", "16x9", "2.21", "unknown" };
-	const char *d;
-	if (dsize >=0 && dsize < 4)
-		d = ds[dsize];
-	else
-		d = "invalid!";
-	hal_debug("%s dispsize(%d) (%s)\n", __FUNCTION__, dsize, d);
-	fop(ioctl, MPEG_VID_SET_DISPSIZE, dsize);
-
-	int avsfd = open("/dev/stb/tdsystem", O_RDONLY);
-	if (avsfd < 0)
-	{
-		perror("open tdsystem");
-		return 0;
-	}
-	if (!noscart && scartvoltage > 0 && video_standby == 0)
-	{
-		hal_info("%s set SCART_PIN_8 to %dV\n", __FUNCTION__, scartvoltage);
-		if (ioctl(avsfd, IOC_AVS_SCART_PIN8_SET, scartvoltage) < 0)
-			perror("IOC_AVS_SCART_PIN8_SET");
-	}
-	close(avsfd);
-	return 0;
-}
-
-int cVideo::getAspectRatio(void)
-{
-	VIDEOINFO v;
-	/* this memset silences *TONS* of valgrind warnings */
-	memset(&v, 0, sizeof(v));
-	ioctl(fd, MPEG_VID_GET_V_INFO, &v);
-	if (v.pel_aspect_ratio < VID_DISPSIZE_4x3 || v.pel_aspect_ratio > VID_DISPSIZE_UNKNOWN)
-	{
-		hal_info("%s invalid value %d, returning 0/unknown fd: %d", __FUNCTION__, v.pel_aspect_ratio, fd);
-		return 0;
-	}
-	/* convert to Coolstream api values. Taken from streaminfo2.cpp */
-	switch (v.pel_aspect_ratio)
-	{
-		case VID_DISPSIZE_4x3:
-			return 1;
-		case VID_DISPSIZE_16x9:
-			return 3;
-		case VID_DISPSIZE_221x100:
-			return 4;
-		default:
-			return 0;
-	}
-}
-
-int cVideo::setCroppingMode(vidDispMode_t format)
-{
-	croppingMode = format;
-	const char *format_string[] = { "norm", "letterbox", "unknown", "mode_1_2", "mode_1_4", "mode_2x", "scale", "disexp" };
-	const char *f;
-	if (format >= VID_DISPMODE_NORM && format <= VID_DISPMODE_DISEXP)
-		f = format_string[format];
-	else
-		f = "ILLEGAL format!";
-	hal_debug("%s(%d) => %s\n", __FUNCTION__, format, f);
-	return fop(ioctl, MPEG_VID_SET_DISPMODE, format);
-}
-
-int cVideo::Start(void * /*PcrChannel*/, unsigned short /*PcrPid*/, unsigned short /*VideoPid*/, void * /*hChannel*/)
-{
-	hal_debug("%s playstate=%d\n", __FUNCTION__, playstate);
-	if (playstate == VIDEO_PLAYING)
-		return 0;
-	if (playstate == VIDEO_FREEZED)  /* in theory better, but not in practice :-) */
-		fop(ioctl, MPEG_VID_CONTINUE);
-	playstate = VIDEO_PLAYING;
-	fop(ioctl, MPEG_VID_PLAY);
-	return fop(ioctl, MPEG_VID_SYNC_ON, VID_SYNC_AUD);
-}
-
-int cVideo::Stop(bool blank)
-{
-	hal_debug("%s(%d)\n", __FUNCTION__, blank);
-	if (blank)
-	{
-		playstate = VIDEO_STOPPED;
-		fop(ioctl, MPEG_VID_STOP);
-		return setBlank(1);
-	}
-	playstate = VIDEO_FREEZED;
-	return fop(ioctl, MPEG_VID_FREEZE);
-}
-
-int cVideo::setBlank(int)
-{
-	hal_debug("%s\n", __FUNCTION__);
-	/* The TripleDragon has no VIDEO_SET_BLANK ioctl.
-	   instead, you write a black still-MPEG Iframe into the decoder.
-	   The original software uses different files for 4:3 and 16:9 and
-	   for PAL and NTSC. I optimized that a little bit
-	 */
-	int index = 0; /* default PAL */
-	int ret = 0;
-	VIDEOINFO v;
-	BUFINFO buf;
-	pthread_mutex_lock(&stillp_mutex);
-	memset(&v, 0, sizeof(v));
-	ioctl(fd, MPEG_VID_GET_V_INFO, &v);
-
-	if ((v.v_size % 240) == 0) /* NTSC */
-	{
-		hal_info("%s NTSC format detected", __FUNCTION__);
-		index = 1;
-	}
-
-	if (blank_data[index] == NULL) /* no MPEG found */
-	{
-		ret = -1;
-		goto out;
-	}
-	/* hack: this might work only on those two still-MPEG files!
-	   I diff'ed the 4:3 and the 16:9 still mpeg from the original
-	   soft and spotted the single bit difference, so there is no
-	   need to keep two different MPEGs in memory
-	   If we would read them from disk all the time it would be
-	   slower and it might wake up the drive occasionally */
-	if (v.pel_aspect_ratio == VID_DISPSIZE_4x3)
-		((char *)blank_data[index])[7] &= ~0x10; // clear the bit
-	else
-		((char *)blank_data[index])[7] |=  0x10; // set the bit
-
-	//WARN("blank[7] == 0x%02x", ((char *)blank_data[index])[7]);
-
-	buf.ulLen = blank_size[index];
-	buf.ulStartAdrOff = (int)blank_data[index];
-	fop(ioctl, MPEG_VID_STILLP_WRITE, &buf);
-	ret = fop(ioctl, MPEG_VID_SELECT_SOURCE, VID_SOURCE_DEMUX);
- out:
-	pthread_mutex_unlock(&stillp_mutex);
-	return ret;
-}
-
-int cVideo::SetVideoSystem(int video_system, bool remember)
-{
-	hal_info("%s(%d, %d)\n", __FUNCTION__, video_system, remember);
-	if (video_system > VID_DISPFMT_SECAM || video_system < 0)
-		video_system = VID_DISPFMT_PAL;
-        return fop(ioctl, MPEG_VID_SET_DISPFMT, video_system);
-}
-
-int cVideo::getPlayState(void)
-{
-	return playstate;
-}
-
-void cVideo::SetVideoMode(analog_mode_t mode)
-{
-	hal_debug("%s(%d)\n", __FUNCTION__, mode);
-	switch(mode)
-	{
-		case ANALOG_SD_YPRPB_SCART:
-			outputformat = VID_OUTFMT_YBR_SVIDEO;
-			break;
-		case ANALOG_SD_RGB_SCART:
-			outputformat = VID_OUTFMT_RGBC_SVIDEO;
-			break;
-		default:
-			hal_info("%s unknown mode %d\n", __FUNCTION__, mode);
-			return;
-	}
-	fop(ioctl, MPEG_VID_SET_OUTFMT, outputformat);
-}
-
-void cVideo::ShowPicture(const char * fname)
-{
-	hal_debug("%s(%s)\n", __FUNCTION__, fname);
-	char destname[512];
-	char cmd[512];
-	char *p;
-	void *data;
-	int mfd;
-	struct stat st, st2;
-	strcpy(destname, "/var/cache");
-	if (stat(fname, &st2))
-	{
-		hal_info("%s: could not stat %s (%m)\n", __func__, fname);
-		return;
-	}
-	mkdir(destname, 0755);
-	/* the cache filename is (example for /share/tuxbox/neutrino/icons/radiomode.jpg):
-	   /var/cache/share.tuxbox.neutrino.icons.radiomode.jpg.m2v
-	   build that filename first...
-	   TODO: this could cause name clashes, use a hashing function instead... */
-	strcat(destname, fname);
-	p = &destname[strlen("/var/cache/")];
-	while ((p = strchr(p, '/')) != NULL)
-		*p = '.';
-	strcat(destname, ".m2v");
-	/* ...then check if it exists already... */
-	if (stat(destname, &st) || (st.st_mtime != st2.st_mtime) || (st.st_size == 0))
-	{
-		struct utimbuf u;
-		u.actime = time(NULL);
-		u.modtime = st2.st_mtime;
-		/* it does not exist or has a different date, so call ffmpeg... */
-		sprintf(cmd, "ffmpeg -y -f mjpeg -i '%s' -s 704x576 '%s' </dev/null",
-							fname, destname);
-		system(cmd); /* TODO: use libavcodec to directly convert it */
-		utime(destname, &u);
-	}
-	/* the mutex is a workaround: setBlank is apparently called from
-	   a differnt thread and takes slightly longer, so that the decoder
-	   was blanked immediately after displaying the image, which is not
-	   what we want. the mutex ensures proper ordering. */
-	pthread_mutex_lock(&stillp_mutex);
-	mfd = open(destname, O_RDONLY);
-	if (mfd < 0)
-	{
-		hal_info("%s cannot open %s: %m", __FUNCTION__, destname);
-		goto out;
-	}
-	if (fstat(mfd, &st) != -1 && st.st_size > 0)
-	{
-		data = malloc(st.st_size);
-		if (! data)
-			hal_info("%s malloc failed (%m)\n", __FUNCTION__);
-		else if (read(mfd, data, st.st_size) != st.st_size)
-			hal_info("%s short read (%m)\n", __FUNCTION__);
-		else
-		{
-			BUFINFO buf;
-			buf.ulLen = st.st_size;
-			buf.ulStartAdrOff = (int)data;
-			Stop(false);
-			fop(ioctl, MPEG_VID_STILLP_WRITE, &buf);
-		}
-		free(data);
-	}
-	close(mfd);
- out:
-	pthread_mutex_unlock(&stillp_mutex);
-	return;
-#if 0
-	/* DirectFB based picviewer: works, but is slow and the infobar
-	   draws in the same plane */
-	int width;
-	int height;
-	if (!fname)
-		return;
-
-	IDirectFBImageProvider *provider;
-	DFBResult err = dfb->CreateImageProvider(dfb, fname, &provider);
-	if (err)
-	{
-		fprintf(stderr, "cVideo::ShowPicture: CreateImageProvider error!\n");
-		return;
-	}
-
-	DFBSurfaceDescription desc;
-	provider->GetSurfaceDescription (provider, &desc);
-	width = desc.width;
-	height = desc.height;
-	provider->RenderTo(provider, dfbdest, NULL);
-	provider->Release(provider);
-#endif
-}
-
-void cVideo::StopPicture()
-{
-	hal_debug("%s\n", __FUNCTION__);
-	fop(ioctl, MPEG_VID_SELECT_SOURCE, VID_SOURCE_DEMUX);
-}
-
-void cVideo::Standby(unsigned int bOn)
-{
-	hal_debug("%s(%d)\n", __FUNCTION__, bOn);
-	if (bOn)
-	{
-		setBlank(1);
-		fop(ioctl, MPEG_VID_SET_OUTFMT, VID_OUTFMT_DISABLE_DACS);
-	} else
-		fop(ioctl, MPEG_VID_SET_OUTFMT, outputformat);
-	routeVideo(bOn);
-	video_standby = bOn;
-}
-
-int cVideo::getBlank(void)
-{
-	VIDEOINFO v;
-	memset(&v, 0, sizeof(v));
-	ioctl(fd, MPEG_VID_GET_V_INFO, &v);
-	/* HACK HACK HACK :-)
-	 * setBlank() puts a 24fps black mpeg into the decoder...
-	 * regular broadcast does not have 24fps, so if it is still
-	 * there, video did not decode... */
-	hal_debug("%s: %hu (blank = 2)\n", __func__, v.frame_rate);
-	return (v.frame_rate == 2);
-}
-
-/* set zoom in percent (100% == 1:1) */
-int cVideo::setZoom(int zoom)
-{
-	if (zoom == -1) // "auto" reset
-		zoom = *zoomvalue;
-
-	if (zoom > 150 || zoom < 100)
-		return -1;
-
-	*zoomvalue = zoom;
-
-	if (zoom == 100)
-	{
-		setCroppingMode(croppingMode);
-		return fop(ioctl, MPEG_VID_SCALE_OFF);
-	}
-
-	/* the SCALEINFO describes the source and destination of the scaled
-	   video. "src" is the part of the source picture that gets scaled,
-	   "dst" is the area on the screen where this part is displayed
-	   Messing around with MPEG_VID_SET_SCALE_POS disables the automatic
-	   letterboxing, which, as I guess, is only a special case of
-	   MPEG_VID_SET_SCALE_POS. Therefor we need to care for letterboxing
-	   etc here, which is probably not yet totally correct */
-	SCALEINFO s;
-	memset(&s, 0, sizeof(s));
-	if (zoom > 100)
-	{
-		/* 1 = 4:3, 3 = 16:9, 4 = 2.21:1, 0 = unknown */
-		int x = getAspectRatio();
-		if (x < 3 && croppingMode == VID_DISPMODE_NORM)
-		{
-			s.src.hori_size = 720;
-			s.des.hori_size = 720 * 3/4 * zoom / 100;
-			if (s.des.hori_size > 720)
-			{
-				/* the destination exceeds the screen size.
-				   TODO: decrease source size to allow higher
-				   zoom factors (is this useful ?) */
-				s.des.hori_size = 720;
-				zoom = 133; // (720*4*100)/(720*3)
-				*zoomvalue = zoom;
-			}
-		}
-		else
-		{
-			s.src.hori_size = 2 * 720 - 720 * zoom / 100;
-			s.des.hori_size = 720;
-		}
-		s.src.vert_size = 2 * 576 - 576 * zoom / 100;
-		s.des.hori_off = (720 - s.des.hori_size) / 2;
-		s.des.vert_size = 576;
-	}
-/* not working correctly (wrong formula) and does not make sense IMHO
-	else
-	{
-		s.src.hori_size = 720;
-		s.src.vert_size = 576;
-		s.des.hori_size = 720 * zoom / 100;
-		s.des.vert_size = 576 * zoom / 100;
-		s.des.hori_off = (720 - s.des.hori_size) / 2;
-		s.des.vert_off = (576 - s.des.vert_size) / 2;
-	}
- */
-	hal_debug("%s %d%% src: %d:%d:%d:%d dst: %d:%d:%d:%d\n", __FUNCTION__, zoom,
-		s.src.hori_off,s.src.vert_off,s.src.hori_size,s.src.vert_size,
-		s.des.hori_off,s.des.vert_off,s.des.hori_size,s.des.vert_size);
-	fop(ioctl, MPEG_VID_SET_DISPMODE, VID_DISPMODE_SCALE);
-	fop(ioctl, MPEG_VID_SCALE_ON);
-	return fop(ioctl, MPEG_VID_SET_SCALE_POS, &s);
-}
-
-#if 0
-int cVideo::getZoom(void)
-{
-	return *zoomvalue;
-}
-
-void cVideo::setZoomAspect(int index)
-{
-	if (index < 0 || index > 1)
-		WARN("index out of range");
-	else
-		zoomvalue = &z[index];
-}
-#endif
-
-/* this function is regularly called, checks if video parameters
-   changed and triggers appropriate actions */
-void cVideo::VideoParamWatchdog(void)
-{
-	static unsigned int _v_info = (unsigned int) -1;
-	unsigned int v_info;
-	if (fd == -1)
-		return;
-	ioctl(fd, MPEG_VID_GET_V_INFO_RAW, &v_info);
-	if (_v_info != v_info)
-	{
-		hal_debug("%s params changed. old: %08x new: %08x\n", __FUNCTION__, _v_info, v_info);
-		setAspectRatio(-1, -1);
-	}
-	_v_info = v_info;
-}
-
-void cVideo::Pig(int x, int y, int w, int h, int /*osd_w*/, int /*osd_h*/)
-{
-	/* x = y = w = h = -1 -> reset / "hide" PIG */
-	if (x == -1 && y == -1 && w == -1 && h == -1)
-	{
-		setZoom(-1);
-		setAspectRatio(-1, -1);
-		return;
-	}
-	SCALEINFO s;
-	memset(&s, 0, sizeof(s));
-	s.src.hori_size = 720;
-	s.src.vert_size = 576;
-	s.des.hori_off = x;
-	s.des.vert_off = y;
-	s.des.hori_size = w;
-	s.des.vert_size = h;
-	hal_debug("%s src: %d:%d:%d:%d dst: %d:%d:%d:%d", __FUNCTION__,
-		s.src.hori_off,s.src.vert_off,s.src.hori_size,s.src.vert_size,
-		s.des.hori_off,s.des.vert_off,s.des.hori_size,s.des.vert_size);
-	fop(ioctl, MPEG_VID_SET_DISPMODE, VID_DISPMODE_SCALE);
-	fop(ioctl, MPEG_VID_SCALE_ON);
-	fop(ioctl, MPEG_VID_SET_SCALE_POS, &s);
-}
-
-void cVideo::getPictureInfo(int &width, int &height, int &rate)
-{
-	VIDEOINFO v;
-	/* this memset silences *TONS* of valgrind warnings */
-	memset(&v, 0, sizeof(v));
-	ioctl(fd, MPEG_VID_GET_V_INFO, &v);
-	/* convert to Coolstream API */
-	rate = (int)v.frame_rate - 1;
-	width = (int)v.h_size;
-	height = (int)v.v_size;
-}
-
-void cVideo::SetSyncMode(AVSYNC_TYPE Mode)
-{
-	hal_debug("%s %d\n", __FUNCTION__, Mode);
-	/*
-	 * { 0, LOCALE_OPTIONS_OFF },
-	 * { 1, LOCALE_OPTIONS_ON  },
-	 * { 2, LOCALE_AUDIOMENU_AVSYNC_AM }
-	 */
-	switch(Mode)
-	{
-		case 0:
-			ioctl(fd, MPEG_VID_SYNC_OFF);
-			break;
-		case 1:
-			ioctl(fd, MPEG_VID_SYNC_ON, VID_SYNC_VID);
-			break;
-		default:
-			ioctl(fd, MPEG_VID_SYNC_ON, VID_SYNC_AUD);
-			break;
-	}
-};
-
-int cVideo::SetStreamType(VIDEO_FORMAT type)
-{
-	static const char *VF[] = {
-		"VIDEO_FORMAT_MPEG2",
-		"VIDEO_FORMAT_MPEG4",
-		"VIDEO_FORMAT_VC1",
-		"VIDEO_FORMAT_JPEG",
-		"VIDEO_FORMAT_GIF",
-		"VIDEO_FORMAT_PNG"
-	};
-
-	hal_debug("%s type=%s\n", __FUNCTION__, VF[type]);
-	return 0;
-}
-
-void cVideo::routeVideo(int standby)
-{
-	hal_debug("%s(%d)\n", __FUNCTION__, standby);
-
-	int avsfd = open("/dev/stb/tdsystem", O_RDONLY);
-	if (avsfd < 0)
-	{
-		perror("open tdsystem");
-		return;
-	}
-
-	/* in standby, we always route VCR scart to the TV. Once there is a UI
-	   to configure this, we can think more about this... */
-	if (standby)
-	{
-		hal_info("%s set fastblank and pin8 to follow VCR SCART, route VCR to TV\n", __FUNCTION__);
-		if (ioctl(avsfd, IOC_AVS_FASTBLANK_SET, (unsigned char)3) < 0)
-			perror("IOC_AVS_FASTBLANK_SET, 3");
-		/* TODO: should probably depend on aspect ratio setting */
-		if (ioctl(avsfd, IOC_AVS_SCART_PIN8_FOLLOW_VCR) < 0)
-			perror("IOC_AVS_SCART_PIN8_FOLLOW_VCR");
-		if (ioctl(avsfd, IOC_AVS_ROUTE_VCR2TV) < 0)
-			perror("IOC_AVS_ROUTE_VCR2TV");
-	} else {
-		unsigned char fblk = 1;
-		hal_info("%s set fastblank=%d pin8=%dV, route encoder to TV\n", __FUNCTION__, fblk, scartvoltage);
-		if (ioctl(avsfd, IOC_AVS_FASTBLANK_SET, fblk) < 0)
-			perror("IOC_AVS_FASTBLANK_SET, fblk");
-		if (!noscart && ioctl(avsfd, IOC_AVS_SCART_PIN8_SET, scartvoltage) < 0)
-			perror("IOC_AVS_SCART_PIN8_SET");
-		if (ioctl(avsfd, IOC_AVS_ROUTE_ENC2TV) < 0)
-			perror("IOC_AVS_ROUTE_ENC2TV");
-	}
-	close(avsfd);
-}
-
-void cVideo::FastForwardMode(int mode)
-{
-	hal_debug("%s\n", __FUNCTION__);
-	fop(ioctl, MPEG_VID_FASTFORWARD, mode);
-}
-
-/* get an image of the video screen
- * this code is inspired by dreambox AIO-grab,
- * git://schwerkraft.elitedvb.net/aio-grab/aio-grab.git */
-/* static lookup tables for faster yuv2rgb conversion */
-static const int yuv2rgbtable_y[256] = {
-	0xFFED5EA0, 0xFFEE88B6, 0xFFEFB2CC, 0xFFF0DCE2, 0xFFF206F8, 0xFFF3310E, 0xFFF45B24, 0xFFF5853A,
-	0xFFF6AF50, 0xFFF7D966, 0xFFF9037C, 0xFFFA2D92, 0xFFFB57A8, 0xFFFC81BE, 0xFFFDABD4, 0xFFFED5EA,
-	0x00000000, 0x00012A16, 0x0002542C, 0x00037E42, 0x0004A858, 0x0005D26E, 0x0006FC84, 0x0008269A,
-	0x000950B0, 0x000A7AC6, 0x000BA4DC, 0x000CCEF2, 0x000DF908, 0x000F231E, 0x00104D34, 0x0011774A,
-	0x0012A160, 0x0013CB76, 0x0014F58C, 0x00161FA2, 0x001749B8, 0x001873CE, 0x00199DE4, 0x001AC7FA,
-	0x001BF210, 0x001D1C26, 0x001E463C, 0x001F7052, 0x00209A68, 0x0021C47E, 0x0022EE94, 0x002418AA,
-	0x002542C0, 0x00266CD6, 0x002796EC, 0x0028C102, 0x0029EB18, 0x002B152E, 0x002C3F44, 0x002D695A,
-	0x002E9370, 0x002FBD86, 0x0030E79C, 0x003211B2, 0x00333BC8, 0x003465DE, 0x00358FF4, 0x0036BA0A,
-	0x0037E420, 0x00390E36, 0x003A384C, 0x003B6262, 0x003C8C78, 0x003DB68E, 0x003EE0A4, 0x00400ABA,
-	0x004134D0, 0x00425EE6, 0x004388FC, 0x0044B312, 0x0045DD28, 0x0047073E, 0x00483154, 0x00495B6A,
-	0x004A8580, 0x004BAF96, 0x004CD9AC, 0x004E03C2, 0x004F2DD8, 0x005057EE, 0x00518204, 0x0052AC1A,
-	0x0053D630, 0x00550046, 0x00562A5C, 0x00575472, 0x00587E88, 0x0059A89E, 0x005AD2B4, 0x005BFCCA,
-	0x005D26E0, 0x005E50F6, 0x005F7B0C, 0x0060A522, 0x0061CF38, 0x0062F94E, 0x00642364, 0x00654D7A,
-	0x00667790, 0x0067A1A6, 0x0068CBBC, 0x0069F5D2, 0x006B1FE8, 0x006C49FE, 0x006D7414, 0x006E9E2A,
-	0x006FC840, 0x0070F256, 0x00721C6C, 0x00734682, 0x00747098, 0x00759AAE, 0x0076C4C4, 0x0077EEDA,
-	0x007918F0, 0x007A4306, 0x007B6D1C, 0x007C9732, 0x007DC148, 0x007EEB5E, 0x00801574, 0x00813F8A,
-	0x008269A0, 0x008393B6, 0x0084BDCC, 0x0085E7E2, 0x008711F8, 0x00883C0E, 0x00896624, 0x008A903A,
-	0x008BBA50, 0x008CE466, 0x008E0E7C, 0x008F3892, 0x009062A8, 0x00918CBE, 0x0092B6D4, 0x0093E0EA,
-	0x00950B00, 0x00963516, 0x00975F2C, 0x00988942, 0x0099B358, 0x009ADD6E, 0x009C0784, 0x009D319A,
-	0x009E5BB0, 0x009F85C6, 0x00A0AFDC, 0x00A1D9F2, 0x00A30408, 0x00A42E1E, 0x00A55834, 0x00A6824A,
-	0x00A7AC60, 0x00A8D676, 0x00AA008C, 0x00AB2AA2, 0x00AC54B8, 0x00AD7ECE, 0x00AEA8E4, 0x00AFD2FA,
-	0x00B0FD10, 0x00B22726, 0x00B3513C, 0x00B47B52, 0x00B5A568, 0x00B6CF7E, 0x00B7F994, 0x00B923AA,
-	0x00BA4DC0, 0x00BB77D6, 0x00BCA1EC, 0x00BDCC02, 0x00BEF618, 0x00C0202E, 0x00C14A44, 0x00C2745A,
-	0x00C39E70, 0x00C4C886, 0x00C5F29C, 0x00C71CB2, 0x00C846C8, 0x00C970DE, 0x00CA9AF4, 0x00CBC50A,
-	0x00CCEF20, 0x00CE1936, 0x00CF434C, 0x00D06D62, 0x00D19778, 0x00D2C18E, 0x00D3EBA4, 0x00D515BA,
-	0x00D63FD0, 0x00D769E6, 0x00D893FC, 0x00D9BE12, 0x00DAE828, 0x00DC123E, 0x00DD3C54, 0x00DE666A,
-	0x00DF9080, 0x00E0BA96, 0x00E1E4AC, 0x00E30EC2, 0x00E438D8, 0x00E562EE, 0x00E68D04, 0x00E7B71A,
-	0x00E8E130, 0x00EA0B46, 0x00EB355C, 0x00EC5F72, 0x00ED8988, 0x00EEB39E, 0x00EFDDB4, 0x00F107CA,
-	0x00F231E0, 0x00F35BF6, 0x00F4860C, 0x00F5B022, 0x00F6DA38, 0x00F8044E, 0x00F92E64, 0x00FA587A,
-	0x00FB8290, 0x00FCACA6, 0x00FDD6BC, 0x00FF00D2, 0x01002AE8, 0x010154FE, 0x01027F14, 0x0103A92A,
-	0x0104D340, 0x0105FD56, 0x0107276C, 0x01085182, 0x01097B98, 0x010AA5AE, 0x010BCFC4, 0x010CF9DA,
-	0x010E23F0, 0x010F4E06, 0x0110781C, 0x0111A232, 0x0112CC48, 0x0113F65E, 0x01152074, 0x01164A8A
-};
-static const int yuv2rgbtable_ru[256] = {
-	0xFEFDA500, 0xFEFFA9B6, 0xFF01AE6C, 0xFF03B322, 0xFF05B7D8, 0xFF07BC8E, 0xFF09C144, 0xFF0BC5FA,
-	0xFF0DCAB0, 0xFF0FCF66, 0xFF11D41C, 0xFF13D8D2, 0xFF15DD88, 0xFF17E23E, 0xFF19E6F4, 0xFF1BEBAA,
-	0xFF1DF060, 0xFF1FF516, 0xFF21F9CC, 0xFF23FE82, 0xFF260338, 0xFF2807EE, 0xFF2A0CA4, 0xFF2C115A,
-	0xFF2E1610, 0xFF301AC6, 0xFF321F7C, 0xFF342432, 0xFF3628E8, 0xFF382D9E, 0xFF3A3254, 0xFF3C370A,
-	0xFF3E3BC0, 0xFF404076, 0xFF42452C, 0xFF4449E2, 0xFF464E98, 0xFF48534E, 0xFF4A5804, 0xFF4C5CBA,
-	0xFF4E6170, 0xFF506626, 0xFF526ADC, 0xFF546F92, 0xFF567448, 0xFF5878FE, 0xFF5A7DB4, 0xFF5C826A,
-	0xFF5E8720, 0xFF608BD6, 0xFF62908C, 0xFF649542, 0xFF6699F8, 0xFF689EAE, 0xFF6AA364, 0xFF6CA81A,
-	0xFF6EACD0, 0xFF70B186, 0xFF72B63C, 0xFF74BAF2, 0xFF76BFA8, 0xFF78C45E, 0xFF7AC914, 0xFF7CCDCA,
-	0xFF7ED280, 0xFF80D736, 0xFF82DBEC, 0xFF84E0A2, 0xFF86E558, 0xFF88EA0E, 0xFF8AEEC4, 0xFF8CF37A,
-	0xFF8EF830, 0xFF90FCE6, 0xFF93019C, 0xFF950652, 0xFF970B08, 0xFF990FBE, 0xFF9B1474, 0xFF9D192A,
-	0xFF9F1DE0, 0xFFA12296, 0xFFA3274C, 0xFFA52C02, 0xFFA730B8, 0xFFA9356E, 0xFFAB3A24, 0xFFAD3EDA,
-	0xFFAF4390, 0xFFB14846, 0xFFB34CFC, 0xFFB551B2, 0xFFB75668, 0xFFB95B1E, 0xFFBB5FD4, 0xFFBD648A,
-	0xFFBF6940, 0xFFC16DF6, 0xFFC372AC, 0xFFC57762, 0xFFC77C18, 0xFFC980CE, 0xFFCB8584, 0xFFCD8A3A,
-	0xFFCF8EF0, 0xFFD193A6, 0xFFD3985C, 0xFFD59D12, 0xFFD7A1C8, 0xFFD9A67E, 0xFFDBAB34, 0xFFDDAFEA,
-	0xFFDFB4A0, 0xFFE1B956, 0xFFE3BE0C, 0xFFE5C2C2, 0xFFE7C778, 0xFFE9CC2E, 0xFFEBD0E4, 0xFFEDD59A,
-	0xFFEFDA50, 0xFFF1DF06, 0xFFF3E3BC, 0xFFF5E872, 0xFFF7ED28, 0xFFF9F1DE, 0xFFFBF694, 0xFFFDFB4A,
-	0x00000000, 0x000204B6, 0x0004096C, 0x00060E22, 0x000812D8, 0x000A178E, 0x000C1C44, 0x000E20FA,
-	0x001025B0, 0x00122A66, 0x00142F1C, 0x001633D2, 0x00183888, 0x001A3D3E, 0x001C41F4, 0x001E46AA,
-	0x00204B60, 0x00225016, 0x002454CC, 0x00265982, 0x00285E38, 0x002A62EE, 0x002C67A4, 0x002E6C5A,
-	0x00307110, 0x003275C6, 0x00347A7C, 0x00367F32, 0x003883E8, 0x003A889E, 0x003C8D54, 0x003E920A,
-	0x004096C0, 0x00429B76, 0x0044A02C, 0x0046A4E2, 0x0048A998, 0x004AAE4E, 0x004CB304, 0x004EB7BA,
-	0x0050BC70, 0x0052C126, 0x0054C5DC, 0x0056CA92, 0x0058CF48, 0x005AD3FE, 0x005CD8B4, 0x005EDD6A,
-	0x0060E220, 0x0062E6D6, 0x0064EB8C, 0x0066F042, 0x0068F4F8, 0x006AF9AE, 0x006CFE64, 0x006F031A,
-	0x007107D0, 0x00730C86, 0x0075113C, 0x007715F2, 0x00791AA8, 0x007B1F5E, 0x007D2414, 0x007F28CA,
-	0x00812D80, 0x00833236, 0x008536EC, 0x00873BA2, 0x00894058, 0x008B450E, 0x008D49C4, 0x008F4E7A,
-	0x00915330, 0x009357E6, 0x00955C9C, 0x00976152, 0x00996608, 0x009B6ABE, 0x009D6F74, 0x009F742A,
-	0x00A178E0, 0x00A37D96, 0x00A5824C, 0x00A78702, 0x00A98BB8, 0x00AB906E, 0x00AD9524, 0x00AF99DA,
-	0x00B19E90, 0x00B3A346, 0x00B5A7FC, 0x00B7ACB2, 0x00B9B168, 0x00BBB61E, 0x00BDBAD4, 0x00BFBF8A,
-	0x00C1C440, 0x00C3C8F6, 0x00C5CDAC, 0x00C7D262, 0x00C9D718, 0x00CBDBCE, 0x00CDE084, 0x00CFE53A,
-	0x00D1E9F0, 0x00D3EEA6, 0x00D5F35C, 0x00D7F812, 0x00D9FCC8, 0x00DC017E, 0x00DE0634, 0x00E00AEA,
-	0x00E20FA0, 0x00E41456, 0x00E6190C, 0x00E81DC2, 0x00EA2278, 0x00EC272E, 0x00EE2BE4, 0x00F0309A,
-	0x00F23550, 0x00F43A06, 0x00F63EBC, 0x00F84372, 0x00FA4828, 0x00FC4CDE, 0x00FE5194, 0x00100564A
-};
-static const int yuv2rgbtable_gu[256] = {
-	0xFFCDD300, 0xFFCE375A, 0xFFCE9BB4, 0xFFCF000E, 0xFFCF6468, 0xFFCFC8C2, 0xFFD02D1C, 0xFFD09176,
-	0xFFD0F5D0, 0xFFD15A2A, 0xFFD1BE84, 0xFFD222DE, 0xFFD28738, 0xFFD2EB92, 0xFFD34FEC, 0xFFD3B446,
-	0xFFD418A0, 0xFFD47CFA, 0xFFD4E154, 0xFFD545AE, 0xFFD5AA08, 0xFFD60E62, 0xFFD672BC, 0xFFD6D716,
-	0xFFD73B70, 0xFFD79FCA, 0xFFD80424, 0xFFD8687E, 0xFFD8CCD8, 0xFFD93132, 0xFFD9958C, 0xFFD9F9E6,
-	0xFFDA5E40, 0xFFDAC29A, 0xFFDB26F4, 0xFFDB8B4E, 0xFFDBEFA8, 0xFFDC5402, 0xFFDCB85C, 0xFFDD1CB6,
-	0xFFDD8110, 0xFFDDE56A, 0xFFDE49C4, 0xFFDEAE1E, 0xFFDF1278, 0xFFDF76D2, 0xFFDFDB2C, 0xFFE03F86,
-	0xFFE0A3E0, 0xFFE1083A, 0xFFE16C94, 0xFFE1D0EE, 0xFFE23548, 0xFFE299A2, 0xFFE2FDFC, 0xFFE36256,
-	0xFFE3C6B0, 0xFFE42B0A, 0xFFE48F64, 0xFFE4F3BE, 0xFFE55818, 0xFFE5BC72, 0xFFE620CC, 0xFFE68526,
-	0xFFE6E980, 0xFFE74DDA, 0xFFE7B234, 0xFFE8168E, 0xFFE87AE8, 0xFFE8DF42, 0xFFE9439C, 0xFFE9A7F6,
-	0xFFEA0C50, 0xFFEA70AA, 0xFFEAD504, 0xFFEB395E, 0xFFEB9DB8, 0xFFEC0212, 0xFFEC666C, 0xFFECCAC6,
-	0xFFED2F20, 0xFFED937A, 0xFFEDF7D4, 0xFFEE5C2E, 0xFFEEC088, 0xFFEF24E2, 0xFFEF893C, 0xFFEFED96,
-	0xFFF051F0, 0xFFF0B64A, 0xFFF11AA4, 0xFFF17EFE, 0xFFF1E358, 0xFFF247B2, 0xFFF2AC0C, 0xFFF31066,
-	0xFFF374C0, 0xFFF3D91A, 0xFFF43D74, 0xFFF4A1CE, 0xFFF50628, 0xFFF56A82, 0xFFF5CEDC, 0xFFF63336,
-	0xFFF69790, 0xFFF6FBEA, 0xFFF76044, 0xFFF7C49E, 0xFFF828F8, 0xFFF88D52, 0xFFF8F1AC, 0xFFF95606,
-	0xFFF9BA60, 0xFFFA1EBA, 0xFFFA8314, 0xFFFAE76E, 0xFFFB4BC8, 0xFFFBB022, 0xFFFC147C, 0xFFFC78D6,
-	0xFFFCDD30, 0xFFFD418A, 0xFFFDA5E4, 0xFFFE0A3E, 0xFFFE6E98, 0xFFFED2F2, 0xFFFF374C, 0xFFFF9BA6,
-	0x00000000, 0x0000645A, 0x0000C8B4, 0x00012D0E, 0x00019168, 0x0001F5C2, 0x00025A1C, 0x0002BE76,
-	0x000322D0, 0x0003872A, 0x0003EB84, 0x00044FDE, 0x0004B438, 0x00051892, 0x00057CEC, 0x0005E146,
-	0x000645A0, 0x0006A9FA, 0x00070E54, 0x000772AE, 0x0007D708, 0x00083B62, 0x00089FBC, 0x00090416,
-	0x00096870, 0x0009CCCA, 0x000A3124, 0x000A957E, 0x000AF9D8, 0x000B5E32, 0x000BC28C, 0x000C26E6,
-	0x000C8B40, 0x000CEF9A, 0x000D53F4, 0x000DB84E, 0x000E1CA8, 0x000E8102, 0x000EE55C, 0x000F49B6,
-	0x000FAE10, 0x0010126A, 0x001076C4, 0x0010DB1E, 0x00113F78, 0x0011A3D2, 0x0012082C, 0x00126C86,
-	0x0012D0E0, 0x0013353A, 0x00139994, 0x0013FDEE, 0x00146248, 0x0014C6A2, 0x00152AFC, 0x00158F56,
-	0x0015F3B0, 0x0016580A, 0x0016BC64, 0x001720BE, 0x00178518, 0x0017E972, 0x00184DCC, 0x0018B226,
-	0x00191680, 0x00197ADA, 0x0019DF34, 0x001A438E, 0x001AA7E8, 0x001B0C42, 0x001B709C, 0x001BD4F6,
-	0x001C3950, 0x001C9DAA, 0x001D0204, 0x001D665E, 0x001DCAB8, 0x001E2F12, 0x001E936C, 0x001EF7C6,
-	0x001F5C20, 0x001FC07A, 0x002024D4, 0x0020892E, 0x0020ED88, 0x002151E2, 0x0021B63C, 0x00221A96,
-	0x00227EF0, 0x0022E34A, 0x002347A4, 0x0023ABFE, 0x00241058, 0x002474B2, 0x0024D90C, 0x00253D66,
-	0x0025A1C0, 0x0026061A, 0x00266A74, 0x0026CECE, 0x00273328, 0x00279782, 0x0027FBDC, 0x00286036,
-	0x0028C490, 0x002928EA, 0x00298D44, 0x0029F19E, 0x002A55F8, 0x002ABA52, 0x002B1EAC, 0x002B8306,
-	0x002BE760, 0x002C4BBA, 0x002CB014, 0x002D146E, 0x002D78C8, 0x002DDD22, 0x002E417C, 0x002EA5D6,
-	0x002F0A30, 0x002F6E8A, 0x002FD2E4, 0x0030373E, 0x00309B98, 0x0030FFF2, 0x0031644C, 0x0031C8A6
-};
-static const int yuv2rgbtable_gv[256] = {
-	0xFF97E900, 0xFF98B92E, 0xFF99895C, 0xFF9A598A, 0xFF9B29B8, 0xFF9BF9E6, 0xFF9CCA14, 0xFF9D9A42,
-	0xFF9E6A70, 0xFF9F3A9E, 0xFFA00ACC, 0xFFA0DAFA, 0xFFA1AB28, 0xFFA27B56, 0xFFA34B84, 0xFFA41BB2,
-	0xFFA4EBE0, 0xFFA5BC0E, 0xFFA68C3C, 0xFFA75C6A, 0xFFA82C98, 0xFFA8FCC6, 0xFFA9CCF4, 0xFFAA9D22,
-	0xFFAB6D50, 0xFFAC3D7E, 0xFFAD0DAC, 0xFFADDDDA, 0xFFAEAE08, 0xFFAF7E36, 0xFFB04E64, 0xFFB11E92,
-	0xFFB1EEC0, 0xFFB2BEEE, 0xFFB38F1C, 0xFFB45F4A, 0xFFB52F78, 0xFFB5FFA6, 0xFFB6CFD4, 0xFFB7A002,
-	0xFFB87030, 0xFFB9405E, 0xFFBA108C, 0xFFBAE0BA, 0xFFBBB0E8, 0xFFBC8116, 0xFFBD5144, 0xFFBE2172,
-	0xFFBEF1A0, 0xFFBFC1CE, 0xFFC091FC, 0xFFC1622A, 0xFFC23258, 0xFFC30286, 0xFFC3D2B4, 0xFFC4A2E2,
-	0xFFC57310, 0xFFC6433E, 0xFFC7136C, 0xFFC7E39A, 0xFFC8B3C8, 0xFFC983F6, 0xFFCA5424, 0xFFCB2452,
-	0xFFCBF480, 0xFFCCC4AE, 0xFFCD94DC, 0xFFCE650A, 0xFFCF3538, 0xFFD00566, 0xFFD0D594, 0xFFD1A5C2,
-	0xFFD275F0, 0xFFD3461E, 0xFFD4164C, 0xFFD4E67A, 0xFFD5B6A8, 0xFFD686D6, 0xFFD75704, 0xFFD82732,
-	0xFFD8F760, 0xFFD9C78E, 0xFFDA97BC, 0xFFDB67EA, 0xFFDC3818, 0xFFDD0846, 0xFFDDD874, 0xFFDEA8A2,
-	0xFFDF78D0, 0xFFE048FE, 0xFFE1192C, 0xFFE1E95A, 0xFFE2B988, 0xFFE389B6, 0xFFE459E4, 0xFFE52A12,
-	0xFFE5FA40, 0xFFE6CA6E, 0xFFE79A9C, 0xFFE86ACA, 0xFFE93AF8, 0xFFEA0B26, 0xFFEADB54, 0xFFEBAB82,
-	0xFFEC7BB0, 0xFFED4BDE, 0xFFEE1C0C, 0xFFEEEC3A, 0xFFEFBC68, 0xFFF08C96, 0xFFF15CC4, 0xFFF22CF2,
-	0xFFF2FD20, 0xFFF3CD4E, 0xFFF49D7C, 0xFFF56DAA, 0xFFF63DD8, 0xFFF70E06, 0xFFF7DE34, 0xFFF8AE62,
-	0xFFF97E90, 0xFFFA4EBE, 0xFFFB1EEC, 0xFFFBEF1A, 0xFFFCBF48, 0xFFFD8F76, 0xFFFE5FA4, 0xFFFF2FD2,
-	0x00000000, 0x0000D02E, 0x0001A05C, 0x0002708A, 0x000340B8, 0x000410E6, 0x0004E114, 0x0005B142,
-	0x00068170, 0x0007519E, 0x000821CC, 0x0008F1FA, 0x0009C228, 0x000A9256, 0x000B6284, 0x000C32B2,
-	0x000D02E0, 0x000DD30E, 0x000EA33C, 0x000F736A, 0x00104398, 0x001113C6, 0x0011E3F4, 0x0012B422,
-	0x00138450, 0x0014547E, 0x001524AC, 0x0015F4DA, 0x0016C508, 0x00179536, 0x00186564, 0x00193592,
-	0x001A05C0, 0x001AD5EE, 0x001BA61C, 0x001C764A, 0x001D4678, 0x001E16A6, 0x001EE6D4, 0x001FB702,
-	0x00208730, 0x0021575E, 0x0022278C, 0x0022F7BA, 0x0023C7E8, 0x00249816, 0x00256844, 0x00263872,
-	0x002708A0, 0x0027D8CE, 0x0028A8FC, 0x0029792A, 0x002A4958, 0x002B1986, 0x002BE9B4, 0x002CB9E2,
-	0x002D8A10, 0x002E5A3E, 0x002F2A6C, 0x002FFA9A, 0x0030CAC8, 0x00319AF6, 0x00326B24, 0x00333B52,
-	0x00340B80, 0x0034DBAE, 0x0035ABDC, 0x00367C0A, 0x00374C38, 0x00381C66, 0x0038EC94, 0x0039BCC2,
-	0x003A8CF0, 0x003B5D1E, 0x003C2D4C, 0x003CFD7A, 0x003DCDA8, 0x003E9DD6, 0x003F6E04, 0x00403E32,
-	0x00410E60, 0x0041DE8E, 0x0042AEBC, 0x00437EEA, 0x00444F18, 0x00451F46, 0x0045EF74, 0x0046BFA2,
-	0x00478FD0, 0x00485FFE, 0x0049302C, 0x004A005A, 0x004AD088, 0x004BA0B6, 0x004C70E4, 0x004D4112,
-	0x004E1140, 0x004EE16E, 0x004FB19C, 0x005081CA, 0x005151F8, 0x00522226, 0x0052F254, 0x0053C282,
-	0x005492B0, 0x005562DE, 0x0056330C, 0x0057033A, 0x0057D368, 0x0058A396, 0x005973C4, 0x005A43F2,
-	0x005B1420, 0x005BE44E, 0x005CB47C, 0x005D84AA, 0x005E54D8, 0x005F2506, 0x005FF534, 0x0060C562,
-	0x00619590, 0x006265BE, 0x006335EC, 0x0064061A, 0x0064D648, 0x0065A676, 0x006676A4, 0x006746D2
-};
-static const int yuv2rgbtable_bv[256] = {
-	0xFF33A280, 0xFF353B3B, 0xFF36D3F6, 0xFF386CB1, 0xFF3A056C, 0xFF3B9E27, 0xFF3D36E2, 0xFF3ECF9D,
-	0xFF406858, 0xFF420113, 0xFF4399CE, 0xFF453289, 0xFF46CB44, 0xFF4863FF, 0xFF49FCBA, 0xFF4B9575,
-	0xFF4D2E30, 0xFF4EC6EB, 0xFF505FA6, 0xFF51F861, 0xFF53911C, 0xFF5529D7, 0xFF56C292, 0xFF585B4D,
-	0xFF59F408, 0xFF5B8CC3, 0xFF5D257E, 0xFF5EBE39, 0xFF6056F4, 0xFF61EFAF, 0xFF63886A, 0xFF652125,
-	0xFF66B9E0, 0xFF68529B, 0xFF69EB56, 0xFF6B8411, 0xFF6D1CCC, 0xFF6EB587, 0xFF704E42, 0xFF71E6FD,
-	0xFF737FB8, 0xFF751873, 0xFF76B12E, 0xFF7849E9, 0xFF79E2A4, 0xFF7B7B5F, 0xFF7D141A, 0xFF7EACD5,
-	0xFF804590, 0xFF81DE4B, 0xFF837706, 0xFF850FC1, 0xFF86A87C, 0xFF884137, 0xFF89D9F2, 0xFF8B72AD,
-	0xFF8D0B68, 0xFF8EA423, 0xFF903CDE, 0xFF91D599, 0xFF936E54, 0xFF95070F, 0xFF969FCA, 0xFF983885,
-	0xFF99D140, 0xFF9B69FB, 0xFF9D02B6, 0xFF9E9B71, 0xFFA0342C, 0xFFA1CCE7, 0xFFA365A2, 0xFFA4FE5D,
-	0xFFA69718, 0xFFA82FD3, 0xFFA9C88E, 0xFFAB6149, 0xFFACFA04, 0xFFAE92BF, 0xFFB02B7A, 0xFFB1C435,
-	0xFFB35CF0, 0xFFB4F5AB, 0xFFB68E66, 0xFFB82721, 0xFFB9BFDC, 0xFFBB5897, 0xFFBCF152, 0xFFBE8A0D,
-	0xFFC022C8, 0xFFC1BB83, 0xFFC3543E, 0xFFC4ECF9, 0xFFC685B4, 0xFFC81E6F, 0xFFC9B72A, 0xFFCB4FE5,
-	0xFFCCE8A0, 0xFFCE815B, 0xFFD01A16, 0xFFD1B2D1, 0xFFD34B8C, 0xFFD4E447, 0xFFD67D02, 0xFFD815BD,
-	0xFFD9AE78, 0xFFDB4733, 0xFFDCDFEE, 0xFFDE78A9, 0xFFE01164, 0xFFE1AA1F, 0xFFE342DA, 0xFFE4DB95,
-	0xFFE67450, 0xFFE80D0B, 0xFFE9A5C6, 0xFFEB3E81, 0xFFECD73C, 0xFFEE6FF7, 0xFFF008B2, 0xFFF1A16D,
-	0xFFF33A28, 0xFFF4D2E3, 0xFFF66B9E, 0xFFF80459, 0xFFF99D14, 0xFFFB35CF, 0xFFFCCE8A, 0xFFFE6745,
-	0x00000000, 0x000198BB, 0x00033176, 0x0004CA31, 0x000662EC, 0x0007FBA7, 0x00099462, 0x000B2D1D,
-	0x000CC5D8, 0x000E5E93, 0x000FF74E, 0x00119009, 0x001328C4, 0x0014C17F, 0x00165A3A, 0x0017F2F5,
-	0x00198BB0, 0x001B246B, 0x001CBD26, 0x001E55E1, 0x001FEE9C, 0x00218757, 0x00232012, 0x0024B8CD,
-	0x00265188, 0x0027EA43, 0x002982FE, 0x002B1BB9, 0x002CB474, 0x002E4D2F, 0x002FE5EA, 0x00317EA5,
-	0x00331760, 0x0034B01B, 0x003648D6, 0x0037E191, 0x00397A4C, 0x003B1307, 0x003CABC2, 0x003E447D,
-	0x003FDD38, 0x004175F3, 0x00430EAE, 0x0044A769, 0x00464024, 0x0047D8DF, 0x0049719A, 0x004B0A55,
-	0x004CA310, 0x004E3BCB, 0x004FD486, 0x00516D41, 0x005305FC, 0x00549EB7, 0x00563772, 0x0057D02D,
-	0x005968E8, 0x005B01A3, 0x005C9A5E, 0x005E3319, 0x005FCBD4, 0x0061648F, 0x0062FD4A, 0x00649605,
-	0x00662EC0, 0x0067C77B, 0x00696036, 0x006AF8F1, 0x006C91AC, 0x006E2A67, 0x006FC322, 0x00715BDD,
-	0x0072F498, 0x00748D53, 0x0076260E, 0x0077BEC9, 0x00795784, 0x007AF03F, 0x007C88FA, 0x007E21B5,
-	0x007FBA70, 0x0081532B, 0x0082EBE6, 0x008484A1, 0x00861D5C, 0x0087B617, 0x00894ED2, 0x008AE78D,
-	0x008C8048, 0x008E1903, 0x008FB1BE, 0x00914A79, 0x0092E334, 0x00947BEF, 0x009614AA, 0x0097AD65,
-	0x00994620, 0x009ADEDB, 0x009C7796, 0x009E1051, 0x009FA90C, 0x00A141C7, 0x00A2DA82, 0x00A4733D,
-	0x00A60BF8, 0x00A7A4B3, 0x00A93D6E, 0x00AAD629, 0x00AC6EE4, 0x00AE079F, 0x00AFA05A, 0x00B13915,
-	0x00B2D1D0, 0x00B46A8B, 0x00B60346, 0x00B79C01, 0x00B934BC, 0x00BACD77, 0x00BC6632, 0x00BDFEED,
-	0x00BF97A8, 0x00C13063, 0x00C2C91E, 0x00C461D9, 0x00C5FA94, 0x00C7934F, 0x00C92C0A, 0x00CAC4C5
-};
-
-#define CLAMP(x)	((x < 0) ? 0 : ((x > 255) ? 255 : x))
-#define SWAP(x,y)	{ x ^= y; y ^= x; x ^= y; }
-#define VIDEO_MEM	_MPEG_VIDEO_MEM_BASE
-#define VIDEO_SIZE	_MPEG_VIDEO_MEM_SIZE
-#define WIDTH_OFF	(VID_USER_MEM_BASE + 0x0100)
-#define HEIGHT_OFF	(VID_USER_MEM_BASE + 0x0102)
-#define GFXFB_MEM	_GFX_FB_MEM_BASE
-#define GFXFB_SIZE	_GFX_FB_MEM_SIZE
-/* TODO: aspect ratio correction and PIP */
-bool cVideo::GetScreenImage(unsigned char * &video, int &xres, int &yres, bool get_video, bool get_osd, bool /*scale_to_video*/)
-{
-	hal_info("%s: get_video: %d get_osd: %d\n", __func__, get_video, get_osd);
-	uint8_t *map;
-	int mfd = open("/dev/mem", O_RDWR);
-	if (mfd < 0) {
-		hal_info("%s: cannot open open /dev/mem (%m)\n", __func__);
-		return false;
-	}
-	/* this hints at incorrect usage */
-	if (video != NULL)
-		hal_info("%s: WARNING, video != NULL?\n", __func__);
-
-	if (get_video)
-	{
-		map = (uint8_t *)mmap(NULL, VIDEO_SIZE, PROT_READ, MAP_SHARED, mfd, VIDEO_MEM);
-		if (map == MAP_FAILED) {
-			hal_info("%s: cannot mmap /dev/mem vor VIDEO (%m)\n", __func__);
-			close(mfd);
-			return false;
-		}
-		uint16_t w = *(uint16_t *)(map + WIDTH_OFF);
-		uint16_t h = *(uint16_t *)(map + HEIGHT_OFF);
-		if (w > 720 || h > 576) {
-			hal_info("%s: unhandled resolution %dx%d, is the tuner locked?\n", __func__, w, h);
-			munmap(map, VIDEO_SIZE);
-			close(mfd);
-			return false;
-		}
-		uint8_t *luma, *chroma;
-		int needmem = w * h * 5 / 4; /* chroma is 1/4 in size of luma */
-		int lumasize = w * h;
-		int chromasize = needmem - lumasize;
-		uint8_t *buf = (uint8_t *)malloc(needmem);
-		if (!buf) {
-			hal_info("%s: cannot allocate %d bytes (%m)\n", __func__, needmem);
-			munmap(map, VIDEO_SIZE);
-			close(mfd);
-			return false;
-		}
-		/* luma is at the beginning of the buffer */
-		memcpy(buf, map, lumasize);
-		/* it looks like the chroma plane is always 720*576 bytes offset to the luma plane */
-		memcpy(buf + lumasize, map + 720 * 576, chromasize);
-		/* release the video buffer */
-		munmap(map, VIDEO_SIZE);
-
-		if (get_osd)
-		{	/* in this case, the framebuffer determines the output resolution */
-			xres = 720;
-			yres = 576;
-		}
-		else
-		{
-			xres = w;
-			yres = h;
-		}
-		video = (unsigned char *)malloc(xres * yres * 4);
-		if (!video) {
-			hal_info("%s: cannot allocate %d bytes for video buffer (%m)\n", __func__, yres * yres * 4);
-			free(buf);
-			close(mfd);
-			return false;
-		}
-
-		luma = buf;
-		chroma = buf + lumasize;
-
-		int Y, U, V, y, x, out1, pos, RU, GU, GV, BV, rgbstride, i;
-
-		// yuv2rgb conversion (4:2:0)
-		hal_info("%s: converting Video from YUV to RGB color space\n", __func__);
-		out1 = pos = 0;
-		rgbstride = w * 4;
-
-		for (y = h; y != 0; y -= 2)
-		{
-			for (x = w; x != 0; x -= 4)
-			{
-				U = *chroma++;
-				V = *chroma++;
-				RU = yuv2rgbtable_ru[U]; // use lookup tables to speedup the whole thing
-				GU = yuv2rgbtable_gu[U];
-				GV = yuv2rgbtable_gv[V];
-				BV = yuv2rgbtable_bv[V];
-				// now we do 8 pixels on each iteration this is more code but much faster
-				for (i = 0; i < 4; i++)
-				{
-					Y = yuv2rgbtable_y[luma[pos]];
-					video[out1    ] = CLAMP((Y + RU) >> 16);
-					video[out1 + 1] = CLAMP((Y - GV - GU) >> 16);
-					video[out1 + 2] = CLAMP((Y + BV) >> 16);
-					video[out1 + 3] = 0xff;
-
-					Y = yuv2rgbtable_y[luma[w + pos]];
-					video[out1 +     rgbstride] = CLAMP((Y + RU) >> 16);
-					video[out1 + 1 + rgbstride] = CLAMP((Y - GV - GU) >> 16);
-					video[out1 + 2 + rgbstride] = CLAMP((Y + BV) >> 16);
-					video[out1 + 3 + rgbstride] = 0xff;
-
-					pos++;
-					out1 += 4;
-				}
-			}
-			out1 += rgbstride;
-			pos += w;
-		}
-		if (get_osd && (w < xres || h < yres))
-		{
-			/* most trivial scaling algorithm:
-			 * - no smoothing/antialiasing or similar
-			 * - only upscaling
-			 * more or less just memcpy
-			 * works "backwards" (from bottom right up left),
-			 * so that no extra buffer is needed */
-			int j, k;
-			uint32_t *v = (uint32_t *)video; /* int pointer to the video buffer */
-			uint32_t *srcline;		 /* the start of the current line (unscaled) */
-			uint32_t *dst = v + xres * yres; /* the current scaled pixel */
-			for (j = yres -1 ; j >= 0; j--)
-			{
-				srcline = v + (((j * h) / yres) * w);
-				for (k = xres - 1; k >= 0; k--) {
-					dst--;
-					*dst = *(srcline + ((k * w) / xres));
-				}
-			}
-		}
-		hal_info("%s: Video-Size: %d x %d\n", __func__, xres, yres);
-		free(buf);
-	}
-	if (get_osd)
-	{
-		if (! get_video)
-		{
-			/* we don't use other framebuffer resolutions */
-			xres = 720;
-			yres = 576;
-			video = (unsigned char *)calloc(xres * yres, 4);
-			if (!video)
-			{
-				hal_info("%s: cannot allocate %d bytes for video buffer (%m)\n", __func__, yres * yres * 4);
-				close(mfd);
-				return false;
-			}
-		}
-		/* we don't need the framebufferdevice, we know where the FB is located */
-		map = (uint8_t *)mmap(NULL, GFXFB_SIZE, PROT_READ, MAP_SHARED, mfd, GFXFB_MEM);
-		if (map == MAP_FAILED) {
-			hal_info("%s: cannot mmap /dev/mem for GFXFB (%m)\n", __func__);
-			close(mfd);
-			return false;
-		}
-		unsigned int i, r, g, b, a, a2;
-		uint8_t *p = map;
-		uint8_t *q = video;
-		for (i = xres * yres; i != 0; i--)
-		{
-			a = *p++;
-			r = *p++;
-			g = *p++;
-			b = *p++;
-			a2 = 0xff - a;
-			/* blue */
-			*q = ((*q * a2 ) + (b * a)) >> 8;
-			q++;
-			/* green */
-			*q = ((*q * a2 ) + (g * a)) >> 8;
-			q++;
-			/* red */
-			*q = ((*q * a2 ) + (r * a)) >> 8;
-			q++;
-			q++; /* skip alpha byte */
-		}
-		munmap(map, GFXFB_SIZE);
-	}
-	close(mfd);
-	return true;
-}
-
-void cVideo::SetDemux(cDemux *)
-{
-	hal_debug("%s: not implemented yet\n", __func__);
-}
diff -Nur libstb-hal-ddt.git.orig/libtriple/video_td.h libstb-hal-ddt.git/libtriple/video_td.h
--- libstb-hal-ddt.git.orig/libtriple/video_td.h	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/libtriple/video_td.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,196 +0,0 @@
-#ifndef __VIDEO_TD_H__
-#define __VIDEO_TD_H__
-
-#include <hardware/vid/vid_inf.h>
-#define video_format_t          vidDispSize_t
-//#define video_displayformat_t   vidDispMode_t
-#include "cs_types.h"
-#include "dmx_td.h"
-
-#define STB_HAL_VIDEO_HAS_GETSCREENIMAGE 1
-
-typedef enum {
-	ANALOG_SD_RGB_SCART = 0x00,
-	ANALOG_SD_YPRPB_SCART,
-	ANALOG_HD_RGB_SCART,
-	ANALOG_HD_YPRPB_SCART,
-	ANALOG_SD_RGB_CINCH = 0x80,
-	ANALOG_SD_YPRPB_CINCH,
-	ANALOG_HD_RGB_CINCH,
-	ANALOG_HD_YPRPB_CINCH,
-} analog_mode_t;
-
-typedef enum {
-	VIDEO_FORMAT_MPEG2 = 0,
-	VIDEO_FORMAT_MPEG4,
-	VIDEO_FORMAT_VC1,
-	VIDEO_FORMAT_JPEG,
-	VIDEO_FORMAT_GIF,
-	VIDEO_FORMAT_PNG
-} VIDEO_FORMAT;
-
-typedef enum {
-	VIDEO_SD = 0,
-	VIDEO_HD,
-	VIDEO_120x60i,
-	VIDEO_320x240i,
-	VIDEO_1440x800i,
-	VIDEO_360x288i
-} VIDEO_DEFINITION;
-
-typedef enum {
-	VIDEO_FRAME_RATE_23_976 = 0,
-	VIDEO_FRAME_RATE_24,
-	VIDEO_FRAME_RATE_25,
-	VIDEO_FRAME_RATE_29_97,
-	VIDEO_FRAME_RATE_30,
-	VIDEO_FRAME_RATE_50,
-	VIDEO_FRAME_RATE_59_94,
-	VIDEO_FRAME_RATE_60
-} VIDEO_FRAME_RATE;
-
-typedef enum {
-	DISPLAY_AR_1_1,
-	DISPLAY_AR_4_3,
-	DISPLAY_AR_14_9,
-	DISPLAY_AR_16_9,
-	DISPLAY_AR_20_9,
-	DISPLAY_AR_RAW,
-} DISPLAY_AR;
-
-typedef enum {
-	DISPLAY_AR_MODE_PANSCAN = 0,
-	DISPLAY_AR_MODE_LETTERBOX,
-	DISPLAY_AR_MODE_NONE,
-	DISPLAY_AR_MODE_PANSCAN2
-} DISPLAY_AR_MODE;
-
-typedef enum {
-	VIDEO_DB_DR_NEITHER = 0,
-	VIDEO_DB_ON,
-	VIDEO_DB_DR_BOTH
-} VIDEO_DB_DR;
-
-typedef enum {
-	VIDEO_PLAY_STILL = 0,
-	VIDEO_PLAY_CLIP,
-	VIDEO_PLAY_TRICK,
-	VIDEO_PLAY_MOTION,
-	VIDEO_PLAY_MOTION_NO_SYNC
-} VIDEO_PLAY_MODE;
-
-typedef enum {
-	VIDEO_STD_NTSC	= VID_DISPFMT_NTSC,	/* 0 */
-	VIDEO_STD_PAL	= VID_DISPFMT_PAL,	/* 1 */
-	VIDEO_STD_SECAM	= VID_DISPFMT_SECAM,	/* 4 */
-	VIDEO_STD_1080I50 = VIDEO_STD_PAL,	/* hack, this is used in neutrino settings default */
-	VIDEO_STD_MAX = VIDEO_STD_SECAM + 1
-} VIDEO_STD;
-
-typedef enum {
-	VIDEO_STOPPED, /* Video is stopped */
-	VIDEO_PLAYING, /* Video is currently playing */
-	VIDEO_FREEZED  /* Video is freezed */
-} video_play_state_t;
-
-/* not used, for dummy functions */
-typedef enum {
-	VIDEO_HDMI_CEC_MODE_OFF	= 0,
-	VIDEO_HDMI_CEC_MODE_TUNER,
-	VIDEO_HDMI_CEC_MODE_RECORDER
-} VIDEO_HDMI_CEC_MODE;
-
-typedef enum
-{
-	VIDEO_CONTROL_BRIGHTNESS = 0,
-	VIDEO_CONTROL_CONTRAST,
-	VIDEO_CONTROL_SATURATION,
-	VIDEO_CONTROL_HUE,
-	VIDEO_CONTROL_SHARPNESS,
-	VIDEO_CONTROL_MAX = VIDEO_CONTROL_SHARPNESS
-} VIDEO_CONTROL;
-
-
-class cVideo
-{
-	private:
-		/* video device */
-		int fd;
-		/* apparently we cannot query the driver's state
-		   => remember it */
-		video_play_state_t playstate;
-		vidDispMode_t croppingMode;
-		vidOutFmt_t outputformat;
-		int scartvoltage;
-		int z[2]; /* zoomvalue for 4:3 (0) and 16:9 (1) in percent */
-		int *zoomvalue;
-		void *blank_data[2]; /* we store two blank MPEGs (PAL/NTSC) in there */
-		int blank_size[2];
-
-		VIDEO_FORMAT	    StreamType;
-		VIDEO_DEFINITION       VideoDefinition;
-		DISPLAY_AR DisplayAR;
-		VIDEO_PLAY_MODE SyncMode;
-		DISPLAY_AR_MODE                ARMode;
-		VIDEO_DB_DR eDbDr;
-		DISPLAY_AR PictureAR;
-		VIDEO_FRAME_RATE FrameRate;
-		void routeVideo(int standby);
-		int video_standby;
-	public:
-		/* constructor & destructor */
-		cVideo(int mode, void *, void *, unsigned int unit = 0);
-		~cVideo(void);
-
-		void * GetTVEnc() { return NULL; };
-		void * GetTVEncSD() { return NULL; };
-
-		/* aspect ratio */
-		int getAspectRatio(void);
-		void getPictureInfo(int &width, int &height, int &rate);
-		int setAspectRatio(int aspect, int mode);
-
-		/* cropping mode */
-		int setCroppingMode(vidDispMode_t x = VID_DISPMODE_NORM);
-
-		/* get play state */
-		int getPlayState(void);
-
-		/* blank on freeze */
-		int getBlank(void);
-		int setBlank(int enable);
-
-		/* change video play state. Parameters are all unused. */
-		int Start(void *PcrChannel = NULL, unsigned short PcrPid = 0, unsigned short VideoPid = 0, void *x = NULL);
-		int Stop(bool blank = true);
-		bool Pause(void);
-
-		/* set video_system */
-		int SetVideoSystem(int video_system, bool remember = true);
-		int SetStreamType(VIDEO_FORMAT type);
-		void SetSyncMode(AVSYNC_TYPE mode);
-		bool SetCECMode(VIDEO_HDMI_CEC_MODE) { return true; };
-		void SetCECAutoView(bool) { return; };
-		void SetCECAutoStandby(bool) { return; };
-		void ShowPicture(const char * fname);
-		void StopPicture();
-		void Standby(unsigned int bOn);
-		void Pig(int x, int y, int w, int h, int osd_w = 1064, int osd_h = 600);
-		void SetControl(int, int) { return; };
-		int setZoom(int);
-		void VideoParamWatchdog(void);
-		void setContrast(int val);
-		void SetVideoMode(analog_mode_t mode);
-		void SetDBDR(int) { return; };
-		void SetAudioHandle(void *) { return; };
-		void FastForwardMode(int mode = 0);
-		void SetAutoModes(int [VIDEO_STD_MAX]) { return; };
-		int  OpenVBI(int) { return 0; };
-		int  CloseVBI(void) { return 0; };
-		int  StartVBI(unsigned short) { return 0; };
-		int  StopVBI(void) { return 0; };
-		void SetDemux(cDemux *dmx);
-		bool GetScreenImage(unsigned char * &data, int &xres, int &yres, bool get_video = true, bool get_osd = false, bool scale_to_video = false);
-};
-
-#endif // __VIDEO_TD_H__
diff -Nur libstb-hal-ddt.git.orig/Makefile.am libstb-hal-ddt.git/Makefile.am
--- libstb-hal-ddt.git.orig/Makefile.am	2020-04-20 16:32:41.000000000 +0200
+++ libstb-hal-ddt.git/Makefile.am	2022-07-23 18:18:31.491773270 +0200
@@ -12,17 +12,6 @@
 #libstb_hal_test_LDADD = libstb-hal.la
 
 # there has to be a better way to do this...
-if BOXTYPE_TRIPLE
-SUBDIRS += libtriple
-libstb_hal_la_LIBADD += \
-	libtriple/libtriple.la
-endif
-
-if BOXTYPE_AZBOX
-SUBDIRS += libazbox
-libstb_hal_la_LIBADD += \
-	libazbox/libazbox.la
-endif
 
 if BOXTYPE_GENERIC
 if BOXMODEL_RASPI
@@ -82,7 +71,6 @@
 	include/ca.h \
 	include/ca_ci.h \
 	include/ca_hal.h \
-	include/cs_api.h \
 	include/cs_types.h \
 	include/dmx_hal.h \
 	include/glfb.h \
diff -Nur libstb-hal-ddt.git.orig/tools/pic2m2v.c libstb-hal-ddt.git/tools/pic2m2v.c
--- libstb-hal-ddt.git.orig/tools/pic2m2v.c	2020-04-20 16:32:42.000000000 +0200
+++ libstb-hal-ddt.git/tools/pic2m2v.c	2022-07-23 18:18:31.543772226 +0200
@@ -25,11 +25,7 @@
 #include <time.h>
 #include <utime.h>
 
-#if HAVE_TRIPLEDRAGON
-#define TARGETRES "704x576"
-#else
 #define TARGETRES "1280x720"
-#endif
 
 int main(int argc, char **argv)
 {
@@ -62,7 +58,7 @@
 		strcat(destname, fname);
 		p = &destname[strlen("/var/cache/")];
 		while ((p = strchr(p, '/')) != NULL)
-			*p = '.';
+			* p = '.';
 		strcat(destname, ".m2v");
 		/* ...then check if it exists already... */
 		if (stat(destname, &st) || (st.st_mtime != st2.st_mtime) || (st.st_size == 0))
@@ -73,7 +69,7 @@
 			printf("converting %s -> %s\n", fname, destname);
 			/* it does not exist or has a different date, so call ffmpeg... */
 			sprintf(cmd, "ffmpeg -y -f mjpeg -i '%s' -s %s '%s' </dev/null",
-							fname, TARGETRES, destname);
+			    fname, TARGETRES, destname);
 			system(cmd); /* TODO: use libavcodec to directly convert it */
 			utime(destname, &u);
 		}
diff -Nur libstb-hal-ddt.git.orig/tools/spark_fp.c libstb-hal-ddt.git/tools/spark_fp.c
--- libstb-hal-ddt.git.orig/tools/spark_fp.c	2019-01-03 17:40:42.000000000 +0100
+++ libstb-hal-ddt.git/tools/spark_fp.c	2022-07-23 18:18:31.543772226 +0200
@@ -69,9 +69,9 @@
 	day   = t->tm_mday;
 
 	date = day - 32076 +
-		1461 * (year + 4800 + (month - 14) / 12) / 4 +
-		367 *  (month - 2 -   (month - 14) / 12 * 12) / 12 -
-		3 *   ((year + 4900 + (month - 14) / 12 ) / 100) / 4;
+	    1461 * (year + 4800 + (month - 14) / 12) / 4 +
+	    367 * (month - 2 - (month - 14) / 12 * 12) / 12 -
+	    3 * ((year + 4900 + (month - 14) / 12) / 100) / 4;
 
 	date += (t->tm_hour + 12.0) / 24.0;
 	date += (t->tm_min) / 1440.0;
@@ -85,7 +85,7 @@
 void time_to_aotom(time_t t, char *dest)
 {
 	/* from u-boot aotom */
-	struct tm* tmp;
+	struct tm *tmp;
 	tmp = localtime(&t);
 #if 0
 	/* this mjd stuff is totally useless: driver only uses dest[2] and dest[3]... */
@@ -147,7 +147,7 @@
 	}
 
 	ret = 0;
-	while ((c = getopt (argc, argv, "gs:tw:Tl:L:P:S:B:i:I:p:")) != -1)
+	while ((c = getopt(argc, argv, "gs:tw:Tl:L:P:S:B:i:I:p:")) != -1)
 	{
 		switch (c)
 		{
@@ -165,7 +165,7 @@
 				t = atol(optarg);
 				if (t == 0)
 					t = time(NULL),
-				ret = set_aotom_time(fd, t);
+					ret = set_aotom_time(fd, t);
 				break;
 			case 't':
 				ret = ioctl(fd, VFDGETTIME, &t);
@@ -212,17 +212,17 @@
 				}
 				tmp = gmtime(&t2);
 				fprintf(stderr, "current time: %04d-%02d-%02d %02d:%02d:%02d\n", tmp->tm_year + 1900,
-						tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+				    tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
 				tmp = gmtime(&t);
 				fprintf(stderr, "wakeup time:  %04d-%02d-%02d %02d:%02d:%02d\n", tmp->tm_year + 1900,
-						tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+				    tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
 				ret = ioctl(fd, VFDSETPOWERONTIME, &t);
 				break;
 			case 'P':
 				ret = ioctl(fd, VFDPOWEROFF);
 				break;
 			case 'p':
-				period = atoi(optarg)/10;
+				period = atoi(optarg) / 10;
 				break;
 			case 'l': /* LED on */
 				aotom.u.led.on = period;
@@ -261,15 +261,19 @@
 			case 'S':
 				if (2 == sscanf(optarg, "%d:%lx", &aotom.u.key.key_nr, (long unsigned int *) &aotom.u.key.key))
 					ioctl(fd, VFDSETSTBYKEY, &aotom);
-				if (1 == sscanf(optarg, "%d", &aotom.u.key.key_nr)) {
+				if (1 == sscanf(optarg, "%d", &aotom.u.key.key_nr))
+				{
 					ret = ioctl(fd, VFDGETSTBYKEY, &aotom);
 					if (ret)
 						perror("ioctl VFDGETSTBYKEY");
 					else
 						fprintf(stderr, "stby key %d = %.8x\n", aotom.u.key.key_nr, aotom.u.key.key);
-				} else {
+				}
+				else
+				{
 					aotom.u.key.key_nr = 0;
-					while(aotom.u.key.key_nr < 5) {
+					while (aotom.u.key.key_nr < 5)
+					{
 						ret = ioctl(fd, VFDGETSTBYKEY, &aotom);
 						if (ret)
 							perror("ioctl VFDGETSTBYKEY");
@@ -282,15 +286,19 @@
 			case 'B':
 				if (2 == sscanf(optarg, "%d:%lx", &aotom.u.key.key_nr, (long unsigned int *) &aotom.u.key.key))
 					ioctl(fd, VFDSETBLUEKEY, &aotom);
-				if (1 == sscanf(optarg, "%d", &aotom.u.key.key_nr)) {
+				if (1 == sscanf(optarg, "%d", &aotom.u.key.key_nr))
+				{
 					ret = ioctl(fd, VFDGETBLUEKEY, &aotom);
 					if (ret)
 						perror("ioctl VFDGETBLUEKEY");
 					else
 						fprintf(stderr, "blue key %d = %.8x\n", aotom.u.key.key_nr, aotom.u.key.key);
-				} else {
+				}
+				else
+				{
 					aotom.u.key.key_nr = 0;
-					while(aotom.u.key.key_nr < 5) {
+					while (aotom.u.key.key_nr < 5)
+					{
 						ret = ioctl(fd, VFDGETBLUEKEY, &aotom);
 						if (ret)
 							perror("ioctl VFDGETBLUEKEY");
